import * as React from 'react';
import React__default, { Children, isValidElement, cloneElement, Component, createElement, Fragment } from 'react';
import * as ReactDOM from 'react-dom';
import ReactDOM__default from 'react-dom';

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends$2() {
  _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$2.apply(this, arguments);
}

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".MuiIconButton-label input[type=\"checkbox\"] {\n    cursor: pointer;\n    position: absolute !important;\n}\n\n.MuiAutocomplete-root {\n    width: 100%;\n}\n\n.MuiFormLabel-root.MuiInputLabel-root, .MuiFormControl-root .MuiInputBase-root{\n    font-size: 16px;\n}\n\n.MuiChip-root .MuiChip-label {\n    font-size: 12px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkF1dG9jb21wbGV0ZU11bHRpc2VsZWN0LmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtJQUNJLGVBQWU7SUFDZiw2QkFBNkI7QUFDakM7O0FBRUE7SUFDSSxXQUFXO0FBQ2Y7O0FBRUE7SUFDSSxlQUFlO0FBQ25COztBQUVBO0lBQ0ksZUFBZTtBQUNuQiIsImZpbGUiOiJBdXRvY29tcGxldGVNdWx0aXNlbGVjdC5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuTXVpSWNvbkJ1dHRvbi1sYWJlbCBpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0ge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGUgIWltcG9ydGFudDtcbn1cblxuLk11aUF1dG9jb21wbGV0ZS1yb290IHtcbiAgICB3aWR0aDogMTAwJTtcbn1cblxuLk11aUZvcm1MYWJlbC1yb290Lk11aUlucHV0TGFiZWwtcm9vdCwgLk11aUZvcm1Db250cm9sLXJvb3QgLk11aUlucHV0QmFzZS1yb290e1xuICAgIGZvbnQtc2l6ZTogMTZweDtcbn1cblxuLk11aUNoaXAtcm9vdCAuTXVpQ2hpcC1sYWJlbCB7XG4gICAgZm9udC1zaXplOiAxMnB4O1xufSJdfQ== */";
styleInject(css_248z);

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends$1() {
  _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$1.apply(this, arguments);
}

var propTypes = {exports: {}};

var reactIs$1 = {exports: {}};

var reactIs_development = {};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

{
  (function () {
    // nor polyfill, then a plain number is used for performance.

    var hasSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
    // (unstable) APIs that have been removed. Can we remove the symbols?

    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
    var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
    var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
    var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
    var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
    var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
    var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
    var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
    var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

    function isValidElementType(type) {
      return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
    }

    function typeOf(object) {
      if (typeof object === 'object' && object !== null) {
        var $$typeof = object.$$typeof;

        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            var type = object.type;

            switch (type) {
              case REACT_ASYNC_MODE_TYPE:
              case REACT_CONCURRENT_MODE_TYPE:
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
                return type;

              default:
                var $$typeofType = type && type.$$typeof;

                switch ($$typeofType) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                  case REACT_PROVIDER_TYPE:
                    return $$typeofType;

                  default:
                    return $$typeof;
                }

            }

          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }

      return undefined;
    } // AsyncMode is deprecated along with isAsyncMode


    var AsyncMode = REACT_ASYNC_MODE_TYPE;
    var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
    var ContextConsumer = REACT_CONTEXT_TYPE;
    var ContextProvider = REACT_PROVIDER_TYPE;
    var Element = REACT_ELEMENT_TYPE;
    var ForwardRef = REACT_FORWARD_REF_TYPE;
    var Fragment = REACT_FRAGMENT_TYPE;
    var Lazy = REACT_LAZY_TYPE;
    var Memo = REACT_MEMO_TYPE;
    var Portal = REACT_PORTAL_TYPE;
    var Profiler = REACT_PROFILER_TYPE;
    var StrictMode = REACT_STRICT_MODE_TYPE;
    var Suspense = REACT_SUSPENSE_TYPE;
    var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

    function isAsyncMode(object) {
      {
        if (!hasWarnedAboutDeprecatedIsAsyncMode) {
          hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

          console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
        }
      }
      return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
    }

    function isConcurrentMode(object) {
      return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
    }

    function isContextConsumer(object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    }

    function isContextProvider(object) {
      return typeOf(object) === REACT_PROVIDER_TYPE;
    }

    function isElement(object) {
      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }

    function isForwardRef(object) {
      return typeOf(object) === REACT_FORWARD_REF_TYPE;
    }

    function isFragment(object) {
      return typeOf(object) === REACT_FRAGMENT_TYPE;
    }

    function isLazy(object) {
      return typeOf(object) === REACT_LAZY_TYPE;
    }

    function isMemo(object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    }

    function isPortal(object) {
      return typeOf(object) === REACT_PORTAL_TYPE;
    }

    function isProfiler(object) {
      return typeOf(object) === REACT_PROFILER_TYPE;
    }

    function isStrictMode(object) {
      return typeOf(object) === REACT_STRICT_MODE_TYPE;
    }

    function isSuspense(object) {
      return typeOf(object) === REACT_SUSPENSE_TYPE;
    }

    reactIs_development.AsyncMode = AsyncMode;
    reactIs_development.ConcurrentMode = ConcurrentMode;
    reactIs_development.ContextConsumer = ContextConsumer;
    reactIs_development.ContextProvider = ContextProvider;
    reactIs_development.Element = Element;
    reactIs_development.ForwardRef = ForwardRef;
    reactIs_development.Fragment = Fragment;
    reactIs_development.Lazy = Lazy;
    reactIs_development.Memo = Memo;
    reactIs_development.Portal = Portal;
    reactIs_development.Profiler = Profiler;
    reactIs_development.StrictMode = StrictMode;
    reactIs_development.Suspense = Suspense;
    reactIs_development.isAsyncMode = isAsyncMode;
    reactIs_development.isConcurrentMode = isConcurrentMode;
    reactIs_development.isContextConsumer = isContextConsumer;
    reactIs_development.isContextProvider = isContextProvider;
    reactIs_development.isElement = isElement;
    reactIs_development.isForwardRef = isForwardRef;
    reactIs_development.isFragment = isFragment;
    reactIs_development.isLazy = isLazy;
    reactIs_development.isMemo = isMemo;
    reactIs_development.isPortal = isPortal;
    reactIs_development.isProfiler = isProfiler;
    reactIs_development.isStrictMode = isStrictMode;
    reactIs_development.isSuspense = isSuspense;
    reactIs_development.isValidElementType = isValidElementType;
    reactIs_development.typeOf = typeOf;
  })();
}

{
  reactIs$1.exports = reactIs_development;
}

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */

var getOwnPropertySymbols$1 = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols$1) {
      symbols = getOwnPropertySymbols$1(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret$2 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
var ReactPropTypesSecret_1 = ReactPropTypesSecret$2;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var printWarning$1 = function () {};

{
  var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;

  var loggedTypeFailures = {};
  var has$1 = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning$1 = function (text) {
    var message = 'Warning: ' + text;

    if (typeof console !== 'undefined') {
      console.error(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}
/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */


function checkPropTypes$1(typeSpecs, values, location, componentName, getStack) {
  {
    for (var typeSpecName in typeSpecs) {
      if (has$1(typeSpecs, typeSpecName)) {
        var error; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
        } catch (ex) {
          error = ex;
        }

        if (error && !(error instanceof Error)) {
          printWarning$1((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
        }

        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;
          var stack = getStack ? getStack() : '';
          printWarning$1('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
        }
      }
    }
  }
}
/**
 * Resets warning cache when testing.
 *
 * @private
 */


checkPropTypes$1.resetWarningCache = function () {
  {
    loggedTypeFailures = {};
  }
};

var checkPropTypes_1 = checkPropTypes$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactIs$1 = reactIs$1.exports;

var assign = objectAssign;

var ReactPropTypesSecret = ReactPropTypesSecret_1;

var checkPropTypes = checkPropTypes_1;

var has = Function.call.bind(Object.prototype.hasOwnProperty);

var printWarning = function () {};

{
  printWarning = function (text) {
    var message = 'Warning: ' + text;

    if (typeof console !== 'undefined') {
      console.error(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

var factoryWithTypeCheckers = function (isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */

  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);

    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }
  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */


  var ANONYMOUS = '<<anonymous>>'; // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.

  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),
    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker
  };
  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */

  /*eslint-disable no-self-compare*/

  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */


  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  } // Make `instanceof Error` still work for returned errors.


  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }

    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
          err.name = 'Invariant Violation';
          throw err;
        } else if (typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;

          if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }

      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }

          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }

        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);

      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }

      var propValue = props[propName];

      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }

      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);

        if (error instanceof Error) {
          return error;
        }
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];

      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];

      if (!ReactIs$1.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      {
        if (arguments.length > 1) {
          printWarning('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' + 'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }

      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];

      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);

        if (type === 'symbol') {
          return String(value);
        }

        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }

    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }

      var propValue = props[propName];
      var propType = getPropType(propValue);

      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }

      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

          if (error instanceof Error) {
            return error;
          }
        }
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') ;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];

      if (typeof checker !== 'function') {
        printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];

        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }

    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);

      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }

      for (var key in shapeTypes) {
        var checker = shapeTypes[key];

        if (!checker) {
          continue;
        }

        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

        if (error) {
          return error;
        }
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);

      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      } // We need to check all keys in case some are required but missing from
      // props.


      var allKeys = assign({}, props[propName], shapeTypes);

      for (var key in allKeys) {
        var checker = shapeTypes[key];

        if (!checker) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }

        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

        if (error) {
          return error;
        }
      }

      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;

      case 'boolean':
        return !propValue;

      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }

        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);

        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;

          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;

              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;

      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    } // falsy value can't be a Symbol


    if (!propValue) {
      return false;
    } // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'


    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    } // Fallback for non-spec compliant Symbols which are polyfilled.


    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  } // Equivalent of `typeof` but with special handling for array and regexp.


  function getPropType(propValue) {
    var propType = typeof propValue;

    if (Array.isArray(propValue)) {
      return 'array';
    }

    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }

    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }

    return propType;
  } // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.


  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }

    var propType = getPropType(propValue);

    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }

    return propType;
  } // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"


  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);

    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;

      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;

      default:
        return type;
    }
  } // Returns class name of the object, if any.


  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }

    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

{
  var ReactIs = reactIs$1.exports; // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod


  var throwOnDirectAccess = true;
  propTypes.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
}

var PropTypes = propTypes.exports;

function toVal(mix) {
  var k,
      y,
      str = '';

  if (typeof mix === 'string' || typeof mix === 'number') {
    str += mix;
  } else if (typeof mix === 'object') {
    if (Array.isArray(mix)) {
      for (k = 0; k < mix.length; k++) {
        if (mix[k]) {
          if (y = toVal(mix[k])) {
            str && (str += ' ');
            str += y;
          }
        }
      }
    } else {
      for (k in mix) {
        if (mix[k]) {
          str && (str += ' ');
          str += k;
        }
      }
    }
  }

  return str;
}

function clsx () {
  var i = 0,
      tmp,
      x,
      str = '';

  while (i < arguments.length) {
    if (tmp = arguments[i++]) {
      if (x = toVal(tmp)) {
        str && (str += ' ');
        str += x;
      }
    }
  }

  return str;
}

function chainPropTypes(propType1, propType2) {

  return function validate() {
    return propType1.apply(void 0, arguments) || propType2.apply(void 0, arguments);
  };
}

function _typeof$1(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$1 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$1(obj);
}

function isPlainObject(item) {
  return item && _typeof$1(item) === 'object' && item.constructor === Object;
}
function deepmerge(target, source) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    clone: true
  };
  var output = options.clone ? _extends$1({}, target) : target;

  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach(function (key) {
      // Avoid prototype pollution
      if (key === '__proto__') {
        return;
      }

      if (isPlainObject(source[key]) && key in target) {
        output[key] = deepmerge(target[key], source[key], options);
      } else {
        output[key] = source[key];
      }
    });
  }

  return output;
}

function isClassComponent$1(elementType) {
  // elementType.prototype?.isReactComponent
  var _elementType$prototyp = elementType.prototype,
      prototype = _elementType$prototyp === void 0 ? {} : _elementType$prototyp;
  return Boolean(prototype.isReactComponent);
}

function acceptingRef(props, propName, componentName, location, propFullName) {
  var element = props[propName];
  var safePropName = propFullName || propName;

  if (element == null) {
    return null;
  }

  var warningHint;
  var elementType = element.type;
  /**
   * Blacklisting instead of whitelisting
   *
   * Blacklisting will miss some components, such as React.Fragment. Those will at least
   * trigger a warning in React.
   * We can't whitelist because there is no safe way to detect React.forwardRef
   * or class components. "Safe" means there's no public API.
   *
   */

  if (typeof elementType === 'function' && !isClassComponent$1(elementType)) {
    warningHint = 'Did you accidentally use a plain function component for an element instead?';
  }

  if (warningHint !== undefined) {
    return new Error("Invalid ".concat(location, " `").concat(safePropName, "` supplied to `").concat(componentName, "`. ") + "Expected an element that can hold a ref. ".concat(warningHint, " ") + 'For more information see https://material-ui.com/r/caveat-with-refs-guide');
  }

  return null;
}

var elementAcceptingRef = chainPropTypes(PropTypes.element, acceptingRef);
elementAcceptingRef.isRequired = chainPropTypes(PropTypes.element.isRequired, acceptingRef);
var elementAcceptingRef$1 = elementAcceptingRef;

function isClassComponent(elementType) {
  // elementType.prototype?.isReactComponent
  var _elementType$prototyp = elementType.prototype,
      prototype = _elementType$prototyp === void 0 ? {} : _elementType$prototyp;
  return Boolean(prototype.isReactComponent);
}

function elementTypeAcceptingRef(props, propName, componentName, location, propFullName) {
  var propValue = props[propName];
  var safePropName = propFullName || propName;

  if (propValue == null) {
    return null;
  }

  var warningHint;
  /**
   * Blacklisting instead of whitelisting
   *
   * Blacklisting will miss some components, such as React.Fragment. Those will at least
   * trigger a warning in React.
   * We can't whitelist because there is no safe way to detect React.forwardRef
   * or class components. "Safe" means there's no public API.
   *
   */

  if (typeof propValue === 'function' && !isClassComponent(propValue)) {
    warningHint = 'Did you accidentally provide a plain function component instead?';
  }

  if (warningHint !== undefined) {
    return new Error("Invalid ".concat(location, " `").concat(safePropName, "` supplied to `").concat(componentName, "`. ") + "Expected an element type that can hold a ref. ".concat(warningHint, " ") + 'For more information see https://material-ui.com/r/caveat-with-refs-guide');
  }

  return null;
}

var elementTypeAcceptingRef$1 = chainPropTypes(propTypes.exports.elementType, elementTypeAcceptingRef);

// However, in order to reduce the number of dependencies and to remove some extra safe checks
// the module was forked.
// Only exported for test purposes.

var specialProperty = "exact-prop: \u200B";
function exactProp(propTypes) {

  return _extends$1({}, propTypes, _defineProperty({}, specialProperty, function (props) {
    var unsupportedProps = Object.keys(props).filter(function (prop) {
      return !propTypes.hasOwnProperty(prop);
    });

    if (unsupportedProps.length > 0) {
      return new Error("The following props are not supported: ".concat(unsupportedProps.map(function (prop) {
        return "`".concat(prop, "`");
      }).join(', '), ". Please remove them."));
    }

    return null;
  }));
}

// https://github.com/JamesMGreene/Function.name/blob/58b314d4a983110c3682f1228f845d39ccca1817/Function.name.js#L3

var fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function getFunctionName(fn) {
  var match = "".concat(fn).match(fnNameMatchRegex);
  var name = match && match[1];
  return name || '';
}
/**
 * @param {function} Component
 * @param {string} fallback
 * @returns {string | undefined}
 */

function getFunctionComponentName(Component) {
  var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return Component.displayName || Component.name || getFunctionName(Component) || fallback;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = getFunctionComponentName(innerType);
  return outerType.displayName || (functionName !== '' ? "".concat(wrapperName, "(").concat(functionName, ")") : wrapperName);
}
/**
 * cherry-pick from
 * https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/getComponentName.js
 * originally forked from recompose/getDisplayName with added IE 11 support
 *
 * @param {React.ReactType} Component
 * @returns {string | undefined}
 */


function getDisplayName(Component) {
  if (Component == null) {
    return undefined;
  }

  if (typeof Component === 'string') {
    return Component;
  }

  if (typeof Component === 'function') {
    return getFunctionComponentName(Component, 'Component');
  }

  if (_typeof$1(Component) === 'object') {
    switch (Component.$$typeof) {
      case reactIs$1.exports.ForwardRef:
        return getWrappedName(Component, Component.render, 'ForwardRef');

      case reactIs$1.exports.Memo:
        return getWrappedName(Component, Component.type, 'memo');

      default:
        return undefined;
    }
  }

  return undefined;
}

function HTMLElementType(props, propName, componentName, location, propFullName) {

  var propValue = props[propName];
  var safePropName = propFullName || propName;

  if (propValue == null) {
    return null;
  }

  if (propValue && propValue.nodeType !== 1) {
    return new Error("Invalid ".concat(location, " `").concat(safePropName, "` supplied to `").concat(componentName, "`. ") + "Expected an HTMLElement.");
  }

  return null;
}

var refType = PropTypes.oneOfType([PropTypes.func, PropTypes.object]);
var refType$1 = refType;

/* eslint-disable no-use-before-define */

/**
 * Returns a number whose value is limited to the given range.
 *
 * @param {number} value The value to be clamped
 * @param {number} min The lower boundary of the output range
 * @param {number} max The upper boundary of the output range
 * @returns {number} A number in the range [min, max]
 */

function clamp(value) {
  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

  {
    if (value < min || value > max) {
      console.error("Material-UI: The value provided ".concat(value, " is out of range [").concat(min, ", ").concat(max, "]."));
    }
  }

  return Math.min(Math.max(min, value), max);
}
/**
 * Converts a color from CSS hex format to CSS rgb format.
 *
 * @param {string} color - Hex color, i.e. #nnn or #nnnnnn
 * @returns {string} A CSS rgb color string
 */


function hexToRgb(color) {
  color = color.substr(1);
  var re = new RegExp(".{1,".concat(color.length >= 6 ? 2 : 1, "}"), 'g');
  var colors = color.match(re);

  if (colors && colors[0].length === 1) {
    colors = colors.map(function (n) {
      return n + n;
    });
  }

  return colors ? "rgb".concat(colors.length === 4 ? 'a' : '', "(").concat(colors.map(function (n, index) {
    return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1000) / 1000;
  }).join(', '), ")") : '';
}
/**
 * Converts a color from hsl format to rgb format.
 *
 * @param {string} color - HSL color values
 * @returns {string} rgb color values
 */

function hslToRgb(color) {
  color = decomposeColor(color);
  var _color = color,
      values = _color.values;
  var h = values[0];
  var s = values[1] / 100;
  var l = values[2] / 100;
  var a = s * Math.min(l, 1 - l);

  var f = function f(n) {
    var k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n + h / 30) % 12;
    return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  };

  var type = 'rgb';
  var rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];

  if (color.type === 'hsla') {
    type += 'a';
    rgb.push(values[3]);
  }

  return recomposeColor({
    type: type,
    values: rgb
  });
}
/**
 * Returns an object with the type and values of a color.
 *
 * Note: Does not support rgb % values.
 *
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @returns {object} - A MUI color object: {type: string, values: number[]}
 */

function decomposeColor(color) {
  // Idempotent
  if (color.type) {
    return color;
  }

  if (color.charAt(0) === '#') {
    return decomposeColor(hexToRgb(color));
  }

  var marker = color.indexOf('(');
  var type = color.substring(0, marker);

  if (['rgb', 'rgba', 'hsl', 'hsla'].indexOf(type) === -1) {
    throw new Error("Material-UI: Unsupported `".concat(color, "` color.\nWe support the following formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla().") );
  }

  var values = color.substring(marker + 1, color.length - 1).split(',');
  values = values.map(function (value) {
    return parseFloat(value);
  });
  return {
    type: type,
    values: values
  };
}
/**
 * Converts a color object with type and values to a string.
 *
 * @param {object} color - Decomposed color
 * @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla'
 * @param {array} color.values - [n,n,n] or [n,n,n,n]
 * @returns {string} A CSS color string
 */

function recomposeColor(color) {
  var type = color.type;
  var values = color.values;

  if (type.indexOf('rgb') !== -1) {
    // Only convert the first 3 values to int (i.e. not alpha)
    values = values.map(function (n, i) {
      return i < 3 ? parseInt(n, 10) : n;
    });
  } else if (type.indexOf('hsl') !== -1) {
    values[1] = "".concat(values[1], "%");
    values[2] = "".concat(values[2], "%");
  }

  return "".concat(type, "(").concat(values.join(', '), ")");
}
/**
 * Calculates the contrast ratio between two colors.
 *
 * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 *
 * @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @returns {number} A contrast ratio value in the range 0 - 21.
 */

function getContrastRatio(foreground, background) {
  var lumA = getLuminance(foreground);
  var lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
/**
 * The relative brightness of any point in a color space,
 * normalized to 0 for darkest black and 1 for lightest white.
 *
 * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 *
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @returns {number} The relative brightness of the color in the range 0 - 1
 */

function getLuminance(color) {
  color = decomposeColor(color);
  var rgb = color.type === 'hsl' ? decomposeColor(hslToRgb(color)).values : color.values;
  rgb = rgb.map(function (val) {
    val /= 255; // normalized

    return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
  }); // Truncate at 3 digits

  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
/**
 * Darken or lighten a color, depending on its luminance.
 * Light colors are darkened, dark colors are lightened.
 *
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param {number} coefficient=0.15 - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */

function emphasize(color) {
  var coefficient = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.15;
  return getLuminance(color) > 0.5 ? darken(color, coefficient) : lighten(color, coefficient);
}
/**
 * Set the absolute transparency of a color.
 * Any existing alpha value is overwritten.
 *
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param {number} value - value to set the alpha channel to in the range 0-1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */

function alpha(color, value) {
  color = decomposeColor(color);
  value = clamp(value);

  if (color.type === 'rgb' || color.type === 'hsl') {
    color.type += 'a';
  }

  color.values[3] = value;
  return recomposeColor(color);
}
/**
 * Darkens a color.
 *
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param {number} coefficient - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */

function darken(color, coefficient) {
  color = decomposeColor(color);
  coefficient = clamp(coefficient);

  if (color.type.indexOf('hsl') !== -1) {
    color.values[2] *= 1 - coefficient;
  } else if (color.type.indexOf('rgb') !== -1) {
    for (var i = 0; i < 3; i += 1) {
      color.values[i] *= 1 - coefficient;
    }
  }

  return recomposeColor(color);
}
/**
 * Lightens a color.
 *
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param {number} coefficient - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */

function lighten(color, coefficient) {
  color = decomposeColor(color);
  coefficient = clamp(coefficient);

  if (color.type.indexOf('hsl') !== -1) {
    color.values[2] += (100 - color.values[2]) * coefficient;
  } else if (color.type.indexOf('rgb') !== -1) {
    for (var i = 0; i < 3; i += 1) {
      color.values[i] += (255 - color.values[i]) * coefficient;
    }
  }

  return recomposeColor(color);
}

// It can't be configured as it's used statically for propTypes.

var keys = ['xs', 'sm', 'md', 'lg', 'xl']; // Keep in mind that @media is inclusive by the CSS specification.

function createBreakpoints(breakpoints) {
  var _breakpoints$values = breakpoints.values,
      values = _breakpoints$values === void 0 ? {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920
  } : _breakpoints$values,
      _breakpoints$unit = breakpoints.unit,
      unit = _breakpoints$unit === void 0 ? 'px' : _breakpoints$unit,
      _breakpoints$step = breakpoints.step,
      step = _breakpoints$step === void 0 ? 5 : _breakpoints$step,
      other = _objectWithoutProperties(breakpoints, ["values", "unit", "step"]);

  function up(key) {
    var value = typeof values[key] === 'number' ? values[key] : key;
    return "@media (min-width:".concat(value).concat(unit, ")");
  }

  function down(key) {
    var endIndex = keys.indexOf(key) + 1;
    var upperbound = values[keys[endIndex]];

    if (endIndex === keys.length) {
      // xl down applies to all sizes
      return up('xs');
    }

    var value = typeof upperbound === 'number' && endIndex > 0 ? upperbound : key;
    return "@media (max-width:".concat(value - step / 100).concat(unit, ")");
  }

  function between(start, end) {
    var endIndex = keys.indexOf(end);

    if (endIndex === keys.length - 1) {
      return up(start);
    }

    return "@media (min-width:".concat(typeof values[start] === 'number' ? values[start] : start).concat(unit, ") and ") + "(max-width:".concat((endIndex !== -1 && typeof values[keys[endIndex + 1]] === 'number' ? values[keys[endIndex + 1]] : end) - step / 100).concat(unit, ")");
  }

  function only(key) {
    return between(key, key);
  }

  var warnedOnce = false;

  function width(key) {
    {
      if (!warnedOnce) {
        warnedOnce = true;
        console.warn(["Material-UI: The `theme.breakpoints.width` utility is deprecated because it's redundant.", 'Use the `theme.breakpoints.values` instead.'].join('\n'));
      }
    }

    return values[key];
  }

  return _extends$1({
    keys: keys,
    values: values,
    up: up,
    down: down,
    between: between,
    only: only,
    width: width
  }, other);
}

function createMixins(breakpoints, spacing, mixins) {
  var _toolbar;

  return _extends$1({
    gutters: function gutters() {
      var styles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      console.warn(['Material-UI: theme.mixins.gutters() is deprecated.', 'You can use the source of the mixin directly:', "\n      paddingLeft: theme.spacing(2),\n      paddingRight: theme.spacing(2),\n      [theme.breakpoints.up('sm')]: {\n        paddingLeft: theme.spacing(3),\n        paddingRight: theme.spacing(3),\n      },\n      "].join('\n'));
      return _extends$1({
        paddingLeft: spacing(2),
        paddingRight: spacing(2)
      }, styles, _defineProperty({}, breakpoints.up('sm'), _extends$1({
        paddingLeft: spacing(3),
        paddingRight: spacing(3)
      }, styles[breakpoints.up('sm')])));
    },
    toolbar: (_toolbar = {
      minHeight: 56
    }, _defineProperty(_toolbar, "".concat(breakpoints.up('xs'), " and (orientation: landscape)"), {
      minHeight: 48
    }), _defineProperty(_toolbar, breakpoints.up('sm'), {
      minHeight: 64
    }), _toolbar)
  }, mixins);
}

var common = {
  black: '#000',
  white: '#fff'
};
var common$1 = common;

var grey = {
  50: '#fafafa',
  100: '#f5f5f5',
  200: '#eeeeee',
  300: '#e0e0e0',
  400: '#bdbdbd',
  500: '#9e9e9e',
  600: '#757575',
  700: '#616161',
  800: '#424242',
  900: '#212121',
  A100: '#d5d5d5',
  A200: '#aaaaaa',
  A400: '#303030',
  A700: '#616161'
};
var grey$1 = grey;

var indigo = {
  50: '#e8eaf6',
  100: '#c5cae9',
  200: '#9fa8da',
  300: '#7986cb',
  400: '#5c6bc0',
  500: '#3f51b5',
  600: '#3949ab',
  700: '#303f9f',
  800: '#283593',
  900: '#1a237e',
  A100: '#8c9eff',
  A200: '#536dfe',
  A400: '#3d5afe',
  A700: '#304ffe'
};
var indigo$1 = indigo;

var pink = {
  50: '#fce4ec',
  100: '#f8bbd0',
  200: '#f48fb1',
  300: '#f06292',
  400: '#ec407a',
  500: '#e91e63',
  600: '#d81b60',
  700: '#c2185b',
  800: '#ad1457',
  900: '#880e4f',
  A100: '#ff80ab',
  A200: '#ff4081',
  A400: '#f50057',
  A700: '#c51162'
};
var pink$1 = pink;

var red = {
  50: '#ffebee',
  100: '#ffcdd2',
  200: '#ef9a9a',
  300: '#e57373',
  400: '#ef5350',
  500: '#f44336',
  600: '#e53935',
  700: '#d32f2f',
  800: '#c62828',
  900: '#b71c1c',
  A100: '#ff8a80',
  A200: '#ff5252',
  A400: '#ff1744',
  A700: '#d50000'
};
var red$1 = red;

var orange = {
  50: '#fff3e0',
  100: '#ffe0b2',
  200: '#ffcc80',
  300: '#ffb74d',
  400: '#ffa726',
  500: '#ff9800',
  600: '#fb8c00',
  700: '#f57c00',
  800: '#ef6c00',
  900: '#e65100',
  A100: '#ffd180',
  A200: '#ffab40',
  A400: '#ff9100',
  A700: '#ff6d00'
};
var orange$1 = orange;

var blue = {
  50: '#e3f2fd',
  100: '#bbdefb',
  200: '#90caf9',
  300: '#64b5f6',
  400: '#42a5f5',
  500: '#2196f3',
  600: '#1e88e5',
  700: '#1976d2',
  800: '#1565c0',
  900: '#0d47a1',
  A100: '#82b1ff',
  A200: '#448aff',
  A400: '#2979ff',
  A700: '#2962ff'
};
var blue$1 = blue;

var green = {
  50: '#e8f5e9',
  100: '#c8e6c9',
  200: '#a5d6a7',
  300: '#81c784',
  400: '#66bb6a',
  500: '#4caf50',
  600: '#43a047',
  700: '#388e3c',
  800: '#2e7d32',
  900: '#1b5e20',
  A100: '#b9f6ca',
  A200: '#69f0ae',
  A400: '#00e676',
  A700: '#00c853'
};
var green$1 = green;

var light = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: 'rgba(0, 0, 0, 0.87)',
    // Secondary text.
    secondary: 'rgba(0, 0, 0, 0.54)',
    // Disabled text have even lower visual prominence.
    disabled: 'rgba(0, 0, 0, 0.38)',
    // Text hints.
    hint: 'rgba(0, 0, 0, 0.38)'
  },
  // The color used to divide different elements.
  divider: 'rgba(0, 0, 0, 0.12)',
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: common$1.white,
    default: grey$1[50]
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: 'rgba(0, 0, 0, 0.54)',
    // The color of an hovered action.
    hover: 'rgba(0, 0, 0, 0.04)',
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: 'rgba(0, 0, 0, 0.08)',
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: 'rgba(0, 0, 0, 0.26)',
    // The background color of a disabled action.
    disabledBackground: 'rgba(0, 0, 0, 0.12)',
    disabledOpacity: 0.38,
    focus: 'rgba(0, 0, 0, 0.12)',
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
};
var dark = {
  text: {
    primary: common$1.white,
    secondary: 'rgba(255, 255, 255, 0.7)',
    disabled: 'rgba(255, 255, 255, 0.5)',
    hint: 'rgba(255, 255, 255, 0.5)',
    icon: 'rgba(255, 255, 255, 0.5)'
  },
  divider: 'rgba(255, 255, 255, 0.12)',
  background: {
    paper: grey$1[800],
    default: '#303030'
  },
  action: {
    active: common$1.white,
    hover: 'rgba(255, 255, 255, 0.08)',
    hoverOpacity: 0.08,
    selected: 'rgba(255, 255, 255, 0.16)',
    selectedOpacity: 0.16,
    disabled: 'rgba(255, 255, 255, 0.3)',
    disabledBackground: 'rgba(255, 255, 255, 0.12)',
    disabledOpacity: 0.38,
    focus: 'rgba(255, 255, 255, 0.12)',
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};

function addLightOrDark(intent, direction, shade, tonalOffset) {
  var tonalOffsetLight = tonalOffset.light || tonalOffset;
  var tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;

  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === 'light') {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === 'dark') {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}

function createPalette(palette) {
  var _palette$primary = palette.primary,
      primary = _palette$primary === void 0 ? {
    light: indigo$1[300],
    main: indigo$1[500],
    dark: indigo$1[700]
  } : _palette$primary,
      _palette$secondary = palette.secondary,
      secondary = _palette$secondary === void 0 ? {
    light: pink$1.A200,
    main: pink$1.A400,
    dark: pink$1.A700
  } : _palette$secondary,
      _palette$error = palette.error,
      error = _palette$error === void 0 ? {
    light: red$1[300],
    main: red$1[500],
    dark: red$1[700]
  } : _palette$error,
      _palette$warning = palette.warning,
      warning = _palette$warning === void 0 ? {
    light: orange$1[300],
    main: orange$1[500],
    dark: orange$1[700]
  } : _palette$warning,
      _palette$info = palette.info,
      info = _palette$info === void 0 ? {
    light: blue$1[300],
    main: blue$1[500],
    dark: blue$1[700]
  } : _palette$info,
      _palette$success = palette.success,
      success = _palette$success === void 0 ? {
    light: green$1[300],
    main: green$1[500],
    dark: green$1[700]
  } : _palette$success,
      _palette$type = palette.type,
      type = _palette$type === void 0 ? 'light' : _palette$type,
      _palette$contrastThre = palette.contrastThreshold,
      contrastThreshold = _palette$contrastThre === void 0 ? 3 : _palette$contrastThre,
      _palette$tonalOffset = palette.tonalOffset,
      tonalOffset = _palette$tonalOffset === void 0 ? 0.2 : _palette$tonalOffset,
      other = _objectWithoutProperties(palette, ["primary", "secondary", "error", "warning", "info", "success", "type", "contrastThreshold", "tonalOffset"]); // Use the same logic as
  // Bootstrap: https://github.com/twbs/bootstrap/blob/1d6e3710dd447de1a200f29e8fa521f8a0908f70/scss/_functions.scss#L59
  // and material-components-web https://github.com/material-components/material-components-web/blob/ac46b8863c4dab9fc22c4c662dc6bd1b65dd652f/packages/mdc-theme/_functions.scss#L54


  function getContrastText(background) {
    var contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;

    {
      var contrast = getContrastRatio(background, contrastText);

      if (contrast < 3) {
        console.error(["Material-UI: The contrast ratio of ".concat(contrast, ":1 for ").concat(contrastText, " on ").concat(background), 'falls below the WCAG recommended absolute minimum contrast ratio of 3:1.', 'https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast'].join('\n'));
      }
    }

    return contrastText;
  }

  var augmentColor = function augmentColor(color) {
    var mainShade = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
    var lightShade = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;
    var darkShade = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 700;
    color = _extends$1({}, color);

    if (!color.main && color[mainShade]) {
      color.main = color[mainShade];
    }

    if (!color.main) {
      throw new Error("Material-UI: The color provided to augmentColor(color) is invalid.\nThe color object needs to have a `main` property or a `".concat(mainShade, "` property.") );
    }

    if (typeof color.main !== 'string') {
      throw new Error("Material-UI: The color provided to augmentColor(color) is invalid.\n`color.main` should be a string, but `".concat(JSON.stringify(color.main), "` was provided instead.\n\nDid you intend to use one of the following approaches?\n\nimport {\xA0green } from \"@material-ui/core/colors\";\n\nconst theme1 = createTheme({ palette: {\n  primary: green,\n} });\n\nconst theme2 = createTheme({ palette: {\n  primary: { main: green[500] },\n} });") );
    }

    addLightOrDark(color, 'light', lightShade, tonalOffset);
    addLightOrDark(color, 'dark', darkShade, tonalOffset);

    if (!color.contrastText) {
      color.contrastText = getContrastText(color.main);
    }

    return color;
  };

  var types = {
    dark: dark,
    light: light
  };

  {
    if (!types[type]) {
      console.error("Material-UI: The palette type `".concat(type, "` is not supported."));
    }
  }

  var paletteOutput = deepmerge(_extends$1({
    // A collection of common colors.
    common: common$1,
    // The palette type, can be light or dark.
    type: type,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor(primary),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor(secondary, 'A400', 'A200', 'A700'),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor(error),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor(warning),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor(info),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor(success),
    // The grey colors.
    grey: grey$1,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: getContrastText,
    // Generate a rich color object.
    augmentColor: augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: tonalOffset
  }, types[type]), other);
  return paletteOutput;
}

function round(value) {
  return Math.round(value * 1e5) / 1e5;
}

var warnedOnce = false;

function roundWithDeprecationWarning(value) {
  {
    if (!warnedOnce) {
      console.warn(['Material-UI: The `theme.typography.round` helper is deprecated.', 'Head to https://material-ui.com/r/migration-v4/#theme for a migration path.'].join('\n'));
      warnedOnce = true;
    }
  }

  return round(value);
}

var caseAllCaps = {
  textTransform: 'uppercase'
};
var defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
/**
 * @see @link{https://material.io/design/typography/the-type-system.html}
 * @see @link{https://material.io/design/typography/understanding-typography.html}
 */

function createTypography(palette, typography) {
  var _ref = typeof typography === 'function' ? typography(palette) : typography,
      _ref$fontFamily = _ref.fontFamily,
      fontFamily = _ref$fontFamily === void 0 ? defaultFontFamily : _ref$fontFamily,
      _ref$fontSize = _ref.fontSize,
      fontSize = _ref$fontSize === void 0 ? 14 : _ref$fontSize,
      _ref$fontWeightLight = _ref.fontWeightLight,
      fontWeightLight = _ref$fontWeightLight === void 0 ? 300 : _ref$fontWeightLight,
      _ref$fontWeightRegula = _ref.fontWeightRegular,
      fontWeightRegular = _ref$fontWeightRegula === void 0 ? 400 : _ref$fontWeightRegula,
      _ref$fontWeightMedium = _ref.fontWeightMedium,
      fontWeightMedium = _ref$fontWeightMedium === void 0 ? 500 : _ref$fontWeightMedium,
      _ref$fontWeightBold = _ref.fontWeightBold,
      fontWeightBold = _ref$fontWeightBold === void 0 ? 700 : _ref$fontWeightBold,
      _ref$htmlFontSize = _ref.htmlFontSize,
      htmlFontSize = _ref$htmlFontSize === void 0 ? 16 : _ref$htmlFontSize,
      allVariants = _ref.allVariants,
      pxToRem2 = _ref.pxToRem,
      other = _objectWithoutProperties(_ref, ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"]);

  {
    if (typeof fontSize !== 'number') {
      console.error('Material-UI: `fontSize` is required to be a number.');
    }

    if (typeof htmlFontSize !== 'number') {
      console.error('Material-UI: `htmlFontSize` is required to be a number.');
    }
  }

  var coef = fontSize / 14;

  var pxToRem = pxToRem2 || function (size) {
    return "".concat(size / htmlFontSize * coef, "rem");
  };

  var buildVariant = function buildVariant(fontWeight, size, lineHeight, letterSpacing, casing) {
    return _extends$1({
      fontFamily: fontFamily,
      fontWeight: fontWeight,
      fontSize: pxToRem(size),
      // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
      lineHeight: lineHeight
    }, fontFamily === defaultFontFamily ? {
      letterSpacing: "".concat(round(letterSpacing / size), "em")
    } : {}, casing, allVariants);
  };

  var variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)
  };
  return deepmerge(_extends$1({
    htmlFontSize: htmlFontSize,
    pxToRem: pxToRem,
    round: roundWithDeprecationWarning,
    // TODO v5: remove
    fontFamily: fontFamily,
    fontSize: fontSize,
    fontWeightLight: fontWeightLight,
    fontWeightRegular: fontWeightRegular,
    fontWeightMedium: fontWeightMedium,
    fontWeightBold: fontWeightBold
  }, variants), other, {
    clone: false // No need to clone deep

  });
}

var shadowKeyUmbraOpacity = 0.2;
var shadowKeyPenumbraOpacity = 0.14;
var shadowAmbientShadowOpacity = 0.12;

function createShadow() {
  return ["".concat(arguments.length <= 0 ? undefined : arguments[0], "px ").concat(arguments.length <= 1 ? undefined : arguments[1], "px ").concat(arguments.length <= 2 ? undefined : arguments[2], "px ").concat(arguments.length <= 3 ? undefined : arguments[3], "px rgba(0,0,0,").concat(shadowKeyUmbraOpacity, ")"), "".concat(arguments.length <= 4 ? undefined : arguments[4], "px ").concat(arguments.length <= 5 ? undefined : arguments[5], "px ").concat(arguments.length <= 6 ? undefined : arguments[6], "px ").concat(arguments.length <= 7 ? undefined : arguments[7], "px rgba(0,0,0,").concat(shadowKeyPenumbraOpacity, ")"), "".concat(arguments.length <= 8 ? undefined : arguments[8], "px ").concat(arguments.length <= 9 ? undefined : arguments[9], "px ").concat(arguments.length <= 10 ? undefined : arguments[10], "px ").concat(arguments.length <= 11 ? undefined : arguments[11], "px rgba(0,0,0,").concat(shadowAmbientShadowOpacity, ")")].join(',');
} // Values from https://github.com/material-components/material-components-web/blob/be8747f94574669cb5e7add1a7c54fa41a89cec7/packages/mdc-elevation/_variables.scss


var shadows = ['none', createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
var shadows$1 = shadows;

var shape = {
  borderRadius: 4
};
var shape$1 = shape;

var responsivePropType = PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.object, PropTypes.array]) ;
var responsivePropType$1 = responsivePropType;

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

var spacingKeys = ['m', 'mt', 'mr', 'mb', 'ml', 'mx', 'my', 'p', 'pt', 'pr', 'pb', 'pl', 'px', 'py', 'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'marginX', 'marginY', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'paddingX', 'paddingY'];
function createUnarySpacing(theme) {
  var themeSpacing = theme.spacing || 8;

  if (typeof themeSpacing === 'number') {
    return function (abs) {
      {
        if (typeof abs !== 'number') {
          console.error("Material-UI: Expected spacing argument to be a number, got ".concat(abs, "."));
        }
      }

      return themeSpacing * abs;
    };
  }

  if (Array.isArray(themeSpacing)) {
    return function (abs) {
      {
        if (abs > themeSpacing.length - 1) {
          console.error(["Material-UI: The value provided (".concat(abs, ") overflows."), "The supported values are: ".concat(JSON.stringify(themeSpacing), "."), "".concat(abs, " > ").concat(themeSpacing.length - 1, ", you need to add the missing values.")].join('\n'));
        }
      }

      return themeSpacing[abs];
    };
  }

  if (typeof themeSpacing === 'function') {
    return themeSpacing;
  }

  {
    console.error(["Material-UI: The `theme.spacing` value (".concat(themeSpacing, ") is invalid."), 'It should be a number, an array or a function.'].join('\n'));
  }

  return function () {
    return undefined;
  };
}

spacingKeys.reduce(function (obj, key) {
  obj[key] = responsivePropType$1;
  return obj;
}, {}) ;

var warnOnce;
function createSpacing() {
  var spacingInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8; // Already transformed.

  if (spacingInput.mui) {
    return spacingInput;
  } // Material Design layouts are visually balanced. Most measurements align to an 8dp grid applied, which aligns both spacing and the overall layout.
  // Smaller components, such as icons and type, can align to a 4dp grid.
  // https://material.io/design/layout/understanding-layout.html#usage


  var transform = createUnarySpacing({
    spacing: spacingInput
  });

  var spacing = function spacing() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    {
      if (!(args.length <= 4)) {
        console.error("Material-UI: Too many arguments provided, expected between 0 and 4, got ".concat(args.length));
      }
    }

    if (args.length === 0) {
      return transform(1);
    }

    if (args.length === 1) {
      return transform(args[0]);
    }

    return args.map(function (argument) {
      if (typeof argument === 'string') {
        return argument;
      }

      var output = transform(argument);
      return typeof output === 'number' ? "".concat(output, "px") : output;
    }).join(' ');
  }; // Backward compatibility, to remove in v5.


  Object.defineProperty(spacing, 'unit', {
    get: function get() {
      {
        if (!warnOnce || 'development' === 'test') {
          console.error(['Material-UI: theme.spacing.unit usage has been deprecated.', 'It will be removed in v5.', 'You can replace `theme.spacing.unit * y` with `theme.spacing(y)`.', '', 'You can use the `https://github.com/mui-org/material-ui/tree/master/packages/material-ui-codemod/README.md#theme-spacing-api` migration helper to make the process smoother.'].join('\n'));
        }

        warnOnce = true;
      }

      return spacingInput;
    }
  });
  spacing.mui = true;
  return spacing;
}

// to learn the context in which each easing should be used.

var easing = {
  // This is the most common easing curve.
  easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'
}; // Follow https://material.io/guidelines/motion/duration-easing.html#duration-easing-common-durations
// to learn when use what timing

var duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};

function formatMs(milliseconds) {
  return "".concat(Math.round(milliseconds), "ms");
}
/**
 * @param {string|Array} props
 * @param {object} param
 * @param {string} param.prop
 * @param {number} param.duration
 * @param {string} param.easing
 * @param {number} param.delay
 */


var transitions = {
  easing: easing,
  duration: duration,
  create: function create() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['all'];
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var _options$duration = options.duration,
        durationOption = _options$duration === void 0 ? duration.standard : _options$duration,
        _options$easing = options.easing,
        easingOption = _options$easing === void 0 ? easing.easeInOut : _options$easing,
        _options$delay = options.delay,
        delay = _options$delay === void 0 ? 0 : _options$delay,
        other = _objectWithoutProperties(options, ["duration", "easing", "delay"]);

    {
      var isString = function isString(value) {
        return typeof value === 'string';
      };

      var isNumber = function isNumber(value) {
        return !isNaN(parseFloat(value));
      };

      if (!isString(props) && !Array.isArray(props)) {
        console.error('Material-UI: Argument "props" must be a string or Array.');
      }

      if (!isNumber(durationOption) && !isString(durationOption)) {
        console.error("Material-UI: Argument \"duration\" must be a number or a string but found ".concat(durationOption, "."));
      }

      if (!isString(easingOption)) {
        console.error('Material-UI: Argument "easing" must be a string.');
      }

      if (!isNumber(delay) && !isString(delay)) {
        console.error('Material-UI: Argument "delay" must be a number or a string.');
      }

      if (Object.keys(other).length !== 0) {
        console.error("Material-UI: Unrecognized argument(s) [".concat(Object.keys(other).join(','), "]."));
      }
    }

    return (Array.isArray(props) ? props : [props]).map(function (animatedProp) {
      return "".concat(animatedProp, " ").concat(typeof durationOption === 'string' ? durationOption : formatMs(durationOption), " ").concat(easingOption, " ").concat(typeof delay === 'string' ? delay : formatMs(delay));
    }).join(',');
  },
  getAutoHeightDuration: function getAutoHeightDuration(height) {
    if (!height) {
      return 0;
    }

    var constant = height / 36; // https://www.wolframalpha.com/input/?i=(4+%2B+15+*+(x+%2F+36+)+**+0.25+%2B+(x+%2F+36)+%2F+5)+*+10

    return Math.round((4 + 15 * Math.pow(constant, 0.25) + constant / 5) * 10);
  }
};

// We need to centralize the zIndex definitions as they work
// like global values in the browser.
var zIndex = {
  mobileStepper: 1000,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
var zIndex$1 = zIndex;

function createTheme() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var _options$breakpoints = options.breakpoints,
      breakpointsInput = _options$breakpoints === void 0 ? {} : _options$breakpoints,
      _options$mixins = options.mixins,
      mixinsInput = _options$mixins === void 0 ? {} : _options$mixins,
      _options$palette = options.palette,
      paletteInput = _options$palette === void 0 ? {} : _options$palette,
      spacingInput = options.spacing,
      _options$typography = options.typography,
      typographyInput = _options$typography === void 0 ? {} : _options$typography,
      other = _objectWithoutProperties(options, ["breakpoints", "mixins", "palette", "spacing", "typography"]);

  var palette = createPalette(paletteInput);
  var breakpoints = createBreakpoints(breakpointsInput);
  var spacing = createSpacing(spacingInput);
  var muiTheme = deepmerge({
    breakpoints: breakpoints,
    direction: 'ltr',
    mixins: createMixins(breakpoints, spacing, mixinsInput),
    overrides: {},
    // Inject custom styles
    palette: palette,
    props: {},
    // Provide default props
    shadows: shadows$1,
    typography: createTypography(palette, typographyInput),
    spacing: spacing,
    shape: shape$1,
    transitions: transitions,
    zIndex: zIndex$1
  }, other);

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  muiTheme = args.reduce(function (acc, argument) {
    return deepmerge(acc, argument);
  }, muiTheme);

  {
    var pseudoClasses = ['checked', 'disabled', 'error', 'focused', 'focusVisible', 'required', 'expanded', 'selected'];

    var traverse = function traverse(node, parentKey) {
      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var key; // eslint-disable-next-line guard-for-in, no-restricted-syntax

      for (key in node) {
        var child = node[key];

        if (depth === 1) {
          if (key.indexOf('Mui') === 0 && child) {
            traverse(child, key, depth + 1);
          }
        } else if (pseudoClasses.indexOf(key) !== -1 && Object.keys(child).length > 0) {
          {
            console.error(["Material-UI: The `".concat(parentKey, "` component increases ") + "the CSS specificity of the `".concat(key, "` internal state."), 'You can not override it like this: ', JSON.stringify(node, null, 2), '', 'Instead, you need to use the $ruleName syntax:', JSON.stringify({
              root: _defineProperty({}, "&$".concat(key), child)
            }, null, 2), '', 'https://material-ui.com/r/pseudo-classes-guide'].join('\n'));
          } // Remove the style to prevent global conflicts.


          node[key] = {};
        }
      }
    };

    traverse(muiTheme.overrides);
  }

  return muiTheme;
}

var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var nested = hasSymbol ? Symbol.for('mui.nested') : '__THEME_NESTED__';

/**
 * This is the list of the style rule name we use as drop in replacement for the built-in
 * pseudo classes (:checked, :disabled, :focused, etc.).
 *
 * Why do they exist in the first place?
 * These classes are used at a specificity of 2.
 * It allows them to override previously definied styles as well as
 * being untouched by simple user overrides.
 */

var pseudoClasses = ['checked', 'disabled', 'error', 'focused', 'focusVisible', 'required', 'expanded', 'selected']; // Returns a function which generates unique class names based on counters.
// When new generator function is created, rule counter is reset.
// We need to reset the rule counter for SSR for each request.
//
// It's inspired by
// https://github.com/cssinjs/jss/blob/4e6a05dd3f7b6572fdd3ab216861d9e446c20331/src/utils/createGenerateClassName.js

function createGenerateClassName() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _options$disableGloba = options.disableGlobal,
      disableGlobal = _options$disableGloba === void 0 ? false : _options$disableGloba;
      options.productionPrefix;
      var _options$seed = options.seed,
      seed = _options$seed === void 0 ? '' : _options$seed;
  var seedPrefix = seed === '' ? '' : "".concat(seed, "-");
  var ruleCounter = 0;

  var getNextCounterId = function getNextCounterId() {
    ruleCounter += 1;

    {
      if (ruleCounter >= 1e10) {
        console.warn(['Material-UI: You might have a memory leak.', 'The ruleCounter is not supposed to grow that much.'].join(''));
      }
    }

    return ruleCounter;
  };

  return function (rule, styleSheet) {
    var name = styleSheet.options.name; // Is a global static MUI style?

    if (name && name.indexOf('Mui') === 0 && !styleSheet.options.link && !disableGlobal) {
      // We can use a shorthand class name, we never use the keys to style the components.
      if (pseudoClasses.indexOf(rule.key) !== -1) {
        return "Mui-".concat(rule.key);
      }

      var prefix = "".concat(seedPrefix).concat(name, "-").concat(rule.key);

      if (!styleSheet.options.theme[nested] || seed !== '') {
        return prefix;
      }

      return "".concat(prefix, "-").concat(getNextCounterId());
    }

    var suffix = "".concat(rule.key, "-").concat(getNextCounterId()); // Help with debuggability.

    if (styleSheet.options.classNamePrefix) {
      return "".concat(seedPrefix).concat(styleSheet.options.classNamePrefix, "-").concat(suffix);
    }

    return "".concat(seedPrefix).concat(suffix);
  };
}

/* eslint-disable no-restricted-syntax */
function getThemeProps(params) {
  var theme = params.theme,
      name = params.name,
      props = params.props;

  if (!theme || !theme.props || !theme.props[name]) {
    return props;
  } // Resolve default props, code borrow from React source.
  // https://github.com/facebook/react/blob/15a8f031838a553e41c0b66eb1bcf1da8448104d/packages/react/src/ReactElement.js#L221


  var defaultProps = theme.props[name];
  var propName;

  for (propName in defaultProps) {
    if (props[propName] === undefined) {
      props[propName] = defaultProps[propName];
    }
  }

  return props;
}

var isProduction = 'development' === 'production';

function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }

    var text = "Warning: " + message;

    if (typeof console !== 'undefined') {
      console.warn(text);
    }

    try {
      throw Error(text);
    } catch (x) {}
  }
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var isBrowser$1 = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var plainObjectConstrurctor = {}.constructor;

function cloneStyle(style) {
  if (style == null || typeof style !== 'object') return style;
  if (Array.isArray(style)) return style.map(cloneStyle);
  if (style.constructor !== plainObjectConstrurctor) return style;
  var newStyle = {};

  for (var name in style) {
    newStyle[name] = cloneStyle(style[name]);
  }

  return newStyle;
}
/**
 * Create a rule instance.
 */


function createRule(name, decl, options) {
  if (name === void 0) {
    name = 'unnamed';
  }

  var jss = options.jss;
  var declCopy = cloneStyle(decl);
  var rule = jss.plugins.onCreateRule(name, declCopy, options);
  if (rule) return rule; // It is an at-rule and it has no instance.

  if (name[0] === '@') {
    warning(false, "[JSS] Unknown rule " + name) ;
  }

  return null;
}

var join = function join(value, by) {
  var result = '';

  for (var i = 0; i < value.length; i++) {
    // Remove !important from the value, it will be readded later.
    if (value[i] === '!important') break;
    if (result) result += by;
    result += value[i];
  }

  return result;
};
/**
 * Converts JSS array value to a CSS string.
 *
 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
 * `border: ['1px', '2px']` > `border: 1px, 2px;`
 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
 * `color: ['red', !important]` > `color: red !important;`
 */


var toCssValue = function toCssValue(value, ignoreImportant) {
  if (ignoreImportant === void 0) {
    ignoreImportant = false;
  }

  if (!Array.isArray(value)) return value;
  var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.

  if (Array.isArray(value[0])) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === '!important') break;
      if (cssValue) cssValue += ', ';
      cssValue += join(value[i], ' ');
    }
  } else cssValue = join(value, ', '); // Add !important, because it was ignored.


  if (!ignoreImportant && value[value.length - 1] === '!important') {
    cssValue += ' !important';
  }

  return cssValue;
};

function getWhitespaceSymbols(options) {
  if (options && options.format === false) {
    return {
      linebreak: '',
      space: ''
    };
  }

  return {
    linebreak: '\n',
    space: ' '
  };
}
/**
 * Indent a string.
 * http://jsperf.com/array-join-vs-for
 */


function indentStr(str, indent) {
  var result = '';

  for (var index = 0; index < indent; index++) {
    result += '  ';
  }

  return result + str;
}
/**
 * Converts a Rule to CSS string.
 */


function toCss(selector, style, options) {
  if (options === void 0) {
    options = {};
  }

  var result = '';
  if (!style) return result;
  var _options = options,
      _options$indent = _options.indent,
      indent = _options$indent === void 0 ? 0 : _options$indent;
  var fallbacks = style.fallbacks;

  if (options.format === false) {
    indent = -Infinity;
  }

  var _getWhitespaceSymbols = getWhitespaceSymbols(options),
      linebreak = _getWhitespaceSymbols.linebreak,
      space = _getWhitespaceSymbols.space;

  if (selector) indent++; // Apply fallbacks first.

  if (fallbacks) {
    // Array syntax {fallbacks: [{prop: value}]}
    if (Array.isArray(fallbacks)) {
      for (var index = 0; index < fallbacks.length; index++) {
        var fallback = fallbacks[index];

        for (var prop in fallback) {
          var value = fallback[prop];

          if (value != null) {
            if (result) result += linebreak;
            result += indentStr(prop + ":" + space + toCssValue(value) + ";", indent);
          }
        }
      }
    } else {
      // Object syntax {fallbacks: {prop: value}}
      for (var _prop in fallbacks) {
        var _value = fallbacks[_prop];

        if (_value != null) {
          if (result) result += linebreak;
          result += indentStr(_prop + ":" + space + toCssValue(_value) + ";", indent);
        }
      }
    }
  }

  for (var _prop2 in style) {
    var _value2 = style[_prop2];

    if (_value2 != null && _prop2 !== 'fallbacks') {
      if (result) result += linebreak;
      result += indentStr(_prop2 + ":" + space + toCssValue(_value2) + ";", indent);
    }
  } // Allow empty style in this case, because properties will be added dynamically.


  if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.

  if (!selector) return result;
  indent--;
  if (result) result = "" + linebreak + result + linebreak;
  return indentStr("" + selector + space + "{" + result, indent) + indentStr('}', indent);
}

var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;

var escape = function (str) {
  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
};

var BaseStyleRule = /*#__PURE__*/function () {
  function BaseStyleRule(key, style, options) {
    this.type = 'style';
    this.isProcessed = false;
    var sheet = options.sheet,
        Renderer = options.Renderer;
    this.key = key;
    this.options = options;
    this.style = style;
    if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();
  }
  /**
   * Get or set a style property.
   */


  var _proto = BaseStyleRule.prototype;

  _proto.prop = function prop(name, value, options) {
    // It's a getter.
    if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.

    var force = options ? options.force : false;
    if (!force && this.style[name] === value) return this;
    var newValue = value;

    if (!options || options.process !== false) {
      newValue = this.options.jss.plugins.onChangeValue(value, name, this);
    }

    var isEmpty = newValue == null || newValue === false;
    var isDefined = (name in this.style); // Value is empty and wasn't defined before.

    if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.

    var remove = isEmpty && isDefined;
    if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.

    if (this.renderable && this.renderer) {
      if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);
      return this;
    }

    var sheet = this.options.sheet;

    if (sheet && sheet.attached) {
      warning(false, '[JSS] Rule is not linked. Missing sheet option "link: true".') ;
    }

    return this;
  };

  return BaseStyleRule;
}();

var StyleRule = /*#__PURE__*/function (_BaseStyleRule) {
  _inheritsLoose(StyleRule, _BaseStyleRule);

  function StyleRule(key, style, options) {
    var _this;

    _this = _BaseStyleRule.call(this, key, style, options) || this;
    var selector = options.selector,
        scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;

    if (selector) {
      _this.selectorText = selector;
    } else if (scoped !== false) {
      _this.id = generateId(_assertThisInitialized(_assertThisInitialized(_this)), sheet);
      _this.selectorText = "." + escape(_this.id);
    }

    return _this;
  }
  /**
   * Set selector string.
   * Attention: use this with caution. Most browsers didn't implement
   * selectorText setter, so this may result in rerendering of entire Style Sheet.
   */


  var _proto2 = StyleRule.prototype;
  /**
   * Apply rule to an element inline.
   */

  _proto2.applyTo = function applyTo(renderable) {
    var renderer = this.renderer;

    if (renderer) {
      var json = this.toJSON();

      for (var prop in json) {
        renderer.setProperty(renderable, prop, json[prop]);
      }
    }

    return this;
  }
  /**
   * Returns JSON representation of the rule.
   * Fallbacks are not supported.
   * Useful for inline styles.
   */
  ;

  _proto2.toJSON = function toJSON() {
    var json = {};

    for (var prop in this.style) {
      var value = this.style[prop];
      if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);
    }

    return json;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto2.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? _extends$1({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.selectorText, this.style, opts);
  };

  _createClass(StyleRule, [{
    key: "selector",
    set: function set(selector) {
      if (selector === this.selectorText) return;
      this.selectorText = selector;
      var renderer = this.renderer,
          renderable = this.renderable;
      if (!renderable || !renderer) return;
      var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.

      if (!hasChanged) {
        renderer.replaceRule(renderable, this);
      }
    }
    /**
     * Get selector string.
     */
    ,
    get: function get() {
      return this.selectorText;
    }
  }]);

  return StyleRule;
}(BaseStyleRule);

var pluginStyleRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (key[0] === '@' || options.parent && options.parent.type === 'keyframes') {
      return null;
    }

    return new StyleRule(key, style, options);
  }
};
var defaultToStringOptions = {
  indent: 1,
  children: true
};
var atRegExp = /@([\w-]+)/;
/**
 * Conditional rule for @media, @supports
 */

var ConditionalRule = /*#__PURE__*/function () {
  function ConditionalRule(key, styles, options) {
    this.type = 'conditional';
    this.isProcessed = false;
    this.key = key;
    var atMatch = key.match(atRegExp);
    this.at = atMatch ? atMatch[1] : 'unknown'; // Key might contain a unique suffix in case the `name` passed by user was duplicate.

    this.query = options.name || "@" + this.at;
    this.options = options;
    this.rules = new RuleList(_extends$1({}, options, {
      parent: this
    }));

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = ConditionalRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions;
    }

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (options.indent == null) options.indent = defaultToStringOptions.indent;
    if (options.children == null) options.children = defaultToStringOptions.children;

    if (options.children === false) {
      return this.query + " {}";
    }

    var children = this.rules.toString(options);
    return children ? this.query + " {" + linebreak + children + linebreak + "}" : '';
  };

  return ConditionalRule;
}();

var keyRegExp = /@media|@supports\s+/;
var pluginConditionalRule = {
  onCreateRule: function onCreateRule(key, styles, options) {
    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
  }
};
var defaultToStringOptions$1 = {
  indent: 1,
  children: true
};
var nameRegExp = /@keyframes\s+([\w-]+)/;
/**
 * Rule for @keyframes
 */

var KeyframesRule = /*#__PURE__*/function () {
  function KeyframesRule(key, frames, options) {
    this.type = 'keyframes';
    this.at = '@keyframes';
    this.isProcessed = false;
    var nameMatch = key.match(nameRegExp);

    if (nameMatch && nameMatch[1]) {
      this.name = nameMatch[1];
    } else {
      this.name = 'noname';
      warning(false, "[JSS] Bad keyframes name " + key) ;
    }

    this.key = this.type + "-" + this.name;
    this.options = options;
    var scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;
    this.id = scoped === false ? this.name : escape(generateId(this, sheet));
    this.rules = new RuleList(_extends$1({}, options, {
      parent: this
    }));

    for (var name in frames) {
      this.rules.add(name, frames[name], _extends$1({}, options, {
        parent: this
      }));
    }

    this.rules.process();
  }
  /**
   * Generates a CSS string.
   */


  var _proto = KeyframesRule.prototype;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions$1;
    }

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
    if (options.children == null) options.children = defaultToStringOptions$1.children;

    if (options.children === false) {
      return this.at + " " + this.id + " {}";
    }

    var children = this.rules.toString(options);
    if (children) children = "" + linebreak + children + linebreak;
    return this.at + " " + this.id + " {" + children + "}";
  };

  return KeyframesRule;
}();

var keyRegExp$1 = /@keyframes\s+/;
var refRegExp$1 = /\$([\w-]+)/g;

var findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
  if (typeof val === 'string') {
    return val.replace(refRegExp$1, function (match, name) {
      if (name in keyframes) {
        return keyframes[name];
      }

      warning(false, "[JSS] Referenced keyframes rule \"" + name + "\" is not defined.") ;
      return match;
    });
  }

  return val;
};
/**
 * Replace the reference for a animation name.
 */


var replaceRef = function replaceRef(style, prop, keyframes) {
  var value = style[prop];
  var refKeyframe = findReferencedKeyframe(value, keyframes);

  if (refKeyframe !== value) {
    style[prop] = refKeyframe;
  }
};

var pluginKeyframesRule = {
  onCreateRule: function onCreateRule(key, frames, options) {
    return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style' || !sheet) return style;
    if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
    if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
    return style;
  },
  onChangeValue: function onChangeValue(val, prop, rule) {
    var sheet = rule.options.sheet;

    if (!sheet) {
      return val;
    }

    switch (prop) {
      case 'animation':
        return findReferencedKeyframe(val, sheet.keyframes);

      case 'animation-name':
        return findReferencedKeyframe(val, sheet.keyframes);

      default:
        return val;
    }
  }
};

var KeyframeRule = /*#__PURE__*/function (_BaseStyleRule) {
  _inheritsLoose(KeyframeRule, _BaseStyleRule);

  function KeyframeRule() {
    return _BaseStyleRule.apply(this, arguments) || this;
  }

  var _proto = KeyframeRule.prototype;
  /**
   * Generates a CSS string.
   */

  _proto.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? _extends$1({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.key, this.style, opts);
  };

  return KeyframeRule;
}(BaseStyleRule);

var pluginKeyframeRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (options.parent && options.parent.type === 'keyframes') {
      return new KeyframeRule(key, style, options);
    }

    return null;
  }
};

var FontFaceRule = /*#__PURE__*/function () {
  function FontFaceRule(key, style, options) {
    this.type = 'font-face';
    this.at = '@font-face';
    this.isProcessed = false;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = FontFaceRule.prototype;

  _proto.toString = function toString(options) {
    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    if (Array.isArray(this.style)) {
      var str = '';

      for (var index = 0; index < this.style.length; index++) {
        str += toCss(this.at, this.style[index]);
        if (this.style[index + 1]) str += linebreak;
      }

      return str;
    }

    return toCss(this.at, this.style, options);
  };

  return FontFaceRule;
}();

var keyRegExp$2 = /@font-face/;
var pluginFontFaceRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
  }
};

var ViewportRule = /*#__PURE__*/function () {
  function ViewportRule(key, style, options) {
    this.type = 'viewport';
    this.at = '@viewport';
    this.isProcessed = false;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = ViewportRule.prototype;

  _proto.toString = function toString(options) {
    return toCss(this.key, this.style, options);
  };

  return ViewportRule;
}();

var pluginViewportRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
  }
};

var SimpleRule = /*#__PURE__*/function () {
  function SimpleRule(key, value, options) {
    this.type = 'simple';
    this.isProcessed = false;
    this.key = key;
    this.value = value;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */
  // eslint-disable-next-line no-unused-vars


  var _proto = SimpleRule.prototype;

  _proto.toString = function toString(options) {
    if (Array.isArray(this.value)) {
      var str = '';

      for (var index = 0; index < this.value.length; index++) {
        str += this.key + " " + this.value[index] + ";";
        if (this.value[index + 1]) str += '\n';
      }

      return str;
    }

    return this.key + " " + this.value + ";";
  };

  return SimpleRule;
}();

var keysMap = {
  '@charset': true,
  '@import': true,
  '@namespace': true
};
var pluginSimpleRule = {
  onCreateRule: function onCreateRule(key, value, options) {
    return key in keysMap ? new SimpleRule(key, value, options) : null;
  }
};
var plugins$1 = [pluginStyleRule, pluginConditionalRule, pluginKeyframesRule, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];
var defaultUpdateOptions = {
  process: true
};
var forceUpdateOptions = {
  force: true,
  process: true
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */

};

var RuleList = /*#__PURE__*/function () {
  // Rules registry for access by .get() method.
  // It contains the same rule registered by name and by selector.
  // Original styles object.
  // Used to ensure correct rules order.
  function RuleList(options) {
    this.map = {};
    this.raw = {};
    this.index = [];
    this.counter = 0;
    this.options = options;
    this.classes = options.classes;
    this.keyframes = options.keyframes;
  }
  /**
   * Create and register rule.
   *
   * Will not render after Style Sheet was rendered the first time.
   */


  var _proto = RuleList.prototype;

  _proto.add = function add(name, decl, ruleOptions) {
    var _this$options = this.options,
        parent = _this$options.parent,
        sheet = _this$options.sheet,
        jss = _this$options.jss,
        Renderer = _this$options.Renderer,
        generateId = _this$options.generateId,
        scoped = _this$options.scoped;

    var options = _extends$1({
      classes: this.classes,
      parent: parent,
      sheet: sheet,
      jss: jss,
      Renderer: Renderer,
      generateId: generateId,
      scoped: scoped,
      name: name,
      keyframes: this.keyframes,
      selector: undefined
    }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
    // we need to make the key unique within this RuleList instance scope.


    var key = name;

    if (name in this.raw) {
      key = name + "-d" + this.counter++;
    } // We need to save the original decl before creating the rule
    // because cache plugin needs to use it as a key to return a cached rule.


    this.raw[key] = decl;

    if (key in this.classes) {
      // E.g. rules inside of @media container
      options.selector = "." + escape(this.classes[key]);
    }

    var rule = createRule(key, decl, options);
    if (!rule) return null;
    this.register(rule);
    var index = options.index === undefined ? this.index.length : options.index;
    this.index.splice(index, 0, rule);
    return rule;
  }
  /**
   * Get a rule.
   */
  ;

  _proto.get = function get(name) {
    return this.map[name];
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.remove = function remove(rule) {
    this.unregister(rule);
    delete this.raw[rule.key];
    this.index.splice(this.index.indexOf(rule), 1);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.index.indexOf(rule);
  }
  /**
   * Run `onProcessRule()` plugins on every rule.
   */
  ;

  _proto.process = function process() {
    var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
    // we end up with very hard-to-track-down side effects.

    this.index.slice(0).forEach(plugins.onProcessRule, plugins);
  }
  /**
   * Register a rule in `.map`, `.classes` and `.keyframes` maps.
   */
  ;

  _proto.register = function register(rule) {
    this.map[rule.key] = rule;

    if (rule instanceof StyleRule) {
      this.map[rule.selector] = rule;
      if (rule.id) this.classes[rule.key] = rule.id;
    } else if (rule instanceof KeyframesRule && this.keyframes) {
      this.keyframes[rule.name] = rule.id;
    }
  }
  /**
   * Unregister a rule.
   */
  ;

  _proto.unregister = function unregister(rule) {
    delete this.map[rule.key];

    if (rule instanceof StyleRule) {
      delete this.map[rule.selector];
      delete this.classes[rule.key];
    } else if (rule instanceof KeyframesRule) {
      delete this.keyframes[rule.name];
    }
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var name;
    var data;
    var options;

    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
      name = arguments.length <= 0 ? undefined : arguments[0];
      data = arguments.length <= 1 ? undefined : arguments[1];
      options = arguments.length <= 2 ? undefined : arguments[2];
    } else {
      data = arguments.length <= 0 ? undefined : arguments[0];
      options = arguments.length <= 1 ? undefined : arguments[1];
      name = null;
    }

    if (name) {
      this.updateOne(this.map[name], data, options);
    } else {
      for (var index = 0; index < this.index.length; index++) {
        this.updateOne(this.index[index], data, options);
      }
    }
  }
  /**
   * Execute plugins, update rule props.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    if (options === void 0) {
      options = defaultUpdateOptions;
    }

    var _this$options2 = this.options,
        plugins = _this$options2.jss.plugins,
        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.

    if (rule.rules instanceof RuleList) {
      rule.rules.update(data, options);
      return;
    }

    var style = rule.style;
    plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.

    if (options.process && style && style !== rule.style) {
      // We need to run the plugins in case new `style` relies on syntax plugins.
      plugins.onProcessStyle(rule.style, rule, sheet); // Update and add props.

      for (var prop in rule.style) {
        var nextValue = rule.style[prop];
        var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (nextValue !== prevValue) {
          rule.prop(prop, nextValue, forceUpdateOptions);
        }
      } // Remove props.


      for (var _prop in style) {
        var _nextValue = rule.style[_prop];
        var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (_nextValue == null && _nextValue !== _prevValue) {
          rule.prop(_prop, null, forceUpdateOptions);
        }
      }
    }
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    var str = '';
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    for (var index = 0; index < this.index.length; index++) {
      var rule = this.index[index];
      var css = rule.toString(options); // No need to render an empty rule.

      if (!css && !link) continue;
      if (str) str += linebreak;
      str += css;
    }

    return str;
  };

  return RuleList;
}();

var StyleSheet = /*#__PURE__*/function () {
  function StyleSheet(styles, options) {
    this.attached = false;
    this.deployed = false;
    this.classes = {};
    this.keyframes = {};
    this.options = _extends$1({}, options, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    });

    if (options.Renderer) {
      this.renderer = new options.Renderer(this);
    }

    this.rules = new RuleList(this.options);

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Attach renderable to the render tree.
   */


  var _proto = StyleSheet.prototype;

  _proto.attach = function attach() {
    if (this.attached) return this;
    if (this.renderer) this.renderer.attach();
    this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.

    if (!this.deployed) this.deploy();
    return this;
  }
  /**
   * Remove renderable from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.attached) return this;
    if (this.renderer) this.renderer.detach();
    this.attached = false;
    return this;
  }
  /**
   * Add a rule to the current stylesheet.
   * Will insert a rule also after the stylesheet has been rendered first time.
   */
  ;

  _proto.addRule = function addRule(name, decl, options) {
    var queue = this.queue; // Plugins can create rules.
    // In order to preserve the right order, we need to queue all `.addRule` calls,
    // which happen after the first `rules.add()` call.

    if (this.attached && !queue) this.queue = [];
    var rule = this.rules.add(name, decl, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);

    if (this.attached) {
      if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
      // It will be inserted all together when .attach is called.

      if (queue) queue.push(rule);else {
        this.insertRule(rule);

        if (this.queue) {
          this.queue.forEach(this.insertRule, this);
          this.queue = undefined;
        }
      }
      return rule;
    } // We can't add rules to a detached style node.
    // We will redeploy the sheet once user will attach it.


    this.deployed = false;
    return rule;
  }
  /**
   * Insert rule into the StyleSheet
   */
  ;

  _proto.insertRule = function insertRule(rule) {
    if (this.renderer) {
      this.renderer.insertRule(rule);
    }
  }
  /**
   * Create and add rules.
   * Will render also after Style Sheet was rendered the first time.
   */
  ;

  _proto.addRules = function addRules(styles, options) {
    var added = [];

    for (var name in styles) {
      var rule = this.addRule(name, styles[name], options);
      if (rule) added.push(rule);
    }

    return added;
  }
  /**
   * Get a rule by name.
   */
  ;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Delete a rule by name.
   * Returns `true`: if rule has been deleted from the DOM.
   */
  ;

  _proto.deleteRule = function deleteRule(name) {
    var rule = typeof name === 'object' ? name : this.rules.get(name);

    if (!rule || // Style sheet was created without link: true and attached, in this case we
    // won't be able to remove the CSS rule from the DOM.
    this.attached && !rule.renderable) {
      return false;
    }

    this.rules.remove(rule);

    if (this.attached && rule.renderable && this.renderer) {
      return this.renderer.deleteRule(rule.renderable);
    }

    return true;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Deploy pure CSS string to a renderable.
   */
  ;

  _proto.deploy = function deploy() {
    if (this.renderer) this.renderer.deploy();
    this.deployed = true;
    return this;
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var _this$rules;

    (_this$rules = this.rules).update.apply(_this$rules, arguments);

    return this;
  }
  /**
   * Updates a single rule.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    this.rules.updateOne(rule, data, options);
    return this;
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    return this.rules.toString(options);
  };

  return StyleSheet;
}();

var PluginsRegistry = /*#__PURE__*/function () {
  function PluginsRegistry() {
    this.plugins = {
      internal: [],
      external: []
    };
    this.registry = {};
  }

  var _proto = PluginsRegistry.prototype;
  /**
   * Call `onCreateRule` hooks and return an object if returned by a hook.
   */

  _proto.onCreateRule = function onCreateRule(name, decl, options) {
    for (var i = 0; i < this.registry.onCreateRule.length; i++) {
      var rule = this.registry.onCreateRule[i](name, decl, options);
      if (rule) return rule;
    }

    return null;
  }
  /**
   * Call `onProcessRule` hooks.
   */
  ;

  _proto.onProcessRule = function onProcessRule(rule) {
    if (rule.isProcessed) return;
    var sheet = rule.options.sheet;

    for (var i = 0; i < this.registry.onProcessRule.length; i++) {
      this.registry.onProcessRule[i](rule, sheet);
    }

    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
    rule.isProcessed = true;
  }
  /**
   * Call `onProcessStyle` hooks.
   */
  ;

  _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
    }
  }
  /**
   * Call `onProcessSheet` hooks.
   */
  ;

  _proto.onProcessSheet = function onProcessSheet(sheet) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
      this.registry.onProcessSheet[i](sheet);
    }
  }
  /**
   * Call `onUpdate` hooks.
   */
  ;

  _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
    for (var i = 0; i < this.registry.onUpdate.length; i++) {
      this.registry.onUpdate[i](data, rule, sheet, options);
    }
  }
  /**
   * Call `onChangeValue` hooks.
   */
  ;

  _proto.onChangeValue = function onChangeValue(value, prop, rule) {
    var processedValue = value;

    for (var i = 0; i < this.registry.onChangeValue.length; i++) {
      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
    }

    return processedValue;
  }
  /**
   * Register a plugin.
   */
  ;

  _proto.use = function use(newPlugin, options) {
    if (options === void 0) {
      options = {
        queue: 'external'
      };
    }

    var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.

    if (plugins.indexOf(newPlugin) !== -1) {
      return;
    }

    plugins.push(newPlugin);
    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {
      for (var name in plugin) {
        if (name in registry) {
          registry[name].push(plugin[name]);
        } else {
          warning(false, "[JSS] Unknown hook \"" + name + "\".") ;
        }
      }

      return registry;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    });
  };

  return PluginsRegistry;
}();
/**
 * Sheets registry to access all instances in one place.
 */


var SheetsRegistry = /*#__PURE__*/function () {
  function SheetsRegistry() {
    this.registry = [];
  }

  var _proto = SheetsRegistry.prototype;
  /**
   * Register a Style Sheet.
   */

  _proto.add = function add(sheet) {
    var registry = this.registry;
    var index = sheet.options.index;
    if (registry.indexOf(sheet) !== -1) return;

    if (registry.length === 0 || index >= this.index) {
      registry.push(sheet);
      return;
    } // Find a position.


    for (var i = 0; i < registry.length; i++) {
      if (registry[i].options.index > index) {
        registry.splice(i, 0, sheet);
        return;
      }
    }
  }
  /**
   * Reset the registry.
   */
  ;

  _proto.reset = function reset() {
    this.registry = [];
  }
  /**
   * Remove a Style Sheet.
   */
  ;

  _proto.remove = function remove(sheet) {
    var index = this.registry.indexOf(sheet);
    this.registry.splice(index, 1);
  }
  /**
   * Convert all attached sheets to a CSS string.
   */
  ;

  _proto.toString = function toString(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        attached = _ref.attached,
        options = _objectWithoutPropertiesLoose(_ref, ["attached"]);

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak;

    var css = '';

    for (var i = 0; i < this.registry.length; i++) {
      var sheet = this.registry[i];

      if (attached != null && sheet.attached !== attached) {
        continue;
      }

      if (css) css += linebreak;
      css += sheet.toString(options);
    }

    return css;
  };

  _createClass(SheetsRegistry, [{
    key: "index",

    /**
     * Current highest index number.
     */
    get: function get() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);

  return SheetsRegistry;
}();
/**
 * This is a global sheets registry. Only DomRenderer will add sheets to it.
 * On the server one should use an own SheetsRegistry instance and add the
 * sheets to it, because you need to make sure to create a new registry for
 * each request in order to not leak sheets across requests.
 */


var sheets = new SheetsRegistry();
/* eslint-disable */

/**
 * Now that `globalThis` is available on most platforms
 * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)
 * we check for `globalThis` first. `globalThis` is necessary for jss
 * to run in Agoric's secure version of JavaScript (SES). Under SES,
 * `globalThis` exists, but `window`, `self`, and `Function('return
 * this')()` are all undefined for security reasons.
 *
 * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
 */

var globalThis$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();
var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
if (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
// the current version with just one short number and use it for classes generation
// we use a counter. Also it is more accurate, because user can manually reevaluate
// the module.

var moduleId = globalThis$1[ns]++;
var maxRules = 1e10;
/**
 * Returns a function which generates unique class names based on counters.
 * When new generator function is created, rule counter is reseted.
 * We need to reset the rule counter for SSR for each request.
 */

var createGenerateId = function createGenerateId(options) {
  if (options === void 0) {
    options = {};
  }

  var ruleCounter = 0;

  var generateId = function generateId(rule, sheet) {
    ruleCounter += 1;

    if (ruleCounter > maxRules) {
      warning(false, "[JSS] You might have a memory leak. Rule counter is at " + ruleCounter + ".") ;
    }

    var jssId = '';
    var prefix = '';

    if (sheet) {
      if (sheet.options.classNamePrefix) {
        prefix = sheet.options.classNamePrefix;
      }

      if (sheet.options.jss.id != null) {
        jssId = String(sheet.options.jss.id);
      }
    }

    if (options.minify) {
      // Using "c" because a number can't be the first char in a class name.
      return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
    }

    return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
  };

  return generateId;
};
/**
 * Cache the value from the first time a function is called.
 */


var memoize = function memoize(fn) {
  var value;
  return function () {
    if (!value) value = fn();
    return value;
  };
};
/**
 * Get a style property value.
 */


var getPropertyValue = function getPropertyValue(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      return cssRule.attributeStyleMap.get(prop);
    }

    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    // IE may throw if property is unknown.
    return '';
  }
};
/**
 * Set a style property.
 */


var setProperty = function setProperty(cssRule, prop, value) {
  try {
    var cssValue = value;

    if (Array.isArray(value)) {
      cssValue = toCssValue(value, true);

      if (value[value.length - 1] === '!important') {
        cssRule.style.setProperty(prop, cssValue, 'important');
        return true;
      }
    } // Support CSSTOM.


    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.set(prop, cssValue);
    } else {
      cssRule.style.setProperty(prop, cssValue);
    }
  } catch (err) {
    // IE may throw if property is unknown.
    return false;
  }

  return true;
};
/**
 * Remove a style property.
 */


var removeProperty = function removeProperty(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.delete(prop);
    } else {
      cssRule.style.removeProperty(prop);
    }
  } catch (err) {
    warning(false, "[JSS] DOMException \"" + err.message + "\" was thrown. Tried to remove property \"" + prop + "\".") ;
  }
};
/**
 * Set the selector.
 */


var setSelector = function setSelector(cssRule, selectorText) {
  cssRule.selectorText = selectorText; // Return false if setter was not successful.
  // Currently works in chrome only.

  return cssRule.selectorText === selectorText;
};
/**
 * Gets the `head` element upon the first call and caches it.
 * We assume it can't be null.
 */


var getHead = memoize(function () {
  return document.querySelector('head');
});
/**
 * Find attached sheet with an index higher than the passed one.
 */

function findHigherSheet(registry, options) {
  for (var i = 0; i < registry.length; i++) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find attached sheet with the highest index.
 */


function findHighestSheet(registry, options) {
  for (var i = registry.length - 1; i >= 0; i--) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find a comment with "jss" inside.
 */


function findCommentNode(text) {
  var head = getHead();

  for (var i = 0; i < head.childNodes.length; i++) {
    var node = head.childNodes[i];

    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
      return node;
    }
  }

  return null;
}
/**
 * Find a node before which we can insert the sheet.
 */


function findPrevNode(options) {
  var registry = sheets.registry;

  if (registry.length > 0) {
    // Try to insert before the next higher sheet.
    var sheet = findHigherSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element
      };
    } // Otherwise insert after the last attached.


    sheet = findHighestSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element.nextSibling
      };
    }
  } // Try to find a comment placeholder if registry is empty.


  var insertionPoint = options.insertionPoint;

  if (insertionPoint && typeof insertionPoint === 'string') {
    var comment = findCommentNode(insertionPoint);

    if (comment) {
      return {
        parent: comment.parentNode,
        node: comment.nextSibling
      };
    } // If user specifies an insertion point and it can't be found in the document -
    // bad specificity issues may appear.


    warning(false, "[JSS] Insertion point \"" + insertionPoint + "\" not found.") ;
  }

  return false;
}
/**
 * Insert style element into the DOM.
 */


function insertStyle(style, options) {
  var insertionPoint = options.insertionPoint;
  var nextNode = findPrevNode(options);

  if (nextNode !== false && nextNode.parent) {
    nextNode.parent.insertBefore(style, nextNode.node);
    return;
  } // Works with iframes and any node types.


  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
    var insertionPointElement = insertionPoint;
    var parentNode = insertionPointElement.parentNode;
    if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);else warning(false, '[JSS] Insertion point is not in the DOM.') ;
    return;
  }

  getHead().appendChild(style);
}
/**
 * Read jss nonce setting from the page if the user has set it.
 */


var getNonce = memoize(function () {
  var node = document.querySelector('meta[property="csp-nonce"]');
  return node ? node.getAttribute('content') : null;
});

var _insertRule = function insertRule(container, rule, index) {
  try {
    if ('insertRule' in container) {
      container.insertRule(rule, index);
    } // Keyframes rule.
    else if ('appendRule' in container) {
      container.appendRule(rule);
    }
  } catch (err) {
    warning(false, "[JSS] " + err.message) ;
    return false;
  }

  return container.cssRules[index];
};

var getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {
  var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong

  if (index === undefined || index > maxIndex) {
    // eslint-disable-next-line no-param-reassign
    return maxIndex;
  }

  return index;
};

var createStyle = function createStyle() {
  var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
  // insert rules after we insert the style tag.
  // It seems to kick-off the source order specificity algorithm.

  el.textContent = '\n';
  return el;
};

var DomRenderer = /*#__PURE__*/function () {
  // Will be empty if link: true option is not set, because
  // it is only for use together with insertRule API.
  function DomRenderer(sheet) {
    this.getPropertyValue = getPropertyValue;
    this.setProperty = setProperty;
    this.removeProperty = removeProperty;
    this.setSelector = setSelector;
    this.hasInsertedRules = false;
    this.cssRules = []; // There is no sheet when the renderer is used from a standalone StyleRule.

    if (sheet) sheets.add(sheet);
    this.sheet = sheet;

    var _ref = this.sheet ? this.sheet.options : {},
        media = _ref.media,
        meta = _ref.meta,
        element = _ref.element;

    this.element = element || createStyle();
    this.element.setAttribute('data-jss', '');
    if (media) this.element.setAttribute('media', media);
    if (meta) this.element.setAttribute('data-meta', meta);
    var nonce = getNonce();
    if (nonce) this.element.setAttribute('nonce', nonce);
  }
  /**
   * Insert style element into render tree.
   */


  var _proto = DomRenderer.prototype;

  _proto.attach = function attach() {
    // In the case the element node is external and it is already in the DOM.
    if (this.element.parentNode || !this.sheet) return;
    insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
    // most browsers create a new CSSStyleSheet, except of all IEs.

    var deployed = Boolean(this.sheet && this.sheet.deployed);

    if (this.hasInsertedRules && deployed) {
      this.hasInsertedRules = false;
      this.deploy();
    }
  }
  /**
   * Remove style element from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.sheet) return;
    var parentNode = this.element.parentNode;
    if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.
    // Though IE will keep them and we need a consistent behavior.

    if (this.sheet.options.link) {
      this.cssRules = [];
      this.element.textContent = '\n';
    }
  }
  /**
   * Inject CSS string into element.
   */
  ;

  _proto.deploy = function deploy() {
    var sheet = this.sheet;
    if (!sheet) return;

    if (sheet.options.link) {
      this.insertRules(sheet.rules);
      return;
    }

    this.element.textContent = "\n" + sheet.toString() + "\n";
  }
  /**
   * Insert RuleList into an element.
   */
  ;

  _proto.insertRules = function insertRules(rules, nativeParent) {
    for (var i = 0; i < rules.index.length; i++) {
      this.insertRule(rules.index[i], i, nativeParent);
    }
  }
  /**
   * Insert a rule into element.
   */
  ;

  _proto.insertRule = function insertRule(rule, index, nativeParent) {
    if (nativeParent === void 0) {
      nativeParent = this.element.sheet;
    }

    if (rule.rules) {
      var parent = rule;
      var latestNativeParent = nativeParent;

      if (rule.type === 'conditional' || rule.type === 'keyframes') {
        var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.


        latestNativeParent = _insertRule(nativeParent, parent.toString({
          children: false
        }), _insertionIndex);

        if (latestNativeParent === false) {
          return false;
        }

        this.refCssRule(rule, _insertionIndex, latestNativeParent);
      }

      this.insertRules(parent.rules, latestNativeParent);
      return latestNativeParent;
    }

    var ruleStr = rule.toString();
    if (!ruleStr) return false;
    var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);

    var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);

    if (nativeRule === false) {
      return false;
    }

    this.hasInsertedRules = true;
    this.refCssRule(rule, insertionIndex, nativeRule);
    return nativeRule;
  };

  _proto.refCssRule = function refCssRule(rule, index, cssRule) {
    rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules
    // like rules inside media queries or keyframes

    if (rule.options.parent instanceof StyleSheet) {
      this.cssRules[index] = cssRule;
    }
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.deleteRule = function deleteRule(cssRule) {
    var sheet = this.element.sheet;
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    sheet.deleteRule(index);
    this.cssRules.splice(index, 1);
    return true;
  }
  /**
   * Get index of a CSS Rule.
   */
  ;

  _proto.indexOf = function indexOf(cssRule) {
    return this.cssRules.indexOf(cssRule);
  }
  /**
   * Generate a new CSS rule and replace the existing one.
   *
   * Only used for some old browsers because they can't set a selector.
   */
  ;

  _proto.replaceRule = function replaceRule(cssRule, rule) {
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    this.element.sheet.deleteRule(index);
    this.cssRules.splice(index, 1);
    return this.insertRule(rule, index);
  }
  /**
   * Get all rules elements.
   */
  ;

  _proto.getRules = function getRules() {
    return this.element.sheet.cssRules;
  };

  return DomRenderer;
}();

var instanceCounter = 0;

var Jss = /*#__PURE__*/function () {
  function Jss(options) {
    this.id = instanceCounter++;
    this.version = "10.8.0";
    this.plugins = new PluginsRegistry();
    this.options = {
      id: {
        minify: false
      },
      createGenerateId: createGenerateId,
      Renderer: isBrowser$1 ? DomRenderer : null,
      plugins: []
    };
    this.generateId = createGenerateId({
      minify: false
    });

    for (var i = 0; i < plugins$1.length; i++) {
      this.plugins.use(plugins$1[i], {
        queue: 'internal'
      });
    }

    this.setup(options);
  }
  /**
   * Prepares various options, applies plugins.
   * Should not be used twice on the same instance, because there is no plugins
   * deduplication logic.
   */


  var _proto = Jss.prototype;

  _proto.setup = function setup(options) {
    if (options === void 0) {
      options = {};
    }

    if (options.createGenerateId) {
      this.options.createGenerateId = options.createGenerateId;
    }

    if (options.id) {
      this.options.id = _extends$1({}, this.options.id, options.id);
    }

    if (options.createGenerateId || options.id) {
      this.generateId = this.options.createGenerateId(this.options.id);
    }

    if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;

    if ('Renderer' in options) {
      this.options.Renderer = options.Renderer;
    } // eslint-disable-next-line prefer-spread


    if (options.plugins) this.use.apply(this, options.plugins);
    return this;
  }
  /**
   * Create a Style Sheet.
   */
  ;

  _proto.createStyleSheet = function createStyleSheet(styles, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        index = _options.index;

    if (typeof index !== 'number') {
      index = sheets.index === 0 ? 0 : sheets.index + 1;
    }

    var sheet = new StyleSheet(styles, _extends$1({}, options, {
      jss: this,
      generateId: options.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: index
    }));
    this.plugins.onProcessSheet(sheet);
    return sheet;
  }
  /**
   * Detach the Style Sheet and remove it from the registry.
   */
  ;

  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
    sheet.detach();
    sheets.remove(sheet);
    return this;
  }
  /**
   * Create a rule without a Style Sheet.
   * [Deprecated] will be removed in the next major version.
   */
  ;

  _proto.createRule = function createRule$1(name, style, options) {
    if (style === void 0) {
      style = {};
    }

    if (options === void 0) {
      options = {};
    } // Enable rule without name for inline styles.


    if (typeof name === 'object') {
      return this.createRule(undefined, name, style);
    }

    var ruleOptions = _extends$1({}, options, {
      name: name,
      jss: this,
      Renderer: this.options.Renderer
    });

    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
    if (!ruleOptions.classes) ruleOptions.classes = {};
    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};
    var rule = createRule(name, style, ruleOptions);
    if (rule) this.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Register plugin. Passed function will be invoked with a rule instance.
   */
  ;

  _proto.use = function use() {
    var _this = this;

    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }

    plugins.forEach(function (plugin) {
      _this.plugins.use(plugin);
    });
    return this;
  };

  return Jss;
}();

var createJss = function createJss(options) {
  return new Jss(options);
};
/**
* Export a constant indicating if this browser has CSSTOM support.
* https://developers.google.com/web/updates/2018/03/cssom
*/


var hasCSSTOMSupport = typeof CSS === 'object' && CSS != null && 'number' in CSS;
/**
 * Extracts a styles object with only props that contain function values.
 */

function getDynamicStyles(styles) {
  var to = null;

  for (var key in styles) {
    var value = styles[key];
    var type = typeof value;

    if (type === 'function') {
      if (!to) to = {};
      to[key] = value;
    } else if (type === 'object' && value !== null && !Array.isArray(value)) {
      var extracted = getDynamicStyles(value);

      if (extracted) {
        if (!to) to = {};
        to[key] = extracted;
      }
    }
  }

  return to;
}
/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */


createJss();

var now = Date.now();
var fnValuesNs = "fnValues" + now;
var fnRuleNs = "fnStyle" + ++now;

var functionPlugin = function functionPlugin() {
  return {
    onCreateRule: function onCreateRule(name, decl, options) {
      if (typeof decl !== 'function') return null;
      var rule = createRule(name, {}, options);
      rule[fnRuleNs] = decl;
      return rule;
    },
    onProcessStyle: function onProcessStyle(style, rule) {
      // We need to extract function values from the declaration, so that we can keep core unaware of them.
      // We need to do that only once.
      // We don't need to extract functions on each style update, since this can happen only once.
      // We don't support function values inside of function rules.
      if (fnValuesNs in rule || fnRuleNs in rule) return style;
      var fnValues = {};

      for (var prop in style) {
        var value = style[prop];
        if (typeof value !== 'function') continue;
        delete style[prop];
        fnValues[prop] = value;
      }

      rule[fnValuesNs] = fnValues;
      return style;
    },
    onUpdate: function onUpdate(data, rule, sheet, options) {
      var styleRule = rule;
      var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object
      // will be returned from that function.

      if (fnRule) {
        // Empty object will remove all currently defined props
        // in case function rule returns a falsy value.
        styleRule.style = fnRule(data) || {};

        {
          for (var prop in styleRule.style) {
            if (typeof styleRule.style[prop] === 'function') {
              warning(false, '[JSS] Function values inside function rules are not supported.') ;
              break;
            }
          }
        }
      }

      var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.

      if (fnValues) {
        for (var _prop in fnValues) {
          styleRule.prop(_prop, fnValues[_prop](data), options);
        }
      }
    }
  };
};

var functions = functionPlugin;

var at = '@global';
var atPrefix = '@global ';

var GlobalContainerRule = /*#__PURE__*/function () {
  function GlobalContainerRule(key, styles, options) {
    this.type = 'global';
    this.at = at;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    this.rules = new RuleList(_extends$1({}, options, {
      parent: this
    }));

    for (var selector in styles) {
      this.rules.add(selector, styles[selector]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = GlobalContainerRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (rule) this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString() {
    return this.rules.toString();
  };

  return GlobalContainerRule;
}();

var GlobalPrefixedRule = /*#__PURE__*/function () {
  function GlobalPrefixedRule(key, style, options) {
    this.type = 'global';
    this.at = at;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    var selector = key.substr(atPrefix.length);
    this.rule = options.jss.createRule(selector, style, _extends$1({}, options, {
      parent: this
    }));
  }

  var _proto2 = GlobalPrefixedRule.prototype;

  _proto2.toString = function toString(options) {
    return this.rule ? this.rule.toString(options) : '';
  };

  return GlobalPrefixedRule;
}();

var separatorRegExp$1 = /\s*,\s*/g;

function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp$1);
  var scoped = '';

  for (var i = 0; i < parts.length; i++) {
    scoped += scope + " " + parts[i].trim();
    if (parts[i + 1]) scoped += ', ';
  }

  return scoped;
}

function handleNestedGlobalContainerRule(rule, sheet) {
  var options = rule.options,
      style = rule.style;
  var rules = style ? style[at] : null;
  if (!rules) return;

  for (var name in rules) {
    sheet.addRule(name, rules[name], _extends$1({}, options, {
      selector: addScope(name, rule.selector)
    }));
  }

  delete style[at];
}

function handlePrefixedGlobalRule(rule, sheet) {
  var options = rule.options,
      style = rule.style;

  for (var prop in style) {
    if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
    var selector = addScope(prop.substr(at.length), rule.selector);
    sheet.addRule(selector, style[prop], _extends$1({}, options, {
      selector: selector
    }));
    delete style[prop];
  }
}
/**
 * Convert nested rules to separate, remove them from original styles.
 */


function jssGlobal() {
  function onCreateRule(name, styles, options) {
    if (!name) return null;

    if (name === at) {
      return new GlobalContainerRule(name, styles, options);
    }

    if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {
      return new GlobalPrefixedRule(name, styles, options);
    }

    var parent = options.parent;

    if (parent) {
      if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {
        options.scoped = false;
      }
    }

    if (options.scoped === false) {
      options.selector = name;
    }

    return null;
  }

  function onProcessRule(rule, sheet) {
    if (rule.type !== 'style' || !sheet) return;
    handleNestedGlobalContainerRule(rule, sheet);
    handlePrefixedGlobalRule(rule, sheet);
  }

  return {
    onCreateRule: onCreateRule,
    onProcessRule: onProcessRule
  };
}

var separatorRegExp = /\s*,\s*/g;
var parentRegExp = /&/g;
var refRegExp = /\$([\w-]+)/g;
/**
 * Convert nested rules to separate, remove them from original styles.
 */

function jssNested() {
  // Get a function to be used for $ref replacement.
  function getReplaceRef(container, sheet) {
    return function (match, key) {
      var rule = container.getRule(key) || sheet && sheet.getRule(key);

      if (rule) {
        return rule.selector;
      }

      warning(false, "[JSS] Could not find the referenced rule \"" + key + "\" in \"" + (container.options.meta || container.toString()) + "\".") ;
      return key;
    };
  }

  function replaceParentRefs(nestedProp, parentProp) {
    var parentSelectors = parentProp.split(separatorRegExp);
    var nestedSelectors = nestedProp.split(separatorRegExp);
    var result = '';

    for (var i = 0; i < parentSelectors.length; i++) {
      var parent = parentSelectors[i];

      for (var j = 0; j < nestedSelectors.length; j++) {
        var nested = nestedSelectors[j];
        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.

        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + " " + nested;
      }
    }

    return result;
  }

  function getOptions(rule, container, prevOptions) {
    // Options has been already created, now we only increase index.
    if (prevOptions) return _extends$1({}, prevOptions, {
      index: prevOptions.index + 1
    });
    var nestingLevel = rule.options.nestingLevel;
    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;

    var options = _extends$1({}, rule.options, {
      nestingLevel: nestingLevel,
      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.

    });

    delete options.name;
    return options;
  }

  function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style') return style;
    var styleRule = rule;
    var container = styleRule.options.parent;
    var options;
    var replaceRef;

    for (var prop in style) {
      var isNested = prop.indexOf('&') !== -1;
      var isNestedConditional = prop[0] === '@';
      if (!isNested && !isNestedConditional) continue;
      options = getOptions(styleRule, container, options);

      if (isNested) {
        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for
        // all nested rules within the sheet.

        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.

        selector = selector.replace(refRegExp, replaceRef);
        container.addRule(selector, style[prop], _extends$1({}, options, {
          selector: selector
        }));
      } else if (isNestedConditional) {
        // Place conditional right after the parent rule to ensure right ordering.
        container.addRule(prop, {}, options).addRule(styleRule.key, style[prop], {
          selector: styleRule.selector
        });
      }

      delete style[prop];
    }

    return style;
  }

  return {
    onProcessStyle: onProcessStyle
  };
}

/* eslint-disable no-var, prefer-template */
var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var cache$2 = {};

function toHyphenLower(match) {
  return '-' + match.toLowerCase();
}

function hyphenateStyleName(name) {
  if (cache$2.hasOwnProperty(name)) {
    return cache$2[name];
  }

  var hName = name.replace(uppercasePattern, toHyphenLower);
  return cache$2[name] = msPattern.test(hName) ? '-' + hName : hName;
}

/**
 * Convert camel cased property names to dash separated.
 */

function convertCase(style) {
  var converted = {};

  for (var prop in style) {
    var key = prop.indexOf('--') === 0 ? prop : hyphenateStyleName(prop);
    converted[key] = style[prop];
  }

  if (style.fallbacks) {
    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
  }

  return converted;
}
/**
 * Allow camel cased property names by converting them back to dasherized.
 */


function camelCase() {
  function onProcessStyle(style) {
    if (Array.isArray(style)) {
      // Handle rules like @font-face, which can have multiple styles in an array
      for (var index = 0; index < style.length; index++) {
        style[index] = convertCase(style[index]);
      }

      return style;
    }

    return convertCase(style);
  }

  function onChangeValue(value, prop, rule) {
    if (prop.indexOf('--') === 0) {
      return value;
    }

    var hyphenatedProp = hyphenateStyleName(prop); // There was no camel case in place

    if (prop === hyphenatedProp) return value;
    rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.

    return null;
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

var px = hasCSSTOMSupport && CSS ? CSS.px : 'px';
var ms = hasCSSTOMSupport && CSS ? CSS.ms : 'ms';
var percent = hasCSSTOMSupport && CSS ? CSS.percent : '%';
/**
 * Generated jss-plugin-default-unit CSS property units
 */

var defaultUnits = {
  // Animation properties
  'animation-delay': ms,
  'animation-duration': ms,
  // Background properties
  'background-position': px,
  'background-position-x': px,
  'background-position-y': px,
  'background-size': px,
  // Border Properties
  border: px,
  'border-bottom': px,
  'border-bottom-left-radius': px,
  'border-bottom-right-radius': px,
  'border-bottom-width': px,
  'border-left': px,
  'border-left-width': px,
  'border-radius': px,
  'border-right': px,
  'border-right-width': px,
  'border-top': px,
  'border-top-left-radius': px,
  'border-top-right-radius': px,
  'border-top-width': px,
  'border-width': px,
  'border-block': px,
  'border-block-end': px,
  'border-block-end-width': px,
  'border-block-start': px,
  'border-block-start-width': px,
  'border-block-width': px,
  'border-inline': px,
  'border-inline-end': px,
  'border-inline-end-width': px,
  'border-inline-start': px,
  'border-inline-start-width': px,
  'border-inline-width': px,
  'border-start-start-radius': px,
  'border-start-end-radius': px,
  'border-end-start-radius': px,
  'border-end-end-radius': px,
  // Margin properties
  margin: px,
  'margin-bottom': px,
  'margin-left': px,
  'margin-right': px,
  'margin-top': px,
  'margin-block': px,
  'margin-block-end': px,
  'margin-block-start': px,
  'margin-inline': px,
  'margin-inline-end': px,
  'margin-inline-start': px,
  // Padding properties
  padding: px,
  'padding-bottom': px,
  'padding-left': px,
  'padding-right': px,
  'padding-top': px,
  'padding-block': px,
  'padding-block-end': px,
  'padding-block-start': px,
  'padding-inline': px,
  'padding-inline-end': px,
  'padding-inline-start': px,
  // Mask properties
  'mask-position-x': px,
  'mask-position-y': px,
  'mask-size': px,
  // Width and height properties
  height: px,
  width: px,
  'min-height': px,
  'max-height': px,
  'min-width': px,
  'max-width': px,
  // Position properties
  bottom: px,
  left: px,
  top: px,
  right: px,
  inset: px,
  'inset-block': px,
  'inset-block-end': px,
  'inset-block-start': px,
  'inset-inline': px,
  'inset-inline-end': px,
  'inset-inline-start': px,
  // Shadow properties
  'box-shadow': px,
  'text-shadow': px,
  // Column properties
  'column-gap': px,
  'column-rule': px,
  'column-rule-width': px,
  'column-width': px,
  // Font and text properties
  'font-size': px,
  'font-size-delta': px,
  'letter-spacing': px,
  'text-decoration-thickness': px,
  'text-indent': px,
  'text-stroke': px,
  'text-stroke-width': px,
  'word-spacing': px,
  // Motion properties
  motion: px,
  'motion-offset': px,
  // Outline properties
  outline: px,
  'outline-offset': px,
  'outline-width': px,
  // Perspective properties
  perspective: px,
  'perspective-origin-x': percent,
  'perspective-origin-y': percent,
  // Transform properties
  'transform-origin': percent,
  'transform-origin-x': percent,
  'transform-origin-y': percent,
  'transform-origin-z': percent,
  // Transition properties
  'transition-delay': ms,
  'transition-duration': ms,
  // Alignment properties
  'vertical-align': px,
  'flex-basis': px,
  // Some random properties
  'shape-margin': px,
  size: px,
  gap: px,
  // Grid properties
  grid: px,
  'grid-gap': px,
  'row-gap': px,
  'grid-row-gap': px,
  'grid-column-gap': px,
  'grid-template-rows': px,
  'grid-template-columns': px,
  'grid-auto-rows': px,
  'grid-auto-columns': px,
  // Not existing properties.
  // Used to avoid issues with jss-plugin-expand integration.
  'box-shadow-x': px,
  'box-shadow-y': px,
  'box-shadow-blur': px,
  'box-shadow-spread': px,
  'font-line-height': px,
  'text-shadow-x': px,
  'text-shadow-y': px,
  'text-shadow-blur': px
};
/**
 * Clones the object and adds a camel cased property version.
 */

function addCamelCasedVersion(obj) {
  var regExp = /(-[a-z])/g;

  var replace = function replace(str) {
    return str[1].toUpperCase();
  };

  var newObj = {};

  for (var key in obj) {
    newObj[key] = obj[key];
    newObj[key.replace(regExp, replace)] = obj[key];
  }

  return newObj;
}

var units = addCamelCasedVersion(defaultUnits);
/**
 * Recursive deep style passing function
 */

function iterate(prop, value, options) {
  if (value == null) return value;

  if (Array.isArray(value)) {
    for (var i = 0; i < value.length; i++) {
      value[i] = iterate(prop, value[i], options);
    }
  } else if (typeof value === 'object') {
    if (prop === 'fallbacks') {
      for (var innerProp in value) {
        value[innerProp] = iterate(innerProp, value[innerProp], options);
      }
    } else {
      for (var _innerProp in value) {
        value[_innerProp] = iterate(prop + "-" + _innerProp, value[_innerProp], options);
      }
    } // eslint-disable-next-line no-restricted-globals

  } else if (typeof value === 'number' && isNaN(value) === false) {
    var unit = options[prop] || units[prop]; // Add the unit if available, except for the special case of 0px.

    if (unit && !(value === 0 && unit === px)) {
      return typeof unit === 'function' ? unit(value).toString() : "" + value + unit;
    }

    return value.toString();
  }

  return value;
}
/**
 * Add unit to numeric values.
 */


function defaultUnit(options) {
  if (options === void 0) {
    options = {};
  }

  var camelCasedOptions = addCamelCasedVersion(options);

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;

    for (var prop in style) {
      style[prop] = iterate(prop, style[prop], camelCasedOptions);
    }

    return style;
  }

  function onChangeValue(value, prop) {
    return iterate(prop, value, camelCasedOptions);
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

var js = '';
var css = '';
var vendor = '';
var browser = '';
var isTouch = isBrowser$1 && 'ontouchstart' in document.documentElement; // We should not do anything if required serverside.

if (isBrowser$1) {
  // Order matters. We need to check Webkit the last one because
  // other vendors use to add Webkit prefixes to some properties
  var jsCssMap = {
    Moz: '-moz-',
    ms: '-ms-',
    O: '-o-',
    Webkit: '-webkit-'
  };

  var _document$createEleme = document.createElement('p'),
      style = _document$createEleme.style;

  var testProp = 'Transform';

  for (var key in jsCssMap) {
    if (key + testProp in style) {
      js = key;
      css = jsCssMap[key];
      break;
    }
  } // Correctly detect the Edge browser.


  if (js === 'Webkit' && 'msHyphens' in style) {
    js = 'ms';
    css = jsCssMap.ms;
    browser = 'edge';
  } // Correctly detect the Safari browser.


  if (js === 'Webkit' && '-apple-trailing-word' in style) {
    vendor = 'apple';
  }
}
/**
 * Vendor prefix string for the current browser.
 *
 * @type {{js: String, css: String, vendor: String, browser: String}}
 * @api public
 */


var prefix = {
  js: js,
  css: css,
  vendor: vendor,
  browser: browser,
  isTouch: isTouch
};
/**
 * Test if a keyframe at-rule should be prefixed or not
 *
 * @param {String} vendor prefix string for the current browser.
 * @return {String}
 * @api public
 */

function supportedKeyframes(key) {
  // Keyframes is already prefixed. e.g. key = '@-webkit-keyframes a'
  if (key[1] === '-') return key; // No need to prefix IE/Edge. Older browsers will ignore unsupported rules.
  // https://caniuse.com/#search=keyframes

  if (prefix.js === 'ms') return key;
  return "@" + prefix.css + "keyframes" + key.substr(10);
} // https://caniuse.com/#search=appearance


var appearence = {
  noPrefill: ['appearance'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'appearance') return false;
    if (prefix.js === 'ms') return "-webkit-" + prop;
    return prefix.css + prop;
  }
}; // https://caniuse.com/#search=color-adjust

var colorAdjust = {
  noPrefill: ['color-adjust'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'color-adjust') return false;
    if (prefix.js === 'Webkit') return prefix.css + "print-" + prop;
    return prop;
  }
};
var regExp = /[-\s]+(.)?/g;
/**
 * Replaces the letter with the capital letter
 *
 * @param {String} match
 * @param {String} c
 * @return {String}
 * @api private
 */

function toUpper(match, c) {
  return c ? c.toUpperCase() : '';
}
/**
 * Convert dash separated strings to camel-cased.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */


function camelize(str) {
  return str.replace(regExp, toUpper);
}
/**
 * Convert dash separated strings to pascal cased.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */


function pascalize(str) {
  return camelize("-" + str);
} // but we can use a longhand property instead.
// https://caniuse.com/#search=mask


var mask = {
  noPrefill: ['mask'],
  supportedProperty: function supportedProperty(prop, style) {
    if (!/^mask/.test(prop)) return false;

    if (prefix.js === 'Webkit') {
      var longhand = 'mask-image';

      if (camelize(longhand) in style) {
        return prop;
      }

      if (prefix.js + pascalize(longhand) in style) {
        return prefix.css + prop;
      }
    }

    return prop;
  }
}; // https://caniuse.com/#search=text-orientation

var textOrientation = {
  noPrefill: ['text-orientation'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'text-orientation') return false;

    if (prefix.vendor === 'apple' && !prefix.isTouch) {
      return prefix.css + prop;
    }

    return prop;
  }
}; // https://caniuse.com/#search=transform

var transform = {
  noPrefill: ['transform'],
  supportedProperty: function supportedProperty(prop, style, options) {
    if (prop !== 'transform') return false;

    if (options.transform) {
      return prop;
    }

    return prefix.css + prop;
  }
}; // https://caniuse.com/#search=transition

var transition = {
  noPrefill: ['transition'],
  supportedProperty: function supportedProperty(prop, style, options) {
    if (prop !== 'transition') return false;

    if (options.transition) {
      return prop;
    }

    return prefix.css + prop;
  }
}; // https://caniuse.com/#search=writing-mode

var writingMode = {
  noPrefill: ['writing-mode'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'writing-mode') return false;

    if (prefix.js === 'Webkit' || prefix.js === 'ms' && prefix.browser !== 'edge') {
      return prefix.css + prop;
    }

    return prop;
  }
}; // https://caniuse.com/#search=user-select

var userSelect = {
  noPrefill: ['user-select'],
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'user-select') return false;

    if (prefix.js === 'Moz' || prefix.js === 'ms' || prefix.vendor === 'apple') {
      return prefix.css + prop;
    }

    return prop;
  }
}; // https://caniuse.com/#search=multicolumn
// https://github.com/postcss/autoprefixer/issues/491
// https://github.com/postcss/autoprefixer/issues/177

var breakPropsOld = {
  supportedProperty: function supportedProperty(prop, style) {
    if (!/^break-/.test(prop)) return false;

    if (prefix.js === 'Webkit') {
      var jsProp = "WebkitColumn" + pascalize(prop);
      return jsProp in style ? prefix.css + "column-" + prop : false;
    }

    if (prefix.js === 'Moz') {
      var _jsProp = "page" + pascalize(prop);

      return _jsProp in style ? "page-" + prop : false;
    }

    return false;
  }
}; // See https://github.com/postcss/autoprefixer/issues/324.

var inlineLogicalOld = {
  supportedProperty: function supportedProperty(prop, style) {
    if (!/^(border|margin|padding)-inline/.test(prop)) return false;
    if (prefix.js === 'Moz') return prop;
    var newProp = prop.replace('-inline', '');
    return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
  }
}; // Camelization is required because we can't test using.
// CSS syntax for e.g. in FF.

var unprefixed = {
  supportedProperty: function supportedProperty(prop, style) {
    return camelize(prop) in style ? prop : false;
  }
};
var prefixed = {
  supportedProperty: function supportedProperty(prop, style) {
    var pascalized = pascalize(prop); // Return custom CSS variable without prefixing.

    if (prop[0] === '-') return prop; // Return already prefixed value without prefixing.

    if (prop[0] === '-' && prop[1] === '-') return prop;
    if (prefix.js + pascalized in style) return prefix.css + prop; // Try webkit fallback.

    if (prefix.js !== 'Webkit' && "Webkit" + pascalized in style) return "-webkit-" + prop;
    return false;
  }
}; // https://caniuse.com/#search=scroll-snap

var scrollSnap = {
  supportedProperty: function supportedProperty(prop) {
    if (prop.substring(0, 11) !== 'scroll-snap') return false;

    if (prefix.js === 'ms') {
      return "" + prefix.css + prop;
    }

    return prop;
  }
}; // https://caniuse.com/#search=overscroll-behavior

var overscrollBehavior = {
  supportedProperty: function supportedProperty(prop) {
    if (prop !== 'overscroll-behavior') return false;

    if (prefix.js === 'ms') {
      return prefix.css + "scroll-chaining";
    }

    return prop;
  }
};
var propMap = {
  'flex-grow': 'flex-positive',
  'flex-shrink': 'flex-negative',
  'flex-basis': 'flex-preferred-size',
  'justify-content': 'flex-pack',
  order: 'flex-order',
  'align-items': 'flex-align',
  'align-content': 'flex-line-pack' // 'align-self' is handled by 'align-self' plugin.

}; // Support old flex spec from 2012.

var flex2012 = {
  supportedProperty: function supportedProperty(prop, style) {
    var newProp = propMap[prop];
    if (!newProp) return false;
    return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
  }
};
var propMap$1 = {
  flex: 'box-flex',
  'flex-grow': 'box-flex',
  'flex-direction': ['box-orient', 'box-direction'],
  order: 'box-ordinal-group',
  'align-items': 'box-align',
  'flex-flow': ['box-orient', 'box-direction'],
  'justify-content': 'box-pack'
};
var propKeys = Object.keys(propMap$1);

var prefixCss = function prefixCss(p) {
  return prefix.css + p;
}; // Support old flex spec from 2009.


var flex2009 = {
  supportedProperty: function supportedProperty(prop, style, _ref) {
    var multiple = _ref.multiple;

    if (propKeys.indexOf(prop) > -1) {
      var newProp = propMap$1[prop];

      if (!Array.isArray(newProp)) {
        return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
      }

      if (!multiple) return false;

      for (var i = 0; i < newProp.length; i++) {
        if (!(prefix.js + pascalize(newProp[0]) in style)) {
          return false;
        }
      }

      return newProp.map(prefixCss);
    }

    return false;
  }
}; // plugins = [
//   ...plugins,
//    breakPropsOld,
//    inlineLogicalOld,
//    unprefixed,
//    prefixed,
//    scrollSnap,
//    flex2012,
//    flex2009
// ]
// Plugins without 'noPrefill' value, going last.
// 'flex-*' plugins should be at the bottom.
// 'flex2009' going after 'flex2012'.
// 'prefixed' going after 'unprefixed'

var plugins = [appearence, colorAdjust, mask, textOrientation, transform, transition, writingMode, userSelect, breakPropsOld, inlineLogicalOld, unprefixed, prefixed, scrollSnap, overscrollBehavior, flex2012, flex2009];
var propertyDetectors = plugins.filter(function (p) {
  return p.supportedProperty;
}).map(function (p) {
  return p.supportedProperty;
});
var noPrefill = plugins.filter(function (p) {
  return p.noPrefill;
}).reduce(function (a, p) {
  a.push.apply(a, _toConsumableArray(p.noPrefill));
  return a;
}, []);
var el;
var cache = {};

if (isBrowser$1) {
  el = document.createElement('p'); // We test every property on vendor prefix requirement.
  // Once tested, result is cached. It gives us up to 70% perf boost.
  // http://jsperf.com/element-style-object-access-vs-plain-object
  //
  // Prefill cache with known css properties to reduce amount of
  // properties we need to feature test at runtime.
  // http://davidwalsh.name/vendor-prefix

  var computed = window.getComputedStyle(document.documentElement, '');

  for (var key$1 in computed) {
    // eslint-disable-next-line no-restricted-globals
    if (!isNaN(key$1)) cache[computed[key$1]] = computed[key$1];
  } // Properties that cannot be correctly detected using the
  // cache prefill method.


  noPrefill.forEach(function (x) {
    return delete cache[x];
  });
}
/**
 * Test if a property is supported, returns supported property with vendor
 * prefix if required. Returns `false` if not supported.
 *
 * @param {String} prop dash separated
 * @param {Object} [options]
 * @return {String|Boolean}
 * @api public
 */


function supportedProperty(prop, options) {
  if (options === void 0) {
    options = {};
  } // For server-side rendering.


  if (!el) return prop; // Remove cache for benchmark tests or return property from the cache.

  if (cache[prop] != null) {
    return cache[prop];
  } // Check if 'transition' or 'transform' natively supported in browser.


  if (prop === 'transition' || prop === 'transform') {
    options[prop] = prop in el.style;
  } // Find a plugin for current prefix property.


  for (var i = 0; i < propertyDetectors.length; i++) {
    cache[prop] = propertyDetectors[i](prop, el.style, options); // Break loop, if value found.

    if (cache[prop]) break;
  } // Reset styles for current property.
  // Firefox can even throw an error for invalid properties, e.g., "0".


  try {
    el.style[prop] = '';
  } catch (err) {
    return false;
  }

  return cache[prop];
}

var cache$1 = {};
var transitionProperties = {
  transition: 1,
  'transition-property': 1,
  '-webkit-transition': 1,
  '-webkit-transition-property': 1
};
var transPropsRegExp = /(^\s*[\w-]+)|, (\s*[\w-]+)(?![^()]*\))/g;
var el$1;
/**
 * Returns prefixed value transition/transform if needed.
 *
 * @param {String} match
 * @param {String} p1
 * @param {String} p2
 * @return {String}
 * @api private
 */

function prefixTransitionCallback(match, p1, p2) {
  if (p1 === 'var') return 'var';
  if (p1 === 'all') return 'all';
  if (p2 === 'all') return ', all';
  var prefixedValue = p1 ? supportedProperty(p1) : ", " + supportedProperty(p2);
  if (!prefixedValue) return p1 || p2;
  return prefixedValue;
}

if (isBrowser$1) el$1 = document.createElement('p');
/**
 * Returns prefixed value if needed. Returns `false` if value is not supported.
 *
 * @param {String} property
 * @param {String} value
 * @return {String|Boolean}
 * @api public
 */

function supportedValue(property, value) {
  // For server-side rendering.
  var prefixedValue = value;
  if (!el$1 || property === 'content') return value; // It is a string or a number as a string like '1'.
  // We want only prefixable values here.
  // eslint-disable-next-line no-restricted-globals

  if (typeof prefixedValue !== 'string' || !isNaN(parseInt(prefixedValue, 10))) {
    return prefixedValue;
  } // Create cache key for current value.


  var cacheKey = property + prefixedValue; // Remove cache for benchmark tests or return value from cache.

  if (cache$1[cacheKey] != null) {
    return cache$1[cacheKey];
  } // IE can even throw an error in some cases, for e.g. style.content = 'bar'.


  try {
    // Test value as it is.
    el$1.style[property] = prefixedValue;
  } catch (err) {
    // Return false if value not supported.
    cache$1[cacheKey] = false;
    return false;
  } // If 'transition' or 'transition-property' property.


  if (transitionProperties[property]) {
    prefixedValue = prefixedValue.replace(transPropsRegExp, prefixTransitionCallback);
  } else if (el$1.style[property] === '') {
    // Value with a vendor prefix.
    prefixedValue = prefix.css + prefixedValue; // Hardcode test to convert "flex" to "-ms-flexbox" for IE10.

    if (prefixedValue === '-ms-flex') el$1.style[property] = '-ms-flexbox'; // Test prefixed value.

    el$1.style[property] = prefixedValue; // Return false if value not supported.

    if (el$1.style[property] === '') {
      cache$1[cacheKey] = false;
      return false;
    }
  } // Reset styles for current property.


  el$1.style[property] = ''; // Write current value to cache.

  cache$1[cacheKey] = prefixedValue;
  return cache$1[cacheKey];
}

/**
 * Add vendor prefix to a property name when needed.
 */

function jssVendorPrefixer() {
  function onProcessRule(rule) {
    if (rule.type === 'keyframes') {
      var atRule = rule;
      atRule.at = supportedKeyframes(atRule.at);
    }
  }

  function prefixStyle(style) {
    for (var prop in style) {
      var value = style[prop];

      if (prop === 'fallbacks' && Array.isArray(value)) {
        style[prop] = value.map(prefixStyle);
        continue;
      }

      var changeProp = false;
      var supportedProp = supportedProperty(prop);
      if (supportedProp && supportedProp !== prop) changeProp = true;
      var changeValue = false;
      var supportedValue$1 = supportedValue(supportedProp, toCssValue(value));
      if (supportedValue$1 && supportedValue$1 !== value) changeValue = true;

      if (changeProp || changeValue) {
        if (changeProp) delete style[prop];
        style[supportedProp || prop] = supportedValue$1 || value;
      }
    }

    return style;
  }

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;
    return prefixStyle(style);
  }

  function onChangeValue(value, prop) {
    return supportedValue(prop, toCssValue(value)) || value;
  }

  return {
    onProcessRule: onProcessRule,
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

/**
 * Sort props by length.
 */
function jssPropsSort() {
  var sort = function sort(prop0, prop1) {
    if (prop0.length === prop1.length) {
      return prop0 > prop1 ? 1 : -1;
    }

    return prop0.length - prop1.length;
  };

  return {
    onProcessStyle: function onProcessStyle(style, rule) {
      if (rule.type !== 'style') return style;
      var newStyle = {};
      var props = Object.keys(style).sort(sort);

      for (var i = 0; i < props.length; i++) {
        newStyle[props[i]] = style[props[i]];
      }

      return newStyle;
    }
  };
}

function jssPreset() {
  return {
    plugins: [functions(), jssGlobal(), jssNested(), camelCase(), defaultUnit(), // Disable the vendor prefixer server-side, it does nothing.
    // This way, we can get a performance boost.
    // In the documentation, we are using `autoprefixer` to solve this problem.
    typeof window === 'undefined' ? null : jssVendorPrefixer(), jssPropsSort()]
  };
}

function mergeClasses() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var baseClasses = options.baseClasses,
      newClasses = options.newClasses,
      Component = options.Component;

  if (!newClasses) {
    return baseClasses;
  }

  var nextClasses = _extends$1({}, baseClasses);

  {
    if (typeof newClasses === 'string') {
      console.error(["Material-UI: The value `".concat(newClasses, "` ") + "provided to the classes prop of ".concat(getDisplayName(Component), " is incorrect."), 'You might want to use the className prop instead.'].join('\n'));
      return baseClasses;
    }
  }

  Object.keys(newClasses).forEach(function (key) {
    {
      if (!baseClasses[key] && newClasses[key]) {
        console.error(["Material-UI: The key `".concat(key, "` ") + "provided to the classes prop is not implemented in ".concat(getDisplayName(Component), "."), "You can only override one of the following: ".concat(Object.keys(baseClasses).join(','), ".")].join('\n'));
      }

      if (newClasses[key] && typeof newClasses[key] !== 'string') {
        console.error(["Material-UI: The key `".concat(key, "` ") + "provided to the classes prop is not valid for ".concat(getDisplayName(Component), "."), "You need to provide a non empty string instead of: ".concat(newClasses[key], ".")].join('\n'));
      }
    }

    if (newClasses[key]) {
      nextClasses[key] = "".concat(baseClasses[key], " ").concat(newClasses[key]);
    }
  });
  return nextClasses;
}

// Used https://github.com/thinkloop/multi-key-cache as inspiration
var multiKeyStore = {
  set: function set(cache, key1, key2, value) {
    var subCache = cache.get(key1);

    if (!subCache) {
      subCache = new Map();
      cache.set(key1, subCache);
    }

    subCache.set(key2, value);
  },
  get: function get(cache, key1, key2) {
    var subCache = cache.get(key1);
    return subCache ? subCache.get(key2) : undefined;
  },
  delete: function _delete(cache, key1, key2) {
    var subCache = cache.get(key1);
    subCache.delete(key2);
  }
};
var multiKeyStore$1 = multiKeyStore;

var ThemeContext = React__default.createContext(null);

{
  ThemeContext.displayName = 'ThemeContext';
}

var ThemeContext$1 = ThemeContext;

function useTheme$1() {
  var theme = React__default.useContext(ThemeContext$1);

  {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React__default.useDebugValue(theme);
  }

  return theme;
}

var jss = createJss(jssPreset()); // Use a singleton or the provided one by the context.
//
// The counter-based approach doesn't tolerate any mistake.
// It's much safer to use the same counter everywhere.

var generateClassName = createGenerateClassName(); // Exported for test purposes

var sheetsManager = new Map();
var defaultOptions = {
  disableGeneration: false,
  generateClassName: generateClassName,
  jss: jss,
  sheetsCache: null,
  sheetsManager: sheetsManager,
  sheetsRegistry: null
};
var StylesContext = React__default.createContext(defaultOptions);

{
  StylesContext.displayName = 'StylesContext';
}

var injectFirstNode;
function StylesProvider(props) {
  var children = props.children,
      _props$injectFirst = props.injectFirst,
      injectFirst = _props$injectFirst === void 0 ? false : _props$injectFirst,
      _props$disableGenerat = props.disableGeneration,
      disableGeneration = _props$disableGenerat === void 0 ? false : _props$disableGenerat,
      localOptions = _objectWithoutProperties(props, ["children", "injectFirst", "disableGeneration"]);

  var outerOptions = React__default.useContext(StylesContext);

  var context = _extends$1({}, outerOptions, {
    disableGeneration: disableGeneration
  }, localOptions);

  {
    if (typeof window === 'undefined' && !context.sheetsManager) {
      console.error('Material-UI: You need to use the ServerStyleSheets API when rendering on the server.');
    }
  }

  {
    if (context.jss.options.insertionPoint && injectFirst) {
      console.error('Material-UI: You cannot use a custom insertionPoint and <StylesContext injectFirst> at the same time.');
    }
  }

  {
    if (injectFirst && localOptions.jss) {
      console.error('Material-UI: You cannot use the jss and injectFirst props at the same time.');
    }
  }

  if (!context.jss.options.insertionPoint && injectFirst && typeof window !== 'undefined') {
    if (!injectFirstNode) {
      var head = document.head;
      injectFirstNode = document.createComment('mui-inject-first');
      head.insertBefore(injectFirstNode, head.firstChild);
    }

    context.jss = createJss({
      plugins: jssPreset().plugins,
      insertionPoint: injectFirstNode
    });
  }

  return /*#__PURE__*/React__default.createElement(StylesContext.Provider, {
    value: context
  }, children);
}
StylesProvider.propTypes = {
  /**
   * Your component tree.
   */
  children: PropTypes.node.isRequired,

  /**
   * You can disable the generation of the styles with this option.
   * It can be useful when traversing the React tree outside of the HTML
   * rendering step on the server.
   * Let's say you are using react-apollo to extract all
   * the queries made by the interface server-side - you can significantly speed up the traversal with this prop.
   */
  disableGeneration: PropTypes.bool,

  /**
   * JSS's class name generator.
   */
  generateClassName: PropTypes.func,

  /**
   * By default, the styles are injected last in the <head> element of the page.
   * As a result, they gain more specificity than any other style sheet.
   * If you want to override Material-UI's styles, set this prop.
   */
  injectFirst: PropTypes.bool,

  /**
   * JSS's instance.
   */
  jss: PropTypes.object,

  /**
   * @ignore
   */
  serverGenerateClassName: PropTypes.func,

  /**
   * @ignore
   *
   * Beta feature.
   *
   * Cache for the sheets.
   */
  sheetsCache: PropTypes.object,

  /**
   * @ignore
   *
   * The sheetsManager is used to deduplicate style sheet injection in the page.
   * It's deduplicating using the (theme, styles) couple.
   * On the server, you should provide a new instance for each request.
   */
  sheetsManager: PropTypes.object,

  /**
   * @ignore
   *
   * Collect the sheets.
   */
  sheetsRegistry: PropTypes.object
} ;

{
  StylesProvider.propTypes = exactProp(StylesProvider.propTypes) ;
}

/* eslint-disable import/prefer-default-export */
// Global index counter to preserve source order.
// We create the style sheet during the creation of the component,
// children are handled after the parents, so the order of style elements would be parent->child.
// It is a problem though when a parent passes a className
// which needs to override any child's styles.
// StyleSheet of the child has a higher specificity, because of the source order.
// So our solution is to render sheets them in the reverse order child->sheet, so
// that parent has a higher specificity.
var indexCounter = -1e9;
function increment() {
  indexCounter += 1;

  {
    if (indexCounter >= 0) {
      console.warn(['Material-UI: You might have a memory leak.', 'The indexCounter is not supposed to grow that much.'].join('\n'));
    }
  }

  return indexCounter;
}

// We use the same empty object to ref count the styles that don't need a theme object.
var noopTheme = {};
var noopTheme$1 = noopTheme;

function getStylesCreator(stylesOrCreator) {
  var themingEnabled = typeof stylesOrCreator === 'function';

  {
    if (_typeof$1(stylesOrCreator) !== 'object' && !themingEnabled) {
      console.error(['Material-UI: The `styles` argument provided is invalid.', 'You need to provide a function generating the styles or a styles object.'].join('\n'));
    }
  }

  return {
    create: function create(theme, name) {
      var styles;

      try {
        styles = themingEnabled ? stylesOrCreator(theme) : stylesOrCreator;
      } catch (err) {
        {
          if (themingEnabled === true && theme === noopTheme$1) {
            // TODO: prepend error message/name instead
            console.error(['Material-UI: The `styles` argument provided is invalid.', 'You are providing a function without a theme in the context.', 'One of the parent elements needs to use a ThemeProvider.'].join('\n'));
          }
        }

        throw err;
      }

      if (!name || !theme.overrides || !theme.overrides[name]) {
        return styles;
      }

      var overrides = theme.overrides[name];

      var stylesWithOverrides = _extends$1({}, styles);

      Object.keys(overrides).forEach(function (key) {
        {
          if (!stylesWithOverrides[key]) {
            console.warn(['Material-UI: You are trying to override a style that does not exist.', "Fix the `".concat(key, "` key of `theme.overrides.").concat(name, "`.")].join('\n'));
          }
        }

        stylesWithOverrides[key] = deepmerge(stylesWithOverrides[key], overrides[key]);
      });
      return stylesWithOverrides;
    },
    options: {}
  };
}

function getClasses(_ref, classes, Component) {
  var state = _ref.state,
      stylesOptions = _ref.stylesOptions;

  if (stylesOptions.disableGeneration) {
    return classes || {};
  }

  if (!state.cacheClasses) {
    state.cacheClasses = {
      // Cache for the finalized classes value.
      value: null,
      // Cache for the last used classes prop pointer.
      lastProp: null,
      // Cache for the last used rendered classes pointer.
      lastJSS: {}
    };
  } // Tracks if either the rendered classes or classes prop has changed,
  // requiring the generation of a new finalized classes object.


  var generate = false;

  if (state.classes !== state.cacheClasses.lastJSS) {
    state.cacheClasses.lastJSS = state.classes;
    generate = true;
  }

  if (classes !== state.cacheClasses.lastProp) {
    state.cacheClasses.lastProp = classes;
    generate = true;
  }

  if (generate) {
    state.cacheClasses.value = mergeClasses({
      baseClasses: state.cacheClasses.lastJSS,
      newClasses: classes,
      Component: Component
    });
  }

  return state.cacheClasses.value;
}

function attach(_ref2, props) {
  var state = _ref2.state,
      theme = _ref2.theme,
      stylesOptions = _ref2.stylesOptions,
      stylesCreator = _ref2.stylesCreator,
      name = _ref2.name;

  if (stylesOptions.disableGeneration) {
    return;
  }

  var sheetManager = multiKeyStore$1.get(stylesOptions.sheetsManager, stylesCreator, theme);

  if (!sheetManager) {
    sheetManager = {
      refs: 0,
      staticSheet: null,
      dynamicStyles: null
    };
    multiKeyStore$1.set(stylesOptions.sheetsManager, stylesCreator, theme, sheetManager);
  }

  var options = _extends$1({}, stylesCreator.options, stylesOptions, {
    theme: theme,
    flip: typeof stylesOptions.flip === 'boolean' ? stylesOptions.flip : theme.direction === 'rtl'
  });

  options.generateId = options.serverGenerateClassName || options.generateClassName;
  var sheetsRegistry = stylesOptions.sheetsRegistry;

  if (sheetManager.refs === 0) {
    var staticSheet;

    if (stylesOptions.sheetsCache) {
      staticSheet = multiKeyStore$1.get(stylesOptions.sheetsCache, stylesCreator, theme);
    }

    var styles = stylesCreator.create(theme, name);

    if (!staticSheet) {
      staticSheet = stylesOptions.jss.createStyleSheet(styles, _extends$1({
        link: false
      }, options));
      staticSheet.attach();

      if (stylesOptions.sheetsCache) {
        multiKeyStore$1.set(stylesOptions.sheetsCache, stylesCreator, theme, staticSheet);
      }
    }

    if (sheetsRegistry) {
      sheetsRegistry.add(staticSheet);
    }

    sheetManager.staticSheet = staticSheet;
    sheetManager.dynamicStyles = getDynamicStyles(styles);
  }

  if (sheetManager.dynamicStyles) {
    var dynamicSheet = stylesOptions.jss.createStyleSheet(sheetManager.dynamicStyles, _extends$1({
      link: true
    }, options));
    dynamicSheet.update(props);
    dynamicSheet.attach();
    state.dynamicSheet = dynamicSheet;
    state.classes = mergeClasses({
      baseClasses: sheetManager.staticSheet.classes,
      newClasses: dynamicSheet.classes
    });

    if (sheetsRegistry) {
      sheetsRegistry.add(dynamicSheet);
    }
  } else {
    state.classes = sheetManager.staticSheet.classes;
  }

  sheetManager.refs += 1;
}

function update$1(_ref3, props) {
  var state = _ref3.state;

  if (state.dynamicSheet) {
    state.dynamicSheet.update(props);
  }
}

function detach(_ref4) {
  var state = _ref4.state,
      theme = _ref4.theme,
      stylesOptions = _ref4.stylesOptions,
      stylesCreator = _ref4.stylesCreator;

  if (stylesOptions.disableGeneration) {
    return;
  }

  var sheetManager = multiKeyStore$1.get(stylesOptions.sheetsManager, stylesCreator, theme);
  sheetManager.refs -= 1;
  var sheetsRegistry = stylesOptions.sheetsRegistry;

  if (sheetManager.refs === 0) {
    multiKeyStore$1.delete(stylesOptions.sheetsManager, stylesCreator, theme);
    stylesOptions.jss.removeStyleSheet(sheetManager.staticSheet);

    if (sheetsRegistry) {
      sheetsRegistry.remove(sheetManager.staticSheet);
    }
  }

  if (state.dynamicSheet) {
    stylesOptions.jss.removeStyleSheet(state.dynamicSheet);

    if (sheetsRegistry) {
      sheetsRegistry.remove(state.dynamicSheet);
    }
  }
}

function useSynchronousEffect(func, values) {
  var key = React__default.useRef([]);
  var output; // Store "generation" key. Just returns a new object every time

  var currentKey = React__default.useMemo(function () {
    return {};
  }, values); // eslint-disable-line react-hooks/exhaustive-deps
  // "the first render", or "memo dropped the value"

  if (key.current !== currentKey) {
    key.current = currentKey;
    output = func();
  }

  React__default.useEffect(function () {
    return function () {
      if (output) {
        output();
      }
    };
  }, [currentKey] // eslint-disable-line react-hooks/exhaustive-deps
  );
}

function makeStyles(stylesOrCreator) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var name = options.name,
      classNamePrefixOption = options.classNamePrefix,
      Component = options.Component,
      _options$defaultTheme = options.defaultTheme,
      defaultTheme = _options$defaultTheme === void 0 ? noopTheme$1 : _options$defaultTheme,
      stylesOptions2 = _objectWithoutProperties(options, ["name", "classNamePrefix", "Component", "defaultTheme"]);

  var stylesCreator = getStylesCreator(stylesOrCreator);
  var classNamePrefix = name || classNamePrefixOption || 'makeStyles';
  stylesCreator.options = {
    index: increment(),
    name: name,
    meta: classNamePrefix,
    classNamePrefix: classNamePrefix
  };

  var useStyles = function useStyles() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var theme = useTheme$1() || defaultTheme;

    var stylesOptions = _extends$1({}, React__default.useContext(StylesContext), stylesOptions2);

    var instance = React__default.useRef();
    var shouldUpdate = React__default.useRef();
    useSynchronousEffect(function () {
      var current = {
        name: name,
        state: {},
        stylesCreator: stylesCreator,
        stylesOptions: stylesOptions,
        theme: theme
      };
      attach(current, props);
      shouldUpdate.current = false;
      instance.current = current;
      return function () {
        detach(current);
      };
    }, [theme, stylesCreator]);
    React__default.useEffect(function () {
      if (shouldUpdate.current) {
        update$1(instance.current, props);
      }

      shouldUpdate.current = true;
    });
    var classes = getClasses(instance.current, props.classes, Component);

    {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React__default.useDebugValue(classes);
    }

    return classes;
  };

  return useStyles;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var reactIs = reactIs$1.exports;
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty$1 = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty$1(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

var hoistNonReactStatics_cjs = hoistNonReactStatics;

// It does not modify the component passed to it;
// instead, it returns a new component, with a `classes` property.

var withStyles$1 = function withStyles(stylesOrCreator) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function (Component) {
    var defaultTheme = options.defaultTheme,
        _options$withTheme = options.withTheme,
        withTheme = _options$withTheme === void 0 ? false : _options$withTheme,
        name = options.name,
        stylesOptions = _objectWithoutProperties(options, ["defaultTheme", "withTheme", "name"]);

    {
      if (Component === undefined) {
        throw new Error(['You are calling withStyles(styles)(Component) with an undefined component.', 'You may have forgotten to import it.'].join('\n'));
      }
    }

    var classNamePrefix = name;

    {
      if (!name) {
        // Provide a better DX outside production.
        var displayName = getDisplayName(Component);

        if (displayName !== undefined) {
          classNamePrefix = displayName;
        }
      }
    }

    var useStyles = makeStyles(stylesOrCreator, _extends$1({
      defaultTheme: defaultTheme,
      Component: Component,
      name: name || Component.displayName,
      classNamePrefix: classNamePrefix
    }, stylesOptions));
    var WithStyles = /*#__PURE__*/React__default.forwardRef(function WithStyles(props, ref) {
      props.classes;
          var innerRef = props.innerRef,
          other = _objectWithoutProperties(props, ["classes", "innerRef"]); // The wrapper receives only user supplied props, which could be a subset of
      // the actual props Component might receive due to merging with defaultProps.
      // So copying it here would give us the same result in the wrapper as well.


      var classes = useStyles(_extends$1({}, Component.defaultProps, props));
      var theme;
      var more = other;

      if (typeof name === 'string' || withTheme) {
        // name and withTheme are invariant in the outer scope
        // eslint-disable-next-line react-hooks/rules-of-hooks
        theme = useTheme$1() || defaultTheme;

        if (name) {
          more = getThemeProps({
            theme: theme,
            name: name,
            props: other
          });
        } // Provide the theme to the wrapped component.
        // So we don't have to use the `withTheme()` Higher-order Component.


        if (withTheme && !more.theme) {
          more.theme = theme;
        }
      }

      return /*#__PURE__*/React__default.createElement(Component, _extends$1({
        ref: innerRef || ref,
        classes: classes
      }, more));
    });
    WithStyles.propTypes = {
      /**
       * Override or extend the styles applied to the component.
       */
      classes: PropTypes.object,

      /**
       * Use that prop to pass a ref to the decorated component.
       * @deprecated
       */
      innerRef: chainPropTypes(PropTypes.oneOfType([PropTypes.func, PropTypes.object]), function (props) {
        if (props.innerRef == null) {
          return null;
        }

        return null; // return new Error(
        //   'Material-UI: The `innerRef` prop is deprecated and will be removed in v5. ' +
        //     'Refs are now automatically forwarded to the inner component.',
        // );
      })
    } ;

    {
      WithStyles.displayName = "WithStyles(".concat(getDisplayName(Component), ")");
    }

    hoistNonReactStatics_cjs(WithStyles, Component);

    {
      // Exposed for test purposes.
      WithStyles.Naked = Component;
      WithStyles.options = options;
      WithStyles.useStyles = useStyles;
    }

    return WithStyles;
  };
};

var withStylesWithoutDefault = withStyles$1;

var defaultTheme = createTheme();
var defaultTheme$1 = defaultTheme;

function useTheme() {
  var theme = useTheme$1() || defaultTheme$1;

  {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React__default.useDebugValue(theme);
  }

  return theme;
}

function withStyles(stylesOrCreator, options) {
  return withStylesWithoutDefault(stylesOrCreator, _extends$1({
    defaultTheme: defaultTheme$1
  }, options));
}

/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1-lts
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

var timeoutDuration = function () {
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];

  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }

  return 0;
}();

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }

    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;
/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/

var debounce$1 = supportsMicroTasks ? microtaskDebounce : taskDebounce;
/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */

function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */


function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  } // NOTE: 1 DOM access here


  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}
/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */


function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }

  return element.parentNode || element.host;
}
/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */


function getScrollParent$1(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;

    case '#document':
      return element.body;
  } // Firefox want us to check `-x` and `-y` variations as well


  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent$1(getParentNode(element));
}
/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */


function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */

function isIE(version) {
  if (version === 11) {
    return isIE11;
  }

  if (version === 10) {
    return isIE10;
  }

  return isIE11 || isIE10;
}
/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */


function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here

  var offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent

  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  } // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...


  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }

  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}
/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */


function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}
/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */


function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  } // Here we make sure to give as "start" the element that comes first in the DOM


  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1; // Get common ancestor container

  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  } // one of the nodes is inside shadowDOM, find which one


  var element1root = getRoot(element1);

  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}
/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */


function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}
/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */


function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}
/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */


function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);
  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};
/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */


function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}
/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */


function getBoundingClientRect(element) {
  var rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11

  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  }; // subtract scrollbar size from sizes

  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;
  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons

  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');
    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent$1(children);
  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth); // In cases where the parent is fixed, we must ignore negative scroll in offset calc

  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }

  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.

  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);
    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them

    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);
  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };
  return getClientRect(offset);
}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */


function isFixed(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }

  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }

  var parentNode = getParentNode(element);

  if (!parentNode) {
    return false;
  }

  return isFixed(parentNode);
}
/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */


function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }

  var el = element.parentElement;

  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }

  return el || document.documentElement;
}
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */


function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; // NOTE: 1 DOM access here

  var boundaries = {
    top: 0,
    left: 0
  };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference)); // Handle viewport case

  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;

    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent$1(getParentNode(reference));

      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation

    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  } // Add paddings


  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;
  return width * height;
}
/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };
  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });
  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });
  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
  var variation = placement.split('-')[1];
  return computedPlacement + (variation ? '-' + variation : '');
}
/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */


function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}
/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */


function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}
/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */


function getOppositePlacement(placement) {
  var hash = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */


function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0]; // Get popper node sizes

  var popperRect = getOuterSizes(popper); // Add position, width and height to our offsets object

  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  }; // depending by the popper placement we have to compute its offsets slightly differently

  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';
  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;

  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}
/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */


function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  } // use `filter` to obtain the same behavior of `find`


  return arr.filter(check)[0];
}
/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */


function findIndex$1(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  } // use `find` + `indexOf` if `findIndex` isn't supported


  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}
/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */


function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex$1(modifiers, 'name', ends));
  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }

    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation

    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);
      data = fn(data, modifier);
    }
  });
  return data;
}
/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */


function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  }; // compute reference element offsets

  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed); // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value

  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding); // store the computed placement inside `originalPlacement`

  data.originalPlacement = data.placement;
  data.positionFixed = this.options.positionFixed; // compute the popper offsets

  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute'; // run the modifiers

  data = runModifiers(this.modifiers, data); // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback

  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}
/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */


function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}
/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */


function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;

    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }

  return null;
}
/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */


function destroy() {
  this.state.isDestroyed = true; // touch DOM only if `applyStyle` modifier is enabled

  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners(); // remove the popper if user explicitly asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it

  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }

  return this;
}
/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */


function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, {
    passive: true
  });

  if (!isBody) {
    attachToScrollParents(getScrollParent$1(target.parentNode), event, callback, scrollParents);
  }

  scrollParents.push(target);
}
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */


function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, {
    passive: true
  }); // Scroll event listener on scroll parents

  var scrollElement = getScrollParent$1(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;
  return state;
}
/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */


function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */


function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound); // Remove scroll event listener on scroll parents

  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  }); // Reset state

  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}
/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */


function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}
/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */


function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}
/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */


function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = ''; // add unit if the value is numeric and is one of the following

    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }

    element.style[prop] = styles[prop] + unit;
  });
}
/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */


function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];

    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */


function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles); // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element

  setAttributes(data.instance.popper, data.attributes); // if arrowElement is defined and arrowStyles has some properties

  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}
/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */


function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed); // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value

  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
  popper.setAttribute('x-placement', placement); // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations

  setStyles(popper, {
    position: options.positionFixed ? 'fixed' : 'absolute'
  });
  return options;
}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */


function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);
  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;
  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */

function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper; // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;

  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }

  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent); // Styles

  var styles = {
    position: popper.position
  };
  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right'; // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed

  var prefixedProperty = getSupportedPropertyName('transform'); // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.

  var left = void 0,
      top = void 0;

  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }

  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }

  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  } // Attributes


  var attributes = {
    'x-placement': data.placement
  }; // Update `data` attributes, styles and arrowStyles

  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
  return data;
}
/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */


function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });
  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';

    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }

  return isRequired;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function arrow(data, options) {
  var _data$offsets$arrow; // arrow depends on keepTogether in order to work


  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element; // if arrowElement is a string, suppose it's a CSS selector

  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement); // if arrowElement is not found, don't run the modifier

    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var isVertical = ['left', 'right'].indexOf(placement) !== -1;
  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len]; //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //
  // top/left side

  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  } // bottom/right side


  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }

  data.offsets.popper = getClientRect(data.offsets.popper); // compute center of the popper

  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2; // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available

  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; // prevent arrowElement from being placed not contiguously to its popper

  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
  return data;
}
/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */


function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }

  return variation;
}
/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */


var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; // Get rid of `auto` `auto-start` and `auto-end`

var validPlacements = placements.slice(3);
/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */

function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */

function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';
  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;

    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;

    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;

    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);
    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference; // using floor because the reference offsets may contain decimals we are not going to consider here

    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required

    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1; // flips variation if reference element overflows boundaries

    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom); // flips variation if popper content overflows boundaries

    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : ''); // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future

      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }

  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}
/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */


function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2]; // If it's not a number it's an operator, I guess

  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;

    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;

      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;

    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }

    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}
/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */


function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0]; // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one

  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1; // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)

  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  }); // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space

  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  } // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.


  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments]; // Convert the values with units to absolute pixels to allow our computations

  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, []) // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  }); // Loop trough the offsets arrays and execute the operations

  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */


function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var basePlacement = placement.split('-')[0];
  var offsets = void 0;

  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken

  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  } // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself


  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification

  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];
  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed); // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed

  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;
  options.boundaries = boundaries;
  var order = options.priority;
  var popper = data.offsets.popper;
  var check = {
    primary: function primary(placement) {
      var value = popper[placement];

      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }

      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];

      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }

      return defineProperty({}, mainSide, value);
    }
  };
  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });
  data.offsets.popper = popper;
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1]; // if shift shiftvariation is specified, run the modifier

  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;
    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';
    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };
    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);
  return data;
}
/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */


var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: offset,

    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries"  or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: preventOverflow,

    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],

    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,

    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: arrow,

    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: flip,

    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',

    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,

    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',

    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,

    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,

    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,

    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: computeStyle,

    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,

    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',

    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: applyStyle,

    /** @prop {Function} */
    onLoad: applyStyleOnLoad,

    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};
/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */

var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};
/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */
// Utils
// Methods

var Popper$2 = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    }; // make update() debounced, so that it only runs at most once-per-tick


    this.update = debounce$1(this.update.bind(this)); // with {} we create a new object with the options inside it

    this.options = _extends({}, Popper.Defaults, options); // init state

    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    }; // get reference and popper elements (allow jQuery wrappers)

    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper; // Deep merge modifiers options

    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    }); // Refactoring modifiers' list (Object => Array)

    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    }) // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    }); // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!

    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    }); // fire the first update to position the popper in the right place

    this.update();
    var eventsEnabled = this.options.eventsEnabled;

    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  } // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }
    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */

    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();
/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper$2.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper$2.placements = placements;
Popper$2.Defaults = Defaults;
var PopperJs = Popper$2;

function deprecatedPropType(validator, reason) {

  return function (props, propName, componentName, location, propFullName) {
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;

    if (typeof props[propName] !== 'undefined') {
      return new Error("The ".concat(location, " `").concat(propFullNameSafe, "` of ") + "`".concat(componentNameSafe, "` is deprecated. ").concat(reason));
    }

    return null;
  };
}

// TODO v5: consider to make it private
function setRef(ref, value) {
  if (typeof ref === 'function') {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}

function useForkRef(refA, refB) {
  /**
   * This will create a new function if the ref props change and are defined.
   * This means react will call the old forkRef with `null` and the new forkRef
   * with the ref. Cleanup naturally emerges from this behavior
   */
  return React.useMemo(function () {
    if (refA == null && refB == null) {
      return null;
    }

    return function (refValue) {
      setRef(refA, refValue);
      setRef(refB, refValue);
    };
  }, [refA, refB]);
}

function getContainer$1(container) {
  container = typeof container === 'function' ? container() : container; // #StrictMode ready

  return ReactDOM.findDOMNode(container);
}

var useEnhancedEffect$6 = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;
/**
 * Portals provide a first-class way to render children into a DOM node
 * that exists outside the DOM hierarchy of the parent component.
 */

var Portal = /*#__PURE__*/React.forwardRef(function Portal(props, ref) {
  var children = props.children,
      container = props.container,
      _props$disablePortal = props.disablePortal,
      disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal,
      onRendered = props.onRendered;

  var _React$useState = React.useState(null),
      mountNode = _React$useState[0],
      setMountNode = _React$useState[1];

  var handleRef = useForkRef( /*#__PURE__*/React.isValidElement(children) ? children.ref : null, ref);
  useEnhancedEffect$6(function () {
    if (!disablePortal) {
      setMountNode(getContainer$1(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect$6(function () {
    if (mountNode && !disablePortal) {
      setRef(ref, mountNode);
      return function () {
        setRef(ref, null);
      };
    }

    return undefined;
  }, [ref, mountNode, disablePortal]);
  useEnhancedEffect$6(function () {
    if (onRendered && (mountNode || disablePortal)) {
      onRendered();
    }
  }, [onRendered, mountNode, disablePortal]);

  if (disablePortal) {
    if ( /*#__PURE__*/React.isValidElement(children)) {
      return /*#__PURE__*/React.cloneElement(children, {
        ref: handleRef
      });
    }

    return children;
  }

  return mountNode ? /*#__PURE__*/ReactDOM.createPortal(children, mountNode) : mountNode;
});
Portal.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * The children to render into the `container`.
   */
  children: PropTypes.node,

  /**
   * A HTML element, component instance, or function that returns either.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: PropTypes
  /* @typescript-to-proptypes-ignore */
  .oneOfType([HTMLElementType, PropTypes.instanceOf(React.Component), PropTypes.func]),

  /**
   * Disable the portal behavior.
   * The children stay within it's parent DOM hierarchy.
   */
  disablePortal: PropTypes.bool,

  /**
   * Callback fired once the children has been mounted into the `container`.
   *
   * This prop will be removed in v5, the ref can be used instead.
   * @deprecated Use the ref instead.
   */
  onRendered: deprecatedPropType(PropTypes.func, 'Use the ref instead.')
} ;

{
  // eslint-disable-next-line
  Portal['propTypes' + ''] = exactProp(Portal.propTypes);
}

var Portal$1 = Portal;

/**
 * Safe chained function
 *
 * Will only create a new function if needed,
 * otherwise will pass back existing functions or null.
 *
 * @param {function} functions to chain
 * @returns {function|null}
 */
function createChainedFunction() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  return funcs.reduce(function (acc, func) {
    if (func == null) {
      return acc;
    }

    {
      if (typeof func !== 'function') {
        console.error('Material-UI: Invalid Argument Type, must only provide functions, undefined, or null.');
      }
    }

    return function chainedFunction() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      acc.apply(this, args);
      func.apply(this, args);
    };
  }, function () {});
}

function flipPlacement(placement, theme) {
  var direction = theme && theme.direction || 'ltr';

  if (direction === 'ltr') {
    return placement;
  }

  switch (placement) {
    case 'bottom-end':
      return 'bottom-start';

    case 'bottom-start':
      return 'bottom-end';

    case 'top-end':
      return 'top-start';

    case 'top-start':
      return 'top-end';

    default:
      return placement;
  }
}

function getAnchorEl$1(anchorEl) {
  return typeof anchorEl === 'function' ? anchorEl() : anchorEl;
}

var useEnhancedEffect$5 = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;
var defaultPopperOptions = {};
/**
 * Poppers rely on the 3rd party library [Popper.js](https://popper.js.org/docs/v1/) for positioning.
 */

var Popper = /*#__PURE__*/React.forwardRef(function Popper(props, ref) {
  var anchorEl = props.anchorEl,
      children = props.children,
      container = props.container,
      _props$disablePortal = props.disablePortal,
      disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal,
      _props$keepMounted = props.keepMounted,
      keepMounted = _props$keepMounted === void 0 ? false : _props$keepMounted,
      modifiers = props.modifiers,
      open = props.open,
      _props$placement = props.placement,
      initialPlacement = _props$placement === void 0 ? 'bottom' : _props$placement,
      _props$popperOptions = props.popperOptions,
      popperOptions = _props$popperOptions === void 0 ? defaultPopperOptions : _props$popperOptions,
      popperRefProp = props.popperRef,
      style = props.style,
      _props$transition = props.transition,
      transition = _props$transition === void 0 ? false : _props$transition,
      other = _objectWithoutProperties(props, ["anchorEl", "children", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition"]);

  var tooltipRef = React.useRef(null);
  var ownRef = useForkRef(tooltipRef, ref);
  var popperRef = React.useRef(null);
  var handlePopperRef = useForkRef(popperRef, popperRefProp);
  var handlePopperRefRef = React.useRef(handlePopperRef);
  useEnhancedEffect$5(function () {
    handlePopperRefRef.current = handlePopperRef;
  }, [handlePopperRef]);
  React.useImperativeHandle(popperRefProp, function () {
    return popperRef.current;
  }, []);

  var _React$useState = React.useState(true),
      exited = _React$useState[0],
      setExited = _React$useState[1];

  var theme = useTheme$1();
  var rtlPlacement = flipPlacement(initialPlacement, theme);
  /**
   * placement initialized from prop but can change during lifetime if modifiers.flip.
   * modifiers.flip is essentially a flip for controlled/uncontrolled behavior
   */

  var _React$useState2 = React.useState(rtlPlacement),
      placement = _React$useState2[0],
      setPlacement = _React$useState2[1];

  React.useEffect(function () {
    if (popperRef.current) {
      popperRef.current.update();
    }
  });
  var handleOpen = React.useCallback(function () {
    if (!tooltipRef.current || !anchorEl || !open) {
      return;
    }

    if (popperRef.current) {
      popperRef.current.destroy();
      handlePopperRefRef.current(null);
    }

    var handlePopperUpdate = function handlePopperUpdate(data) {
      setPlacement(data.placement);
    };

    var resolvedAnchorEl = getAnchorEl$1(anchorEl);

    {
      if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
        var box = resolvedAnchorEl.getBoundingClientRect();

        if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          console.warn(['Material-UI: The `anchorEl` prop provided to the component is invalid.', 'The anchor element should be part of the document layout.', "Make sure the element is present in the document or that it's not display none."].join('\n'));
        }
      }
    }

    var popper = new PopperJs(getAnchorEl$1(anchorEl), tooltipRef.current, _extends$1({
      placement: rtlPlacement
    }, popperOptions, {
      modifiers: _extends$1({}, disablePortal ? {} : {
        // It's using scrollParent by default, we can use the viewport when using a portal.
        preventOverflow: {
          boundariesElement: 'window'
        }
      }, modifiers, popperOptions.modifiers),
      // We could have been using a custom modifier like react-popper is doing.
      // But it seems this is the best public API for this use case.
      onCreate: createChainedFunction(handlePopperUpdate, popperOptions.onCreate),
      onUpdate: createChainedFunction(handlePopperUpdate, popperOptions.onUpdate)
    }));
    handlePopperRefRef.current(popper);
  }, [anchorEl, disablePortal, modifiers, open, rtlPlacement, popperOptions]);
  var handleRef = React.useCallback(function (node) {
    setRef(ownRef, node);
    handleOpen();
  }, [ownRef, handleOpen]);

  var handleEnter = function handleEnter() {
    setExited(false);
  };

  var handleClose = function handleClose() {
    if (!popperRef.current) {
      return;
    }

    popperRef.current.destroy();
    handlePopperRefRef.current(null);
  };

  var handleExited = function handleExited() {
    setExited(true);
    handleClose();
  };

  React.useEffect(function () {
    return function () {
      handleClose();
    };
  }, []);
  React.useEffect(function () {
    if (!open && !transition) {
      // Otherwise handleExited will call this.
      handleClose();
    }
  }, [open, transition]);

  if (!keepMounted && !open && (!transition || exited)) {
    return null;
  }

  var childProps = {
    placement: placement
  };

  if (transition) {
    childProps.TransitionProps = {
      in: open,
      onEnter: handleEnter,
      onExited: handleExited
    };
  }

  return /*#__PURE__*/React.createElement(Portal$1, {
    disablePortal: disablePortal,
    container: container
  }, /*#__PURE__*/React.createElement("div", _extends$1({
    ref: handleRef,
    role: "tooltip"
  }, other, {
    style: _extends$1({
      // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
      position: 'fixed',
      // Fix Popper.js display issue
      top: 0,
      left: 0,
      display: !open && keepMounted && !transition ? 'none' : null
    }, style)
  }), typeof children === 'function' ? children(childProps) : children));
});
Popper.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * A HTML element, [referenceObject](https://popper.js.org/docs/v1/#referenceObject),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: chainPropTypes(PropTypes.oneOfType([HTMLElementType, PropTypes.object, PropTypes.func]), function (props) {
    if (props.open) {
      var resolvedAnchorEl = getAnchorEl$1(props.anchorEl);

      if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
        var box = resolvedAnchorEl.getBoundingClientRect();

        if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          return new Error(['Material-UI: The `anchorEl` prop provided to the component is invalid.', 'The anchor element should be part of the document layout.', "Make sure the element is present in the document or that it's not display none."].join('\n'));
        }
      } else if (!resolvedAnchorEl || typeof resolvedAnchorEl.clientWidth !== 'number' || typeof resolvedAnchorEl.clientHeight !== 'number' || typeof resolvedAnchorEl.getBoundingClientRect !== 'function') {
        return new Error(['Material-UI: The `anchorEl` prop provided to the component is invalid.', 'It should be an HTML element instance or a referenceObject ', '(https://popper.js.org/docs/v1/#referenceObject).'].join('\n'));
      }
    }

    return null;
  }),

  /**
   * Popper render function or node.
   */
  children: PropTypes
  /* @typescript-to-proptypes-ignore */
  .oneOfType([PropTypes.node, PropTypes.func]).isRequired,

  /**
   * A HTML element, component instance, or function that returns either.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: PropTypes
  /* @typescript-to-proptypes-ignore */
  .oneOfType([HTMLElementType, PropTypes.instanceOf(React.Component), PropTypes.func]),

  /**
   * Disable the portal behavior.
   * The children stay within it's parent DOM hierarchy.
   */
  disablePortal: PropTypes.bool,

  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   */
  keepMounted: PropTypes.bool,

  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v1/#modifiers).
   */
  modifiers: PropTypes.object,

  /**
   * If `true`, the popper is visible.
   */
  open: PropTypes.bool.isRequired,

  /**
   * Popper placement.
   */
  placement: PropTypes.oneOf(['bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),

  /**
   * Options provided to the [`popper.js`](https://popper.js.org/docs/v1/) instance.
   */
  popperOptions: PropTypes.object,

  /**
   * A ref that points to the used popper instance.
   */
  popperRef: refType$1,

  /**
   * @ignore
   */
  style: PropTypes.object,

  /**
   * Help supporting a react-transition-group/Transition component.
   */
  transition: PropTypes.bool
} ;
var Popper$1 = Popper;

//
// A strict capitalization should uppercase the first letter of each word a the sentence.
// We only handle the first word.

function capitalize(string) {
  if (typeof string !== 'string') {
    throw new Error("Material-UI: capitalize(string) expects a string argument." );
  }

  return string.charAt(0).toUpperCase() + string.slice(1);
}

var styles$s = function styles(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      boxSizing: 'border-box',
      lineHeight: '48px',
      listStyle: 'none',
      color: theme.palette.text.secondary,
      fontFamily: theme.typography.fontFamily,
      fontWeight: theme.typography.fontWeightMedium,
      fontSize: theme.typography.pxToRem(14)
    },

    /* Styles applied to the root element if `color="primary"`. */
    colorPrimary: {
      color: theme.palette.primary.main
    },

    /* Styles applied to the root element if `color="inherit"`. */
    colorInherit: {
      color: 'inherit'
    },

    /* Styles applied to the inner `component` element if `disableGutters={false}`. */
    gutters: {
      paddingLeft: 16,
      paddingRight: 16
    },

    /* Styles applied to the root element if `inset={true}`. */
    inset: {
      paddingLeft: 72
    },

    /* Styles applied to the root element if `disableSticky={false}`. */
    sticky: {
      position: 'sticky',
      top: 0,
      zIndex: 1,
      backgroundColor: 'inherit'
    }
  };
};
var ListSubheader = /*#__PURE__*/React.forwardRef(function ListSubheader(props, ref) {
  var classes = props.classes,
      className = props.className,
      _props$color = props.color,
      color = _props$color === void 0 ? 'default' : _props$color,
      _props$component = props.component,
      Component = _props$component === void 0 ? 'li' : _props$component,
      _props$disableGutters = props.disableGutters,
      disableGutters = _props$disableGutters === void 0 ? false : _props$disableGutters,
      _props$disableSticky = props.disableSticky,
      disableSticky = _props$disableSticky === void 0 ? false : _props$disableSticky,
      _props$inset = props.inset,
      inset = _props$inset === void 0 ? false : _props$inset,
      other = _objectWithoutProperties(props, ["classes", "className", "color", "component", "disableGutters", "disableSticky", "inset"]);

  return /*#__PURE__*/React.createElement(Component, _extends$1({
    className: clsx(classes.root, className, color !== 'default' && classes["color".concat(capitalize(color))], inset && classes.inset, !disableSticky && classes.sticky, !disableGutters && classes.gutters),
    ref: ref
  }, other));
});
ListSubheader.propTypes = {
  /**
   * The content of the component.
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object.isRequired,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */
  color: PropTypes.oneOf(['default', 'primary', 'inherit']),

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes
  /* @typescript-to-proptypes-ignore */
  .elementType,

  /**
   * If `true`, the List Subheader will not have gutters.
   */
  disableGutters: PropTypes.bool,

  /**
   * If `true`, the List Subheader will not stick to the top during scroll.
   */
  disableSticky: PropTypes.bool,

  /**
   * If `true`, the List Subheader will be indented.
   */
  inset: PropTypes.bool
} ;
var ListSubheader$1 = withStyles(styles$s, {
  name: 'MuiListSubheader'
})(ListSubheader);

var styles$r = function styles(theme) {
  var elevations = {};
  theme.shadows.forEach(function (shadow, index) {
    elevations["elevation".concat(index)] = {
      boxShadow: shadow
    };
  });
  return _extends$1({
    /* Styles applied to the root element. */
    root: {
      backgroundColor: theme.palette.background.paper,
      color: theme.palette.text.primary,
      transition: theme.transitions.create('box-shadow')
    },

    /* Styles applied to the root element if `square={false}`. */
    rounded: {
      borderRadius: theme.shape.borderRadius
    },

    /* Styles applied to the root element if `variant="outlined"`. */
    outlined: {
      border: "1px solid ".concat(theme.palette.divider)
    }
  }, elevations);
};
var Paper = /*#__PURE__*/React.forwardRef(function Paper(props, ref) {
  var classes = props.classes,
      className = props.className,
      _props$component = props.component,
      Component = _props$component === void 0 ? 'div' : _props$component,
      _props$square = props.square,
      square = _props$square === void 0 ? false : _props$square,
      _props$elevation = props.elevation,
      elevation = _props$elevation === void 0 ? 1 : _props$elevation,
      _props$variant = props.variant,
      variant = _props$variant === void 0 ? 'elevation' : _props$variant,
      other = _objectWithoutProperties(props, ["classes", "className", "component", "square", "elevation", "variant"]);

  return /*#__PURE__*/React.createElement(Component, _extends$1({
    className: clsx(classes.root, className, variant === 'outlined' ? classes.outlined : classes["elevation".concat(elevation)], !square && classes.rounded),
    ref: ref
  }, other));
});
Paper.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * The content of the component.
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes
  /* @typescript-to-proptypes-ignore */
  .elementType,

  /**
   * Shadow depth, corresponds to `dp` in the spec.
   * It accepts values between 0 and 24 inclusive.
   */
  elevation: chainPropTypes(PropTypes.number, function (props) {
    var classes = props.classes,
        elevation = props.elevation; // in case `withStyles` fails to inject we don't need this warning

    if (classes === undefined) {
      return null;
    }

    if (elevation != null && classes["elevation".concat(elevation)] === undefined) {
      return new Error("Material-UI: This elevation `".concat(elevation, "` is not implemented."));
    }

    return null;
  }),

  /**
   * If `true`, rounded corners are disabled.
   */
  square: PropTypes.bool,

  /**
   * The variant to use.
   */
  variant: PropTypes.oneOf(['elevation', 'outlined'])
} ;
var Paper$1 = withStyles(styles$r, {
  name: 'MuiPaper'
})(Paper);

var useEnhancedEffect$4 = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;
/**
 * https://github.com/facebook/react/issues/14099#issuecomment-440013892
 *
 * @param {function} fn
 */

function useEventCallback(fn) {
  var ref = React.useRef(fn);
  useEnhancedEffect$4(function () {
    ref.current = fn;
  });
  return React.useCallback(function () {
    return (ref.current).apply(void 0, arguments);
  }, []);
}

// based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js
var hadKeyboardEvent = true;
var hadFocusVisibleRecently = false;
var hadFocusVisibleRecentlyTimeout = null;
var inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  'datetime-local': true
};
/**
 * Computes whether the given element should automatically trigger the
 * `focus-visible` class being added, i.e. whether it should always match
 * `:focus-visible` when focused.
 * @param {Element} node
 * @return {boolean}
 */

function focusTriggersKeyboardModality(node) {
  var type = node.type,
      tagName = node.tagName;

  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {
    return true;
  }

  if (tagName === 'TEXTAREA' && !node.readOnly) {
    return true;
  }

  if (node.isContentEditable) {
    return true;
  }

  return false;
}
/**
 * Keep track of our keyboard modality state with `hadKeyboardEvent`.
 * If the most recent user interaction was via the keyboard;
 * and the key press did not include a meta, alt/option, or control key;
 * then the modality is keyboard. Otherwise, the modality is not keyboard.
 * @param {KeyboardEvent} event
 */


function handleKeyDown(event) {
  if (event.metaKey || event.altKey || event.ctrlKey) {
    return;
  }

  hadKeyboardEvent = true;
}
/**
 * If at any point a user clicks with a pointing device, ensure that we change
 * the modality away from keyboard.
 * This avoids the situation where a user presses a key on an already focused
 * element, and then clicks on a different element, focusing it with a
 * pointing device, while we still think we're in keyboard modality.
 */


function handlePointerDown() {
  hadKeyboardEvent = false;
}

function handleVisibilityChange() {
  if (this.visibilityState === 'hidden') {
    // If the tab becomes active again, the browser will handle calling focus
    // on the element (Safari actually calls it twice).
    // If this tab change caused a blur on an element with focus-visible,
    // re-apply the class when the user switches back to the tab.
    if (hadFocusVisibleRecently) {
      hadKeyboardEvent = true;
    }
  }
}

function prepare(doc) {
  doc.addEventListener('keydown', handleKeyDown, true);
  doc.addEventListener('mousedown', handlePointerDown, true);
  doc.addEventListener('pointerdown', handlePointerDown, true);
  doc.addEventListener('touchstart', handlePointerDown, true);
  doc.addEventListener('visibilitychange', handleVisibilityChange, true);
}

function isFocusVisible(event) {
  var target = event.target;

  try {
    return target.matches(':focus-visible');
  } catch (error) {} // browsers not implementing :focus-visible will throw a SyntaxError
  // we use our own heuristic for those browsers
  // rethrow might be better if it's not the expected error but do we really
  // want to crash if focus-visible malfunctioned?
  // no need for validFocusTarget check. the user does that by attaching it to
  // focusable events only


  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}
/**
 * Should be called if a blur event is fired on a focus-visible element
 */


function handleBlurVisible() {
  // To detect a tab/window switch, we look for a blur event followed
  // rapidly by a visibility change.
  // If we don't see a visibility change within 100ms, it's probably a
  // regular focus change.
  hadFocusVisibleRecently = true;
  window.clearTimeout(hadFocusVisibleRecentlyTimeout);
  hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {
    hadFocusVisibleRecently = false;
  }, 100);
}

function useIsFocusVisible() {
  var ref = React.useCallback(function (instance) {
    var node = ReactDOM.findDOMNode(instance);

    if (node != null) {
      prepare(node.ownerDocument);
    }
  }, []);

  {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useDebugValue(isFocusVisible);
  }

  return {
    isFocusVisible: isFocusVisible,
    onBlurVisible: handleBlurVisible,
    ref: ref
  };
}

var config = {
  disabled: false
};

var timeoutsShape = PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
  enter: PropTypes.number,
  exit: PropTypes.number,
  appear: PropTypes.number
}).isRequired]) ;
PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
  enter: PropTypes.string,
  exit: PropTypes.string,
  active: PropTypes.string
}), PropTypes.shape({
  enter: PropTypes.string,
  enterDone: PropTypes.string,
  enterActive: PropTypes.string,
  exit: PropTypes.string,
  exitDone: PropTypes.string,
  exitActive: PropTypes.string
})]) ;

var TransitionGroupContext = React__default.createContext(null);

var UNMOUNTED = 'unmounted';
var EXITED = 'exited';
var ENTERING = 'entering';
var ENTERED = 'entered';
var EXITING = 'exiting';
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * ---
 *
 * **Note**: `Transition` is a platform-agnostic base component. If you're using
 * transitions in CSS, you'll probably want to use
 * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
 * instead. It inherits all the features of `Transition`, but contains
 * additional features necessary to play nice with CSS transitions (hence the
 * name of the component).
 *
 * ---
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the
 * components. It's up to you to give meaning and effect to those states. For
 * example we can add styles to a component when it enters or exits:
 *
 * ```jsx
 * import { Transition } from 'react-transition-group';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 1 },
 *   entered:  { opacity: 1 },
 *   exiting:  { opacity: 0 },
 *   exited:  { opacity: 0 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {state => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component
 * begins the "Enter" stage. During this stage, the component will shift from
 * its current transition state, to `'entering'` for the duration of the
 * transition and then to the `'entered'` stage once it's complete. Let's take
 * the following example (we'll use the
 * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <Transition in={inProp} timeout={500}>
 *         {state => (
 *           // ...
 *         )}
 *       </Transition>
 *       <button onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state
 * and stay there for 500ms (the value of `timeout`) before it finally switches
 * to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from
 * `'exiting'` to `'exited'`.
 */

var Transition = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Transition, _React$Component);

  function Transition(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;

    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;

    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }

    return null;
  } // getSnapshotBeforeUpdate(prevProps) {
  //   let nextStatus = null
  //   if (prevProps !== this.props) {
  //     const { status } = this.state
  //     if (this.props.in) {
  //       if (status !== ENTERING && status !== ENTERED) {
  //         nextStatus = ENTERING
  //       }
  //     } else {
  //       if (status === ENTERING || status === ENTERED) {
  //         nextStatus = EXITING
  //       }
  //     }
  //   }
  //   return { nextStatus }
  // }
  ;

  var _proto = Transition.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;

    if (prevProps !== this.props) {
      var status = this.state.status;

      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }

    this.updateStatus(false, nextStatus);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };

  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;

    if (timeout != null && typeof timeout !== 'number') {
      exit = timeout.exit;
      enter = timeout.enter; // TODO: remove fallback for next major

      appear = timeout.appear !== undefined ? timeout.appear : enter;
    }

    return {
      exit: exit,
      enter: enter,
      appear: appear
    };
  };

  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }

    if (nextStatus !== null) {
      // nextStatus will always be ENTERING or EXITING.
      this.cancelNextCallback();

      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };

  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;

    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;

    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM__default.findDOMNode(this), appearing],
        maybeNode = _ref2[0],
        maybeAppearing = _ref2[1];

    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
    // if we are mounting and running this it means appear _must_ be set

    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function () {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }

    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function () {
      _this2.props.onEntering(maybeNode, maybeAppearing);

      _this2.onTransitionEnd(enterTimeout, function () {
        _this2.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };

  _proto.performExit = function performExit() {
    var _this3 = this;

    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? undefined : ReactDOM__default.findDOMNode(this); // no exit animation skip right to EXITED

    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function () {
        _this3.props.onExited(maybeNode);
      });
      return;
    }

    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function () {
      _this3.props.onExiting(maybeNode);

      _this3.onTransitionEnd(timeouts.exit, function () {
        _this3.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };

  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };

  _proto.safeSetState = function safeSetState(nextState, callback) {
    // This shouldn't be necessary, but there are weird race conditions with
    // setState callbacks and unmounting in testing, so always make sure that
    // we can cancel any pending setState callbacks after we unmount.
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };

  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;

    var active = true;

    this.nextCallback = function (event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };

    this.nextCallback.cancel = function () {
      active = false;
    };

    return this.nextCallback;
  };

  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM__default.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }

    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
          maybeNode = _ref3[0],
          maybeNextCallback = _ref3[1];

      this.props.addEndListener(maybeNode, maybeNextCallback);
    }

    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };

  _proto.render = function render() {
    var status = this.state.status;

    if (status === UNMOUNTED) {
      return null;
    }

    var _this$props = this.props,
        children = _this$props.children;
        _this$props.in;
        _this$props.mountOnEnter;
        _this$props.unmountOnExit;
        _this$props.appear;
        _this$props.enter;
        _this$props.exit;
        _this$props.timeout;
        _this$props.addEndListener;
        _this$props.onEnter;
        _this$props.onEntering;
        _this$props.onEntered;
        _this$props.onExit;
        _this$props.onExiting;
        _this$props.onExited;
        _this$props.nodeRef;
        var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);

    return (
      /*#__PURE__*/
      // allows for nested Transitions
      React__default.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === 'function' ? children(status, childProps) : React__default.cloneElement(React__default.Children.only(children), childProps))
    );
  };

  return Transition;
}(React__default.Component);

Transition.contextType = TransitionGroupContext;
Transition.propTypes = {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: PropTypes.shape({
    current: typeof Element === 'undefined' ? PropTypes.any : function (propValue, key, componentName, location, propFullName, secret) {
      var value = propValue[key];
      return PropTypes.instanceOf(value && 'ownerDocument' in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
    }
  }),

  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,

  /**
   * Show the component; triggers the enter or exit states
   */
  in: PropTypes.bool,

  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: PropTypes.bool,

  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: PropTypes.bool,

  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: PropTypes.bool,

  /**
   * Enable or disable enter transitions.
   */
  enter: PropTypes.bool,

  /**
   * Enable or disable exit transitions.
   */
  exit: PropTypes.bool,

  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function timeout(props) {
    var pt = timeoutsShape;
    if (!props.addEndListener) pt = pt.isRequired;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return pt.apply(void 0, [props].concat(args));
  },

  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: PropTypes.func,

  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: PropTypes.func,

  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,

  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: PropTypes.func,

  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: PropTypes.func,

  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: PropTypes.func,

  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: PropTypes.func
} ; // Name the function so it is clearer in the documentation

function noop() {}

Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition$1 = Transition;

/**
 * Given `this.props.children`, return an object mapping key to child.
 *
 * @param {*} children `this.props.children`
 * @return {object} Mapping of key to child
 */

function getChildMapping(children, mapFn) {
  var mapper = function mapper(child) {
    return mapFn && isValidElement(child) ? mapFn(child) : child;
  };

  var result = Object.create(null);
  if (children) Children.map(children, function (c) {
    return c;
  }).forEach(function (child) {
    // run the map function here instead so that the key is the computed one
    result[child.key] = mapper(child);
  });
  return result;
}
/**
 * When you're adding or removing children some may be added or removed in the
 * same render pass. We want to show *both* since we want to simultaneously
 * animate elements in and out. This function takes a previous set of keys
 * and a new set of keys and merges them with its best guess of the correct
 * ordering. In the future we may expose some of the utilities in
 * ReactMultiChild to make this easy, but for now React itself does not
 * directly have this concept of the union of prevChildren and nextChildren
 * so we implement it here.
 *
 * @param {object} prev prev children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @param {object} next next children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @return {object} a key set that contains all keys in `prev` and all keys
 * in `next` in a reasonable order.
 */

function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};

  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  } // For each key of `next`, the list of keys to insert before that key in
  // the combined list


  var nextKeysPending = Object.create(null);
  var pendingKeys = [];

  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }

  var i;
  var childMapping = {};

  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }

    childMapping[nextKey] = getValueForKey(nextKey);
  } // Finally, add the keys which didn't appear before any key in `next`


  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }

  return childMapping;
}

function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}

function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function (child) {
    return cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, 'appear', props),
      enter: getProp(child, 'enter', props),
      exit: getProp(child, 'exit', props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function (key) {
    var child = children[key];
    if (!isValidElement(child)) return;
    var hasPrev = (key in prevChildMapping);
    var hasNext = (key in nextChildMapping);
    var prevChild = prevChildMapping[key];
    var isLeaving = isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)

    if (hasNext && (!hasPrev || isLeaving)) {
      // console.log('entering', key)
      children[key] = cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      // item is old (exiting)
      // console.log('leaving', key)
      children[key] = cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && isValidElement(prevChild)) {
      // item hasn't changed transition states
      // copy over the last transition props;
      // console.log('unchanged', key)
      children[key] = cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    }
  });
  return children;
}

var values = Object.values || function (obj) {
  return Object.keys(obj).map(function (k) {
    return obj[k];
  });
};

var defaultProps = {
  component: 'div',
  childFactory: function childFactory(child) {
    return child;
  }
};
/**
 * The `<TransitionGroup>` component manages a set of transition components
 * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
 * components, `<TransitionGroup>` is a state machine for managing the mounting
 * and unmounting of components over time.
 *
 * Consider the example below. As items are removed or added to the TodoList the
 * `in` prop is toggled automatically by the `<TransitionGroup>`.
 *
 * Note that `<TransitionGroup>`  does not define any animation behavior!
 * Exactly _how_ a list item animates is up to the individual transition
 * component. This means you can mix and match animations across different list
 * items.
 */

var TransitionGroup = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(TransitionGroup, _React$Component);

  function TransitionGroup(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;

    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this)); // Initial children should all be entering, dependent on appear


    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited: handleExited,
      firstRender: true
    };
    return _this;
  }

  var _proto = TransitionGroup.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children,
        handleExited = _ref.handleExited,
        firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  } // node is `undefined` when user provided `nodeRef` prop
  ;

  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;

    if (child.props.onExited) {
      child.props.onExited(node);
    }

    if (this.mounted) {
      this.setState(function (state) {
        var children = _extends$1({}, state.children);

        delete children[child.key];
        return {
          children: children
        };
      });
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        Component = _this$props.component,
        childFactory = _this$props.childFactory,
        props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);

    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory);
    delete props.appear;
    delete props.enter;
    delete props.exit;

    if (Component === null) {
      return /*#__PURE__*/React__default.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }

    return /*#__PURE__*/React__default.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /*#__PURE__*/React__default.createElement(Component, props, children));
  };

  return TransitionGroup;
}(React__default.Component);

TransitionGroup.propTypes = {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: PropTypes.any,

  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: PropTypes.node,

  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: PropTypes.bool,

  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: PropTypes.bool,

  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: PropTypes.bool,

  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: PropTypes.func
} ;
TransitionGroup.defaultProps = defaultProps;
var TransitionGroup$1 = TransitionGroup;

var useEnhancedEffect$3 = typeof window === 'undefined' ? React.useEffect : React.useLayoutEffect;
/**
 * @ignore - internal component.
 */

function Ripple(props) {
  var classes = props.classes,
      _props$pulsate = props.pulsate,
      pulsate = _props$pulsate === void 0 ? false : _props$pulsate,
      rippleX = props.rippleX,
      rippleY = props.rippleY,
      rippleSize = props.rippleSize,
      inProp = props.in,
      _props$onExited = props.onExited,
      onExited = _props$onExited === void 0 ? function () {} : _props$onExited,
      timeout = props.timeout;

  var _React$useState = React.useState(false),
      leaving = _React$useState[0],
      setLeaving = _React$useState[1];

  var rippleClassName = clsx(classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  var rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  var childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  var handleExited = useEventCallback(onExited); // Ripple is used for user feedback (e.g. click or press) so we want to apply styles with the highest priority

  useEnhancedEffect$3(function () {
    if (!inProp) {
      // react-transition-group#onExit
      setLeaving(true); // react-transition-group#onExited

      var timeoutId = setTimeout(handleExited, timeout);
      return function () {
        clearTimeout(timeoutId);
      };
    }

    return undefined;
  }, [handleExited, inProp, timeout]);
  return /*#__PURE__*/React.createElement("span", {
    className: rippleClassName,
    style: rippleStyles
  }, /*#__PURE__*/React.createElement("span", {
    className: childClassName
  }));
}

Ripple.propTypes = {
  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object.isRequired,

  /**
   * @ignore - injected from TransitionGroup
   */
  in: PropTypes.bool,

  /**
   * @ignore - injected from TransitionGroup
   */
  onExited: PropTypes.func,

  /**
   * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.
   */
  pulsate: PropTypes.bool,

  /**
   * Diameter of the ripple.
   */
  rippleSize: PropTypes.number,

  /**
   * Horizontal position of the ripple center.
   */
  rippleX: PropTypes.number,

  /**
   * Vertical position of the ripple center.
   */
  rippleY: PropTypes.number,

  /**
   * exit delay
   */
  timeout: PropTypes.number.isRequired
} ;

var DURATION = 550;
var DELAY_RIPPLE = 80;
var styles$q = function styles(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      overflow: 'hidden',
      pointerEvents: 'none',
      position: 'absolute',
      zIndex: 0,
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      borderRadius: 'inherit'
    },

    /* Styles applied to the internal `Ripple` components `ripple` class. */
    ripple: {
      opacity: 0,
      position: 'absolute'
    },

    /* Styles applied to the internal `Ripple` components `rippleVisible` class. */
    rippleVisible: {
      opacity: 0.3,
      transform: 'scale(1)',
      animation: "$enter ".concat(DURATION, "ms ").concat(theme.transitions.easing.easeInOut)
    },

    /* Styles applied to the internal `Ripple` components `ripplePulsate` class. */
    ripplePulsate: {
      animationDuration: "".concat(theme.transitions.duration.shorter, "ms")
    },

    /* Styles applied to the internal `Ripple` components `child` class. */
    child: {
      opacity: 1,
      display: 'block',
      width: '100%',
      height: '100%',
      borderRadius: '50%',
      backgroundColor: 'currentColor'
    },

    /* Styles applied to the internal `Ripple` components `childLeaving` class. */
    childLeaving: {
      opacity: 0,
      animation: "$exit ".concat(DURATION, "ms ").concat(theme.transitions.easing.easeInOut)
    },

    /* Styles applied to the internal `Ripple` components `childPulsate` class. */
    childPulsate: {
      position: 'absolute',
      left: 0,
      top: 0,
      animation: "$pulsate 2500ms ".concat(theme.transitions.easing.easeInOut, " 200ms infinite")
    },
    '@keyframes enter': {
      '0%': {
        transform: 'scale(0)',
        opacity: 0.1
      },
      '100%': {
        transform: 'scale(1)',
        opacity: 0.3
      }
    },
    '@keyframes exit': {
      '0%': {
        opacity: 1
      },
      '100%': {
        opacity: 0
      }
    },
    '@keyframes pulsate': {
      '0%': {
        transform: 'scale(1)'
      },
      '50%': {
        transform: 'scale(0.92)'
      },
      '100%': {
        transform: 'scale(1)'
      }
    }
  };
};
/**
 * @ignore - internal component.
 *
 * TODO v5: Make private
 */

var TouchRipple = /*#__PURE__*/React.forwardRef(function TouchRipple(props, ref) {
  var _props$center = props.center,
      centerProp = _props$center === void 0 ? false : _props$center,
      classes = props.classes,
      className = props.className,
      other = _objectWithoutProperties(props, ["center", "classes", "className"]);

  var _React$useState = React.useState([]),
      ripples = _React$useState[0],
      setRipples = _React$useState[1];

  var nextKey = React.useRef(0);
  var rippleCallback = React.useRef(null);
  React.useEffect(function () {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]); // Used to filter out mouse emulated events on mobile.

  var ignoringMouseDown = React.useRef(false); // We use a timer in order to only show the ripples for touch "click" like events.
  // We don't want to display the ripple for touch scroll events.

  var startTimer = React.useRef(null); // This is the hook called once the previous timeout is ready.

  var startTimerCommit = React.useRef(null);
  var container = React.useRef(null);
  React.useEffect(function () {
    return function () {
      clearTimeout(startTimer.current);
    };
  }, []);
  var startCommit = React.useCallback(function (params) {
    var pulsate = params.pulsate,
        rippleX = params.rippleX,
        rippleY = params.rippleY,
        rippleSize = params.rippleSize,
        cb = params.cb;
    setRipples(function (oldRipples) {
      return [].concat(_toConsumableArray(oldRipples), [/*#__PURE__*/React.createElement(Ripple, {
        key: nextKey.current,
        classes: classes,
        timeout: DURATION,
        pulsate: pulsate,
        rippleX: rippleX,
        rippleY: rippleY,
        rippleSize: rippleSize
      })]);
    });
    nextKey.current += 1;
    rippleCallback.current = cb;
  }, [classes]);
  var start = React.useCallback(function () {
    var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var cb = arguments.length > 2 ? arguments[2] : undefined;
    var _options$pulsate = options.pulsate,
        pulsate = _options$pulsate === void 0 ? false : _options$pulsate,
        _options$center = options.center,
        center = _options$center === void 0 ? centerProp || options.pulsate : _options$center,
        _options$fakeElement = options.fakeElement,
        fakeElement = _options$fakeElement === void 0 ? false : _options$fakeElement;

    if (event.type === 'mousedown' && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }

    if (event.type === 'touchstart') {
      ignoringMouseDown.current = true;
    }

    var element = fakeElement ? null : container.current;
    var rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    }; // Get the size of the ripple

    var rippleX;
    var rippleY;
    var rippleSize;

    if (center || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      var _ref = event.touches ? event.touches[0] : event,
          clientX = _ref.clientX,
          clientY = _ref.clientY;

      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }

    if (center) {
      rippleSize = Math.sqrt((2 * Math.pow(rect.width, 2) + Math.pow(rect.height, 2)) / 3); // For some reason the animation is broken on Mobile Chrome if the size if even.

      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      var sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      var sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(Math.pow(sizeX, 2) + Math.pow(sizeY, 2));
    } // Touche devices


    if (event.touches) {
      // check that this isn't another touchstart due to multitouch
      // otherwise we will only clear a single timer when unmounting while two
      // are running
      if (startTimerCommit.current === null) {
        // Prepare the ripple effect.
        startTimerCommit.current = function () {
          startCommit({
            pulsate: pulsate,
            rippleX: rippleX,
            rippleY: rippleY,
            rippleSize: rippleSize,
            cb: cb
          });
        }; // Delay the execution of the ripple effect.


        startTimer.current = setTimeout(function () {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        }, DELAY_RIPPLE); // We have to make a tradeoff with this value.
      }
    } else {
      startCommit({
        pulsate: pulsate,
        rippleX: rippleX,
        rippleY: rippleY,
        rippleSize: rippleSize,
        cb: cb
      });
    }
  }, [centerProp, startCommit]);
  var pulsate = React.useCallback(function () {
    start({}, {
      pulsate: true
    });
  }, [start]);
  var stop = React.useCallback(function (event, cb) {
    clearTimeout(startTimer.current); // The touch interaction occurs too quickly.
    // We still want to show ripple effect.

    if (event.type === 'touchend' && startTimerCommit.current) {
      event.persist();
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.current = setTimeout(function () {
        stop(event, cb);
      });
      return;
    }

    startTimerCommit.current = null;
    setRipples(function (oldRipples) {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }

      return oldRipples;
    });
    rippleCallback.current = cb;
  }, []);
  React.useImperativeHandle(ref, function () {
    return {
      pulsate: pulsate,
      start: start,
      stop: stop
    };
  }, [pulsate, start, stop]);
  return /*#__PURE__*/React.createElement("span", _extends$1({
    className: clsx(classes.root, className),
    ref: container
  }, other), /*#__PURE__*/React.createElement(TransitionGroup$1, {
    component: null,
    exit: true
  }, ripples));
});
TouchRipple.propTypes = {
  /**
   * If `true`, the ripple starts at the center of the component
   * rather than at the point of interaction.
   */
  center: PropTypes.bool,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object.isRequired,

  /**
   * @ignore
   */
  className: PropTypes.string
} ;
var TouchRipple$1 = withStyles(styles$q, {
  flip: false,
  name: 'MuiTouchRipple'
})( /*#__PURE__*/React.memo(TouchRipple));

var styles$p = {
  /* Styles applied to the root element. */
  root: {
    display: 'inline-flex',
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative',
    WebkitTapHighlightColor: 'transparent',
    backgroundColor: 'transparent',
    // Reset default value
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    border: 0,
    margin: 0,
    // Remove the margin in Safari
    borderRadius: 0,
    padding: 0,
    // Remove the padding in Firefox
    cursor: 'pointer',
    userSelect: 'none',
    verticalAlign: 'middle',
    '-moz-appearance': 'none',
    // Reset
    '-webkit-appearance': 'none',
    // Reset
    textDecoration: 'none',
    // So we take precedent over the style of a native <a /> element.
    color: 'inherit',
    '&::-moz-focus-inner': {
      borderStyle: 'none' // Remove Firefox dotted outline.

    },
    '&$disabled': {
      pointerEvents: 'none',
      // Disable link interactions
      cursor: 'default'
    },
    '@media print': {
      colorAdjust: 'exact'
    }
  },

  /* Pseudo-class applied to the root element if `disabled={true}`. */
  disabled: {},

  /* Pseudo-class applied to the root element if keyboard focused. */
  focusVisible: {}
};
/**
 * `ButtonBase` contains as few styles as possible.
 * It aims to be a simple building block for creating a button.
 * It contains a load of style reset and some focus/ripple logic.
 */

var ButtonBase = /*#__PURE__*/React.forwardRef(function ButtonBase(props, ref) {
  var action = props.action,
      buttonRefProp = props.buttonRef,
      _props$centerRipple = props.centerRipple,
      centerRipple = _props$centerRipple === void 0 ? false : _props$centerRipple,
      children = props.children,
      classes = props.classes,
      className = props.className,
      _props$component = props.component,
      component = _props$component === void 0 ? 'button' : _props$component,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      _props$disableRipple = props.disableRipple,
      disableRipple = _props$disableRipple === void 0 ? false : _props$disableRipple,
      _props$disableTouchRi = props.disableTouchRipple,
      disableTouchRipple = _props$disableTouchRi === void 0 ? false : _props$disableTouchRi,
      _props$focusRipple = props.focusRipple,
      focusRipple = _props$focusRipple === void 0 ? false : _props$focusRipple,
      focusVisibleClassName = props.focusVisibleClassName,
      onBlur = props.onBlur,
      onClick = props.onClick,
      onFocus = props.onFocus,
      onFocusVisible = props.onFocusVisible,
      onKeyDown = props.onKeyDown,
      onKeyUp = props.onKeyUp,
      onMouseDown = props.onMouseDown,
      onMouseLeave = props.onMouseLeave,
      onMouseUp = props.onMouseUp,
      onTouchEnd = props.onTouchEnd,
      onTouchMove = props.onTouchMove,
      onTouchStart = props.onTouchStart,
      onDragLeave = props.onDragLeave,
      _props$tabIndex = props.tabIndex,
      tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex,
      TouchRippleProps = props.TouchRippleProps,
      _props$type = props.type,
      type = _props$type === void 0 ? 'button' : _props$type,
      other = _objectWithoutProperties(props, ["action", "buttonRef", "centerRipple", "children", "classes", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "onBlur", "onClick", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "onDragLeave", "tabIndex", "TouchRippleProps", "type"]);

  var buttonRef = React.useRef(null);

  function getButtonNode() {
    // #StrictMode ready
    return ReactDOM.findDOMNode(buttonRef.current);
  }

  var rippleRef = React.useRef(null);

  var _React$useState = React.useState(false),
      focusVisible = _React$useState[0],
      setFocusVisible = _React$useState[1];

  if (disabled && focusVisible) {
    setFocusVisible(false);
  }

  var _useIsFocusVisible = useIsFocusVisible(),
      isFocusVisible = _useIsFocusVisible.isFocusVisible,
      onBlurVisible = _useIsFocusVisible.onBlurVisible,
      focusVisibleRef = _useIsFocusVisible.ref;

  React.useImperativeHandle(action, function () {
    return {
      focusVisible: function focusVisible() {
        setFocusVisible(true);
        buttonRef.current.focus();
      }
    };
  }, []);
  React.useEffect(function () {
    if (focusVisible && focusRipple && !disableRipple) {
      rippleRef.current.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible]);

  function useRippleHandler(rippleAction, eventCallback) {
    var skipRippleAction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : disableTouchRipple;
    return useEventCallback(function (event) {
      if (eventCallback) {
        eventCallback(event);
      }

      var ignore = skipRippleAction;

      if (!ignore && rippleRef.current) {
        rippleRef.current[rippleAction](event);
      }

      return true;
    });
  }

  var handleMouseDown = useRippleHandler('start', onMouseDown);
  var handleDragLeave = useRippleHandler('stop', onDragLeave);
  var handleMouseUp = useRippleHandler('stop', onMouseUp);
  var handleMouseLeave = useRippleHandler('stop', function (event) {
    if (focusVisible) {
      event.preventDefault();
    }

    if (onMouseLeave) {
      onMouseLeave(event);
    }
  });
  var handleTouchStart = useRippleHandler('start', onTouchStart);
  var handleTouchEnd = useRippleHandler('stop', onTouchEnd);
  var handleTouchMove = useRippleHandler('stop', onTouchMove);
  var handleBlur = useRippleHandler('stop', function (event) {
    if (focusVisible) {
      onBlurVisible(event);
      setFocusVisible(false);
    }

    if (onBlur) {
      onBlur(event);
    }
  }, false);
  var handleFocus = useEventCallback(function (event) {
    // Fix for https://github.com/facebook/react/issues/7769
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }

    if (isFocusVisible(event)) {
      setFocusVisible(true);

      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }

    if (onFocus) {
      onFocus(event);
    }
  });

  var isNonNativeButton = function isNonNativeButton() {
    var button = getButtonNode();
    return component && component !== 'button' && !(button.tagName === 'A' && button.href);
  };
  /**
   * IE 11 shim for https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat
   */


  var keydownRef = React.useRef(false);
  var handleKeyDown = useEventCallback(function (event) {
    // Check if key is already down to avoid repeats being counted as multiple activations
    if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === ' ') {
      keydownRef.current = true;
      event.persist();
      rippleRef.current.stop(event, function () {
        rippleRef.current.start(event);
      });
    }

    if (event.target === event.currentTarget && isNonNativeButton() && event.key === ' ') {
      event.preventDefault();
    }

    if (onKeyDown) {
      onKeyDown(event);
    } // Keyboard accessibility for non interactive elements


    if (event.target === event.currentTarget && isNonNativeButton() && event.key === 'Enter' && !disabled) {
      event.preventDefault();

      if (onClick) {
        onClick(event);
      }
    }
  });
  var handleKeyUp = useEventCallback(function (event) {
    // calling preventDefault in keyUp on a <button> will not dispatch a click event if Space is pressed
    // https://codesandbox.io/s/button-keyup-preventdefault-dn7f0
    if (focusRipple && event.key === ' ' && rippleRef.current && focusVisible && !event.defaultPrevented) {
      keydownRef.current = false;
      event.persist();
      rippleRef.current.stop(event, function () {
        rippleRef.current.pulsate(event);
      });
    }

    if (onKeyUp) {
      onKeyUp(event);
    } // Keyboard accessibility for non interactive elements


    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === ' ' && !event.defaultPrevented) {
      onClick(event);
    }
  });
  var ComponentProp = component;

  if (ComponentProp === 'button' && other.href) {
    ComponentProp = 'a';
  }

  var buttonProps = {};

  if (ComponentProp === 'button') {
    buttonProps.type = type;
    buttonProps.disabled = disabled;
  } else {
    if (ComponentProp !== 'a' || !other.href) {
      buttonProps.role = 'button';
    }

    buttonProps['aria-disabled'] = disabled;
  }

  var handleUserRef = useForkRef(buttonRefProp, ref);
  var handleOwnRef = useForkRef(focusVisibleRef, buttonRef);
  var handleRef = useForkRef(handleUserRef, handleOwnRef);

  var _React$useState2 = React.useState(false),
      mountedState = _React$useState2[0],
      setMountedState = _React$useState2[1];

  React.useEffect(function () {
    setMountedState(true);
  }, []);
  var enableTouchRipple = mountedState && !disableRipple && !disabled;

  {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useEffect(function () {
      if (enableTouchRipple && !rippleRef.current) {
        console.error(['Material-UI: The `component` prop provided to ButtonBase is invalid.', 'Please make sure the children prop is rendered in this custom component.'].join('\n'));
      }
    }, [enableTouchRipple]);
  }

  return /*#__PURE__*/React.createElement(ComponentProp, _extends$1({
    className: clsx(classes.root, className, focusVisible && [classes.focusVisible, focusVisibleClassName], disabled && classes.disabled),
    onBlur: handleBlur,
    onClick: onClick,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex
  }, buttonProps, other), children, enableTouchRipple ?
  /*#__PURE__*/

  /* TouchRipple is only needed client-side, x2 boost on the server. */
  React.createElement(TouchRipple$1, _extends$1({
    ref: rippleRef,
    center: centerRipple
  }, TouchRippleProps)) : null);
});
ButtonBase.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */
  action: refType$1,

  /**
   * @ignore
   *
   * Use that prop to pass a ref to the native button component.
   * @deprecated Use `ref` instead.
   */
  buttonRef: deprecatedPropType(refType$1, 'Use `ref` instead.'),

  /**
   * If `true`, the ripples will be centered.
   * They won't start at the cursor interaction position.
   */
  centerRipple: PropTypes.bool,

  /**
   * The content of the component.
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: elementTypeAcceptingRef$1,

  /**
   * If `true`, the base button will be disabled.
   */
  disabled: PropTypes.bool,

  /**
   * If `true`, the ripple effect will be disabled.
   *
   *  Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `focusVisibleClassName`.
   */
  disableRipple: PropTypes.bool,

  /**
   * If `true`, the touch ripple effect will be disabled.
   */
  disableTouchRipple: PropTypes.bool,

  /**
   * If `true`, the base button will have a keyboard focus ripple.
   */
  focusRipple: PropTypes.bool,

  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/master/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: PropTypes.string,

  /**
   * @ignore
   */
  href: PropTypes.string,

  /**
   * @ignore
   */
  onBlur: PropTypes.func,

  /**
   * @ignore
   */
  onClick: PropTypes.func,

  /**
   * @ignore
   */
  onDragLeave: PropTypes.func,

  /**
   * @ignore
   */
  onFocus: PropTypes.func,

  /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */
  onFocusVisible: PropTypes.func,

  /**
   * @ignore
   */
  onKeyDown: PropTypes.func,

  /**
   * @ignore
   */
  onKeyUp: PropTypes.func,

  /**
   * @ignore
   */
  onMouseDown: PropTypes.func,

  /**
   * @ignore
   */
  onMouseLeave: PropTypes.func,

  /**
   * @ignore
   */
  onMouseUp: PropTypes.func,

  /**
   * @ignore
   */
  onTouchEnd: PropTypes.func,

  /**
   * @ignore
   */
  onTouchMove: PropTypes.func,

  /**
   * @ignore
   */
  onTouchStart: PropTypes.func,

  /**
   * @ignore
   */
  tabIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Props applied to the `TouchRipple` element.
   */
  TouchRippleProps: PropTypes.object,

  /**
   * @ignore
   */
  type: PropTypes.oneOfType([PropTypes.oneOf(['button', 'reset', 'submit']), PropTypes.string])
} ;
var ButtonBase$1 = withStyles(styles$p, {
  name: 'MuiButtonBase'
})(ButtonBase);

var styles$o = function styles(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      textAlign: 'center',
      flex: '0 0 auto',
      fontSize: theme.typography.pxToRem(24),
      padding: 12,
      borderRadius: '50%',
      overflow: 'visible',
      // Explicitly set the default value to solve a bug on IE 11.
      color: theme.palette.action.active,
      transition: theme.transitions.create('background-color', {
        duration: theme.transitions.duration.shortest
      }),
      '&:hover': {
        backgroundColor: alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        '@media (hover: none)': {
          backgroundColor: 'transparent'
        }
      },
      '&$disabled': {
        backgroundColor: 'transparent',
        color: theme.palette.action.disabled
      }
    },

    /* Styles applied to the root element if `edge="start"`. */
    edgeStart: {
      marginLeft: -12,
      '$sizeSmall&': {
        marginLeft: -3
      }
    },

    /* Styles applied to the root element if `edge="end"`. */
    edgeEnd: {
      marginRight: -12,
      '$sizeSmall&': {
        marginRight: -3
      }
    },

    /* Styles applied to the root element if `color="inherit"`. */
    colorInherit: {
      color: 'inherit'
    },

    /* Styles applied to the root element if `color="primary"`. */
    colorPrimary: {
      color: theme.palette.primary.main,
      '&:hover': {
        backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        '@media (hover: none)': {
          backgroundColor: 'transparent'
        }
      }
    },

    /* Styles applied to the root element if `color="secondary"`. */
    colorSecondary: {
      color: theme.palette.secondary.main,
      '&:hover': {
        backgroundColor: alpha(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        '@media (hover: none)': {
          backgroundColor: 'transparent'
        }
      }
    },

    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},

    /* Styles applied to the root element if `size="small"`. */
    sizeSmall: {
      padding: 3,
      fontSize: theme.typography.pxToRem(18)
    },

    /* Styles applied to the children container element. */
    label: {
      width: '100%',
      display: 'flex',
      alignItems: 'inherit',
      justifyContent: 'inherit'
    }
  };
};
/**
 * Refer to the [Icons](/components/icons/) section of the documentation
 * regarding the available icon options.
 */

var IconButton = /*#__PURE__*/React.forwardRef(function IconButton(props, ref) {
  var _props$edge = props.edge,
      edge = _props$edge === void 0 ? false : _props$edge,
      children = props.children,
      classes = props.classes,
      className = props.className,
      _props$color = props.color,
      color = _props$color === void 0 ? 'default' : _props$color,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      _props$disableFocusRi = props.disableFocusRipple,
      disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi,
      _props$size = props.size,
      size = _props$size === void 0 ? 'medium' : _props$size,
      other = _objectWithoutProperties(props, ["edge", "children", "classes", "className", "color", "disabled", "disableFocusRipple", "size"]);

  return /*#__PURE__*/React.createElement(ButtonBase$1, _extends$1({
    className: clsx(classes.root, className, color !== 'default' && classes["color".concat(capitalize(color))], disabled && classes.disabled, size === "small" && classes["size".concat(capitalize(size))], {
      'start': classes.edgeStart,
      'end': classes.edgeEnd
    }[edge]),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled: disabled,
    ref: ref
  }, other), /*#__PURE__*/React.createElement("span", {
    className: classes.label
  }, children));
});
IconButton.propTypes = {
  /**
   * The icon element.
   */
  children: chainPropTypes(PropTypes.node, function (props) {
    var found = React.Children.toArray(props.children).some(function (child) {
      return /*#__PURE__*/React.isValidElement(child) && child.props.onClick;
    });

    if (found) {
      return new Error(['Material-UI: You are providing an onClick event listener ' + 'to a child of a button element.', 'Firefox will never trigger the event.', 'You should move the onClick listener to the parent button element.', 'https://github.com/mui-org/material-ui/issues/13957'].join('\n'));
    }

    return null;
  }),

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object.isRequired,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */
  color: PropTypes.oneOf(['default', 'inherit', 'primary', 'secondary']),

  /**
   * If `true`, the button will be disabled.
   */
  disabled: PropTypes.bool,

  /**
   * If `true`, the  keyboard focus ripple will be disabled.
   */
  disableFocusRipple: PropTypes.bool,

  /**
   * If `true`, the ripple effect will be disabled.
   */
  disableRipple: PropTypes.bool,

  /**
   * If given, uses a negative margin to counteract the padding on one
   * side (this is often helpful for aligning the left or right
   * side of the icon with content above or below, without ruining the border
   * size and shape).
   */
  edge: PropTypes.oneOf(['start', 'end', false]),

  /**
   * The size of the button.
   * `small` is equivalent to the dense button styling.
   */
  size: PropTypes.oneOf(['small', 'medium'])
} ;
var IconButton$1 = withStyles(styles$o, {
  name: 'MuiIconButton'
})(IconButton);

var styles$n = function styles(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      userSelect: 'none',
      width: '1em',
      height: '1em',
      display: 'inline-block',
      fill: 'currentColor',
      flexShrink: 0,
      fontSize: theme.typography.pxToRem(24),
      transition: theme.transitions.create('fill', {
        duration: theme.transitions.duration.shorter
      })
    },

    /* Styles applied to the root element if `color="primary"`. */
    colorPrimary: {
      color: theme.palette.primary.main
    },

    /* Styles applied to the root element if `color="secondary"`. */
    colorSecondary: {
      color: theme.palette.secondary.main
    },

    /* Styles applied to the root element if `color="action"`. */
    colorAction: {
      color: theme.palette.action.active
    },

    /* Styles applied to the root element if `color="error"`. */
    colorError: {
      color: theme.palette.error.main
    },

    /* Styles applied to the root element if `color="disabled"`. */
    colorDisabled: {
      color: theme.palette.action.disabled
    },

    /* Styles applied to the root element if `fontSize="inherit"`. */
    fontSizeInherit: {
      fontSize: 'inherit'
    },

    /* Styles applied to the root element if `fontSize="small"`. */
    fontSizeSmall: {
      fontSize: theme.typography.pxToRem(20)
    },

    /* Styles applied to the root element if `fontSize="large"`. */
    fontSizeLarge: {
      fontSize: theme.typography.pxToRem(35)
    }
  };
};
var SvgIcon = /*#__PURE__*/React.forwardRef(function SvgIcon(props, ref) {
  var children = props.children,
      classes = props.classes,
      className = props.className,
      _props$color = props.color,
      color = _props$color === void 0 ? 'inherit' : _props$color,
      _props$component = props.component,
      Component = _props$component === void 0 ? 'svg' : _props$component,
      _props$fontSize = props.fontSize,
      fontSize = _props$fontSize === void 0 ? 'medium' : _props$fontSize,
      htmlColor = props.htmlColor,
      titleAccess = props.titleAccess,
      _props$viewBox = props.viewBox,
      viewBox = _props$viewBox === void 0 ? '0 0 24 24' : _props$viewBox,
      other = _objectWithoutProperties(props, ["children", "classes", "className", "color", "component", "fontSize", "htmlColor", "titleAccess", "viewBox"]);

  return /*#__PURE__*/React.createElement(Component, _extends$1({
    className: clsx(classes.root, className, color !== 'inherit' && classes["color".concat(capitalize(color))], fontSize !== 'default' && fontSize !== 'medium' && classes["fontSize".concat(capitalize(fontSize))]),
    focusable: "false",
    viewBox: viewBox,
    color: htmlColor,
    "aria-hidden": titleAccess ? undefined : true,
    role: titleAccess ? 'img' : undefined,
    ref: ref
  }, other), children, titleAccess ? /*#__PURE__*/React.createElement("title", null, titleAccess) : null);
});
SvgIcon.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * Node passed into the SVG element.
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * The color of the component. It supports those theme colors that make sense for this component.
   * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
   */
  color: PropTypes.oneOf(['action', 'disabled', 'error', 'inherit', 'primary', 'secondary']),

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes
  /* @typescript-to-proptypes-ignore */
  .elementType,

  /**
   * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
   */
  fontSize: chainPropTypes(PropTypes.oneOf(['default', 'inherit', 'large', 'medium', 'small']), function (props) {
    var fontSize = props.fontSize;

    if (fontSize === 'default') {
      throw new Error('Material-UI: `fontSize="default"` is deprecated. Use `fontSize="medium"` instead.');
    }

    return null;
  }),

  /**
   * Applies a color attribute to the SVG element.
   */
  htmlColor: PropTypes.string,

  /**
   * The shape-rendering attribute. The behavior of the different options is described on the
   * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).
   * If you are having issues with blurry icons you should investigate this property.
   */
  shapeRendering: PropTypes.string,

  /**
   * Provides a human-readable title for the element that contains it.
   * https://www.w3.org/TR/SVG-access/#Equivalent
   */
  titleAccess: PropTypes.string,

  /**
   * Allows you to redefine what the coordinates without units mean inside an SVG element.
   * For example, if the SVG element is 500 (width) by 200 (height),
   * and you pass viewBox="0 0 50 20",
   * this means that the coordinates inside the SVG will go from the top left corner (0,0)
   * to bottom right (50,20) and each unit will be worth 10px.
   */
  viewBox: PropTypes.string
} ;
SvgIcon.muiName = 'SvgIcon';
var SvgIcon$1 = withStyles(styles$n, {
  name: 'MuiSvgIcon'
})(SvgIcon);

/**
 * Private module reserved for @material-ui/x packages.
 */

function createSvgIcon(path, displayName) {
  var Component = function Component(props, ref) {
    return /*#__PURE__*/React__default.createElement(SvgIcon$1, _extends$1({
      ref: ref
    }, props), path);
  };

  {
    // Need to set `displayName` on the inner component for React.memo.
    // React prior to 16.14 ignores `displayName` on the wrapper.
    Component.displayName = "".concat(displayName, "Icon");
  }

  Component.muiName = SvgIcon$1.muiName;
  return /*#__PURE__*/React__default.memo( /*#__PURE__*/React__default.forwardRef(Component));
}

/**
 * @ignore - internal component.
 */

var CancelIcon = createSvgIcon( /*#__PURE__*/React.createElement("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
}), 'Cancel');

function unsupportedProp(props, propName, componentName, location, propFullName) {

  var propFullNameSafe = propFullName || propName;

  if (typeof props[propName] !== 'undefined') {
    return new Error("The prop `".concat(propFullNameSafe, "` is not supported. Please remove it."));
  }

  return null;
}

var styles$m = function styles(theme) {
  var backgroundColor = theme.palette.type === 'light' ? theme.palette.grey[300] : theme.palette.grey[700];
  var deleteIconColor = alpha(theme.palette.text.primary, 0.26);
  return {
    /* Styles applied to the root element. */
    root: {
      fontFamily: theme.typography.fontFamily,
      fontSize: theme.typography.pxToRem(13),
      display: 'inline-flex',
      alignItems: 'center',
      justifyContent: 'center',
      height: 32,
      color: theme.palette.getContrastText(backgroundColor),
      backgroundColor: backgroundColor,
      borderRadius: 32 / 2,
      whiteSpace: 'nowrap',
      transition: theme.transitions.create(['background-color', 'box-shadow']),
      // label will inherit this from root, then `clickable` class overrides this for both
      cursor: 'default',
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0,
      textDecoration: 'none',
      border: 'none',
      // Remove `button` border
      padding: 0,
      // Remove `button` padding
      verticalAlign: 'middle',
      boxSizing: 'border-box',
      '&$disabled': {
        opacity: 0.5,
        pointerEvents: 'none'
      },
      '& $avatar': {
        marginLeft: 5,
        marginRight: -6,
        width: 24,
        height: 24,
        color: theme.palette.type === 'light' ? theme.palette.grey[700] : theme.palette.grey[300],
        fontSize: theme.typography.pxToRem(12)
      },
      '& $avatarColorPrimary': {
        color: theme.palette.primary.contrastText,
        backgroundColor: theme.palette.primary.dark
      },
      '& $avatarColorSecondary': {
        color: theme.palette.secondary.contrastText,
        backgroundColor: theme.palette.secondary.dark
      },
      '& $avatarSmall': {
        marginLeft: 4,
        marginRight: -4,
        width: 18,
        height: 18,
        fontSize: theme.typography.pxToRem(10)
      }
    },

    /* Styles applied to the root element if `size="small"`. */
    sizeSmall: {
      height: 24
    },

    /* Styles applied to the root element if `color="primary"`. */
    colorPrimary: {
      backgroundColor: theme.palette.primary.main,
      color: theme.palette.primary.contrastText
    },

    /* Styles applied to the root element if `color="secondary"`. */
    colorSecondary: {
      backgroundColor: theme.palette.secondary.main,
      color: theme.palette.secondary.contrastText
    },

    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},

    /* Styles applied to the root element if `onClick` is defined or `clickable={true}`. */
    clickable: {
      userSelect: 'none',
      WebkitTapHighlightColor: 'transparent',
      cursor: 'pointer',
      '&:hover, &:focus': {
        backgroundColor: emphasize(backgroundColor, 0.08)
      },
      '&:active': {
        boxShadow: theme.shadows[1]
      }
    },

    /* Styles applied to the root element if `onClick` and `color="primary"` is defined or `clickable={true}`. */
    clickableColorPrimary: {
      '&:hover, &:focus': {
        backgroundColor: emphasize(theme.palette.primary.main, 0.08)
      }
    },

    /* Styles applied to the root element if `onClick` and `color="secondary"` is defined or `clickable={true}`. */
    clickableColorSecondary: {
      '&:hover, &:focus': {
        backgroundColor: emphasize(theme.palette.secondary.main, 0.08)
      }
    },

    /* Styles applied to the root element if `onDelete` is defined. */
    deletable: {
      '&:focus': {
        backgroundColor: emphasize(backgroundColor, 0.08)
      }
    },

    /* Styles applied to the root element if `onDelete` and `color="primary"` is defined. */
    deletableColorPrimary: {
      '&:focus': {
        backgroundColor: emphasize(theme.palette.primary.main, 0.2)
      }
    },

    /* Styles applied to the root element if `onDelete` and `color="secondary"` is defined. */
    deletableColorSecondary: {
      '&:focus': {
        backgroundColor: emphasize(theme.palette.secondary.main, 0.2)
      }
    },

    /* Styles applied to the root element if `variant="outlined"`. */
    outlined: {
      backgroundColor: 'transparent',
      border: "1px solid ".concat(theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)'),
      '$clickable&:hover, $clickable&:focus, $deletable&:focus': {
        backgroundColor: alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity)
      },
      '& $avatar': {
        marginLeft: 4
      },
      '& $avatarSmall': {
        marginLeft: 2
      },
      '& $icon': {
        marginLeft: 4
      },
      '& $iconSmall': {
        marginLeft: 2
      },
      '& $deleteIcon': {
        marginRight: 5
      },
      '& $deleteIconSmall': {
        marginRight: 3
      }
    },

    /* Styles applied to the root element if `variant="outlined"` and `color="primary"`. */
    outlinedPrimary: {
      color: theme.palette.primary.main,
      border: "1px solid ".concat(theme.palette.primary.main),
      '$clickable&:hover, $clickable&:focus, $deletable&:focus': {
        backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity)
      }
    },

    /* Styles applied to the root element if `variant="outlined"` and `color="secondary"`. */
    outlinedSecondary: {
      color: theme.palette.secondary.main,
      border: "1px solid ".concat(theme.palette.secondary.main),
      '$clickable&:hover, $clickable&:focus, $deletable&:focus': {
        backgroundColor: alpha(theme.palette.secondary.main, theme.palette.action.hoverOpacity)
      }
    },
    // TODO v5: remove

    /* Styles applied to the `avatar` element. */
    avatar: {},

    /* Styles applied to the `avatar` element if `size="small"`. */
    avatarSmall: {},

    /* Styles applied to the `avatar` element if `color="primary"`. */
    avatarColorPrimary: {},

    /* Styles applied to the `avatar` element if `color="secondary"`. */
    avatarColorSecondary: {},

    /* Styles applied to the `icon` element. */
    icon: {
      color: theme.palette.type === 'light' ? theme.palette.grey[700] : theme.palette.grey[300],
      marginLeft: 5,
      marginRight: -6
    },

    /* Styles applied to the `icon` element if `size="small"`. */
    iconSmall: {
      width: 18,
      height: 18,
      marginLeft: 4,
      marginRight: -4
    },

    /* Styles applied to the `icon` element if `color="primary"`. */
    iconColorPrimary: {
      color: 'inherit'
    },

    /* Styles applied to the `icon` element if `color="secondary"`. */
    iconColorSecondary: {
      color: 'inherit'
    },

    /* Styles applied to the label `span` element. */
    label: {
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      paddingLeft: 12,
      paddingRight: 12,
      whiteSpace: 'nowrap'
    },

    /* Styles applied to the label `span` element if `size="small"`. */
    labelSmall: {
      paddingLeft: 8,
      paddingRight: 8
    },

    /* Styles applied to the `deleteIcon` element. */
    deleteIcon: {
      WebkitTapHighlightColor: 'transparent',
      color: deleteIconColor,
      height: 22,
      width: 22,
      cursor: 'pointer',
      margin: '0 5px 0 -6px',
      '&:hover': {
        color: alpha(deleteIconColor, 0.4)
      }
    },

    /* Styles applied to the `deleteIcon` element if `size="small"`. */
    deleteIconSmall: {
      height: 16,
      width: 16,
      marginRight: 4,
      marginLeft: -4
    },

    /* Styles applied to the deleteIcon element if `color="primary"` and `variant="default"`. */
    deleteIconColorPrimary: {
      color: alpha(theme.palette.primary.contrastText, 0.7),
      '&:hover, &:active': {
        color: theme.palette.primary.contrastText
      }
    },

    /* Styles applied to the deleteIcon element if `color="secondary"` and `variant="default"`. */
    deleteIconColorSecondary: {
      color: alpha(theme.palette.secondary.contrastText, 0.7),
      '&:hover, &:active': {
        color: theme.palette.secondary.contrastText
      }
    },

    /* Styles applied to the deleteIcon element if `color="primary"` and `variant="outlined"`. */
    deleteIconOutlinedColorPrimary: {
      color: alpha(theme.palette.primary.main, 0.7),
      '&:hover, &:active': {
        color: theme.palette.primary.main
      }
    },

    /* Styles applied to the deleteIcon element if `color="secondary"` and `variant="outlined"`. */
    deleteIconOutlinedColorSecondary: {
      color: alpha(theme.palette.secondary.main, 0.7),
      '&:hover, &:active': {
        color: theme.palette.secondary.main
      }
    }
  };
};

function isDeleteKeyboardEvent(keyboardEvent) {
  return keyboardEvent.key === 'Backspace' || keyboardEvent.key === 'Delete';
}
/**
 * Chips represent complex entities in small blocks, such as a contact.
 */


var Chip = /*#__PURE__*/React.forwardRef(function Chip(props, ref) {
  var avatarProp = props.avatar,
      classes = props.classes,
      className = props.className,
      clickableProp = props.clickable,
      _props$color = props.color,
      color = _props$color === void 0 ? 'default' : _props$color,
      ComponentProp = props.component,
      deleteIconProp = props.deleteIcon,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      iconProp = props.icon,
      label = props.label,
      onClick = props.onClick,
      onDelete = props.onDelete,
      onKeyDown = props.onKeyDown,
      onKeyUp = props.onKeyUp,
      _props$size = props.size,
      size = _props$size === void 0 ? 'medium' : _props$size,
      _props$variant = props.variant,
      variant = _props$variant === void 0 ? 'default' : _props$variant,
      other = _objectWithoutProperties(props, ["avatar", "classes", "className", "clickable", "color", "component", "deleteIcon", "disabled", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "size", "variant"]);

  var chipRef = React.useRef(null);
  var handleRef = useForkRef(chipRef, ref);

  var handleDeleteIconClick = function handleDeleteIconClick(event) {
    // Stop the event from bubbling up to the `Chip`
    event.stopPropagation();

    if (onDelete) {
      onDelete(event);
    }
  };

  var handleKeyDown = function handleKeyDown(event) {
    // Ignore events from children of `Chip`.
    if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
      // will be handled in keyUp, otherwise some browsers
      // might init navigation
      event.preventDefault();
    }

    if (onKeyDown) {
      onKeyDown(event);
    }
  };

  var handleKeyUp = function handleKeyUp(event) {
    // Ignore events from children of `Chip`.
    if (event.currentTarget === event.target) {
      if (onDelete && isDeleteKeyboardEvent(event)) {
        onDelete(event);
      } else if (event.key === 'Escape' && chipRef.current) {
        chipRef.current.blur();
      }
    }

    if (onKeyUp) {
      onKeyUp(event);
    }
  };

  var clickable = clickableProp !== false && onClick ? true : clickableProp;
  var small = size === 'small';
  var Component = ComponentProp || (clickable ? ButtonBase$1 : 'div');
  var moreProps = Component === ButtonBase$1 ? {
    component: 'div'
  } : {};
  var deleteIcon = null;

  if (onDelete) {
    var customClasses = clsx(color !== 'default' && (variant === "default" ? classes["deleteIconColor".concat(capitalize(color))] : classes["deleteIconOutlinedColor".concat(capitalize(color))]), small && classes.deleteIconSmall);
    deleteIcon = deleteIconProp && /*#__PURE__*/React.isValidElement(deleteIconProp) ? /*#__PURE__*/React.cloneElement(deleteIconProp, {
      className: clsx(deleteIconProp.props.className, classes.deleteIcon, customClasses),
      onClick: handleDeleteIconClick
    }) : /*#__PURE__*/React.createElement(CancelIcon, {
      className: clsx(classes.deleteIcon, customClasses),
      onClick: handleDeleteIconClick
    });
  }

  var avatar = null;

  if (avatarProp && /*#__PURE__*/React.isValidElement(avatarProp)) {
    avatar = /*#__PURE__*/React.cloneElement(avatarProp, {
      className: clsx(classes.avatar, avatarProp.props.className, small && classes.avatarSmall, color !== 'default' && classes["avatarColor".concat(capitalize(color))])
    });
  }

  var icon = null;

  if (iconProp && /*#__PURE__*/React.isValidElement(iconProp)) {
    icon = /*#__PURE__*/React.cloneElement(iconProp, {
      className: clsx(classes.icon, iconProp.props.className, small && classes.iconSmall, color !== 'default' && classes["iconColor".concat(capitalize(color))])
    });
  }

  {
    if (avatar && icon) {
      console.error('Material-UI: The Chip component can not handle the avatar ' + 'and the icon prop at the same time. Pick one.');
    }
  }

  return /*#__PURE__*/React.createElement(Component, _extends$1({
    role: clickable || onDelete ? 'button' : undefined,
    className: clsx(classes.root, className, color !== 'default' && [classes["color".concat(capitalize(color))], clickable && classes["clickableColor".concat(capitalize(color))], onDelete && classes["deletableColor".concat(capitalize(color))]], variant !== "default" && [classes.outlined, {
      'primary': classes.outlinedPrimary,
      'secondary': classes.outlinedSecondary
    }[color]], disabled && classes.disabled, small && classes.sizeSmall, clickable && classes.clickable, onDelete && classes.deletable),
    "aria-disabled": disabled ? true : undefined,
    tabIndex: clickable || onDelete ? 0 : undefined,
    onClick: onClick,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    ref: handleRef
  }, moreProps, other), avatar || icon, /*#__PURE__*/React.createElement("span", {
    className: clsx(classes.label, small && classes.labelSmall)
  }, label), deleteIcon);
});
Chip.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * Avatar element.
   */
  avatar: PropTypes.element,

  /**
   * This prop isn't supported.
   * Use the `component` prop if you need to change the children structure.
   */
  children: unsupportedProp,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * If `true`, the chip will appear clickable, and will raise when pressed,
   * even if the onClick prop is not defined.
   * If false, the chip will not be clickable, even if onClick prop is defined.
   * This can be used, for example,
   * along with the component prop to indicate an anchor Chip is clickable.
   */
  clickable: PropTypes.bool,

  /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */
  color: PropTypes.oneOf(['default', 'primary', 'secondary']),

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes
  /* @typescript-to-proptypes-ignore */
  .elementType,

  /**
   * Override the default delete icon element. Shown only if `onDelete` is set.
   */
  deleteIcon: PropTypes.element,

  /**
   * If `true`, the chip should be displayed in a disabled state.
   */
  disabled: PropTypes.bool,

  /**
   * Icon element.
   */
  icon: PropTypes.element,

  /**
   * The content of the label.
   */
  label: PropTypes.node,

  /**
   * @ignore
   */
  onClick: PropTypes.func,

  /**
   * Callback function fired when the delete icon is clicked.
   * If set, the delete icon will be shown.
   */
  onDelete: PropTypes.func,

  /**
   * @ignore
   */
  onKeyDown: PropTypes.func,

  /**
   * @ignore
   */
  onKeyUp: PropTypes.func,

  /**
   * The size of the chip.
   */
  size: PropTypes.oneOf(['medium', 'small']),

  /**
   * The variant to use.
   */
  variant: PropTypes.oneOf(['default', 'outlined'])
} ;
var Chip$1 = withStyles(styles$m, {
  name: 'MuiChip'
})(Chip);

// Corresponds to 10 frames at 60 Hz.
// A few bytes payload overhead when lodash/debounce is ~3 kB and debounce ~300 B.
function debounce(func) {
  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 166;
  var timeout;

  function debounced() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    } // eslint-disable-next-line consistent-this


    var that = this;

    var later = function later() {
      func.apply(that, args);
    };

    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  }

  debounced.clear = function () {
    clearTimeout(timeout);
  };

  return debounced;
}

function isMuiElement(element, muiNames) {
  return /*#__PURE__*/React.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;
}

function ownerDocument(node) {
  return node && node.ownerDocument || document;
}

function ownerWindow(node) {
  var doc = ownerDocument(node);
  return doc.defaultView || window;
}

/* eslint-disable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */
function useControlled(_ref) {
  var controlled = _ref.controlled,
      defaultProp = _ref.default,
      name = _ref.name,
      _ref$state = _ref.state,
      state = _ref$state === void 0 ? 'value' : _ref$state;

  var _React$useRef = React.useRef(controlled !== undefined),
      isControlled = _React$useRef.current;

  var _React$useState = React.useState(defaultProp),
      valueState = _React$useState[0],
      setValue = _React$useState[1];

  var value = isControlled ? controlled : valueState;

  {
    React.useEffect(function () {
      if (isControlled !== (controlled !== undefined)) {
        console.error(["Material-UI: A component is changing the ".concat(isControlled ? '' : 'un', "controlled ").concat(state, " state of ").concat(name, " to be ").concat(isControlled ? 'un' : '', "controlled."), 'Elements should not switch from uncontrolled to controlled (or vice versa).', "Decide between using a controlled or uncontrolled ".concat(name, " ") + 'element for the lifetime of the component.', "The nature of the state is determined during the first render, it's considered controlled if the value is not `undefined`.", 'More info: https://fb.me/react-controlled-components'].join('\n'));
      }
    }, [controlled]);

    var _React$useRef2 = React.useRef(defaultProp),
        defaultValue = _React$useRef2.current;

    React.useEffect(function () {
      if (!isControlled && defaultValue !== defaultProp) {
        console.error(["Material-UI: A component is changing the default ".concat(state, " state of an uncontrolled ").concat(name, " after being initialized. ") + "To suppress this warning opt to use a controlled ".concat(name, ".")].join('\n'));
      }
    }, [JSON.stringify(defaultProp)]);
  }

  var setValueIfUncontrolled = React.useCallback(function (newValue) {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}

/**
 * Private module reserved for @material-ui/x packages.
 */

function useId(idOverride) {
  var _React$useState = React.useState(idOverride),
      defaultId = _React$useState[0],
      setDefaultId = _React$useState[1];

  var id = idOverride || defaultId;
  React.useEffect(function () {
    if (defaultId == null) {
      // Fallback to this default id when possible.
      // Use the random value for client-side rendering only.
      // We can't use it server-side.
      setDefaultId("mui-".concat(Math.round(Math.random() * 1e5)));
    }
  }, [defaultId]);
  return id;
}

/**
 * @ignore - internal component.
 */

var CloseIcon = createSvgIcon( /*#__PURE__*/React.createElement("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), 'Close');

/**
 * @ignore - internal component.
 */

var ArrowDropDownIcon$1 = createSvgIcon( /*#__PURE__*/React.createElement("path", {
  d: "M7 10l5 5 5-5z"
}), 'ArrowDropDown');

// Give up on IE 11 support for this feature

function stripDiacritics(string) {
  return typeof string.normalize !== 'undefined' ? string.normalize('NFD').replace(/[\u0300-\u036f]/g, '') : string;
}

function createFilterOptions() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _config$ignoreAccents = config.ignoreAccents,
      ignoreAccents = _config$ignoreAccents === void 0 ? true : _config$ignoreAccents,
      _config$ignoreCase = config.ignoreCase,
      ignoreCase = _config$ignoreCase === void 0 ? true : _config$ignoreCase,
      limit = config.limit,
      _config$matchFrom = config.matchFrom,
      matchFrom = _config$matchFrom === void 0 ? 'any' : _config$matchFrom,
      stringify = config.stringify,
      _config$trim = config.trim,
      trim = _config$trim === void 0 ? false : _config$trim;
  return function (options, _ref) {
    var inputValue = _ref.inputValue,
        getOptionLabel = _ref.getOptionLabel;
    var input = trim ? inputValue.trim() : inputValue;

    if (ignoreCase) {
      input = input.toLowerCase();
    }

    if (ignoreAccents) {
      input = stripDiacritics(input);
    }

    var filteredOptions = options.filter(function (option) {
      var candidate = (stringify || getOptionLabel)(option);

      if (ignoreCase) {
        candidate = candidate.toLowerCase();
      }

      if (ignoreAccents) {
        candidate = stripDiacritics(candidate);
      }

      return matchFrom === 'start' ? candidate.indexOf(input) === 0 : candidate.indexOf(input) > -1;
    });
    return typeof limit === 'number' ? filteredOptions.slice(0, limit) : filteredOptions;
  };
} // To replace with .findIndex() once we stop IE 11 support.

function findIndex(array, comp) {
  for (var i = 0; i < array.length; i += 1) {
    if (comp(array[i])) {
      return i;
    }
  }

  return -1;
}

var defaultFilterOptions = createFilterOptions(); // Number of options to jump in list box when pageup and pagedown keys are used.

var pageSize = 5;
function useAutocomplete(props) {
  var _props$autoComplete = props.autoComplete,
      autoComplete = _props$autoComplete === void 0 ? false : _props$autoComplete,
      _props$autoHighlight = props.autoHighlight,
      autoHighlight = _props$autoHighlight === void 0 ? false : _props$autoHighlight,
      _props$autoSelect = props.autoSelect,
      autoSelect = _props$autoSelect === void 0 ? false : _props$autoSelect,
      _props$blurOnSelect = props.blurOnSelect,
      blurOnSelect = _props$blurOnSelect === void 0 ? false : _props$blurOnSelect,
      _props$clearOnBlur = props.clearOnBlur,
      clearOnBlur = _props$clearOnBlur === void 0 ? !props.freeSolo : _props$clearOnBlur,
      _props$clearOnEscape = props.clearOnEscape,
      clearOnEscape = _props$clearOnEscape === void 0 ? false : _props$clearOnEscape,
      _props$componentName = props.componentName,
      componentName = _props$componentName === void 0 ? 'useAutocomplete' : _props$componentName,
      _props$debug = props.debug,
      debug = _props$debug === void 0 ? false : _props$debug,
      _props$defaultValue = props.defaultValue,
      defaultValue = _props$defaultValue === void 0 ? props.multiple ? [] : null : _props$defaultValue,
      _props$disableClearab = props.disableClearable,
      disableClearable = _props$disableClearab === void 0 ? false : _props$disableClearab,
      _props$disableCloseOn = props.disableCloseOnSelect,
      disableCloseOnSelect = _props$disableCloseOn === void 0 ? false : _props$disableCloseOn,
      _props$disabledItemsF = props.disabledItemsFocusable,
      disabledItemsFocusable = _props$disabledItemsF === void 0 ? false : _props$disabledItemsF,
      _props$disableListWra = props.disableListWrap,
      disableListWrap = _props$disableListWra === void 0 ? false : _props$disableListWra,
      _props$filterOptions = props.filterOptions,
      filterOptions = _props$filterOptions === void 0 ? defaultFilterOptions : _props$filterOptions,
      _props$filterSelected = props.filterSelectedOptions,
      filterSelectedOptions = _props$filterSelected === void 0 ? false : _props$filterSelected,
      _props$freeSolo = props.freeSolo,
      freeSolo = _props$freeSolo === void 0 ? false : _props$freeSolo,
      getOptionDisabled = props.getOptionDisabled,
      _props$getOptionLabel = props.getOptionLabel,
      getOptionLabelProp = _props$getOptionLabel === void 0 ? function (option) {
    return option;
  } : _props$getOptionLabel,
      _props$getOptionSelec = props.getOptionSelected,
      getOptionSelected = _props$getOptionSelec === void 0 ? function (option, value) {
    return option === value;
  } : _props$getOptionSelec,
      groupBy = props.groupBy,
      _props$handleHomeEndK = props.handleHomeEndKeys,
      handleHomeEndKeys = _props$handleHomeEndK === void 0 ? !props.freeSolo : _props$handleHomeEndK,
      idProp = props.id,
      _props$includeInputIn = props.includeInputInList,
      includeInputInList = _props$includeInputIn === void 0 ? false : _props$includeInputIn,
      inputValueProp = props.inputValue,
      _props$multiple = props.multiple,
      multiple = _props$multiple === void 0 ? false : _props$multiple,
      onChange = props.onChange,
      onClose = props.onClose,
      onHighlightChange = props.onHighlightChange,
      onInputChange = props.onInputChange,
      onOpen = props.onOpen,
      openProp = props.open,
      _props$openOnFocus = props.openOnFocus,
      openOnFocus = _props$openOnFocus === void 0 ? false : _props$openOnFocus,
      options = props.options,
      _props$selectOnFocus = props.selectOnFocus,
      selectOnFocus = _props$selectOnFocus === void 0 ? !props.freeSolo : _props$selectOnFocus,
      valueProp = props.value;
  var id = useId(idProp);
  var getOptionLabel = getOptionLabelProp;

  {
    getOptionLabel = function getOptionLabel(option) {
      var optionLabel = getOptionLabelProp(option);

      if (typeof optionLabel !== 'string') {
        var erroneousReturn = optionLabel === undefined ? 'undefined' : "".concat(_typeof$1(optionLabel), " (").concat(optionLabel, ")");
        console.error("Material-UI: The `getOptionLabel` method of ".concat(componentName, " returned ").concat(erroneousReturn, " instead of a string for ").concat(JSON.stringify(option), "."));
      }

      return optionLabel;
    };
  }

  var ignoreFocus = React.useRef(false);
  var firstFocus = React.useRef(true);
  var inputRef = React.useRef(null);
  var listboxRef = React.useRef(null);

  var _React$useState = React.useState(null),
      anchorEl = _React$useState[0],
      setAnchorEl = _React$useState[1];

  var _React$useState2 = React.useState(-1),
      focusedTag = _React$useState2[0],
      setFocusedTag = _React$useState2[1];

  var defaultHighlighted = autoHighlight ? 0 : -1;
  var highlightedIndexRef = React.useRef(defaultHighlighted);

  var _useControlled = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: componentName
  }),
      _useControlled2 = _slicedToArray(_useControlled, 2),
      value = _useControlled2[0],
      setValue = _useControlled2[1];

  var _useControlled3 = useControlled({
    controlled: inputValueProp,
    default: '',
    name: componentName,
    state: 'inputValue'
  }),
      _useControlled4 = _slicedToArray(_useControlled3, 2),
      inputValue = _useControlled4[0],
      setInputValue = _useControlled4[1];

  var _React$useState3 = React.useState(false),
      focused = _React$useState3[0],
      setFocused = _React$useState3[1];

  var resetInputValue = useEventCallback(function (event, newValue) {
    var newInputValue;

    if (multiple) {
      newInputValue = '';
    } else if (newValue == null) {
      newInputValue = '';
    } else {
      var optionLabel = getOptionLabel(newValue);
      newInputValue = typeof optionLabel === 'string' ? optionLabel : '';
    }

    if (inputValue === newInputValue) {
      return;
    }

    setInputValue(newInputValue);

    if (onInputChange) {
      onInputChange(event, newInputValue, 'reset');
    }
  });
  React.useEffect(function () {
    resetInputValue(null, value);
  }, [value, resetInputValue]);

  var _useControlled5 = useControlled({
    controlled: openProp,
    default: false,
    name: componentName,
    state: 'open'
  }),
      _useControlled6 = _slicedToArray(_useControlled5, 2),
      open = _useControlled6[0],
      setOpenState = _useControlled6[1];

  var inputValueIsSelectedValue = !multiple && value != null && inputValue === getOptionLabel(value);
  var popupOpen = open;
  var filteredOptions = popupOpen ? filterOptions(options.filter(function (option) {
    if (filterSelectedOptions && (multiple ? value : [value]).some(function (value2) {
      return value2 !== null && getOptionSelected(option, value2);
    })) {
      return false;
    }

    return true;
  }), // we use the empty string to manipulate `filterOptions` to not filter any options
  // i.e. the filter predicate always returns true
  {
    inputValue: inputValueIsSelectedValue ? '' : inputValue,
    getOptionLabel: getOptionLabel
  }) : [];

  {
    if (value !== null && !freeSolo && options.length > 0) {
      var missingValue = (multiple ? value : [value]).filter(function (value2) {
        return !options.some(function (option) {
          return getOptionSelected(option, value2);
        });
      });

      if (missingValue.length > 0) {
        console.warn(["Material-UI: The value provided to ".concat(componentName, " is invalid."), "None of the options match with `".concat(missingValue.length > 1 ? JSON.stringify(missingValue) : JSON.stringify(missingValue[0]), "`."), 'You can use the `getOptionSelected` prop to customize the equality test.'].join('\n'));
      }
    }
  }

  var focusTag = useEventCallback(function (tagToFocus) {
    if (tagToFocus === -1) {
      inputRef.current.focus();
    } else {
      anchorEl.querySelector("[data-tag-index=\"".concat(tagToFocus, "\"]")).focus();
    }
  }); // Ensure the focusedTag is never inconsistent

  React.useEffect(function () {
    if (multiple && focusedTag > value.length - 1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
  }, [value, multiple, focusedTag, focusTag]);

  function validOptionIndex(index, direction) {
    if (!listboxRef.current || index === -1) {
      return -1;
    }

    var nextFocus = index;

    while (true) {
      // Out of range
      if (direction === 'next' && nextFocus === filteredOptions.length || direction === 'previous' && nextFocus === -1) {
        return -1;
      }

      var option = listboxRef.current.querySelector("[data-option-index=\"".concat(nextFocus, "\"]")); // Same logic as MenuList.js

      var nextFocusDisabled = disabledItemsFocusable ? false : option && (option.disabled || option.getAttribute('aria-disabled') === 'true');

      if (option && !option.hasAttribute('tabindex') || nextFocusDisabled) {
        // Move to the next element.
        nextFocus += direction === 'next' ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }

  var setHighlightedIndex = useEventCallback(function (_ref2) {
    var event = _ref2.event,
        index = _ref2.index,
        _ref2$reason = _ref2.reason,
        reason = _ref2$reason === void 0 ? 'auto' : _ref2$reason;
    highlightedIndexRef.current = index; // does the index exist?

    if (index === -1) {
      inputRef.current.removeAttribute('aria-activedescendant');
    } else {
      inputRef.current.setAttribute('aria-activedescendant', "".concat(id, "-option-").concat(index));
    }

    if (onHighlightChange) {
      onHighlightChange(event, index === -1 ? null : filteredOptions[index], reason);
    }

    if (!listboxRef.current) {
      return;
    }

    var prev = listboxRef.current.querySelector('[data-focus]');

    if (prev) {
      prev.removeAttribute('data-focus');
    }

    var listboxNode = listboxRef.current.parentElement.querySelector('[role="listbox"]'); // "No results"

    if (!listboxNode) {
      return;
    }

    if (index === -1) {
      listboxNode.scrollTop = 0;
      return;
    }

    var option = listboxRef.current.querySelector("[data-option-index=\"".concat(index, "\"]"));

    if (!option) {
      return;
    }

    option.setAttribute('data-focus', 'true'); // Scroll active descendant into view.
    // Logic copied from https://www.w3.org/TR/wai-aria-practices/examples/listbox/js/listbox.js
    //
    // Consider this API instead once it has a better browser support:
    // .scrollIntoView({ scrollMode: 'if-needed', block: 'nearest' });

    if (listboxNode.scrollHeight > listboxNode.clientHeight && reason !== 'mouse') {
      var element = option;
      var scrollBottom = listboxNode.clientHeight + listboxNode.scrollTop;
      var elementBottom = element.offsetTop + element.offsetHeight;

      if (elementBottom > scrollBottom) {
        listboxNode.scrollTop = elementBottom - listboxNode.clientHeight;
      } else if (element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0) < listboxNode.scrollTop) {
        listboxNode.scrollTop = element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0);
      }
    }
  });
  var changeHighlightedIndex = useEventCallback(function (_ref3) {
    var event = _ref3.event,
        diff = _ref3.diff,
        _ref3$direction = _ref3.direction,
        direction = _ref3$direction === void 0 ? 'next' : _ref3$direction,
        _ref3$reason = _ref3.reason,
        reason = _ref3$reason === void 0 ? 'auto' : _ref3$reason;

    if (!popupOpen) {
      return;
    }

    var getNextIndex = function getNextIndex() {
      var maxIndex = filteredOptions.length - 1;

      if (diff === 'reset') {
        return defaultHighlighted;
      }

      if (diff === 'start') {
        return 0;
      }

      if (diff === 'end') {
        return maxIndex;
      }

      var newIndex = highlightedIndexRef.current + diff;

      if (newIndex < 0) {
        if (newIndex === -1 && includeInputInList) {
          return -1;
        }

        if (disableListWrap && highlightedIndexRef.current !== -1 || Math.abs(diff) > 1) {
          return 0;
        }

        return maxIndex;
      }

      if (newIndex > maxIndex) {
        if (newIndex === maxIndex + 1 && includeInputInList) {
          return -1;
        }

        if (disableListWrap || Math.abs(diff) > 1) {
          return maxIndex;
        }

        return 0;
      }

      return newIndex;
    };

    var nextIndex = validOptionIndex(getNextIndex(), direction);
    setHighlightedIndex({
      index: nextIndex,
      reason: reason,
      event: event
    }); // Sync the content of the input with the highlighted option.

    if (autoComplete && diff !== 'reset') {
      if (nextIndex === -1) {
        inputRef.current.value = inputValue;
      } else {
        var option = getOptionLabel(filteredOptions[nextIndex]);
        inputRef.current.value = option; // The portion of the selected suggestion that has not been typed by the user,
        // a completion string, appears inline after the input cursor in the textbox.

        var index = option.toLowerCase().indexOf(inputValue.toLowerCase());

        if (index === 0 && inputValue.length > 0) {
          inputRef.current.setSelectionRange(inputValue.length, option.length);
        }
      }
    }
  });
  var syncHighlightedIndex = React.useCallback(function () {
    if (!popupOpen) {
      return;
    }

    var valueItem = multiple ? value[0] : value; // The popup is empty, reset

    if (filteredOptions.length === 0 || valueItem == null) {
      changeHighlightedIndex({
        diff: 'reset'
      });
      return;
    }

    if (!listboxRef.current) {
      return;
    } // Synchronize the value with the highlighted index


    if (!filterSelectedOptions && valueItem != null) {
      var currentOption = filteredOptions[highlightedIndexRef.current]; // Keep the current highlighted index if possible

      if (multiple && currentOption && findIndex(value, function (val) {
        return getOptionSelected(currentOption, val);
      }) !== -1) {
        return;
      }

      var itemIndex = findIndex(filteredOptions, function (optionItem) {
        return getOptionSelected(optionItem, valueItem);
      });

      if (itemIndex === -1) {
        changeHighlightedIndex({
          diff: 'reset'
        });
      } else {
        setHighlightedIndex({
          index: itemIndex
        });
      }

      return;
    } // Prevent the highlighted index to leak outside the boundaries.


    if (highlightedIndexRef.current >= filteredOptions.length - 1) {
      setHighlightedIndex({
        index: filteredOptions.length - 1
      });
      return;
    } // Restore the focus to the previous index.


    setHighlightedIndex({
      index: highlightedIndexRef.current
    }); // Ignore filteredOptions (and options, getOptionSelected, getOptionLabel) not to break the scroll position
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [// Only sync the highlighted index when the option switch between empty and not
  // eslint-disable-next-line react-hooks/exhaustive-deps
  filteredOptions.length === 0, // Don't sync the highlighted index with the value when multiple
  // eslint-disable-next-line react-hooks/exhaustive-deps
  multiple ? false : value, filterSelectedOptions, changeHighlightedIndex, setHighlightedIndex, popupOpen, inputValue, multiple]);
  var handleListboxRef = useEventCallback(function (node) {
    setRef(listboxRef, node);

    if (!node) {
      return;
    }

    syncHighlightedIndex();
  });
  React.useEffect(function () {
    syncHighlightedIndex();
  }, [syncHighlightedIndex]);

  var handleOpen = function handleOpen(event) {
    if (open) {
      return;
    }

    setOpenState(true);

    if (onOpen) {
      onOpen(event);
    }
  };

  var handleClose = function handleClose(event, reason) {
    if (!open) {
      return;
    }

    setOpenState(false);

    if (onClose) {
      onClose(event, reason);
    }
  };

  var handleValue = function handleValue(event, newValue, reason, details) {
    if (value === newValue) {
      return;
    }

    if (onChange) {
      onChange(event, newValue, reason, details);
    }

    setValue(newValue);
  };

  var isTouch = React.useRef(false);

  var selectNewValue = function selectNewValue(event, option) {
    var reasonProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'select-option';
    var origin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'options';
    var reason = reasonProp;
    var newValue = option;

    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];

      {
        var matches = newValue.filter(function (val) {
          return getOptionSelected(option, val);
        });

        if (matches.length > 1) {
          console.error(["Material-UI: The `getOptionSelected` method of ".concat(componentName, " do not handle the arguments correctly."), "The component expects a single value to match a given option but found ".concat(matches.length, " matches.")].join('\n'));
        }
      }

      var itemIndex = findIndex(newValue, function (valueItem) {
        return getOptionSelected(option, valueItem);
      });

      if (itemIndex === -1) {
        newValue.push(option);
      } else if (origin !== 'freeSolo') {
        newValue.splice(itemIndex, 1);
        reason = 'remove-option';
      }
    }

    resetInputValue(event, newValue);
    handleValue(event, newValue, reason, {
      option: option
    });

    if (!disableCloseOnSelect) {
      handleClose(event, reason);
    }

    if (blurOnSelect === true || blurOnSelect === 'touch' && isTouch.current || blurOnSelect === 'mouse' && !isTouch.current) {
      inputRef.current.blur();
    }
  };

  function validTagIndex(index, direction) {
    if (index === -1) {
      return -1;
    }

    var nextFocus = index;

    while (true) {
      // Out of range
      if (direction === 'next' && nextFocus === value.length || direction === 'previous' && nextFocus === -1) {
        return -1;
      }

      var option = anchorEl.querySelector("[data-tag-index=\"".concat(nextFocus, "\"]")); // Same logic as MenuList.js

      if (option && (!option.hasAttribute('tabindex') || option.disabled || option.getAttribute('aria-disabled') === 'true')) {
        nextFocus += direction === 'next' ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }

  var handleFocusTag = function handleFocusTag(event, direction) {
    if (!multiple) {
      return;
    }

    handleClose(event, 'toggleInput');
    var nextTag = focusedTag;

    if (focusedTag === -1) {
      if (inputValue === '' && direction === 'previous') {
        nextTag = value.length - 1;
      }
    } else {
      nextTag += direction === 'next' ? 1 : -1;

      if (nextTag < 0) {
        nextTag = 0;
      }

      if (nextTag === value.length) {
        nextTag = -1;
      }
    }

    nextTag = validTagIndex(nextTag, direction);
    setFocusedTag(nextTag);
    focusTag(nextTag);
  };

  var handleClear = function handleClear(event) {
    ignoreFocus.current = true;
    setInputValue('');

    if (onInputChange) {
      onInputChange(event, '', 'clear');
    }

    handleValue(event, multiple ? [] : null, 'clear');
  };

  var handleKeyDown = function handleKeyDown(other) {
    return function (event) {
      if (focusedTag !== -1 && ['ArrowLeft', 'ArrowRight'].indexOf(event.key) === -1) {
        setFocusedTag(-1);
        focusTag(-1);
      }

      switch (event.key) {
        case 'Home':
          if (popupOpen && handleHomeEndKeys) {
            // Prevent scroll of the page
            event.preventDefault();
            changeHighlightedIndex({
              diff: 'start',
              direction: 'next',
              reason: 'keyboard',
              event: event
            });
          }

          break;

        case 'End':
          if (popupOpen && handleHomeEndKeys) {
            // Prevent scroll of the page
            event.preventDefault();
            changeHighlightedIndex({
              diff: 'end',
              direction: 'previous',
              reason: 'keyboard',
              event: event
            });
          }

          break;

        case 'PageUp':
          // Prevent scroll of the page
          event.preventDefault();
          changeHighlightedIndex({
            diff: -pageSize,
            direction: 'previous',
            reason: 'keyboard',
            event: event
          });
          handleOpen(event);
          break;

        case 'PageDown':
          // Prevent scroll of the page
          event.preventDefault();
          changeHighlightedIndex({
            diff: pageSize,
            direction: 'next',
            reason: 'keyboard',
            event: event
          });
          handleOpen(event);
          break;

        case 'ArrowDown':
          // Prevent cursor move
          event.preventDefault();
          changeHighlightedIndex({
            diff: 1,
            direction: 'next',
            reason: 'keyboard',
            event: event
          });
          handleOpen(event);
          break;

        case 'ArrowUp':
          // Prevent cursor move
          event.preventDefault();
          changeHighlightedIndex({
            diff: -1,
            direction: 'previous',
            reason: 'keyboard',
            event: event
          });
          handleOpen(event);
          break;

        case 'ArrowLeft':
          handleFocusTag(event, 'previous');
          break;

        case 'ArrowRight':
          handleFocusTag(event, 'next');
          break;

        case 'Enter':
          // Wait until IME is settled.
          if (event.which === 229) {
            break;
          }

          if (highlightedIndexRef.current !== -1 && popupOpen) {
            var option = filteredOptions[highlightedIndexRef.current];
            var disabled = getOptionDisabled ? getOptionDisabled(option) : false; // We don't want to validate the form.

            event.preventDefault();

            if (disabled) {
              return;
            }

            selectNewValue(event, option, 'select-option'); // Move the selection to the end.

            if (autoComplete) {
              inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
            }
          } else if (freeSolo && inputValue !== '' && inputValueIsSelectedValue === false) {
            if (multiple) {
              // Allow people to add new values before they submit the form.
              event.preventDefault();
            }

            selectNewValue(event, inputValue, 'create-option', 'freeSolo');
          }

          break;

        case 'Escape':
          if (popupOpen) {
            // Avoid Opera to exit fullscreen mode.
            event.preventDefault(); // Avoid the Modal to handle the event.

            event.stopPropagation();
            handleClose(event, 'escape');
          } else if (clearOnEscape && (inputValue !== '' || multiple && value.length > 0)) {
            // Avoid Opera to exit fullscreen mode.
            event.preventDefault(); // Avoid the Modal to handle the event.

            event.stopPropagation();
            handleClear(event);
          }

          break;

        case 'Backspace':
          if (multiple && inputValue === '' && value.length > 0) {
            var index = focusedTag === -1 ? value.length - 1 : focusedTag;
            var newValue = value.slice();
            newValue.splice(index, 1);
            handleValue(event, newValue, 'remove-option', {
              option: value[index]
            });
          }

          break;
      }

      if (other.onKeyDown) {
        other.onKeyDown(event);
      }
    };
  };

  var handleFocus = function handleFocus(event) {
    setFocused(true);

    if (openOnFocus && !ignoreFocus.current) {
      handleOpen(event);
    }
  };

  var handleBlur = function handleBlur(event) {
    // Ignore the event when using the scrollbar with IE 11
    if (listboxRef.current !== null && document.activeElement === listboxRef.current.parentElement) {
      inputRef.current.focus();
      return;
    }

    setFocused(false);
    firstFocus.current = true;
    ignoreFocus.current = false;

    if (debug && inputValue !== '') {
      return;
    }

    if (autoSelect && highlightedIndexRef.current !== -1 && popupOpen) {
      selectNewValue(event, filteredOptions[highlightedIndexRef.current], 'blur');
    } else if (autoSelect && freeSolo && inputValue !== '') {
      selectNewValue(event, inputValue, 'blur', 'freeSolo');
    } else if (clearOnBlur) {
      resetInputValue(event, value);
    }

    handleClose(event, 'blur');
  };

  var handleInputChange = function handleInputChange(event) {
    var newValue = event.target.value;

    if (inputValue !== newValue) {
      setInputValue(newValue);

      if (onInputChange) {
        onInputChange(event, newValue, 'input');
      }
    }

    if (newValue === '') {
      if (!disableClearable && !multiple) {
        handleValue(event, null, 'clear');
      }
    } else {
      handleOpen(event);
    }
  };

  var handleOptionMouseOver = function handleOptionMouseOver(event) {
    setHighlightedIndex({
      event: event,
      index: Number(event.currentTarget.getAttribute('data-option-index')),
      reason: 'mouse'
    });
  };

  var handleOptionTouchStart = function handleOptionTouchStart() {
    isTouch.current = true;
  };

  var handleOptionClick = function handleOptionClick(event) {
    var index = Number(event.currentTarget.getAttribute('data-option-index'));
    selectNewValue(event, filteredOptions[index], 'select-option');
    isTouch.current = false;
  };

  var handleTagDelete = function handleTagDelete(index) {
    return function (event) {
      var newValue = value.slice();
      newValue.splice(index, 1);
      handleValue(event, newValue, 'remove-option', {
        option: value[index]
      });
    };
  };

  var handlePopupIndicator = function handlePopupIndicator(event) {
    if (open) {
      handleClose(event, 'toggleInput');
    } else {
      handleOpen(event);
    }
  }; // Prevent input blur when interacting with the combobox


  var handleMouseDown = function handleMouseDown(event) {
    if (event.target.getAttribute('id') !== id) {
      event.preventDefault();
    }
  }; // Focus the input when interacting with the combobox


  var handleClick = function handleClick() {
    inputRef.current.focus();

    if (selectOnFocus && firstFocus.current && inputRef.current.selectionEnd - inputRef.current.selectionStart === 0) {
      inputRef.current.select();
    }

    firstFocus.current = false;
  };

  var handleInputMouseDown = function handleInputMouseDown(event) {
    if (inputValue === '' || !open) {
      handlePopupIndicator(event);
    }
  };

  var dirty = freeSolo && inputValue.length > 0;
  dirty = dirty || (multiple ? value.length > 0 : value !== null);
  var groupedOptions = filteredOptions;

  if (groupBy) {
    // used to keep track of key and indexes in the result array
    var indexBy = new Map();
    var warn = false;
    groupedOptions = filteredOptions.reduce(function (acc, option, index) {
      var group = groupBy(option);

      if (acc.length > 0 && acc[acc.length - 1].group === group) {
        acc[acc.length - 1].options.push(option);
      } else {
        {
          if (indexBy.get(group) && !warn) {
            console.warn("Material-UI: The options provided combined with the `groupBy` method of ".concat(componentName, " returns duplicated headers."), 'You can solve the issue by sorting the options with the output of `groupBy`.');
            warn = true;
          }

          indexBy.set(group, true);
        }

        acc.push({
          key: index,
          index: index,
          group: group,
          options: [option]
        });
      }

      return acc;
    }, []);
  }

  return {
    getRootProps: function getRootProps() {
      var other = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return _extends$1({
        'aria-owns': popupOpen ? "".concat(id, "-popup") : null,
        role: 'combobox',
        'aria-expanded': popupOpen
      }, other, {
        onKeyDown: handleKeyDown(other),
        onMouseDown: handleMouseDown,
        onClick: handleClick
      });
    },
    getInputLabelProps: function getInputLabelProps() {
      return {
        id: "".concat(id, "-label"),
        htmlFor: id
      };
    },
    getInputProps: function getInputProps() {
      return {
        id: id,
        value: inputValue,
        onBlur: handleBlur,
        onFocus: handleFocus,
        onChange: handleInputChange,
        onMouseDown: handleInputMouseDown,
        // if open then this is handled imperativeley so don't let react override
        // only have an opinion about this when closed
        'aria-activedescendant': popupOpen ? '' : null,
        'aria-autocomplete': autoComplete ? 'both' : 'list',
        'aria-controls': popupOpen ? "".concat(id, "-popup") : null,
        // Disable browser's suggestion that might overlap with the popup.
        // Handle autocomplete but not autofill.
        autoComplete: 'off',
        ref: inputRef,
        autoCapitalize: 'none',
        spellCheck: 'false'
      };
    },
    getClearProps: function getClearProps() {
      return {
        tabIndex: -1,
        onClick: handleClear
      };
    },
    getPopupIndicatorProps: function getPopupIndicatorProps() {
      return {
        tabIndex: -1,
        onClick: handlePopupIndicator
      };
    },
    getTagProps: function getTagProps(_ref4) {
      var index = _ref4.index;
      return {
        key: index,
        'data-tag-index': index,
        tabIndex: -1,
        onDelete: handleTagDelete(index)
      };
    },
    getListboxProps: function getListboxProps() {
      return {
        role: 'listbox',
        id: "".concat(id, "-popup"),
        'aria-labelledby': "".concat(id, "-label"),
        ref: handleListboxRef,
        onMouseDown: function onMouseDown(event) {
          // Prevent blur
          event.preventDefault();
        }
      };
    },
    getOptionProps: function getOptionProps(_ref5) {
      var index = _ref5.index,
          option = _ref5.option;
      var selected = (multiple ? value : [value]).some(function (value2) {
        return value2 != null && getOptionSelected(option, value2);
      });
      var disabled = getOptionDisabled ? getOptionDisabled(option) : false;
      return {
        key: index,
        tabIndex: -1,
        role: 'option',
        id: "".concat(id, "-option-").concat(index),
        onMouseOver: handleOptionMouseOver,
        onClick: handleOptionClick,
        onTouchStart: handleOptionTouchStart,
        'data-option-index': index,
        'aria-disabled': disabled,
        'aria-selected': selected
      };
    },
    id: id,
    inputValue: inputValue,
    value: value,
    dirty: dirty,
    popupOpen: popupOpen,
    focused: focused || focusedTag !== -1,
    anchorEl: anchorEl,
    setAnchorEl: setAnchorEl,
    focusedTag: focusedTag,
    groupedOptions: groupedOptions
  };
}

var styles$l = function styles(theme) {
  var _option;

  return {
    /* Styles applied to the root element. */
    root: {
      '&$focused $clearIndicatorDirty': {
        visibility: 'visible'
      },

      /* Avoid double tap issue on iOS */
      '@media (pointer: fine)': {
        '&:hover $clearIndicatorDirty': {
          visibility: 'visible'
        }
      }
    },

    /* Styles applied to the root element if `fullWidth={true}`. */
    fullWidth: {
      width: '100%'
    },

    /* Pseudo-class applied to the root element if focused. */
    focused: {},

    /* Styles applied to the tag elements, e.g. the chips. */
    tag: {
      margin: 3,
      maxWidth: 'calc(100% - 6px)'
    },

    /* Styles applied to the tag elements, e.g. the chips if `size="small"`. */
    tagSizeSmall: {
      margin: 2,
      maxWidth: 'calc(100% - 4px)'
    },

    /* Styles applied when the popup icon is rendered. */
    hasPopupIcon: {},

    /* Styles applied when the clear icon is rendered. */
    hasClearIcon: {},

    /* Styles applied to the Input element. */
    inputRoot: {
      flexWrap: 'wrap',
      '$hasPopupIcon &, $hasClearIcon &': {
        paddingRight: 26 + 4
      },
      '$hasPopupIcon$hasClearIcon &': {
        paddingRight: 52 + 4
      },
      '& $input': {
        width: 0,
        minWidth: 30
      },
      '&[class*="MuiInput-root"]': {
        paddingBottom: 1,
        '& $input': {
          padding: 4
        },
        '& $input:first-child': {
          padding: '6px 0'
        }
      },
      '&[class*="MuiInput-root"][class*="MuiInput-marginDense"]': {
        '& $input': {
          padding: '4px 4px 5px'
        },
        '& $input:first-child': {
          padding: '3px 0 6px'
        }
      },
      '&[class*="MuiOutlinedInput-root"]': {
        padding: 9,
        '$hasPopupIcon &, $hasClearIcon &': {
          paddingRight: 26 + 4 + 9
        },
        '$hasPopupIcon$hasClearIcon &': {
          paddingRight: 52 + 4 + 9
        },
        '& $input': {
          padding: '9.5px 4px'
        },
        '& $input:first-child': {
          paddingLeft: 6
        },
        '& $endAdornment': {
          right: 9
        }
      },
      '&[class*="MuiOutlinedInput-root"][class*="MuiOutlinedInput-marginDense"]': {
        padding: 6,
        '& $input': {
          padding: '4.5px 4px'
        }
      },
      '&[class*="MuiFilledInput-root"]': {
        paddingTop: 19,
        paddingLeft: 8,
        '$hasPopupIcon &, $hasClearIcon &': {
          paddingRight: 26 + 4 + 9
        },
        '$hasPopupIcon$hasClearIcon &': {
          paddingRight: 52 + 4 + 9
        },
        '& $input': {
          padding: '9px 4px'
        },
        '& $endAdornment': {
          right: 9
        }
      },
      '&[class*="MuiFilledInput-root"][class*="MuiFilledInput-marginDense"]': {
        paddingBottom: 1,
        '& $input': {
          padding: '4.5px 4px'
        }
      }
    },

    /* Styles applied to the input element. */
    input: {
      flexGrow: 1,
      textOverflow: 'ellipsis',
      opacity: 0
    },

    /* Styles applied to the input element if tag focused. */
    inputFocused: {
      opacity: 1
    },

    /* Styles applied to the endAdornment element. */
    endAdornment: {
      // We use a position absolute to support wrapping tags.
      position: 'absolute',
      right: 0,
      top: 'calc(50% - 14px)' // Center vertically

    },

    /* Styles applied to the clear indicator. */
    clearIndicator: {
      marginRight: -2,
      padding: 4,
      visibility: 'hidden'
    },

    /* Styles applied to the clear indicator if the input is dirty. */
    clearIndicatorDirty: {},

    /* Styles applied to the popup indicator. */
    popupIndicator: {
      padding: 2,
      marginRight: -2
    },

    /* Styles applied to the popup indicator if the popup is open. */
    popupIndicatorOpen: {
      transform: 'rotate(180deg)'
    },

    /* Styles applied to the popper element. */
    popper: {
      zIndex: theme.zIndex.modal
    },

    /* Styles applied to the popper element if `disablePortal={true}`. */
    popperDisablePortal: {
      position: 'absolute'
    },

    /* Styles applied to the `Paper` component. */
    paper: _extends$1({}, theme.typography.body1, {
      overflow: 'hidden',
      margin: '4px 0'
    }),

    /* Styles applied to the `listbox` component. */
    listbox: {
      listStyle: 'none',
      margin: 0,
      padding: '8px 0',
      maxHeight: '40vh',
      overflow: 'auto'
    },

    /* Styles applied to the loading wrapper. */
    loading: {
      color: theme.palette.text.secondary,
      padding: '14px 16px'
    },

    /* Styles applied to the no option wrapper. */
    noOptions: {
      color: theme.palette.text.secondary,
      padding: '14px 16px'
    },

    /* Styles applied to the option elements. */
    option: (_option = {
      minHeight: 48,
      display: 'flex',
      justifyContent: 'flex-start',
      alignItems: 'center',
      cursor: 'pointer',
      paddingTop: 6,
      boxSizing: 'border-box',
      outline: '0',
      WebkitTapHighlightColor: 'transparent',
      paddingBottom: 6,
      paddingLeft: 16,
      paddingRight: 16
    }, _defineProperty(_option, theme.breakpoints.up('sm'), {
      minHeight: 'auto'
    }), _defineProperty(_option, '&[aria-selected="true"]', {
      backgroundColor: theme.palette.action.selected
    }), _defineProperty(_option, '&[data-focus="true"]', {
      backgroundColor: theme.palette.action.hover
    }), _defineProperty(_option, '&:active', {
      backgroundColor: theme.palette.action.selected
    }), _defineProperty(_option, '&[aria-disabled="true"]', {
      opacity: theme.palette.action.disabledOpacity,
      pointerEvents: 'none'
    }), _option),

    /* Styles applied to the group's label elements. */
    groupLabel: {
      backgroundColor: theme.palette.background.paper,
      top: -8
    },

    /* Styles applied to the group's ul elements. */
    groupUl: {
      padding: 0,
      '& $option': {
        paddingLeft: 24
      }
    }
  };
};

function DisablePortal(props) {
  // eslint-disable-next-line react/prop-types
  props.anchorEl;
      props.open;
      var other = _objectWithoutProperties(props, ["anchorEl", "open"]);

  return /*#__PURE__*/React.createElement("div", other);
}

var _ref$1 = /*#__PURE__*/React.createElement(CloseIcon, {
  fontSize: "small"
});

var _ref2$1 = /*#__PURE__*/React.createElement(ArrowDropDownIcon$1, null);

var Autocomplete = /*#__PURE__*/React.forwardRef(function Autocomplete(props, ref) {
  /* eslint-disable no-unused-vars */
  props.autoComplete;
      props.autoHighlight;
      props.autoSelect;
      props.blurOnSelect;
      var ChipProps = props.ChipProps,
      classes = props.classes,
      className = props.className,
      _props$clearOnBlur = props.clearOnBlur;
      _props$clearOnBlur === void 0 ? !props.freeSolo : _props$clearOnBlur;
      props.clearOnEscape;
      var _props$clearText = props.clearText,
      clearText = _props$clearText === void 0 ? 'Clear' : _props$clearText,
      _props$closeIcon = props.closeIcon,
      closeIcon = _props$closeIcon === void 0 ? _ref$1 : _props$closeIcon,
      _props$closeText = props.closeText,
      closeText = _props$closeText === void 0 ? 'Close' : _props$closeText;
      props.debug;
      var _props$defaultValue = props.defaultValue;
      _props$defaultValue === void 0 ? props.multiple ? [] : null : _props$defaultValue;
      var _props$disableClearab = props.disableClearable,
      disableClearable = _props$disableClearab === void 0 ? false : _props$disableClearab;
      props.disableCloseOnSelect;
      var _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled;
      props.disabledItemsFocusable;
      props.disableListWrap;
      var _props$disablePortal = props.disablePortal,
      disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal;
      props.filterOptions;
      props.filterSelectedOptions;
      var _props$forcePopupIcon = props.forcePopupIcon,
      forcePopupIcon = _props$forcePopupIcon === void 0 ? 'auto' : _props$forcePopupIcon,
      _props$freeSolo = props.freeSolo,
      freeSolo = _props$freeSolo === void 0 ? false : _props$freeSolo,
      _props$fullWidth = props.fullWidth,
      fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
      _props$getLimitTagsTe = props.getLimitTagsText,
      getLimitTagsText = _props$getLimitTagsTe === void 0 ? function (more) {
    return "+".concat(more);
  } : _props$getLimitTagsTe;
      props.getOptionDisabled;
      var _props$getOptionLabel = props.getOptionLabel,
      getOptionLabel = _props$getOptionLabel === void 0 ? function (x) {
    return x;
  } : _props$getOptionLabel;
      props.getOptionSelected;
      var groupBy = props.groupBy,
      _props$handleHomeEndK = props.handleHomeEndKeys;
      _props$handleHomeEndK === void 0 ? !props.freeSolo : _props$handleHomeEndK;
      props.id;
      props.includeInputInList;
      props.inputValue;
      var _props$limitTags = props.limitTags,
      limitTags = _props$limitTags === void 0 ? -1 : _props$limitTags,
      _props$ListboxCompone = props.ListboxComponent,
      ListboxComponent = _props$ListboxCompone === void 0 ? 'ul' : _props$ListboxCompone,
      ListboxProps = props.ListboxProps,
      _props$loading = props.loading,
      loading = _props$loading === void 0 ? false : _props$loading,
      _props$loadingText = props.loadingText,
      loadingText = _props$loadingText === void 0 ? 'Loading' : _props$loadingText,
      _props$multiple = props.multiple,
      multiple = _props$multiple === void 0 ? false : _props$multiple,
      _props$noOptionsText = props.noOptionsText,
      noOptionsText = _props$noOptionsText === void 0 ? 'No options' : _props$noOptionsText;
      props.onChange;
      props.onClose;
      props.onHighlightChange;
      props.onInputChange;
      props.onOpen;
      props.open;
      props.openOnFocus;
      var _props$openText = props.openText,
      openText = _props$openText === void 0 ? 'Open' : _props$openText;
      props.options;
      var _props$PaperComponent = props.PaperComponent,
      PaperComponent = _props$PaperComponent === void 0 ? Paper$1 : _props$PaperComponent,
      _props$PopperComponen = props.PopperComponent,
      PopperComponentProp = _props$PopperComponen === void 0 ? Popper$1 : _props$PopperComponen,
      _props$popupIcon = props.popupIcon,
      popupIcon = _props$popupIcon === void 0 ? _ref2$1 : _props$popupIcon,
      renderGroupProp = props.renderGroup,
      renderInput = props.renderInput,
      renderOptionProp = props.renderOption,
      renderTags = props.renderTags,
      _props$selectOnFocus = props.selectOnFocus;
      _props$selectOnFocus === void 0 ? !props.freeSolo : _props$selectOnFocus;
      var _props$size = props.size,
      size = _props$size === void 0 ? 'medium' : _props$size;
      props.value;
      var other = _objectWithoutProperties(props, ["autoComplete", "autoHighlight", "autoSelect", "blurOnSelect", "ChipProps", "classes", "className", "clearOnBlur", "clearOnEscape", "clearText", "closeIcon", "closeText", "debug", "defaultValue", "disableClearable", "disableCloseOnSelect", "disabled", "disabledItemsFocusable", "disableListWrap", "disablePortal", "filterOptions", "filterSelectedOptions", "forcePopupIcon", "freeSolo", "fullWidth", "getLimitTagsText", "getOptionDisabled", "getOptionLabel", "getOptionSelected", "groupBy", "handleHomeEndKeys", "id", "includeInputInList", "inputValue", "limitTags", "ListboxComponent", "ListboxProps", "loading", "loadingText", "multiple", "noOptionsText", "onChange", "onClose", "onHighlightChange", "onInputChange", "onOpen", "open", "openOnFocus", "openText", "options", "PaperComponent", "PopperComponent", "popupIcon", "renderGroup", "renderInput", "renderOption", "renderTags", "selectOnFocus", "size", "value"]);
  /* eslint-enable no-unused-vars */


  var PopperComponent = disablePortal ? DisablePortal : PopperComponentProp;

  var _useAutocomplete = useAutocomplete(_extends$1({}, props, {
    componentName: 'Autocomplete'
  })),
      getRootProps = _useAutocomplete.getRootProps,
      getInputProps = _useAutocomplete.getInputProps,
      getInputLabelProps = _useAutocomplete.getInputLabelProps,
      getPopupIndicatorProps = _useAutocomplete.getPopupIndicatorProps,
      getClearProps = _useAutocomplete.getClearProps,
      getTagProps = _useAutocomplete.getTagProps,
      getListboxProps = _useAutocomplete.getListboxProps,
      getOptionProps = _useAutocomplete.getOptionProps,
      value = _useAutocomplete.value,
      dirty = _useAutocomplete.dirty,
      id = _useAutocomplete.id,
      popupOpen = _useAutocomplete.popupOpen,
      focused = _useAutocomplete.focused,
      focusedTag = _useAutocomplete.focusedTag,
      anchorEl = _useAutocomplete.anchorEl,
      setAnchorEl = _useAutocomplete.setAnchorEl,
      inputValue = _useAutocomplete.inputValue,
      groupedOptions = _useAutocomplete.groupedOptions;

  var startAdornment;

  if (multiple && value.length > 0) {
    var getCustomizedTagProps = function getCustomizedTagProps(params) {
      return _extends$1({
        className: clsx(classes.tag, size === 'small' && classes.tagSizeSmall),
        disabled: disabled
      }, getTagProps(params));
    };

    if (renderTags) {
      startAdornment = renderTags(value, getCustomizedTagProps);
    } else {
      startAdornment = value.map(function (option, index) {
        return /*#__PURE__*/React.createElement(Chip$1, _extends$1({
          label: getOptionLabel(option),
          size: size
        }, getCustomizedTagProps({
          index: index
        }), ChipProps));
      });
    }
  }

  if (limitTags > -1 && Array.isArray(startAdornment)) {
    var more = startAdornment.length - limitTags;

    if (!focused && more > 0) {
      startAdornment = startAdornment.splice(0, limitTags);
      startAdornment.push( /*#__PURE__*/React.createElement("span", {
        className: classes.tag,
        key: startAdornment.length
      }, getLimitTagsText(more)));
    }
  }

  var defaultRenderGroup = function defaultRenderGroup(params) {
    return /*#__PURE__*/React.createElement("li", {
      key: params.key
    }, /*#__PURE__*/React.createElement(ListSubheader$1, {
      className: classes.groupLabel,
      component: "div"
    }, params.group), /*#__PURE__*/React.createElement("ul", {
      className: classes.groupUl
    }, params.children));
  };

  var renderGroup = renderGroupProp || defaultRenderGroup;
  var renderOption = renderOptionProp || getOptionLabel;

  var renderListOption = function renderListOption(option, index) {
    var optionProps = getOptionProps({
      option: option,
      index: index
    });
    return /*#__PURE__*/React.createElement("li", _extends$1({}, optionProps, {
      className: classes.option
    }), renderOption(option, {
      selected: optionProps['aria-selected'],
      inputValue: inputValue
    }));
  };

  var hasClearIcon = !disableClearable && !disabled;
  var hasPopupIcon = (!freeSolo || forcePopupIcon === true) && forcePopupIcon !== false;
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", _extends$1({
    ref: ref,
    className: clsx(classes.root, className, focused && classes.focused, fullWidth && classes.fullWidth, hasClearIcon && classes.hasClearIcon, hasPopupIcon && classes.hasPopupIcon)
  }, getRootProps(other)), renderInput({
    id: id,
    disabled: disabled,
    fullWidth: true,
    size: size === 'small' ? 'small' : undefined,
    InputLabelProps: getInputLabelProps(),
    InputProps: {
      ref: setAnchorEl,
      className: classes.inputRoot,
      startAdornment: startAdornment,
      endAdornment: /*#__PURE__*/React.createElement("div", {
        className: classes.endAdornment
      }, hasClearIcon ? /*#__PURE__*/React.createElement(IconButton$1, _extends$1({}, getClearProps(), {
        "aria-label": clearText,
        title: clearText,
        className: clsx(classes.clearIndicator, dirty && classes.clearIndicatorDirty)
      }), closeIcon) : null, hasPopupIcon ? /*#__PURE__*/React.createElement(IconButton$1, _extends$1({}, getPopupIndicatorProps(), {
        disabled: disabled,
        "aria-label": popupOpen ? closeText : openText,
        title: popupOpen ? closeText : openText,
        className: clsx(classes.popupIndicator, popupOpen && classes.popupIndicatorOpen)
      }), popupIcon) : null)
    },
    inputProps: _extends$1({
      className: clsx(classes.input, focusedTag === -1 && classes.inputFocused),
      disabled: disabled
    }, getInputProps())
  })), popupOpen && anchorEl ? /*#__PURE__*/React.createElement(PopperComponent, {
    className: clsx(classes.popper, disablePortal && classes.popperDisablePortal),
    style: {
      width: anchorEl ? anchorEl.clientWidth : null
    },
    role: "presentation",
    anchorEl: anchorEl,
    open: true
  }, /*#__PURE__*/React.createElement(PaperComponent, {
    className: classes.paper
  }, loading && groupedOptions.length === 0 ? /*#__PURE__*/React.createElement("div", {
    className: classes.loading
  }, loadingText) : null, groupedOptions.length === 0 && !freeSolo && !loading ? /*#__PURE__*/React.createElement("div", {
    className: classes.noOptions
  }, noOptionsText) : null, groupedOptions.length > 0 ? /*#__PURE__*/React.createElement(ListboxComponent, _extends$1({
    className: classes.listbox
  }, getListboxProps(), ListboxProps), groupedOptions.map(function (option, index) {
    if (groupBy) {
      return renderGroup({
        key: option.key,
        group: option.group,
        children: option.options.map(function (option2, index2) {
          return renderListOption(option2, option.index + index2);
        })
      });
    }

    return renderListOption(option, index);
  })) : null)) : null);
});
Autocomplete.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * If `true`, the portion of the selected suggestion that has not been typed by the user,
   * known as the completion string, appears inline after the input cursor in the textbox.
   * The inline completion string is visually highlighted and has a selected state.
   */
  autoComplete: PropTypes.bool,

  /**
   * If `true`, the first option is automatically highlighted.
   */
  autoHighlight: PropTypes.bool,

  /**
   * If `true`, the selected option becomes the value of the input
   * when the Autocomplete loses focus unless the user chooses
   * a different option or changes the character string in the input.
   */
  autoSelect: PropTypes.bool,

  /**
   * Control if the input should be blurred when an option is selected:
   *
   * - `false` the input is not blurred.
   * - `true` the input is always blurred.
   * - `touch` the input is blurred after a touch event.
   * - `mouse` the input is blurred after a mouse event.
   */
  blurOnSelect: PropTypes.oneOfType([PropTypes.oneOf(['mouse', 'touch']), PropTypes.bool]),

  /**
   * Props applied to the [`Chip`](/api/chip/) element.
   */
  ChipProps: PropTypes.object,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * If `true`, the input's text will be cleared on blur if no value is selected.
   *
   * Set to `true` if you want to help the user enter a new value.
   * Set to `false` if you want to help the user resume his search.
   */
  clearOnBlur: PropTypes.bool,

  /**
   * If `true`, clear all values when the user presses escape and the popup is closed.
   */
  clearOnEscape: PropTypes.bool,

  /**
   * Override the default text for the *clear* icon button.
   *
   * For localization purposes, you can use the provided [translations](/guides/localization/).
   */
  clearText: PropTypes.string,

  /**
   * The icon to display in place of the default close icon.
   */
  closeIcon: PropTypes.node,

  /**
   * Override the default text for the *close popup* icon button.
   *
   * For localization purposes, you can use the provided [translations](/guides/localization/).
   */
  closeText: PropTypes.string,

  /**
   * If `true`, the popup will ignore the blur event if the input is filled.
   * You can inspect the popup markup with your browser tools.
   * Consider this option when you need to customize the component.
   */
  debug: PropTypes.bool,

  /**
   * The default input value. Use when the component is not controlled.
   */
  defaultValue: PropTypes.any,

  /**
   * If `true`, the input can't be cleared.
   */
  disableClearable: PropTypes
  /* @typescript-to-proptypes-ignore */
  .bool,

  /**
   * If `true`, the popup won't close when a value is selected.
   */
  disableCloseOnSelect: PropTypes.bool,

  /**
   * If `true`, the input will be disabled.
   */
  disabled: PropTypes.bool,

  /**
   * If `true`, will allow focus on disabled items.
   */
  disabledItemsFocusable: PropTypes.bool,

  /**
   * If `true`, the list box in the popup will not wrap focus.
   */
  disableListWrap: PropTypes.bool,

  /**
   * Disable the portal behavior.
   * The children stay within it's parent DOM hierarchy.
   */
  disablePortal: PropTypes.bool,

  /**
   * A filter function that determines the options that are eligible.
   *
   * @param {T[]} options The options to render.
   * @param {object} state The state of the component.
   * @returns {T[]}
   */
  filterOptions: PropTypes.func,

  /**
   * If `true`, hide the selected options from the list box.
   */
  filterSelectedOptions: PropTypes.bool,

  /**
   * Force the visibility display of the popup icon.
   */
  forcePopupIcon: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.bool]),

  /**
   * If `true`, the Autocomplete is free solo, meaning that the user input is not bound to provided options.
   */
  freeSolo: PropTypes
  /* @typescript-to-proptypes-ignore */
  .bool,

  /**
   * If `true`, the input will take up the full width of its container.
   */
  fullWidth: PropTypes.bool,

  /**
   * The label to display when the tags are truncated (`limitTags`).
   *
   * @param {number} more The number of truncated tags.
   * @returns {ReactNode}
   */
  getLimitTagsText: PropTypes.func,

  /**
   * Used to determine the disabled state for a given option.
   *
   * @param {T} option The option to test.
   * @returns {boolean}
   */
  getOptionDisabled: PropTypes.func,

  /**
   * Used to determine the string value for a given option.
   * It's used to fill the input (and the list box options if `renderOption` is not provided).
   *
   * @param {T} option
   * @returns {string}
   */
  getOptionLabel: PropTypes.func,

  /**
   * Used to determine if an option is selected, considering the current value.
   * Uses strict equality by default.
   *
   * @param {T} option The option to test.
   * @param {T} value The value to test against.
   * @returns {boolean}
   */
  getOptionSelected: PropTypes.func,

  /**
   * If provided, the options will be grouped under the returned string.
   * The groupBy value is also used as the text for group headings when `renderGroup` is not provided.
   *
   * @param {T} options The options to group.
   * @returns {string}
   */
  groupBy: PropTypes.func,

  /**
   * If `true`, the component handles the "Home" and "End" keys when the popup is open.
   * It should move focus to the first option and last option, respectively.
   */
  handleHomeEndKeys: PropTypes.bool,

  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: PropTypes.string,

  /**
   * If `true`, the highlight can move to the input.
   */
  includeInputInList: PropTypes.bool,

  /**
   * The input value.
   */
  inputValue: PropTypes.string,

  /**
   * The maximum number of tags that will be visible when not focused.
   * Set `-1` to disable the limit.
   */
  limitTags: PropTypes.number,

  /**
   * The component used to render the listbox.
   */
  ListboxComponent: PropTypes.elementType,

  /**
   * Props applied to the Listbox element.
   */
  ListboxProps: PropTypes.object,

  /**
   * If `true`, the component is in a loading state.
   */
  loading: PropTypes.bool,

  /**
   * Text to display when in a loading state.
   *
   * For localization purposes, you can use the provided [translations](/guides/localization/).
   */
  loadingText: PropTypes.node,

  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   */
  multiple: PropTypes
  /* @typescript-to-proptypes-ignore */
  .bool,

  /**
   * Text to display when there are no options.
   *
   * For localization purposes, you can use the provided [translations](/guides/localization/).
   */
  noOptionsText: PropTypes.node,

  /**
   * Callback fired when the value changes.
   *
   * @param {object} event The event source of the callback.
   * @param {T|T[]} value The new value of the component.
   * @param {string} reason One of "create-option", "select-option", "remove-option", "blur" or "clear".
   */
  onChange: PropTypes.func,

  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"toggleInput"`, `"escape"`, `"select-option"`, `"blur"`.
   */
  onClose: PropTypes.func,

  /**
   * Callback fired when the highlight option changes.
   *
   * @param {object} event The event source of the callback.
   * @param {T} option The highlighted option.
   * @param {string} reason Can be: `"keyboard"`, `"auto"`, `"mouse"`.
   */
  onHighlightChange: PropTypes.func,

  /**
   * Callback fired when the input value changes.
   *
   * @param {object} event The event source of the callback.
   * @param {string} value The new value of the text input.
   * @param {string} reason Can be: `"input"` (user input), `"reset"` (programmatic change), `"clear"`.
   */
  onInputChange: PropTypes.func,

  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: PropTypes.func,

  /**
   * Control the popup` open state.
   */
  open: PropTypes.bool,

  /**
   * If `true`, the popup will open on input focus.
   */
  openOnFocus: PropTypes.bool,

  /**
   * Override the default text for the *open popup* icon button.
   *
   * For localization purposes, you can use the provided [translations](/guides/localization/).
   */
  openText: PropTypes.string,

  /**
   * Array of options.
   */
  options: PropTypes.array.isRequired,

  /**
   * The component used to render the body of the popup.
   */
  PaperComponent: PropTypes.elementType,

  /**
   * The component used to position the popup.
   */
  PopperComponent: PropTypes.elementType,

  /**
   * The icon to display in place of the default popup icon.
   */
  popupIcon: PropTypes.node,

  /**
   * Render the group.
   *
   * @param {any} option The group to render.
   * @returns {ReactNode}
   */
  renderGroup: PropTypes.func,

  /**
   * Render the input.
   *
   * @param {object} params
   * @returns {ReactNode}
   */
  renderInput: PropTypes.func.isRequired,

  /**
   * Render the option, use `getOptionLabel` by default.
   *
   * @param {T} option The option to render.
   * @param {object} state The state of the component.
   * @returns {ReactNode}
   */
  renderOption: PropTypes.func,

  /**
   * Render the selected value.
   *
   * @param {T[]} value The `value` provided to the component.
   * @param {function} getTagProps A tag props getter.
   * @returns {ReactNode}
   */
  renderTags: PropTypes.func,

  /**
   * If `true`, the input's text will be selected on focus.
   * It helps the user clear the selected value.
   */
  selectOnFocus: PropTypes.bool,

  /**
   * The size of the autocomplete.
   */
  size: PropTypes.oneOf(['medium', 'small']),

  /**
   * The value of the autocomplete.
   *
   * The value must have reference equality with the option in order to be selected.
   * You can customize the equality behavior with the `getOptionSelected` prop.
   */
  value: PropTypes.any
} ;
var Autocomplete$1 = withStyles(styles$l, {
  name: 'MuiAutocomplete'
})(Autocomplete);

function formControlState(_ref) {
  var props = _ref.props,
      states = _ref.states,
      muiFormControl = _ref.muiFormControl;
  return states.reduce(function (acc, state) {
    acc[state] = props[state];

    if (muiFormControl) {
      if (typeof props[state] === 'undefined') {
        acc[state] = muiFormControl[state];
      }
    }

    return acc;
  }, {});
}

/**
 * @ignore - internal component.
 */

var FormControlContext = React.createContext();

{
  FormControlContext.displayName = 'FormControlContext';
}

function useFormControl$1() {
  return React.useContext(FormControlContext);
}
var FormControlContext$1 = FormControlContext;

function getStyleValue(computedStyle, property) {
  return parseInt(computedStyle[property], 10) || 0;
}

var useEnhancedEffect$2 = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;
var styles$k = {
  /* Styles applied to the shadow textarea element. */
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: 'hidden',
    // Remove from the content flow
    position: 'absolute',
    // Ignore the scrollbar width
    overflow: 'hidden',
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: 'translateZ(0)'
  }
};
var TextareaAutosize = /*#__PURE__*/React.forwardRef(function TextareaAutosize(props, ref) {
  var onChange = props.onChange,
      rows = props.rows,
      rowsMax = props.rowsMax,
      rowsMinProp = props.rowsMin,
      maxRowsProp = props.maxRows,
      _props$minRows = props.minRows,
      minRowsProp = _props$minRows === void 0 ? 1 : _props$minRows,
      style = props.style,
      value = props.value,
      other = _objectWithoutProperties(props, ["onChange", "rows", "rowsMax", "rowsMin", "maxRows", "minRows", "style", "value"]);

  var maxRows = maxRowsProp || rowsMax;
  var minRows = rows || rowsMinProp || minRowsProp;

  var _React$useRef = React.useRef(value != null),
      isControlled = _React$useRef.current;

  var inputRef = React.useRef(null);
  var handleRef = useForkRef(ref, inputRef);
  var shadowRef = React.useRef(null);
  var renders = React.useRef(0);

  var _React$useState = React.useState({}),
      state = _React$useState[0],
      setState = _React$useState[1];

  var syncHeight = React.useCallback(function () {
    var input = inputRef.current;
    var computedStyle = window.getComputedStyle(input);
    var inputShallow = shadowRef.current;
    inputShallow.style.width = computedStyle.width;
    inputShallow.value = input.value || props.placeholder || 'x';

    if (inputShallow.value.slice(-1) === '\n') {
      // Certain fonts which overflow the line height will cause the textarea
      // to report a different scrollHeight depending on whether the last line
      // is empty. Make it non-empty to avoid this issue.
      inputShallow.value += ' ';
    }

    var boxSizing = computedStyle['box-sizing'];
    var padding = getStyleValue(computedStyle, 'padding-bottom') + getStyleValue(computedStyle, 'padding-top');
    var border = getStyleValue(computedStyle, 'border-bottom-width') + getStyleValue(computedStyle, 'border-top-width'); // The height of the inner content

    var innerHeight = inputShallow.scrollHeight - padding; // Measure height of a textarea with a single row

    inputShallow.value = 'x';
    var singleRowHeight = inputShallow.scrollHeight - padding; // The height of the outer content

    var outerHeight = innerHeight;

    if (minRows) {
      outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
    }

    if (maxRows) {
      outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
    }

    outerHeight = Math.max(outerHeight, singleRowHeight); // Take the box sizing into account for applying this value as a style.

    var outerHeightStyle = outerHeight + (boxSizing === 'border-box' ? padding + border : 0);
    var overflow = Math.abs(outerHeight - innerHeight) <= 1;
    setState(function (prevState) {
      // Need a large enough difference to update the height.
      // This prevents infinite rendering loop.
      if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow)) {
        renders.current += 1;
        return {
          overflow: overflow,
          outerHeightStyle: outerHeightStyle
        };
      }

      {
        if (renders.current === 20) {
          console.error(['Material-UI: Too many re-renders. The layout is unstable.', 'TextareaAutosize limits the number of renders to prevent an infinite loop.'].join('\n'));
        }
      }

      return prevState;
    });
  }, [maxRows, minRows, props.placeholder]);
  React.useEffect(function () {
    var handleResize = debounce(function () {
      renders.current = 0;
      syncHeight();
    });
    window.addEventListener('resize', handleResize);
    return function () {
      handleResize.clear();
      window.removeEventListener('resize', handleResize);
    };
  }, [syncHeight]);
  useEnhancedEffect$2(function () {
    syncHeight();
  });
  React.useEffect(function () {
    renders.current = 0;
  }, [value]);

  var handleChange = function handleChange(event) {
    renders.current = 0;

    if (!isControlled) {
      syncHeight();
    }

    if (onChange) {
      onChange(event);
    }
  };

  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("textarea", _extends$1({
    value: value,
    onChange: handleChange,
    ref: handleRef // Apply the rows prop to get a "correct" first SSR paint
    ,
    rows: minRows,
    style: _extends$1({
      height: state.outerHeightStyle,
      // Need a large enough difference to allow scrolling.
      // This prevents infinite rendering loop.
      overflow: state.overflow ? 'hidden' : null
    }, style)
  }, other)), /*#__PURE__*/React.createElement("textarea", {
    "aria-hidden": true,
    className: props.className,
    readOnly: true,
    ref: shadowRef,
    tabIndex: -1,
    style: _extends$1({}, styles$k.shadow, style)
  }));
});
TextareaAutosize.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * Maximum number of rows to display.
   */
  maxRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Minimum number of rows to display.
   */
  minRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * @ignore
   */
  onChange: PropTypes.func,

  /**
   * @ignore
   */
  placeholder: PropTypes.string,

  /**
   * Minimum number of rows to display.
   * @deprecated Use `minRows` instead.
   */
  rows: deprecatedPropType(PropTypes.oneOfType([PropTypes.number, PropTypes.string]), 'Use `minRows` instead.'),

  /**
   * Maximum number of rows to display.
   * @deprecated Use `maxRows` instead.
   */
  rowsMax: deprecatedPropType(PropTypes.oneOfType([PropTypes.number, PropTypes.string]), 'Use `maxRows` instead.'),

  /**
   * Minimum number of rows to display.
   * @deprecated Use `minRows` instead.
   */
  rowsMin: deprecatedPropType(PropTypes.oneOfType([PropTypes.number, PropTypes.string]), 'Use `minRows` instead.'),

  /**
   * @ignore
   */
  style: PropTypes.object,

  /**
   * @ignore
   */
  value: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.number, PropTypes.string])
} ;
var TextareaAutosize$1 = TextareaAutosize;

// Supports determination of isControlled().
// Controlled input accepts its current value as a prop.
//
// @see https://facebook.github.io/react/docs/forms.html#controlled-components
// @param value
// @returns {boolean} true if string (including '') or number (including zero)
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0);
} // Determine if field is empty or filled.
// Response determines if label is presented above field or as placeholder.
//
// @param obj
// @param SSR
// @returns {boolean} False when not present or empty string.
//                    True when any number or string with length.

function isFilled(obj) {
  var SSR = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return obj && (hasValue(obj.value) && obj.value !== '' || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== '');
} // Determine if an Input is adorned on start.
// It's corresponding to the left with LTR.
//
// @param obj
// @returns {boolean} False when no adornments.
//                    True when adorned at the start.

function isAdornedStart(obj) {
  return obj.startAdornment;
}

var styles$j = function styles(theme) {
  var light = theme.palette.type === 'light';
  var placeholder = {
    color: 'currentColor',
    opacity: light ? 0.42 : 0.5,
    transition: theme.transitions.create('opacity', {
      duration: theme.transitions.duration.shorter
    })
  };
  var placeholderHidden = {
    opacity: '0 !important'
  };
  var placeholderVisible = {
    opacity: light ? 0.42 : 0.5
  };
  return {
    '@global': {
      '@keyframes mui-auto-fill': {},
      '@keyframes mui-auto-fill-cancel': {}
    },

    /* Styles applied to the root element. */
    root: _extends$1({}, theme.typography.body1, {
      color: theme.palette.text.primary,
      lineHeight: '1.1876em',
      // Reset (19px), match the native input line-height
      boxSizing: 'border-box',
      // Prevent padding issue with fullWidth.
      position: 'relative',
      cursor: 'text',
      display: 'inline-flex',
      alignItems: 'center',
      '&$disabled': {
        color: theme.palette.text.disabled,
        cursor: 'default'
      }
    }),

    /* Styles applied to the root element if the component is a descendant of `FormControl`. */
    formControl: {},

    /* Styles applied to the root element if the component is focused. */
    focused: {},

    /* Styles applied to the root element if `disabled={true}`. */
    disabled: {},

    /* Styles applied to the root element if `startAdornment` is provided. */
    adornedStart: {},

    /* Styles applied to the root element if `endAdornment` is provided. */
    adornedEnd: {},

    /* Pseudo-class applied to the root element if `error={true}`. */
    error: {},

    /* Styles applied to the `input` element if `margin="dense"`. */
    marginDense: {},

    /* Styles applied to the root element if `multiline={true}`. */
    multiline: {
      padding: "".concat(8 - 2, "px 0 ").concat(8 - 1, "px"),
      '&$marginDense': {
        paddingTop: 4 - 1
      }
    },

    /* Styles applied to the root element if the color is secondary. */
    colorSecondary: {},

    /* Styles applied to the root element if `fullWidth={true}`. */
    fullWidth: {
      width: '100%'
    },

    /* Styles applied to the `input` element. */
    input: {
      font: 'inherit',
      letterSpacing: 'inherit',
      color: 'currentColor',
      padding: "".concat(8 - 2, "px 0 ").concat(8 - 1, "px"),
      border: 0,
      boxSizing: 'content-box',
      background: 'none',
      height: '1.1876em',
      // Reset (19px), match the native input line-height
      margin: 0,
      // Reset for Safari
      WebkitTapHighlightColor: 'transparent',
      display: 'block',
      // Make the flex item shrink with Firefox
      minWidth: 0,
      width: '100%',
      // Fix IE 11 width issue
      animationName: 'mui-auto-fill-cancel',
      animationDuration: '10ms',
      '&::-webkit-input-placeholder': placeholder,
      '&::-moz-placeholder': placeholder,
      // Firefox 19+
      '&:-ms-input-placeholder': placeholder,
      // IE 11
      '&::-ms-input-placeholder': placeholder,
      // Edge
      '&:focus': {
        outline: 0
      },
      // Reset Firefox invalid required input style
      '&:invalid': {
        boxShadow: 'none'
      },
      '&::-webkit-search-decoration': {
        // Remove the padding when type=search.
        '-webkit-appearance': 'none'
      },
      // Show and hide the placeholder logic
      'label[data-shrink=false] + $formControl &': {
        '&::-webkit-input-placeholder': placeholderHidden,
        '&::-moz-placeholder': placeholderHidden,
        // Firefox 19+
        '&:-ms-input-placeholder': placeholderHidden,
        // IE 11
        '&::-ms-input-placeholder': placeholderHidden,
        // Edge
        '&:focus::-webkit-input-placeholder': placeholderVisible,
        '&:focus::-moz-placeholder': placeholderVisible,
        // Firefox 19+
        '&:focus:-ms-input-placeholder': placeholderVisible,
        // IE 11
        '&:focus::-ms-input-placeholder': placeholderVisible // Edge

      },
      '&$disabled': {
        opacity: 1 // Reset iOS opacity

      },
      '&:-webkit-autofill': {
        animationDuration: '5000s',
        animationName: 'mui-auto-fill'
      }
    },

    /* Styles applied to the `input` element if `margin="dense"`. */
    inputMarginDense: {
      paddingTop: 4 - 1
    },

    /* Styles applied to the `input` element if `multiline={true}`. */
    inputMultiline: {
      height: 'auto',
      resize: 'none',
      padding: 0
    },

    /* Styles applied to the `input` element if `type="search"`. */
    inputTypeSearch: {
      // Improve type search style.
      '-moz-appearance': 'textfield',
      '-webkit-appearance': 'textfield'
    },

    /* Styles applied to the `input` element if `startAdornment` is provided. */
    inputAdornedStart: {},

    /* Styles applied to the `input` element if `endAdornment` is provided. */
    inputAdornedEnd: {},

    /* Styles applied to the `input` element if `hiddenLabel={true}`. */
    inputHiddenLabel: {}
  };
};
var useEnhancedEffect$1 = typeof window === 'undefined' ? React.useEffect : React.useLayoutEffect;
/**
 * `InputBase` contains as few styles as possible.
 * It aims to be a simple building block for creating an input.
 * It contains a load of style reset and some state logic.
 */

var InputBase = /*#__PURE__*/React.forwardRef(function InputBase(props, ref) {
  var ariaDescribedby = props['aria-describedby'],
      autoComplete = props.autoComplete,
      autoFocus = props.autoFocus,
      classes = props.classes,
      className = props.className;
      props.color;
      var defaultValue = props.defaultValue,
      disabled = props.disabled,
      endAdornment = props.endAdornment;
      props.error;
      var _props$fullWidth = props.fullWidth,
      fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
      id = props.id,
      _props$inputComponent = props.inputComponent,
      inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent,
      _props$inputProps = props.inputProps,
      inputPropsProp = _props$inputProps === void 0 ? {} : _props$inputProps,
      inputRefProp = props.inputRef;
      props.margin;
      var _props$multiline = props.multiline,
      multiline = _props$multiline === void 0 ? false : _props$multiline,
      name = props.name,
      onBlur = props.onBlur,
      onChange = props.onChange,
      onClick = props.onClick,
      onFocus = props.onFocus,
      onKeyDown = props.onKeyDown,
      onKeyUp = props.onKeyUp,
      placeholder = props.placeholder,
      readOnly = props.readOnly,
      renderSuffix = props.renderSuffix,
      rows = props.rows,
      rowsMax = props.rowsMax,
      rowsMin = props.rowsMin,
      maxRows = props.maxRows,
      minRows = props.minRows,
      startAdornment = props.startAdornment,
      _props$type = props.type,
      type = _props$type === void 0 ? 'text' : _props$type,
      valueProp = props.value,
      other = _objectWithoutProperties(props, ["aria-describedby", "autoComplete", "autoFocus", "classes", "className", "color", "defaultValue", "disabled", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "rowsMax", "rowsMin", "maxRows", "minRows", "startAdornment", "type", "value"]);

  var value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;

  var _React$useRef = React.useRef(value != null),
      isControlled = _React$useRef.current;

  var inputRef = React.useRef();
  var handleInputRefWarning = React.useCallback(function (instance) {
    {
      if (instance && instance.nodeName !== 'INPUT' && !instance.focus) {
        console.error(['Material-UI: You have provided a `inputComponent` to the input component', 'that does not correctly handle the `inputRef` prop.', 'Make sure the `inputRef` prop is called with a HTMLInputElement.'].join('\n'));
      }
    }
  }, []);
  var handleInputPropsRefProp = useForkRef(inputPropsProp.ref, handleInputRefWarning);
  var handleInputRefProp = useForkRef(inputRefProp, handleInputPropsRefProp);
  var handleInputRef = useForkRef(inputRef, handleInputRefProp);

  var _React$useState = React.useState(false),
      focused = _React$useState[0],
      setFocused = _React$useState[1];

  var muiFormControl = useFormControl$1();

  {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useEffect(function () {
      if (muiFormControl) {
        return muiFormControl.registerEffect();
      }

      return undefined;
    }, [muiFormControl]);
  }

  var fcs = formControlState({
    props: props,
    muiFormControl: muiFormControl,
    states: ['color', 'disabled', 'error', 'hiddenLabel', 'margin', 'required', 'filled']
  });
  fcs.focused = muiFormControl ? muiFormControl.focused : focused; // The blur won't fire when the disabled state is set on a focused input.
  // We need to book keep the focused state manually.

  React.useEffect(function () {
    if (!muiFormControl && disabled && focused) {
      setFocused(false);

      if (onBlur) {
        onBlur();
      }
    }
  }, [muiFormControl, disabled, focused, onBlur]);
  var onFilled = muiFormControl && muiFormControl.onFilled;
  var onEmpty = muiFormControl && muiFormControl.onEmpty;
  var checkDirty = React.useCallback(function (obj) {
    if (isFilled(obj)) {
      if (onFilled) {
        onFilled();
      }
    } else if (onEmpty) {
      onEmpty();
    }
  }, [onFilled, onEmpty]);
  useEnhancedEffect$1(function () {
    if (isControlled) {
      checkDirty({
        value: value
      });
    }
  }, [value, checkDirty, isControlled]);

  var handleFocus = function handleFocus(event) {
    // Fix a bug with IE 11 where the focus/blur events are triggered
    // while the input is disabled.
    if (fcs.disabled) {
      event.stopPropagation();
      return;
    }

    if (onFocus) {
      onFocus(event);
    }

    if (inputPropsProp.onFocus) {
      inputPropsProp.onFocus(event);
    }

    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    } else {
      setFocused(true);
    }
  };

  var handleBlur = function handleBlur(event) {
    if (onBlur) {
      onBlur(event);
    }

    if (inputPropsProp.onBlur) {
      inputPropsProp.onBlur(event);
    }

    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    } else {
      setFocused(false);
    }
  };

  var handleChange = function handleChange(event) {
    if (!isControlled) {
      var element = event.target || inputRef.current;

      if (element == null) {
        throw new Error("Material-UI: Expected valid input target. Did you use a custom `inputComponent` and forget to forward refs? See https://material-ui.com/r/input-component-ref-interface for more info." );
      }

      checkDirty({
        value: element.value
      });
    }

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (inputPropsProp.onChange) {
      inputPropsProp.onChange.apply(inputPropsProp, [event].concat(args));
    } // Perform in the willUpdate


    if (onChange) {
      onChange.apply(void 0, [event].concat(args));
    }
  }; // Check the input state on mount, in case it was filled by the user
  // or auto filled by the browser before the hydration (for SSR).


  React.useEffect(function () {
    checkDirty(inputRef.current);
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  var handleClick = function handleClick(event) {
    if (inputRef.current && event.currentTarget === event.target) {
      inputRef.current.focus();
    }

    if (onClick) {
      onClick(event);
    }
  };

  var InputComponent = inputComponent;

  var inputProps = _extends$1({}, inputPropsProp, {
    ref: handleInputRef
  });

  if (typeof InputComponent !== 'string') {
    inputProps = _extends$1({
      // Rename ref to inputRef as we don't know the
      // provided `inputComponent` structure.
      inputRef: handleInputRef,
      type: type
    }, inputProps, {
      ref: null
    });
  } else if (multiline) {
    if (rows && !maxRows && !minRows && !rowsMax && !rowsMin) {
      InputComponent = 'textarea';
    } else {
      inputProps = _extends$1({
        minRows: rows || minRows,
        rowsMax: rowsMax,
        maxRows: maxRows
      }, inputProps);
      InputComponent = TextareaAutosize$1;
    }
  } else {
    inputProps = _extends$1({
      type: type
    }, inputProps);
  }

  var handleAutoFill = function handleAutoFill(event) {
    // Provide a fake value as Chrome might not let you access it for security reasons.
    checkDirty(event.animationName === 'mui-auto-fill-cancel' ? inputRef.current : {
      value: 'x'
    });
  };

  React.useEffect(function () {
    if (muiFormControl) {
      muiFormControl.setAdornedStart(Boolean(startAdornment));
    }
  }, [muiFormControl, startAdornment]);
  return /*#__PURE__*/React.createElement("div", _extends$1({
    className: clsx(classes.root, classes["color".concat(capitalize(fcs.color || 'primary'))], className, fcs.disabled && classes.disabled, fcs.error && classes.error, fullWidth && classes.fullWidth, fcs.focused && classes.focused, muiFormControl && classes.formControl, multiline && classes.multiline, startAdornment && classes.adornedStart, endAdornment && classes.adornedEnd, fcs.margin === 'dense' && classes.marginDense),
    onClick: handleClick,
    ref: ref
  }, other), startAdornment, /*#__PURE__*/React.createElement(FormControlContext$1.Provider, {
    value: null
  }, /*#__PURE__*/React.createElement(InputComponent, _extends$1({
    "aria-invalid": fcs.error,
    "aria-describedby": ariaDescribedby,
    autoComplete: autoComplete,
    autoFocus: autoFocus,
    defaultValue: defaultValue,
    disabled: fcs.disabled,
    id: id,
    onAnimationStart: handleAutoFill,
    name: name,
    placeholder: placeholder,
    readOnly: readOnly,
    required: fcs.required,
    rows: rows,
    value: value,
    onKeyDown: onKeyDown,
    onKeyUp: onKeyUp
  }, inputProps, {
    className: clsx(classes.input, inputPropsProp.className, fcs.disabled && classes.disabled, multiline && classes.inputMultiline, fcs.hiddenLabel && classes.inputHiddenLabel, startAdornment && classes.inputAdornedStart, endAdornment && classes.inputAdornedEnd, type === 'search' && classes.inputTypeSearch, fcs.margin === 'dense' && classes.inputMarginDense),
    onBlur: handleBlur,
    onChange: handleChange,
    onFocus: handleFocus
  }))), endAdornment, renderSuffix ? renderSuffix(_extends$1({}, fcs, {
    startAdornment: startAdornment
  })) : null);
});
InputBase.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * @ignore
   */
  'aria-describedby': PropTypes.string,

  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: PropTypes.string,

  /**
   * If `true`, the `input` element will be focused during the first mount.
   */
  autoFocus: PropTypes.bool,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */
  color: PropTypes.oneOf(['primary', 'secondary']),

  /**
   * The default `input` element value. Use when the component is not controlled.
   */
  defaultValue: PropTypes.any,

  /**
   * If `true`, the `input` element will be disabled.
   */
  disabled: PropTypes.bool,

  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: PropTypes.node,

  /**
   * If `true`, the input will indicate an error. This is normally obtained via context from
   * FormControl.
   */
  error: PropTypes.bool,

  /**
   * If `true`, the input will take up the full width of its container.
   */
  fullWidth: PropTypes.bool,

  /**
   * The id of the `input` element.
   */
  id: PropTypes.string,

  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   */
  inputComponent: PropTypes.elementType,

  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: PropTypes.object,

  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType$1,

  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: PropTypes.oneOf(['dense', 'none']),

  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * If `true`, a textarea element will be rendered.
   */
  multiline: PropTypes.bool,

  /**
   * Name attribute of the `input` element.
   */
  name: PropTypes.string,

  /**
   * Callback fired when the input is blurred.
   *
   * Notice that the first argument (event) might be undefined.
   */
  onBlur: PropTypes.func,

  /**
   * Callback fired when the value is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: PropTypes.func,

  /**
   * @ignore
   */
  onClick: PropTypes.func,

  /**
   * @ignore
   */
  onFocus: PropTypes.func,

  /**
   * @ignore
   */
  onKeyDown: PropTypes.func,

  /**
   * @ignore
   */
  onKeyUp: PropTypes.func,

  /**
   * The short hint displayed in the input before the user enters a value.
   */
  placeholder: PropTypes.string,

  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: PropTypes.bool,

  /**
   * @ignore
   */
  renderSuffix: PropTypes.func,

  /**
   * If `true`, the `input` element will be required.
   */
  required: PropTypes.bool,

  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Maximum number of rows to display.
   * @deprecated Use `maxRows` instead.
   */
  rowsMax: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Minimum number of rows to display.
   * @deprecated Use `minRows` instead.
   */
  rowsMin: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: PropTypes.node,

  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   */
  type: PropTypes.string,

  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: PropTypes.any
} ;
var InputBase$1 = withStyles(styles$j, {
  name: 'MuiInputBase'
})(InputBase);

var styles$i = function styles(theme) {
  var light = theme.palette.type === 'light';
  var bottomLineColor = light ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)';
  return {
    /* Styles applied to the root element. */
    root: {
      position: 'relative'
    },

    /* Styles applied to the root element if the component is a descendant of `FormControl`. */
    formControl: {
      'label + &': {
        marginTop: 16
      }
    },

    /* Styles applied to the root element if the component is focused. */
    focused: {},

    /* Styles applied to the root element if `disabled={true}`. */
    disabled: {},

    /* Styles applied to the root element if color secondary. */
    colorSecondary: {
      '&$underline:after': {
        borderBottomColor: theme.palette.secondary.main
      }
    },

    /* Styles applied to the root element if `disableUnderline={false}`. */
    underline: {
      '&:after': {
        borderBottom: "2px solid ".concat(theme.palette.primary.main),
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
        content: '""',
        position: 'absolute',
        right: 0,
        transform: 'scaleX(0)',
        transition: theme.transitions.create('transform', {
          duration: theme.transitions.duration.shorter,
          easing: theme.transitions.easing.easeOut
        }),
        pointerEvents: 'none' // Transparent to the hover style.

      },
      '&$focused:after': {
        transform: 'scaleX(1)'
      },
      '&$error:after': {
        borderBottomColor: theme.palette.error.main,
        transform: 'scaleX(1)' // error is always underlined in red

      },
      '&:before': {
        borderBottom: "1px solid ".concat(bottomLineColor),
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
        content: '"\\00a0"',
        position: 'absolute',
        right: 0,
        transition: theme.transitions.create('border-bottom-color', {
          duration: theme.transitions.duration.shorter
        }),
        pointerEvents: 'none' // Transparent to the hover style.

      },
      '&:hover:not($disabled):before': {
        borderBottom: "2px solid ".concat(theme.palette.text.primary),
        // Reset on touch devices, it doesn't add specificity
        '@media (hover: none)': {
          borderBottom: "1px solid ".concat(bottomLineColor)
        }
      },
      '&$disabled:before': {
        borderBottomStyle: 'dotted'
      }
    },

    /* Pseudo-class applied to the root element if `error={true}`. */
    error: {},

    /* Styles applied to the `input` element if `margin="dense"`. */
    marginDense: {},

    /* Styles applied to the root element if `multiline={true}`. */
    multiline: {},

    /* Styles applied to the root element if `fullWidth={true}`. */
    fullWidth: {},

    /* Styles applied to the `input` element. */
    input: {},

    /* Styles applied to the `input` element if `margin="dense"`. */
    inputMarginDense: {},

    /* Styles applied to the `input` element if `multiline={true}`. */
    inputMultiline: {},

    /* Styles applied to the `input` element if `type="search"`. */
    inputTypeSearch: {}
  };
};
var Input = /*#__PURE__*/React.forwardRef(function Input(props, ref) {
  var disableUnderline = props.disableUnderline,
      classes = props.classes,
      _props$fullWidth = props.fullWidth,
      fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
      _props$inputComponent = props.inputComponent,
      inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent,
      _props$multiline = props.multiline,
      multiline = _props$multiline === void 0 ? false : _props$multiline,
      _props$type = props.type,
      type = _props$type === void 0 ? 'text' : _props$type,
      other = _objectWithoutProperties(props, ["disableUnderline", "classes", "fullWidth", "inputComponent", "multiline", "type"]);

  return /*#__PURE__*/React.createElement(InputBase$1, _extends$1({
    classes: _extends$1({}, classes, {
      root: clsx(classes.root, !disableUnderline && classes.underline),
      underline: null
    }),
    fullWidth: fullWidth,
    inputComponent: inputComponent,
    multiline: multiline,
    ref: ref,
    type: type
  }, other));
});
Input.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: PropTypes.string,

  /**
   * If `true`, the `input` element will be focused during the first mount.
   */
  autoFocus: PropTypes.bool,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */
  color: PropTypes.oneOf(['primary', 'secondary']),

  /**
   * The default `input` element value. Use when the component is not controlled.
   */
  defaultValue: PropTypes.any,

  /**
   * If `true`, the `input` element will be disabled.
   */
  disabled: PropTypes.bool,

  /**
   * If `true`, the input will not have an underline.
   */
  disableUnderline: PropTypes.bool,

  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: PropTypes.node,

  /**
   * If `true`, the input will indicate an error. This is normally obtained via context from
   * FormControl.
   */
  error: PropTypes.bool,

  /**
   * If `true`, the input will take up the full width of its container.
   */
  fullWidth: PropTypes.bool,

  /**
   * The id of the `input` element.
   */
  id: PropTypes.string,

  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   */
  inputComponent: PropTypes.elementType,

  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: PropTypes.object,

  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType$1,

  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: PropTypes.oneOf(['dense', 'none']),

  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * If `true`, a textarea element will be rendered.
   */
  multiline: PropTypes.bool,

  /**
   * Name attribute of the `input` element.
   */
  name: PropTypes.string,

  /**
   * Callback fired when the value is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: PropTypes.func,

  /**
   * The short hint displayed in the input before the user enters a value.
   */
  placeholder: PropTypes.string,

  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: PropTypes.bool,

  /**
   * If `true`, the `input` element will be required.
   */
  required: PropTypes.bool,

  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: PropTypes.node,

  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   */
  type: PropTypes.string,

  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: PropTypes.any
} ;
Input.muiName = 'Input';
var Input$1 = withStyles(styles$i, {
  name: 'MuiInput'
})(Input);

var styles$h = function styles(theme) {
  var light = theme.palette.type === 'light';
  var bottomLineColor = light ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)';
  var backgroundColor = light ? 'rgba(0, 0, 0, 0.09)' : 'rgba(255, 255, 255, 0.09)';
  return {
    /* Styles applied to the root element. */
    root: {
      position: 'relative',
      backgroundColor: backgroundColor,
      borderTopLeftRadius: theme.shape.borderRadius,
      borderTopRightRadius: theme.shape.borderRadius,
      transition: theme.transitions.create('background-color', {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      }),
      '&:hover': {
        backgroundColor: light ? 'rgba(0, 0, 0, 0.13)' : 'rgba(255, 255, 255, 0.13)',
        // Reset on touch devices, it doesn't add specificity
        '@media (hover: none)': {
          backgroundColor: backgroundColor
        }
      },
      '&$focused': {
        backgroundColor: light ? 'rgba(0, 0, 0, 0.09)' : 'rgba(255, 255, 255, 0.09)'
      },
      '&$disabled': {
        backgroundColor: light ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.12)'
      }
    },

    /* Styles applied to the root element if color secondary. */
    colorSecondary: {
      '&$underline:after': {
        borderBottomColor: theme.palette.secondary.main
      }
    },

    /* Styles applied to the root element if `disableUnderline={false}`. */
    underline: {
      '&:after': {
        borderBottom: "2px solid ".concat(theme.palette.primary.main),
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
        content: '""',
        position: 'absolute',
        right: 0,
        transform: 'scaleX(0)',
        transition: theme.transitions.create('transform', {
          duration: theme.transitions.duration.shorter,
          easing: theme.transitions.easing.easeOut
        }),
        pointerEvents: 'none' // Transparent to the hover style.

      },
      '&$focused:after': {
        transform: 'scaleX(1)'
      },
      '&$error:after': {
        borderBottomColor: theme.palette.error.main,
        transform: 'scaleX(1)' // error is always underlined in red

      },
      '&:before': {
        borderBottom: "1px solid ".concat(bottomLineColor),
        left: 0,
        bottom: 0,
        // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
        content: '"\\00a0"',
        position: 'absolute',
        right: 0,
        transition: theme.transitions.create('border-bottom-color', {
          duration: theme.transitions.duration.shorter
        }),
        pointerEvents: 'none' // Transparent to the hover style.

      },
      '&:hover:before': {
        borderBottom: "1px solid ".concat(theme.palette.text.primary)
      },
      '&$disabled:before': {
        borderBottomStyle: 'dotted'
      }
    },

    /* Pseudo-class applied to the root element if the component is focused. */
    focused: {},

    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},

    /* Styles applied to the root element if `startAdornment` is provided. */
    adornedStart: {
      paddingLeft: 12
    },

    /* Styles applied to the root element if `endAdornment` is provided. */
    adornedEnd: {
      paddingRight: 12
    },

    /* Pseudo-class applied to the root element if `error={true}`. */
    error: {},

    /* Styles applied to the `input` element if `margin="dense"`. */
    marginDense: {},

    /* Styles applied to the root element if `multiline={true}`. */
    multiline: {
      padding: '27px 12px 10px',
      '&$marginDense': {
        paddingTop: 23,
        paddingBottom: 6
      }
    },

    /* Styles applied to the `input` element. */
    input: {
      padding: '27px 12px 10px',
      '&:-webkit-autofill': {
        WebkitBoxShadow: theme.palette.type === 'light' ? null : '0 0 0 100px #266798 inset',
        WebkitTextFillColor: theme.palette.type === 'light' ? null : '#fff',
        caretColor: theme.palette.type === 'light' ? null : '#fff',
        borderTopLeftRadius: 'inherit',
        borderTopRightRadius: 'inherit'
      }
    },

    /* Styles applied to the `input` element if `margin="dense"`. */
    inputMarginDense: {
      paddingTop: 23,
      paddingBottom: 6
    },

    /* Styles applied to the `input` if in `<FormControl hiddenLabel />`. */
    inputHiddenLabel: {
      paddingTop: 18,
      paddingBottom: 19,
      '&$inputMarginDense': {
        paddingTop: 10,
        paddingBottom: 11
      }
    },

    /* Styles applied to the `input` element if `multiline={true}`. */
    inputMultiline: {
      padding: 0
    },

    /* Styles applied to the `input` element if `startAdornment` is provided. */
    inputAdornedStart: {
      paddingLeft: 0
    },

    /* Styles applied to the `input` element if `endAdornment` is provided. */
    inputAdornedEnd: {
      paddingRight: 0
    }
  };
};
var FilledInput = /*#__PURE__*/React.forwardRef(function FilledInput(props, ref) {
  var disableUnderline = props.disableUnderline,
      classes = props.classes,
      _props$fullWidth = props.fullWidth,
      fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
      _props$inputComponent = props.inputComponent,
      inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent,
      _props$multiline = props.multiline,
      multiline = _props$multiline === void 0 ? false : _props$multiline,
      _props$type = props.type,
      type = _props$type === void 0 ? 'text' : _props$type,
      other = _objectWithoutProperties(props, ["disableUnderline", "classes", "fullWidth", "inputComponent", "multiline", "type"]);

  return /*#__PURE__*/React.createElement(InputBase$1, _extends$1({
    classes: _extends$1({}, classes, {
      root: clsx(classes.root, !disableUnderline && classes.underline),
      underline: null
    }),
    fullWidth: fullWidth,
    inputComponent: inputComponent,
    multiline: multiline,
    ref: ref,
    type: type
  }, other));
});
FilledInput.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: PropTypes.string,

  /**
   * If `true`, the `input` element will be focused during the first mount.
   */
  autoFocus: PropTypes.bool,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */
  color: PropTypes.oneOf(['primary', 'secondary']),

  /**
   * The default `input` element value. Use when the component is not controlled.
   */
  defaultValue: PropTypes.any,

  /**
   * If `true`, the `input` element will be disabled.
   */
  disabled: PropTypes.bool,

  /**
   * If `true`, the input will not have an underline.
   */
  disableUnderline: PropTypes.bool,

  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: PropTypes.node,

  /**
   * If `true`, the input will indicate an error. This is normally obtained via context from
   * FormControl.
   */
  error: PropTypes.bool,

  /**
   * If `true`, the input will take up the full width of its container.
   */
  fullWidth: PropTypes.bool,

  /**
   * The id of the `input` element.
   */
  id: PropTypes.string,

  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   */
  inputComponent: PropTypes.elementType,

  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: PropTypes.object,

  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType$1,

  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: PropTypes.oneOf(['dense', 'none']),

  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * If `true`, a textarea element will be rendered.
   */
  multiline: PropTypes.bool,

  /**
   * Name attribute of the `input` element.
   */
  name: PropTypes.string,

  /**
   * Callback fired when the value is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: PropTypes.func,

  /**
   * The short hint displayed in the input before the user enters a value.
   */
  placeholder: PropTypes.string,

  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: PropTypes.bool,

  /**
   * If `true`, the `input` element will be required.
   */
  required: PropTypes.bool,

  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: PropTypes.node,

  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   */
  type: PropTypes.string,

  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: PropTypes.any
} ;
FilledInput.muiName = 'Input';
var FilledInput$1 = withStyles(styles$h, {
  name: 'MuiFilledInput'
})(FilledInput);

var styles$g = function styles(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      position: 'absolute',
      bottom: 0,
      right: 0,
      top: -5,
      left: 0,
      margin: 0,
      padding: '0 8px',
      pointerEvents: 'none',
      borderRadius: 'inherit',
      borderStyle: 'solid',
      borderWidth: 1,
      overflow: 'hidden'
    },

    /* Styles applied to the legend element when `labelWidth` is provided. */
    legend: {
      textAlign: 'left',
      padding: 0,
      lineHeight: '11px',
      // sync with `height` in `legend` styles
      transition: theme.transitions.create('width', {
        duration: 150,
        easing: theme.transitions.easing.easeOut
      })
    },

    /* Styles applied to the legend element. */
    legendLabelled: {
      display: 'block',
      width: 'auto',
      textAlign: 'left',
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: '0.75em',
      visibility: 'hidden',
      maxWidth: 0.01,
      transition: theme.transitions.create('max-width', {
        duration: 50,
        easing: theme.transitions.easing.easeOut
      }),
      '& > span': {
        paddingLeft: 5,
        paddingRight: 5,
        display: 'inline-block'
      }
    },

    /* Styles applied to the legend element is notched. */
    legendNotched: {
      maxWidth: 1000,
      transition: theme.transitions.create('max-width', {
        duration: 100,
        easing: theme.transitions.easing.easeOut,
        delay: 50
      })
    }
  };
};
/**
 * @ignore - internal component.
 */

var NotchedOutline = /*#__PURE__*/React.forwardRef(function NotchedOutline(props, ref) {
  props.children;
      var classes = props.classes,
      className = props.className,
      label = props.label,
      labelWidthProp = props.labelWidth,
      notched = props.notched,
      style = props.style,
      other = _objectWithoutProperties(props, ["children", "classes", "className", "label", "labelWidth", "notched", "style"]);

  var theme = useTheme();
  var align = theme.direction === 'rtl' ? 'right' : 'left';

  if (label !== undefined) {
    return /*#__PURE__*/React.createElement("fieldset", _extends$1({
      "aria-hidden": true,
      className: clsx(classes.root, className),
      ref: ref,
      style: style
    }, other), /*#__PURE__*/React.createElement("legend", {
      className: clsx(classes.legendLabelled, notched && classes.legendNotched)
    }, label ? /*#__PURE__*/React.createElement("span", null, label) : /*#__PURE__*/React.createElement("span", {
      dangerouslySetInnerHTML: {
        __html: '&#8203;'
      }
    })));
  }

  var labelWidth = labelWidthProp > 0 ? labelWidthProp * 0.75 + 8 : 0.01;
  return /*#__PURE__*/React.createElement("fieldset", _extends$1({
    "aria-hidden": true,
    style: _extends$1(_defineProperty({}, "padding".concat(capitalize(align)), 8), style),
    className: clsx(classes.root, className),
    ref: ref
  }, other), /*#__PURE__*/React.createElement("legend", {
    className: classes.legend,
    style: {
      // IE 11: fieldset with legend does not render
      // a border radius. This maintains consistency
      // by always having a legend rendered
      width: notched ? labelWidth : 0.01
    }
  }, /*#__PURE__*/React.createElement("span", {
    dangerouslySetInnerHTML: {
      __html: '&#8203;'
    }
  })));
});
NotchedOutline.propTypes = {
  /**
   * The content of the component.
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * The label.
   */
  label: PropTypes.node,

  /**
   * The width of the label.
   */
  labelWidth: PropTypes.number.isRequired,

  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: PropTypes.bool.isRequired,

  /**
   * @ignore
   */
  style: PropTypes.object
} ;
var NotchedOutline$1 = withStyles(styles$g, {
  name: 'PrivateNotchedOutline'
})(NotchedOutline);

var styles$f = function styles(theme) {
  var borderColor = theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)';
  return {
    /* Styles applied to the root element. */
    root: {
      position: 'relative',
      borderRadius: theme.shape.borderRadius,
      '&:hover $notchedOutline': {
        borderColor: theme.palette.text.primary
      },
      // Reset on touch devices, it doesn't add specificity
      '@media (hover: none)': {
        '&:hover $notchedOutline': {
          borderColor: borderColor
        }
      },
      '&$focused $notchedOutline': {
        borderColor: theme.palette.primary.main,
        borderWidth: 2
      },
      '&$error $notchedOutline': {
        borderColor: theme.palette.error.main
      },
      '&$disabled $notchedOutline': {
        borderColor: theme.palette.action.disabled
      }
    },

    /* Styles applied to the root element if the color is secondary. */
    colorSecondary: {
      '&$focused $notchedOutline': {
        borderColor: theme.palette.secondary.main
      }
    },

    /* Styles applied to the root element if the component is focused. */
    focused: {},

    /* Styles applied to the root element if `disabled={true}`. */
    disabled: {},

    /* Styles applied to the root element if `startAdornment` is provided. */
    adornedStart: {
      paddingLeft: 14
    },

    /* Styles applied to the root element if `endAdornment` is provided. */
    adornedEnd: {
      paddingRight: 14
    },

    /* Pseudo-class applied to the root element if `error={true}`. */
    error: {},

    /* Styles applied to the `input` element if `margin="dense"`. */
    marginDense: {},

    /* Styles applied to the root element if `multiline={true}`. */
    multiline: {
      padding: '18.5px 14px',
      '&$marginDense': {
        paddingTop: 10.5,
        paddingBottom: 10.5
      }
    },

    /* Styles applied to the `NotchedOutline` element. */
    notchedOutline: {
      borderColor: borderColor
    },

    /* Styles applied to the `input` element. */
    input: {
      padding: '18.5px 14px',
      '&:-webkit-autofill': {
        WebkitBoxShadow: theme.palette.type === 'light' ? null : '0 0 0 100px #266798 inset',
        WebkitTextFillColor: theme.palette.type === 'light' ? null : '#fff',
        caretColor: theme.palette.type === 'light' ? null : '#fff',
        borderRadius: 'inherit'
      }
    },

    /* Styles applied to the `input` element if `margin="dense"`. */
    inputMarginDense: {
      paddingTop: 10.5,
      paddingBottom: 10.5
    },

    /* Styles applied to the `input` element if `multiline={true}`. */
    inputMultiline: {
      padding: 0
    },

    /* Styles applied to the `input` element if `startAdornment` is provided. */
    inputAdornedStart: {
      paddingLeft: 0
    },

    /* Styles applied to the `input` element if `endAdornment` is provided. */
    inputAdornedEnd: {
      paddingRight: 0
    }
  };
};
var OutlinedInput = /*#__PURE__*/React.forwardRef(function OutlinedInput(props, ref) {
  var classes = props.classes,
      _props$fullWidth = props.fullWidth,
      fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
      _props$inputComponent = props.inputComponent,
      inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent,
      label = props.label,
      _props$labelWidth = props.labelWidth,
      labelWidth = _props$labelWidth === void 0 ? 0 : _props$labelWidth,
      _props$multiline = props.multiline,
      multiline = _props$multiline === void 0 ? false : _props$multiline,
      notched = props.notched,
      _props$type = props.type,
      type = _props$type === void 0 ? 'text' : _props$type,
      other = _objectWithoutProperties(props, ["classes", "fullWidth", "inputComponent", "label", "labelWidth", "multiline", "notched", "type"]);

  return /*#__PURE__*/React.createElement(InputBase$1, _extends$1({
    renderSuffix: function renderSuffix(state) {
      return /*#__PURE__*/React.createElement(NotchedOutline$1, {
        className: classes.notchedOutline,
        label: label,
        labelWidth: labelWidth,
        notched: typeof notched !== 'undefined' ? notched : Boolean(state.startAdornment || state.filled || state.focused)
      });
    },
    classes: _extends$1({}, classes, {
      root: clsx(classes.root, classes.underline),
      notchedOutline: null
    }),
    fullWidth: fullWidth,
    inputComponent: inputComponent,
    multiline: multiline,
    ref: ref,
    type: type
  }, other));
});
OutlinedInput.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: PropTypes.string,

  /**
   * If `true`, the `input` element will be focused during the first mount.
   */
  autoFocus: PropTypes.bool,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */
  color: PropTypes.oneOf(['primary', 'secondary']),

  /**
   * The default `input` element value. Use when the component is not controlled.
   */
  defaultValue: PropTypes.any,

  /**
   * If `true`, the `input` element will be disabled.
   */
  disabled: PropTypes.bool,

  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: PropTypes.node,

  /**
   * If `true`, the input will indicate an error. This is normally obtained via context from
   * FormControl.
   */
  error: PropTypes.bool,

  /**
   * If `true`, the input will take up the full width of its container.
   */
  fullWidth: PropTypes.bool,

  /**
   * The id of the `input` element.
   */
  id: PropTypes.string,

  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   */
  inputComponent: PropTypes.elementType,

  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: PropTypes.object,

  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType$1,

  /**
   * The label of the input. It is only used for layout. The actual labelling
   * is handled by `InputLabel`. If specified `labelWidth` is ignored.
   */
  label: PropTypes.node,

  /**
   * The width of the label. Is ignored if `label` is provided. Prefer `label`
   * if the input label appears with a strike through.
   */
  labelWidth: PropTypes.number,

  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: PropTypes.oneOf(['dense', 'none']),

  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * If `true`, a textarea element will be rendered.
   */
  multiline: PropTypes.bool,

  /**
   * Name attribute of the `input` element.
   */
  name: PropTypes.string,

  /**
   * If `true`, the outline is notched to accommodate the label.
   */
  notched: PropTypes.bool,

  /**
   * Callback fired when the value is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: PropTypes.func,

  /**
   * The short hint displayed in the input before the user enters a value.
   */
  placeholder: PropTypes.string,

  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: PropTypes.bool,

  /**
   * If `true`, the `input` element will be required.
   */
  required: PropTypes.bool,

  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: PropTypes.node,

  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   */
  type: PropTypes.string,

  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: PropTypes.any
} ;
OutlinedInput.muiName = 'Input';
var OutlinedInput$1 = withStyles(styles$f, {
  name: 'MuiOutlinedInput'
})(OutlinedInput);

function useFormControl() {
  return React.useContext(FormControlContext$1);
}

var styles$e = function styles(theme) {
  return {
    /* Styles applied to the root element. */
    root: _extends$1({
      color: theme.palette.text.secondary
    }, theme.typography.body1, {
      lineHeight: 1,
      padding: 0,
      '&$focused': {
        color: theme.palette.primary.main
      },
      '&$disabled': {
        color: theme.palette.text.disabled
      },
      '&$error': {
        color: theme.palette.error.main
      }
    }),

    /* Styles applied to the root element if the color is secondary. */
    colorSecondary: {
      '&$focused': {
        color: theme.palette.secondary.main
      }
    },

    /* Pseudo-class applied to the root element if `focused={true}`. */
    focused: {},

    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},

    /* Pseudo-class applied to the root element if `error={true}`. */
    error: {},

    /* Pseudo-class applied to the root element if `filled={true}`. */
    filled: {},

    /* Pseudo-class applied to the root element if `required={true}`. */
    required: {},

    /* Styles applied to the asterisk element. */
    asterisk: {
      '&$error': {
        color: theme.palette.error.main
      }
    }
  };
};
var FormLabel = /*#__PURE__*/React.forwardRef(function FormLabel(props, ref) {
  var children = props.children,
      classes = props.classes,
      className = props.className;
      props.color;
      var _props$component = props.component,
      Component = _props$component === void 0 ? 'label' : _props$component;
      props.disabled;
      props.error;
      props.filled;
      props.focused;
      props.required;
      var other = _objectWithoutProperties(props, ["children", "classes", "className", "color", "component", "disabled", "error", "filled", "focused", "required"]);

  var muiFormControl = useFormControl();
  var fcs = formControlState({
    props: props,
    muiFormControl: muiFormControl,
    states: ['color', 'required', 'focused', 'disabled', 'error', 'filled']
  });
  return /*#__PURE__*/React.createElement(Component, _extends$1({
    className: clsx(classes.root, classes["color".concat(capitalize(fcs.color || 'primary'))], className, fcs.disabled && classes.disabled, fcs.error && classes.error, fcs.filled && classes.filled, fcs.focused && classes.focused, fcs.required && classes.required),
    ref: ref
  }, other), children, fcs.required && /*#__PURE__*/React.createElement("span", {
    "aria-hidden": true,
    className: clsx(classes.asterisk, fcs.error && classes.error)
  }, "\u2009", '*'));
});
FormLabel.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * The content of the component.
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */
  color: PropTypes.oneOf(['primary', 'secondary']),

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes
  /* @typescript-to-proptypes-ignore */
  .elementType,

  /**
   * If `true`, the label should be displayed in a disabled state.
   */
  disabled: PropTypes.bool,

  /**
   * If `true`, the label should be displayed in an error state.
   */
  error: PropTypes.bool,

  /**
   * If `true`, the label should use filled classes key.
   */
  filled: PropTypes.bool,

  /**
   * If `true`, the input of this label is focused (used by `FormGroup` components).
   */
  focused: PropTypes.bool,

  /**
   * If `true`, the label will indicate that the input is required.
   */
  required: PropTypes.bool
} ;
var FormLabel$1 = withStyles(styles$e, {
  name: 'MuiFormLabel'
})(FormLabel);

var styles$d = function styles(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      display: 'block',
      transformOrigin: 'top left'
    },

    /* Pseudo-class applied to the root element if `focused={true}`. */
    focused: {},

    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},

    /* Pseudo-class applied to the root element if `error={true}`. */
    error: {},

    /* Pseudo-class applied to the root element if `required={true}`. */
    required: {},

    /* Pseudo-class applied to the asterisk element. */
    asterisk: {},

    /* Styles applied to the root element if the component is a descendant of `FormControl`. */
    formControl: {
      position: 'absolute',
      left: 0,
      top: 0,
      // slight alteration to spec spacing to match visual spec result
      transform: 'translate(0, 24px) scale(1)'
    },

    /* Styles applied to the root element if `margin="dense"`. */
    marginDense: {
      // Compensation for the `Input.inputDense` style.
      transform: 'translate(0, 21px) scale(1)'
    },

    /* Styles applied to the `input` element if `shrink={true}`. */
    shrink: {
      transform: 'translate(0, 1.5px) scale(0.75)',
      transformOrigin: 'top left'
    },

    /* Styles applied to the `input` element if `disableAnimation={false}`. */
    animated: {
      transition: theme.transitions.create(['color', 'transform'], {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      })
    },

    /* Styles applied to the root element if `variant="filled"`. */
    filled: {
      // Chrome's autofill feature gives the input field a yellow background.
      // Since the input field is behind the label in the HTML tree,
      // the input field is drawn last and hides the label with an opaque background color.
      // zIndex: 1 will raise the label above opaque background-colors of input.
      zIndex: 1,
      pointerEvents: 'none',
      transform: 'translate(12px, 20px) scale(1)',
      '&$marginDense': {
        transform: 'translate(12px, 17px) scale(1)'
      },
      '&$shrink': {
        transform: 'translate(12px, 10px) scale(0.75)',
        '&$marginDense': {
          transform: 'translate(12px, 7px) scale(0.75)'
        }
      }
    },

    /* Styles applied to the root element if `variant="outlined"`. */
    outlined: {
      // see comment above on filled.zIndex
      zIndex: 1,
      pointerEvents: 'none',
      transform: 'translate(14px, 20px) scale(1)',
      '&$marginDense': {
        transform: 'translate(14px, 12px) scale(1)'
      },
      '&$shrink': {
        transform: 'translate(14px, -6px) scale(0.75)'
      }
    }
  };
};
var InputLabel = /*#__PURE__*/React.forwardRef(function InputLabel(props, ref) {
  var classes = props.classes,
      className = props.className,
      _props$disableAnimati = props.disableAnimation,
      disableAnimation = _props$disableAnimati === void 0 ? false : _props$disableAnimati;
      props.margin;
      var shrinkProp = props.shrink;
      props.variant;
      var other = _objectWithoutProperties(props, ["classes", "className", "disableAnimation", "margin", "shrink", "variant"]);

  var muiFormControl = useFormControl();
  var shrink = shrinkProp;

  if (typeof shrink === 'undefined' && muiFormControl) {
    shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
  }

  var fcs = formControlState({
    props: props,
    muiFormControl: muiFormControl,
    states: ['margin', 'variant']
  });
  return /*#__PURE__*/React.createElement(FormLabel$1, _extends$1({
    "data-shrink": shrink,
    className: clsx(classes.root, className, muiFormControl && classes.formControl, !disableAnimation && classes.animated, shrink && classes.shrink, fcs.margin === 'dense' && classes.marginDense, {
      'filled': classes.filled,
      'outlined': classes.outlined
    }[fcs.variant]),
    classes: {
      focused: classes.focused,
      disabled: classes.disabled,
      error: classes.error,
      required: classes.required,
      asterisk: classes.asterisk
    },
    ref: ref
  }, other));
});
InputLabel.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * The contents of the `InputLabel`.
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */
  color: PropTypes.oneOf(['primary', 'secondary']),

  /**
   * If `true`, the transition animation is disabled.
   */
  disableAnimation: PropTypes.bool,

  /**
   * If `true`, apply disabled class.
   */
  disabled: PropTypes.bool,

  /**
   * If `true`, the label will be displayed in an error state.
   */
  error: PropTypes.bool,

  /**
   * If `true`, the input of this label is focused.
   */
  focused: PropTypes.bool,

  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: PropTypes.oneOf(['dense']),

  /**
   * if `true`, the label will indicate that the input is required.
   */
  required: PropTypes.bool,

  /**
   * If `true`, the label is shrunk.
   */
  shrink: PropTypes.bool,

  /**
   * The variant to use.
   */
  variant: PropTypes.oneOf(['filled', 'outlined', 'standard'])
} ;
var InputLabel$1 = withStyles(styles$d, {
  name: 'MuiInputLabel'
})(InputLabel);

var styles$c = {
  /* Styles applied to the root element. */
  root: {
    display: 'inline-flex',
    flexDirection: 'column',
    position: 'relative',
    // Reset fieldset default style.
    minWidth: 0,
    padding: 0,
    margin: 0,
    border: 0,
    verticalAlign: 'top' // Fix alignment issue on Safari.

  },

  /* Styles applied to the root element if `margin="normal"`. */
  marginNormal: {
    marginTop: 16,
    marginBottom: 8
  },

  /* Styles applied to the root element if `margin="dense"`. */
  marginDense: {
    marginTop: 8,
    marginBottom: 4
  },

  /* Styles applied to the root element if `fullWidth={true}`. */
  fullWidth: {
    width: '100%'
  }
};
/**
 * Provides context such as filled/focused/error/required for form inputs.
 * Relying on the context provides high flexibility and ensures that the state always stays
 * consistent across the children of the `FormControl`.
 * This context is used by the following components:
 *
 *  - FormLabel
 *  - FormHelperText
 *  - Input
 *  - InputLabel
 *
 * You can find one composition example below and more going to [the demos](/components/text-fields/#components).
 *
 * ```jsx
 * <FormControl>
 *   <InputLabel htmlFor="my-input">Email address</InputLabel>
 *   <Input id="my-input" aria-describedby="my-helper-text" />
 *   <FormHelperText id="my-helper-text">We'll never share your email.</FormHelperText>
 * </FormControl>
 * ```
 *
 * Only one input can be used within a FormControl.
 */

var FormControl = /*#__PURE__*/React.forwardRef(function FormControl(props, ref) {
  var children = props.children,
      classes = props.classes,
      className = props.className,
      _props$color = props.color,
      color = _props$color === void 0 ? 'primary' : _props$color,
      _props$component = props.component,
      Component = _props$component === void 0 ? 'div' : _props$component,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      _props$error = props.error,
      error = _props$error === void 0 ? false : _props$error,
      _props$fullWidth = props.fullWidth,
      fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
      visuallyFocused = props.focused,
      _props$hiddenLabel = props.hiddenLabel,
      hiddenLabel = _props$hiddenLabel === void 0 ? false : _props$hiddenLabel,
      _props$margin = props.margin,
      margin = _props$margin === void 0 ? 'none' : _props$margin,
      _props$required = props.required,
      required = _props$required === void 0 ? false : _props$required,
      size = props.size,
      _props$variant = props.variant,
      variant = _props$variant === void 0 ? 'standard' : _props$variant,
      other = _objectWithoutProperties(props, ["children", "classes", "className", "color", "component", "disabled", "error", "fullWidth", "focused", "hiddenLabel", "margin", "required", "size", "variant"]);

  var _React$useState = React.useState(function () {
    // We need to iterate through the children and find the Input in order
    // to fully support server-side rendering.
    var initialAdornedStart = false;

    if (children) {
      React.Children.forEach(children, function (child) {
        if (!isMuiElement(child, ['Input', 'Select'])) {
          return;
        }

        var input = isMuiElement(child, ['Select']) ? child.props.input : child;

        if (input && isAdornedStart(input.props)) {
          initialAdornedStart = true;
        }
      });
    }

    return initialAdornedStart;
  }),
      adornedStart = _React$useState[0],
      setAdornedStart = _React$useState[1];

  var _React$useState2 = React.useState(function () {
    // We need to iterate through the children and find the Input in order
    // to fully support server-side rendering.
    var initialFilled = false;

    if (children) {
      React.Children.forEach(children, function (child) {
        if (!isMuiElement(child, ['Input', 'Select'])) {
          return;
        }

        if (isFilled(child.props, true)) {
          initialFilled = true;
        }
      });
    }

    return initialFilled;
  }),
      filled = _React$useState2[0],
      setFilled = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      _focused = _React$useState3[0],
      setFocused = _React$useState3[1];

  var focused = visuallyFocused !== undefined ? visuallyFocused : _focused;

  if (disabled && focused) {
    setFocused(false);
  }

  var registerEffect;

  {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    var registeredInput = React.useRef(false);

    registerEffect = function registerEffect() {
      if (registeredInput.current) {
        console.error(['Material-UI: There are multiple InputBase components inside a FormControl.', 'This is not supported. It might cause infinite rendering loops.', 'Only use one InputBase.'].join('\n'));
      }

      registeredInput.current = true;
      return function () {
        registeredInput.current = false;
      };
    };
  }

  var onFilled = React.useCallback(function () {
    setFilled(true);
  }, []);
  var onEmpty = React.useCallback(function () {
    setFilled(false);
  }, []);
  var childContext = {
    adornedStart: adornedStart,
    setAdornedStart: setAdornedStart,
    color: color,
    disabled: disabled,
    error: error,
    filled: filled,
    focused: focused,
    fullWidth: fullWidth,
    hiddenLabel: hiddenLabel,
    margin: (size === 'small' ? 'dense' : undefined) || margin,
    onBlur: function onBlur() {
      setFocused(false);
    },
    onEmpty: onEmpty,
    onFilled: onFilled,
    onFocus: function onFocus() {
      setFocused(true);
    },
    registerEffect: registerEffect,
    required: required,
    variant: variant
  };
  return /*#__PURE__*/React.createElement(FormControlContext$1.Provider, {
    value: childContext
  }, /*#__PURE__*/React.createElement(Component, _extends$1({
    className: clsx(classes.root, className, margin !== 'none' && classes["margin".concat(capitalize(margin))], fullWidth && classes.fullWidth),
    ref: ref
  }, other), children));
});
FormControl.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * The contents of the form control.
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */
  color: PropTypes.oneOf(['primary', 'secondary']),

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes
  /* @typescript-to-proptypes-ignore */
  .elementType,

  /**
   * If `true`, the label, input and helper text should be displayed in a disabled state.
   */
  disabled: PropTypes.bool,

  /**
   * If `true`, the label should be displayed in an error state.
   */
  error: PropTypes.bool,

  /**
   * If `true`, the component will be displayed in focused state.
   */
  focused: PropTypes.bool,

  /**
   * If `true`, the component will take up the full width of its container.
   */
  fullWidth: PropTypes.bool,

  /**
   * If `true`, the label will be hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   */
  hiddenLabel: PropTypes.bool,

  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   */
  margin: PropTypes.oneOf(['dense', 'none', 'normal']),

  /**
   * If `true`, the label will indicate that the input is required.
   */
  required: PropTypes.bool,

  /**
   * The size of the text field.
   */
  size: PropTypes.oneOf(['medium', 'small']),

  /**
   * The variant to use.
   */
  variant: PropTypes.oneOf(['filled', 'outlined', 'standard'])
} ;
var FormControl$1 = withStyles(styles$c, {
  name: 'MuiFormControl'
})(FormControl);

var styles$b = function styles(theme) {
  return {
    /* Styles applied to the root element. */
    root: _extends$1({
      color: theme.palette.text.secondary
    }, theme.typography.caption, {
      textAlign: 'left',
      marginTop: 3,
      margin: 0,
      '&$disabled': {
        color: theme.palette.text.disabled
      },
      '&$error': {
        color: theme.palette.error.main
      }
    }),

    /* Pseudo-class applied to the root element if `error={true}`. */
    error: {},

    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},

    /* Styles applied to the root element if `margin="dense"`. */
    marginDense: {
      marginTop: 4
    },

    /* Styles applied to the root element if `variant="filled"` or `variant="outlined"`. */
    contained: {
      marginLeft: 14,
      marginRight: 14
    },

    /* Pseudo-class applied to the root element if `focused={true}`. */
    focused: {},

    /* Pseudo-class applied to the root element if `filled={true}`. */
    filled: {},

    /* Pseudo-class applied to the root element if `required={true}`. */
    required: {}
  };
};
var FormHelperText = /*#__PURE__*/React.forwardRef(function FormHelperText(props, ref) {
  var children = props.children,
      classes = props.classes,
      className = props.className,
      _props$component = props.component,
      Component = _props$component === void 0 ? 'p' : _props$component;
      props.disabled;
      props.error;
      props.filled;
      props.focused;
      props.margin;
      props.required;
      props.variant;
      var other = _objectWithoutProperties(props, ["children", "classes", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"]);

  var muiFormControl = useFormControl();
  var fcs = formControlState({
    props: props,
    muiFormControl: muiFormControl,
    states: ['variant', 'margin', 'disabled', 'error', 'filled', 'focused', 'required']
  });
  return /*#__PURE__*/React.createElement(Component, _extends$1({
    className: clsx(classes.root, (fcs.variant === 'filled' || fcs.variant === 'outlined') && classes.contained, className, fcs.disabled && classes.disabled, fcs.error && classes.error, fcs.filled && classes.filled, fcs.focused && classes.focused, fcs.required && classes.required, fcs.margin === 'dense' && classes.marginDense),
    ref: ref
  }, other), children === ' ' ?
  /*#__PURE__*/
  // eslint-disable-next-line react/no-danger
  React.createElement("span", {
    dangerouslySetInnerHTML: {
      __html: '&#8203;'
    }
  }) : children);
});
FormHelperText.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * The content of the component.
   *
   * If `' '` is provided, the component reserves one line height for displaying a future message.
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes
  /* @typescript-to-proptypes-ignore */
  .elementType,

  /**
   * If `true`, the helper text should be displayed in a disabled state.
   */
  disabled: PropTypes.bool,

  /**
   * If `true`, helper text should be displayed in an error state.
   */
  error: PropTypes.bool,

  /**
   * If `true`, the helper text should use filled classes key.
   */
  filled: PropTypes.bool,

  /**
   * If `true`, the helper text should use focused classes key.
   */
  focused: PropTypes.bool,

  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   */
  margin: PropTypes.oneOf(['dense']),

  /**
   * If `true`, the helper text should use required classes key.
   */
  required: PropTypes.bool,

  /**
   * The variant to use.
   */
  variant: PropTypes.oneOf(['filled', 'outlined', 'standard'])
} ;
var FormHelperText$1 = withStyles(styles$b, {
  name: 'MuiFormHelperText'
})(FormHelperText);

// A change of the browser zoom change the scrollbar size.
// Credit https://github.com/twbs/bootstrap/blob/3ffe3a5d82f6f561b82ff78d82b32a7d14aed558/js/src/modal.js#L512-L519
function getScrollbarSize() {
  var scrollDiv = document.createElement('div');
  scrollDiv.style.width = '99px';
  scrollDiv.style.height = '99px';
  scrollDiv.style.position = 'absolute';
  scrollDiv.style.top = '-9999px';
  scrollDiv.style.overflow = 'scroll';
  document.body.appendChild(scrollDiv);
  var scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarSize;
}

function isOverflowing(container) {
  var doc = ownerDocument(container);

  if (doc.body === container) {
    return ownerWindow(doc).innerWidth > doc.documentElement.clientWidth;
  }

  return container.scrollHeight > container.clientHeight;
}

function ariaHidden(node, show) {
  if (show) {
    node.setAttribute('aria-hidden', 'true');
  } else {
    node.removeAttribute('aria-hidden');
  }
}

function getPaddingRight(node) {
  return parseInt(window.getComputedStyle(node)['padding-right'], 10) || 0;
}

function ariaHiddenSiblings(container, mountNode, currentNode) {
  var nodesToExclude = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var show = arguments.length > 4 ? arguments[4] : undefined;
  var blacklist = [mountNode, currentNode].concat(_toConsumableArray(nodesToExclude));
  var blacklistTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE'];
  [].forEach.call(container.children, function (node) {
    if (node.nodeType === 1 && blacklist.indexOf(node) === -1 && blacklistTagNames.indexOf(node.tagName) === -1) {
      ariaHidden(node, show);
    }
  });
}

function findIndexOf(containerInfo, callback) {
  var idx = -1;
  containerInfo.some(function (item, index) {
    if (callback(item)) {
      idx = index;
      return true;
    }

    return false;
  });
  return idx;
}

function handleContainer(containerInfo, props) {
  var restoreStyle = [];
  var restorePaddings = [];
  var container = containerInfo.container;
  var fixedNodes;

  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      // Compute the size before applying overflow hidden to avoid any scroll jumps.
      var scrollbarSize = getScrollbarSize();
      restoreStyle.push({
        value: container.style.paddingRight,
        key: 'padding-right',
        el: container
      }); // Use computed style, here to get the real padding to add our scrollbar width.

      container.style['padding-right'] = "".concat(getPaddingRight(container) + scrollbarSize, "px"); // .mui-fixed is a global helper.

      fixedNodes = ownerDocument(container).querySelectorAll('.mui-fixed');
      [].forEach.call(fixedNodes, function (node) {
        restorePaddings.push(node.style.paddingRight);
        node.style.paddingRight = "".concat(getPaddingRight(node) + scrollbarSize, "px");
      });
    } // Improve Gatsby support
    // https://css-tricks.com/snippets/css/force-vertical-scrollbar/


    var parent = container.parentElement;
    var scrollContainer = parent.nodeName === 'HTML' && window.getComputedStyle(parent)['overflow-y'] === 'scroll' ? parent : container; // Block the scroll even if no scrollbar is visible to account for mobile keyboard
    // screensize shrink.

    restoreStyle.push({
      value: scrollContainer.style.overflow,
      key: 'overflow',
      el: scrollContainer
    });
    scrollContainer.style.overflow = 'hidden';
  }

  var restore = function restore() {
    if (fixedNodes) {
      [].forEach.call(fixedNodes, function (node, i) {
        if (restorePaddings[i]) {
          node.style.paddingRight = restorePaddings[i];
        } else {
          node.style.removeProperty('padding-right');
        }
      });
    }

    restoreStyle.forEach(function (_ref) {
      var value = _ref.value,
          el = _ref.el,
          key = _ref.key;

      if (value) {
        el.style.setProperty(key, value);
      } else {
        el.style.removeProperty(key);
      }
    });
  };

  return restore;
}

function getHiddenSiblings(container) {
  var hiddenSiblings = [];
  [].forEach.call(container.children, function (node) {
    if (node.getAttribute && node.getAttribute('aria-hidden') === 'true') {
      hiddenSiblings.push(node);
    }
  });
  return hiddenSiblings;
}
/**
 * @ignore - do not document.
 *
 * Proper state management for containers and the modals in those containers.
 * Simplified, but inspired by react-overlay's ModalManager class.
 * Used by the Modal to ensure proper styling of containers.
 */


var ModalManager = /*#__PURE__*/function () {
  function ModalManager() {
    _classCallCheck(this, ModalManager); // this.modals[modalIndex] = modal


    this.modals = []; // this.containers[containerIndex] = {
    //   modals: [],
    //   container,
    //   restore: null,
    // }

    this.containers = [];
  }

  _createClass(ModalManager, [{
    key: "add",
    value: function add(modal, container) {
      var modalIndex = this.modals.indexOf(modal);

      if (modalIndex !== -1) {
        return modalIndex;
      }

      modalIndex = this.modals.length;
      this.modals.push(modal); // If the modal we are adding is already in the DOM.

      if (modal.modalRef) {
        ariaHidden(modal.modalRef, false);
      }

      var hiddenSiblingNodes = getHiddenSiblings(container);
      ariaHiddenSiblings(container, modal.mountNode, modal.modalRef, hiddenSiblingNodes, true);
      var containerIndex = findIndexOf(this.containers, function (item) {
        return item.container === container;
      });

      if (containerIndex !== -1) {
        this.containers[containerIndex].modals.push(modal);
        return modalIndex;
      }

      this.containers.push({
        modals: [modal],
        container: container,
        restore: null,
        hiddenSiblingNodes: hiddenSiblingNodes
      });
      return modalIndex;
    }
  }, {
    key: "mount",
    value: function mount(modal, props) {
      var containerIndex = findIndexOf(this.containers, function (item) {
        return item.modals.indexOf(modal) !== -1;
      });
      var containerInfo = this.containers[containerIndex];

      if (!containerInfo.restore) {
        containerInfo.restore = handleContainer(containerInfo, props);
      }
    }
  }, {
    key: "remove",
    value: function remove(modal) {
      var modalIndex = this.modals.indexOf(modal);

      if (modalIndex === -1) {
        return modalIndex;
      }

      var containerIndex = findIndexOf(this.containers, function (item) {
        return item.modals.indexOf(modal) !== -1;
      });
      var containerInfo = this.containers[containerIndex];
      containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
      this.modals.splice(modalIndex, 1); // If that was the last modal in a container, clean up the container.

      if (containerInfo.modals.length === 0) {
        // The modal might be closed before it had the chance to be mounted in the DOM.
        if (containerInfo.restore) {
          containerInfo.restore();
        }

        if (modal.modalRef) {
          // In case the modal wasn't in the DOM yet.
          ariaHidden(modal.modalRef, true);
        }

        ariaHiddenSiblings(containerInfo.container, modal.mountNode, modal.modalRef, containerInfo.hiddenSiblingNodes, false);
        this.containers.splice(containerIndex, 1);
      } else {
        // Otherwise make sure the next top modal is visible to a screen reader.
        var nextTop = containerInfo.modals[containerInfo.modals.length - 1]; // as soon as a modal is adding its modalRef is undefined. it can't set
        // aria-hidden because the dom element doesn't exist either
        // when modal was unmounted before modalRef gets null

        if (nextTop.modalRef) {
          ariaHidden(nextTop.modalRef, false);
        }
      }

      return modalIndex;
    }
  }, {
    key: "isTopModal",
    value: function isTopModal(modal) {
      return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
    }
  }]);

  return ModalManager;
}();

/* eslint-disable consistent-return, jsx-a11y/no-noninteractive-tabindex, camelcase */
/**
 * Utility component that locks focus inside the component.
 */

function Unstable_TrapFocus(props) {
  var children = props.children,
      _props$disableAutoFoc = props.disableAutoFocus,
      disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc,
      _props$disableEnforce = props.disableEnforceFocus,
      disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce,
      _props$disableRestore = props.disableRestoreFocus,
      disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore,
      getDoc = props.getDoc,
      isEnabled = props.isEnabled,
      open = props.open;
  var ignoreNextEnforceFocus = React.useRef();
  var sentinelStart = React.useRef(null);
  var sentinelEnd = React.useRef(null);
  var nodeToRestore = React.useRef();
  var rootRef = React.useRef(null); // can be removed once we drop support for non ref forwarding class components

  var handleOwnRef = React.useCallback(function (instance) {
    // #StrictMode ready
    rootRef.current = ReactDOM.findDOMNode(instance);
  }, []);
  var handleRef = useForkRef(children.ref, handleOwnRef);
  var prevOpenRef = React.useRef();
  React.useEffect(function () {
    prevOpenRef.current = open;
  }, [open]);

  if (!prevOpenRef.current && open && typeof window !== 'undefined') {
    // WARNING: Potentially unsafe in concurrent mode.
    // The way the read on `nodeToRestore` is setup could make this actually safe.
    // Say we render `open={false}` -> `open={true}` but never commit.
    // We have now written a state that wasn't committed. But no committed effect
    // will read this wrong value. We only read from `nodeToRestore` in effects
    // that were committed on `open={true}`
    // WARNING: Prevents the instance from being garbage collected. Should only
    // hold a weak ref.
    nodeToRestore.current = getDoc().activeElement;
  }

  React.useEffect(function () {
    if (!open) {
      return;
    }

    var doc = ownerDocument(rootRef.current); // We might render an empty child.

    if (!disableAutoFocus && rootRef.current && !rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute('tabIndex')) {
        {
          console.error(['Material-UI: The modal content node does not accept focus.', 'For the benefit of assistive technologies, ' + 'the tabIndex of the node is being set to "-1".'].join('\n'));
        }

        rootRef.current.setAttribute('tabIndex', -1);
      }

      rootRef.current.focus();
    }

    var contain = function contain() {
      var rootElement = rootRef.current; // Cleanup functions are executed lazily in React 17.
      // Contain can be called between the component being unmounted and its cleanup function being run.

      if (rootElement === null) {
        return;
      }

      if (!doc.hasFocus() || disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }

      if (rootRef.current && !rootRef.current.contains(doc.activeElement)) {
        rootRef.current.focus();
      }
    };

    var loopFocus = function loopFocus(event) {
      // 9 = Tab
      if (disableEnforceFocus || !isEnabled() || event.keyCode !== 9) {
        return;
      } // Make sure the next tab starts from the right place.


      if (doc.activeElement === rootRef.current) {
        // We need to ignore the next contain as
        // it will try to move the focus back to the rootRef element.
        ignoreNextEnforceFocus.current = true;

        if (event.shiftKey) {
          sentinelEnd.current.focus();
        } else {
          sentinelStart.current.focus();
        }
      }
    };

    doc.addEventListener('focus', contain, true);
    doc.addEventListener('keydown', loopFocus, true); // With Edge, Safari and Firefox, no focus related events are fired when the focused area stops being a focused area
    // e.g. https://bugzilla.mozilla.org/show_bug.cgi?id=559561.
    //
    // The whatwg spec defines how the browser should behave but does not explicitly mention any events:
    // https://html.spec.whatwg.org/multipage/interaction.html#focus-fixup-rule.

    var interval = setInterval(function () {
      contain();
    }, 50);
    return function () {
      clearInterval(interval);
      doc.removeEventListener('focus', contain, true);
      doc.removeEventListener('keydown', loopFocus, true); // restoreLastFocus()

      if (!disableRestoreFocus) {
        // In IE 11 it is possible for document.activeElement to be null resulting
        // in nodeToRestore.current being null.
        // Not all elements in IE 11 have a focus method.
        // Once IE 11 support is dropped the focus() call can be unconditional.
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          nodeToRestore.current.focus();
        }

        nodeToRestore.current = null;
      }
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    tabIndex: 0,
    ref: sentinelStart,
    "data-test": "sentinelStart"
  }), /*#__PURE__*/React.cloneElement(children, {
    ref: handleRef
  }), /*#__PURE__*/React.createElement("div", {
    tabIndex: 0,
    ref: sentinelEnd,
    "data-test": "sentinelEnd"
  }));
}

Unstable_TrapFocus.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * A single child content element.
   */
  children: PropTypes.node,

  /**
   * If `true`, the trap focus will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any trap focus children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the trap focus less
   * accessible to assistive technologies, like screen readers.
   */
  disableAutoFocus: PropTypes.bool,

  /**
   * If `true`, the trap focus will not prevent focus from leaving the trap focus while open.
   *
   * Generally this should never be set to `true` as it makes the trap focus less
   * accessible to assistive technologies, like screen readers.
   */
  disableEnforceFocus: PropTypes.bool,

  /**
   * If `true`, the trap focus will not restore focus to previously focused element once
   * trap focus is hidden.
   */
  disableRestoreFocus: PropTypes.bool,

  /**
   * Return the document to consider.
   * We use it to implement the restore focus between different browser documents.
   */
  getDoc: PropTypes.func.isRequired,

  /**
   * Do we still want to enforce the focus?
   * This prop helps nesting TrapFocus elements.
   */
  isEnabled: PropTypes.func.isRequired,

  /**
   * If `true`, focus will be locked.
   */
  open: PropTypes.bool.isRequired
} ;

{
  // eslint-disable-next-line
  Unstable_TrapFocus['propTypes' + ''] = exactProp(Unstable_TrapFocus.propTypes);
}

var styles$a = {
  /* Styles applied to the root element. */
  root: {
    zIndex: -1,
    position: 'fixed',
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    WebkitTapHighlightColor: 'transparent'
  },

  /* Styles applied to the root element if `invisible={true}`. */
  invisible: {
    backgroundColor: 'transparent'
  }
};
/**
 * @ignore - internal component.
 */

var SimpleBackdrop = /*#__PURE__*/React.forwardRef(function SimpleBackdrop(props, ref) {
  var _props$invisible = props.invisible,
      invisible = _props$invisible === void 0 ? false : _props$invisible,
      open = props.open,
      other = _objectWithoutProperties(props, ["invisible", "open"]);

  return open ? /*#__PURE__*/React.createElement("div", _extends$1({
    "aria-hidden": true,
    ref: ref
  }, other, {
    style: _extends$1({}, styles$a.root, invisible ? styles$a.invisible : {}, other.style)
  })) : null;
});
SimpleBackdrop.propTypes = {
  /**
   * If `true`, the backdrop is invisible.
   * It can be used when rendering a popover or a custom select component.
   */
  invisible: PropTypes.bool,

  /**
   * If `true`, the backdrop is open.
   */
  open: PropTypes.bool.isRequired
} ;
var SimpleBackdrop$1 = SimpleBackdrop;

function getContainer(container) {
  container = typeof container === 'function' ? container() : container;
  return ReactDOM.findDOMNode(container);
}

function getHasTransition(props) {
  return props.children ? props.children.props.hasOwnProperty('in') : false;
} // A modal manager used to track and manage the state of open Modals.
// Modals don't open on the server so this won't conflict with concurrent requests.


var defaultManager = new ModalManager();
var styles$9 = function styles(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      position: 'fixed',
      zIndex: theme.zIndex.modal,
      right: 0,
      bottom: 0,
      top: 0,
      left: 0
    },

    /* Styles applied to the root element if the `Modal` has exited. */
    hidden: {
      visibility: 'hidden'
    }
  };
};
/**
 * Modal is a lower-level construct that is leveraged by the following components:
 *
 * - [Dialog](/api/dialog/)
 * - [Drawer](/api/drawer/)
 * - [Menu](/api/menu/)
 * - [Popover](/api/popover/)
 *
 * If you are creating a modal dialog, you probably want to use the [Dialog](/api/dialog/) component
 * rather than directly using Modal.
 *
 * This component shares many concepts with [react-overlays](https://react-bootstrap.github.io/react-overlays/#modals).
 */

var Modal = /*#__PURE__*/React.forwardRef(function Modal(inProps, ref) {
  var theme = useTheme$1();
  var props = getThemeProps({
    name: 'MuiModal',
    props: _extends$1({}, inProps),
    theme: theme
  });

  var _props$BackdropCompon = props.BackdropComponent,
      BackdropComponent = _props$BackdropCompon === void 0 ? SimpleBackdrop$1 : _props$BackdropCompon,
      BackdropProps = props.BackdropProps,
      children = props.children,
      _props$closeAfterTran = props.closeAfterTransition,
      closeAfterTransition = _props$closeAfterTran === void 0 ? false : _props$closeAfterTran,
      container = props.container,
      _props$disableAutoFoc = props.disableAutoFocus,
      disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc,
      _props$disableBackdro = props.disableBackdropClick,
      disableBackdropClick = _props$disableBackdro === void 0 ? false : _props$disableBackdro,
      _props$disableEnforce = props.disableEnforceFocus,
      disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce,
      _props$disableEscapeK = props.disableEscapeKeyDown,
      disableEscapeKeyDown = _props$disableEscapeK === void 0 ? false : _props$disableEscapeK,
      _props$disablePortal = props.disablePortal,
      disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal,
      _props$disableRestore = props.disableRestoreFocus,
      disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore,
      _props$disableScrollL = props.disableScrollLock,
      disableScrollLock = _props$disableScrollL === void 0 ? false : _props$disableScrollL,
      _props$hideBackdrop = props.hideBackdrop,
      hideBackdrop = _props$hideBackdrop === void 0 ? false : _props$hideBackdrop,
      _props$keepMounted = props.keepMounted,
      keepMounted = _props$keepMounted === void 0 ? false : _props$keepMounted,
      _props$manager = props.manager,
      manager = _props$manager === void 0 ? defaultManager : _props$manager,
      onBackdropClick = props.onBackdropClick,
      onClose = props.onClose,
      onEscapeKeyDown = props.onEscapeKeyDown,
      onRendered = props.onRendered,
      open = props.open,
      other = _objectWithoutProperties(props, ["BackdropComponent", "BackdropProps", "children", "closeAfterTransition", "container", "disableAutoFocus", "disableBackdropClick", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onEscapeKeyDown", "onRendered", "open"]);

  var _React$useState = React.useState(true),
      exited = _React$useState[0],
      setExited = _React$useState[1];

  var modal = React.useRef({});
  var mountNodeRef = React.useRef(null);
  var modalRef = React.useRef(null);
  var handleRef = useForkRef(modalRef, ref);
  var hasTransition = getHasTransition(props);

  var getDoc = function getDoc() {
    return ownerDocument(mountNodeRef.current);
  };

  var getModal = function getModal() {
    modal.current.modalRef = modalRef.current;
    modal.current.mountNode = mountNodeRef.current;
    return modal.current;
  };

  var handleMounted = function handleMounted() {
    manager.mount(getModal(), {
      disableScrollLock: disableScrollLock
    }); // Fix a bug on Chrome where the scroll isn't initially 0.

    modalRef.current.scrollTop = 0;
  };

  var handleOpen = useEventCallback(function () {
    var resolvedContainer = getContainer(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer); // The element was already mounted.

    if (modalRef.current) {
      handleMounted();
    }
  });
  var isTopModal = React.useCallback(function () {
    return manager.isTopModal(getModal());
  }, [manager]);
  var handlePortalRef = useEventCallback(function (node) {
    mountNodeRef.current = node;

    if (!node) {
      return;
    }

    if (onRendered) {
      onRendered();
    }

    if (open && isTopModal()) {
      handleMounted();
    } else {
      ariaHidden(modalRef.current, true);
    }
  });
  var handleClose = React.useCallback(function () {
    manager.remove(getModal());
  }, [manager]);
  React.useEffect(function () {
    return function () {
      handleClose();
    };
  }, [handleClose]);
  React.useEffect(function () {
    if (open) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);

  if (!keepMounted && !open && (!hasTransition || exited)) {
    return null;
  }

  var handleEnter = function handleEnter() {
    setExited(false);
  };

  var handleExited = function handleExited() {
    setExited(true);

    if (closeAfterTransition) {
      handleClose();
    }
  };

  var handleBackdropClick = function handleBackdropClick(event) {
    if (event.target !== event.currentTarget) {
      return;
    }

    if (onBackdropClick) {
      onBackdropClick(event);
    }

    if (!disableBackdropClick && onClose) {
      onClose(event, 'backdropClick');
    }
  };

  var handleKeyDown = function handleKeyDown(event) {
    // The handler doesn't take event.defaultPrevented into account:
    //
    // event.preventDefault() is meant to stop default behaviours like
    // clicking a checkbox to check it, hitting a button to submit a form,
    // and hitting left arrow to move the cursor in a text input etc.
    // Only special HTML elements have these default behaviors.
    if (event.key !== 'Escape' || !isTopModal()) {
      return;
    }

    if (onEscapeKeyDown) {
      onEscapeKeyDown(event);
    }

    if (!disableEscapeKeyDown) {
      // Swallow the event, in case someone is listening for the escape key on the body.
      event.stopPropagation();

      if (onClose) {
        onClose(event, 'escapeKeyDown');
      }
    }
  };

  var inlineStyle = styles$9(theme || {
    zIndex: zIndex$1
  });
  var childProps = {};

  if (children.props.tabIndex === undefined) {
    childProps.tabIndex = children.props.tabIndex || '-1';
  } // It's a Transition like component


  if (hasTransition) {
    childProps.onEnter = createChainedFunction(handleEnter, children.props.onEnter);
    childProps.onExited = createChainedFunction(handleExited, children.props.onExited);
  }

  return /*#__PURE__*/React.createElement(Portal$1, {
    ref: handlePortalRef,
    container: container,
    disablePortal: disablePortal
  }, /*#__PURE__*/React.createElement("div", _extends$1({
    ref: handleRef,
    onKeyDown: handleKeyDown,
    role: "presentation"
  }, other, {
    style: _extends$1({}, inlineStyle.root, !open && exited ? inlineStyle.hidden : {}, other.style)
  }), hideBackdrop ? null : /*#__PURE__*/React.createElement(BackdropComponent, _extends$1({
    open: open,
    onClick: handleBackdropClick
  }, BackdropProps)), /*#__PURE__*/React.createElement(Unstable_TrapFocus, {
    disableEnforceFocus: disableEnforceFocus,
    disableAutoFocus: disableAutoFocus,
    disableRestoreFocus: disableRestoreFocus,
    getDoc: getDoc,
    isEnabled: isTopModal,
    open: open
  }, /*#__PURE__*/React.cloneElement(children, childProps))));
});
Modal.propTypes = {
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   */
  BackdropComponent: PropTypes.elementType,

  /**
   * Props applied to the [`Backdrop`](/api/backdrop/) element.
   */
  BackdropProps: PropTypes.object,

  /**
   * A single child content element.
   */
  children: elementAcceptingRef$1.isRequired,

  /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   */
  closeAfterTransition: PropTypes.bool,

  /**
   * A HTML element, component instance, or function that returns either.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: PropTypes
  /* @typescript-to-proptypes-ignore */
  .oneOfType([HTMLElementType, PropTypes.instanceOf(React.Component), PropTypes.func]),

  /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   */
  disableAutoFocus: PropTypes.bool,

  /**
   * If `true`, clicking the backdrop will not fire `onClose`.
   */
  disableBackdropClick: deprecatedPropType(PropTypes.bool, 'Use the onClose prop with the `reason` argument to filter the `backdropClick` events.'),

  /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   */
  disableEnforceFocus: PropTypes.bool,

  /**
   * If `true`, hitting escape will not fire `onClose`.
   */
  disableEscapeKeyDown: PropTypes.bool,

  /**
   * Disable the portal behavior.
   * The children stay within it's parent DOM hierarchy.
   */
  disablePortal: PropTypes.bool,

  /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden.
   */
  disableRestoreFocus: PropTypes.bool,

  /**
   * Disable the scroll lock behavior.
   */
  disableScrollLock: PropTypes.bool,

  /**
   * If `true`, the backdrop is not rendered.
   */
  hideBackdrop: PropTypes.bool,

  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   */
  keepMounted: PropTypes.bool,

  /**
   * @ignore
   */
  manager: PropTypes.object,

  /**
   * Callback fired when the backdrop is clicked.
   */
  onBackdropClick: deprecatedPropType(PropTypes.func, 'Use the onClose prop with the `reason` argument to handle the `backdropClick` events.'),

  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: PropTypes.func,

  /**
   * Callback fired when the escape key is pressed,
   * `disableEscapeKeyDown` is false and the modal is in focus.
   */
  onEscapeKeyDown: deprecatedPropType(PropTypes.func, 'Use the onClose prop with the `reason` argument to handle the `escapeKeyDown` events.'),

  /**
   * Callback fired once the children has been mounted into the `container`.
   * It signals that the `open={true}` prop took effect.
   *
   * This prop will be removed in v5, the ref can be used instead.
   */
  onRendered: deprecatedPropType(PropTypes.func, 'Use the ref instead.'),

  /**
   * If `true`, the modal is open.
   */
  open: PropTypes.bool.isRequired
} ;
var Modal$1 = Modal;

var reflow = function reflow(node) {
  return node.scrollTop;
};
function getTransitionProps(props, options) {
  var timeout = props.timeout,
      _props$style = props.style,
      style = _props$style === void 0 ? {} : _props$style;
  return {
    duration: style.transitionDuration || typeof timeout === 'number' ? timeout : timeout[options.mode] || 0,
    delay: style.transitionDelay
  };
}

function getScale(value) {
  return "scale(".concat(value, ", ").concat(Math.pow(value, 2), ")");
}

var styles$8 = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: 'none'
  }
};
/**
 * The Grow transition is used by the [Tooltip](/components/tooltips/) and
 * [Popover](/components/popover/) components.
 * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
 */

var Grow = /*#__PURE__*/React.forwardRef(function Grow(props, ref) {
  var children = props.children,
      _props$disableStrictM = props.disableStrictModeCompat,
      disableStrictModeCompat = _props$disableStrictM === void 0 ? false : _props$disableStrictM,
      inProp = props.in,
      onEnter = props.onEnter,
      onEntered = props.onEntered,
      onEntering = props.onEntering,
      onExit = props.onExit,
      onExited = props.onExited,
      onExiting = props.onExiting,
      style = props.style,
      _props$timeout = props.timeout,
      timeout = _props$timeout === void 0 ? 'auto' : _props$timeout,
      _props$TransitionComp = props.TransitionComponent,
      TransitionComponent = _props$TransitionComp === void 0 ? Transition$1 : _props$TransitionComp,
      other = _objectWithoutProperties(props, ["children", "disableStrictModeCompat", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"]);

  var timer = React.useRef();
  var autoTimeout = React.useRef();
  var theme = useTheme();
  var enableStrictModeCompat = theme.unstable_strictMode && !disableStrictModeCompat;
  var nodeRef = React.useRef(null);
  var foreignRef = useForkRef(children.ref, ref);
  var handleRef = useForkRef(enableStrictModeCompat ? nodeRef : undefined, foreignRef);

  var normalizedTransitionCallback = function normalizedTransitionCallback(callback) {
    return function (nodeOrAppearing, maybeAppearing) {
      if (callback) {
        var _ref = enableStrictModeCompat ? [nodeRef.current, nodeOrAppearing] : [nodeOrAppearing, maybeAppearing],
            _ref2 = _slicedToArray(_ref, 2),
            node = _ref2[0],
            isAppearing = _ref2[1]; // onEnterXxx and onExitXxx callbacks have a different arguments.length value.


        if (isAppearing === undefined) {
          callback(node);
        } else {
          callback(node, isAppearing);
        }
      }
    };
  };

  var handleEntering = normalizedTransitionCallback(onEntering);
  var handleEnter = normalizedTransitionCallback(function (node, isAppearing) {
    reflow(node); // So the animation always start from the start.

    var _getTransitionProps = getTransitionProps({
      style: style,
      timeout: timeout
    }, {
      mode: 'enter'
    }),
        transitionDuration = _getTransitionProps.duration,
        delay = _getTransitionProps.delay;

    var duration;

    if (timeout === 'auto') {
      duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
      autoTimeout.current = duration;
    } else {
      duration = transitionDuration;
    }

    node.style.transition = [theme.transitions.create('opacity', {
      duration: duration,
      delay: delay
    }), theme.transitions.create('transform', {
      duration: duration * 0.666,
      delay: delay
    })].join(',');

    if (onEnter) {
      onEnter(node, isAppearing);
    }
  });
  var handleEntered = normalizedTransitionCallback(onEntered);
  var handleExiting = normalizedTransitionCallback(onExiting);
  var handleExit = normalizedTransitionCallback(function (node) {
    var _getTransitionProps2 = getTransitionProps({
      style: style,
      timeout: timeout
    }, {
      mode: 'exit'
    }),
        transitionDuration = _getTransitionProps2.duration,
        delay = _getTransitionProps2.delay;

    var duration;

    if (timeout === 'auto') {
      duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
      autoTimeout.current = duration;
    } else {
      duration = transitionDuration;
    }

    node.style.transition = [theme.transitions.create('opacity', {
      duration: duration,
      delay: delay
    }), theme.transitions.create('transform', {
      duration: duration * 0.666,
      delay: delay || duration * 0.333
    })].join(',');
    node.style.opacity = '0';
    node.style.transform = getScale(0.75);

    if (onExit) {
      onExit(node);
    }
  });
  var handleExited = normalizedTransitionCallback(onExited);

  var addEndListener = function addEndListener(nodeOrNext, maybeNext) {
    var next = enableStrictModeCompat ? nodeOrNext : maybeNext;

    if (timeout === 'auto') {
      timer.current = setTimeout(next, autoTimeout.current || 0);
    }
  };

  React.useEffect(function () {
    return function () {
      clearTimeout(timer.current);
    };
  }, []);
  return /*#__PURE__*/React.createElement(TransitionComponent, _extends$1({
    appear: true,
    in: inProp,
    nodeRef: enableStrictModeCompat ? nodeRef : undefined,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: addEndListener,
    timeout: timeout === 'auto' ? null : timeout
  }, other), function (state, childProps) {
    return /*#__PURE__*/React.cloneElement(children, _extends$1({
      style: _extends$1({
        opacity: 0,
        transform: getScale(0.75),
        visibility: state === 'exited' && !inProp ? 'hidden' : undefined
      }, styles$8[state], style, children.props.style),
      ref: handleRef
    }, childProps));
  });
});
Grow.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * A single child content element.
   */
  children: PropTypes.element,

  /**
   * Enable this prop if you encounter 'Function components cannot be given refs',
   * use `unstable_createStrictModeTheme`,
   * and can't forward the ref in the child component.
   */
  disableStrictModeCompat: PropTypes.bool,

  /**
   * If `true`, show the component; triggers the enter or exit animation.
   */
  in: PropTypes.bool,

  /**
   * @ignore
   */
  onEnter: PropTypes.func,

  /**
   * @ignore
   */
  onEntered: PropTypes.func,

  /**
   * @ignore
   */
  onEntering: PropTypes.func,

  /**
   * @ignore
   */
  onExit: PropTypes.func,

  /**
   * @ignore
   */
  onExited: PropTypes.func,

  /**
   * @ignore
   */
  onExiting: PropTypes.func,

  /**
   * @ignore
   */
  style: PropTypes.object,

  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   *
   * Set to 'auto' to automatically calculate transition time based on height.
   */
  timeout: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number, PropTypes.shape({
    appear: PropTypes.number,
    enter: PropTypes.number,
    exit: PropTypes.number
  })])
} ;
Grow.muiSupportAuto = true;
var Grow$1 = Grow;

function getOffsetTop(rect, vertical) {
  var offset = 0;

  if (typeof vertical === 'number') {
    offset = vertical;
  } else if (vertical === 'center') {
    offset = rect.height / 2;
  } else if (vertical === 'bottom') {
    offset = rect.height;
  }

  return offset;
}
function getOffsetLeft(rect, horizontal) {
  var offset = 0;

  if (typeof horizontal === 'number') {
    offset = horizontal;
  } else if (horizontal === 'center') {
    offset = rect.width / 2;
  } else if (horizontal === 'right') {
    offset = rect.width;
  }

  return offset;
}

function getTransformOriginValue(transformOrigin) {
  return [transformOrigin.horizontal, transformOrigin.vertical].map(function (n) {
    return typeof n === 'number' ? "".concat(n, "px") : n;
  }).join(' ');
} // Sum the scrollTop between two elements.


function getScrollParent(parent, child) {
  var element = child;
  var scrollTop = 0;

  while (element && element !== parent) {
    element = element.parentElement;
    scrollTop += element.scrollTop;
  }

  return scrollTop;
}

function getAnchorEl(anchorEl) {
  return typeof anchorEl === 'function' ? anchorEl() : anchorEl;
}

var styles$7 = {
  /* Styles applied to the root element. */
  root: {},

  /* Styles applied to the `Paper` component. */
  paper: {
    position: 'absolute',
    overflowY: 'auto',
    overflowX: 'hidden',
    // So we see the popover when it's empty.
    // It's most likely on issue on userland.
    minWidth: 16,
    minHeight: 16,
    maxWidth: 'calc(100% - 32px)',
    maxHeight: 'calc(100% - 32px)',
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  }
};
var Popover = /*#__PURE__*/React.forwardRef(function Popover(props, ref) {
  var action = props.action,
      anchorEl = props.anchorEl,
      _props$anchorOrigin = props.anchorOrigin,
      anchorOrigin = _props$anchorOrigin === void 0 ? {
    vertical: 'top',
    horizontal: 'left'
  } : _props$anchorOrigin,
      anchorPosition = props.anchorPosition,
      _props$anchorReferenc = props.anchorReference,
      anchorReference = _props$anchorReferenc === void 0 ? 'anchorEl' : _props$anchorReferenc,
      children = props.children,
      classes = props.classes,
      className = props.className,
      containerProp = props.container,
      _props$elevation = props.elevation,
      elevation = _props$elevation === void 0 ? 8 : _props$elevation,
      getContentAnchorEl = props.getContentAnchorEl,
      _props$marginThreshol = props.marginThreshold,
      marginThreshold = _props$marginThreshol === void 0 ? 16 : _props$marginThreshol,
      onEnter = props.onEnter,
      onEntered = props.onEntered,
      onEntering = props.onEntering,
      onExit = props.onExit,
      onExited = props.onExited,
      onExiting = props.onExiting,
      open = props.open,
      _props$PaperProps = props.PaperProps,
      PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps,
      _props$transformOrigi = props.transformOrigin,
      transformOrigin = _props$transformOrigi === void 0 ? {
    vertical: 'top',
    horizontal: 'left'
  } : _props$transformOrigi,
      _props$TransitionComp = props.TransitionComponent,
      TransitionComponent = _props$TransitionComp === void 0 ? Grow$1 : _props$TransitionComp,
      _props$transitionDura = props.transitionDuration,
      transitionDurationProp = _props$transitionDura === void 0 ? 'auto' : _props$transitionDura,
      _props$TransitionProp = props.TransitionProps,
      TransitionProps = _props$TransitionProp === void 0 ? {} : _props$TransitionProp,
      other = _objectWithoutProperties(props, ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "classes", "className", "container", "elevation", "getContentAnchorEl", "marginThreshold", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "open", "PaperProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps"]);

  var paperRef = React.useRef(); // Returns the top/left offset of the position
  // to attach to on the anchor element (or body if none is provided)

  var getAnchorOffset = React.useCallback(function (contentAnchorOffset) {
    if (anchorReference === 'anchorPosition') {
      {
        if (!anchorPosition) {
          console.error('Material-UI: You need to provide a `anchorPosition` prop when using ' + '<Popover anchorReference="anchorPosition" />.');
        }
      }

      return anchorPosition;
    }

    var resolvedAnchorEl = getAnchorEl(anchorEl); // If an anchor element wasn't provided, just use the parent body element of this Popover

    var anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
    var anchorRect = anchorElement.getBoundingClientRect();

    {
      var box = anchorElement.getBoundingClientRect();

      if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
        console.warn(['Material-UI: The `anchorEl` prop provided to the component is invalid.', 'The anchor element should be part of the document layout.', "Make sure the element is present in the document or that it's not display none."].join('\n'));
      }
    }

    var anchorVertical = contentAnchorOffset === 0 ? anchorOrigin.vertical : 'center';
    return {
      top: anchorRect.top + getOffsetTop(anchorRect, anchorVertical),
      left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
    };
  }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]); // Returns the vertical offset of inner content to anchor the transform on if provided

  var getContentAnchorOffset = React.useCallback(function (element) {
    var contentAnchorOffset = 0;

    if (getContentAnchorEl && anchorReference === 'anchorEl') {
      var contentAnchorEl = getContentAnchorEl(element);

      if (contentAnchorEl && element.contains(contentAnchorEl)) {
        var scrollTop = getScrollParent(element, contentAnchorEl);
        contentAnchorOffset = contentAnchorEl.offsetTop + contentAnchorEl.clientHeight / 2 - scrollTop || 0;
      } // != the default value


      {
        if (anchorOrigin.vertical !== 'top') {
          console.error(['Material-UI: You can not change the default `anchorOrigin.vertical` value ', 'when also providing the `getContentAnchorEl` prop to the popover component.', 'Only use one of the two props.', 'Set `getContentAnchorEl` to `null | undefined`' + ' or leave `anchorOrigin.vertical` unchanged.'].join('\n'));
        }
      }
    }

    return contentAnchorOffset;
  }, [anchorOrigin.vertical, anchorReference, getContentAnchorEl]); // Return the base transform origin using the element
  // and taking the content anchor offset into account if in use

  var getTransformOrigin = React.useCallback(function (elemRect) {
    var contentAnchorOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return {
      vertical: getOffsetTop(elemRect, transformOrigin.vertical) + contentAnchorOffset,
      horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
    };
  }, [transformOrigin.horizontal, transformOrigin.vertical]);
  var getPositioningStyle = React.useCallback(function (element) {
    // Check if the parent has requested anchoring on an inner content node
    var contentAnchorOffset = getContentAnchorOffset(element);
    var elemRect = {
      width: element.offsetWidth,
      height: element.offsetHeight
    }; // Get the transform origin point on the element itself

    var elemTransformOrigin = getTransformOrigin(elemRect, contentAnchorOffset);

    if (anchorReference === 'none') {
      return {
        top: null,
        left: null,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    } // Get the offset of of the anchoring element


    var anchorOffset = getAnchorOffset(contentAnchorOffset); // Calculate element positioning

    var top = anchorOffset.top - elemTransformOrigin.vertical;
    var left = anchorOffset.left - elemTransformOrigin.horizontal;
    var bottom = top + elemRect.height;
    var right = left + elemRect.width; // Use the parent window of the anchorEl if provided

    var containerWindow = ownerWindow(getAnchorEl(anchorEl)); // Window thresholds taking required margin into account

    var heightThreshold = containerWindow.innerHeight - marginThreshold;
    var widthThreshold = containerWindow.innerWidth - marginThreshold; // Check if the vertical axis needs shifting

    if (top < marginThreshold) {
      var diff = top - marginThreshold;
      top -= diff;
      elemTransformOrigin.vertical += diff;
    } else if (bottom > heightThreshold) {
      var _diff = bottom - heightThreshold;

      top -= _diff;
      elemTransformOrigin.vertical += _diff;
    }

    {
      if (elemRect.height > heightThreshold && elemRect.height && heightThreshold) {
        console.error(['Material-UI: The popover component is too tall.', "Some part of it can not be seen on the screen (".concat(elemRect.height - heightThreshold, "px)."), 'Please consider adding a `max-height` to improve the user-experience.'].join('\n'));
      }
    } // Check if the horizontal axis needs shifting


    if (left < marginThreshold) {
      var _diff2 = left - marginThreshold;

      left -= _diff2;
      elemTransformOrigin.horizontal += _diff2;
    } else if (right > widthThreshold) {
      var _diff3 = right - widthThreshold;

      left -= _diff3;
      elemTransformOrigin.horizontal += _diff3;
    }

    return {
      top: "".concat(Math.round(top), "px"),
      left: "".concat(Math.round(left), "px"),
      transformOrigin: getTransformOriginValue(elemTransformOrigin)
    };
  }, [anchorEl, anchorReference, getAnchorOffset, getContentAnchorOffset, getTransformOrigin, marginThreshold]);
  var setPositioningStyles = React.useCallback(function () {
    var element = paperRef.current;

    if (!element) {
      return;
    }

    var positioning = getPositioningStyle(element);

    if (positioning.top !== null) {
      element.style.top = positioning.top;
    }

    if (positioning.left !== null) {
      element.style.left = positioning.left;
    }

    element.style.transformOrigin = positioning.transformOrigin;
  }, [getPositioningStyle]);

  var handleEntering = function handleEntering(element, isAppearing) {
    if (onEntering) {
      onEntering(element, isAppearing);
    }

    setPositioningStyles();
  };

  var handlePaperRef = React.useCallback(function (instance) {
    // #StrictMode ready
    paperRef.current = ReactDOM.findDOMNode(instance);
  }, []);
  React.useEffect(function () {
    if (open) {
      setPositioningStyles();
    }
  });
  React.useImperativeHandle(action, function () {
    return open ? {
      updatePosition: function updatePosition() {
        setPositioningStyles();
      }
    } : null;
  }, [open, setPositioningStyles]);
  React.useEffect(function () {
    if (!open) {
      return undefined;
    }

    var handleResize = debounce(function () {
      setPositioningStyles();
    });
    window.addEventListener('resize', handleResize);
    return function () {
      handleResize.clear();
      window.removeEventListener('resize', handleResize);
    };
  }, [open, setPositioningStyles]);
  var transitionDuration = transitionDurationProp;

  if (transitionDurationProp === 'auto' && !TransitionComponent.muiSupportAuto) {
    transitionDuration = undefined;
  } // If the container prop is provided, use that
  // If the anchorEl prop is provided, use its parent body element as the container
  // If neither are provided let the Modal take care of choosing the container


  var container = containerProp || (anchorEl ? ownerDocument(getAnchorEl(anchorEl)).body : undefined);
  return /*#__PURE__*/React.createElement(Modal$1, _extends$1({
    container: container,
    open: open,
    ref: ref,
    BackdropProps: {
      invisible: true
    },
    className: clsx(classes.root, className)
  }, other), /*#__PURE__*/React.createElement(TransitionComponent, _extends$1({
    appear: true,
    in: open,
    onEnter: onEnter,
    onEntered: onEntered,
    onExit: onExit,
    onExited: onExited,
    onExiting: onExiting,
    timeout: transitionDuration
  }, TransitionProps, {
    onEntering: createChainedFunction(handleEntering, TransitionProps.onEntering)
  }), /*#__PURE__*/React.createElement(Paper$1, _extends$1({
    elevation: elevation,
    ref: handlePaperRef
  }, PaperProps, {
    className: clsx(classes.paper, PaperProps.className)
  }), children)));
});
Popover.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * A ref for imperative actions.
   * It currently only supports updatePosition() action.
   */
  action: refType$1,

  /**
   * A HTML element, or a function that returns it.
   * It's used to set the position of the popover.
   */
  anchorEl: chainPropTypes(PropTypes.oneOfType([HTMLElementType, PropTypes.func]), function (props) {
    if (props.open && (!props.anchorReference || props.anchorReference === 'anchorEl')) {
      var resolvedAnchorEl = getAnchorEl(props.anchorEl);

      if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
        var box = resolvedAnchorEl.getBoundingClientRect();

        if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          return new Error(['Material-UI: The `anchorEl` prop provided to the component is invalid.', 'The anchor element should be part of the document layout.', "Make sure the element is present in the document or that it's not display none."].join('\n'));
        }
      } else {
        return new Error(['Material-UI: The `anchorEl` prop provided to the component is invalid.', "It should be an Element instance but it's `".concat(resolvedAnchorEl, "` instead.")].join('\n'));
      }
    }

    return null;
  }),

  /**
   * This is the point on the anchor where the popover's
   * `anchorEl` will attach to. This is not used when the
   * anchorReference is 'anchorPosition'.
   *
   * Options:
   * vertical: [top, center, bottom];
   * horizontal: [left, center, right].
   */
  anchorOrigin: PropTypes.shape({
    horizontal: PropTypes.oneOfType([PropTypes.oneOf(['center', 'left', 'right']), PropTypes.number]).isRequired,
    vertical: PropTypes.oneOfType([PropTypes.oneOf(['bottom', 'center', 'top']), PropTypes.number]).isRequired
  }),

  /**
   * This is the position that may be used
   * to set the position of the popover.
   * The coordinates are relative to
   * the application's client area.
   */
  anchorPosition: PropTypes.shape({
    left: PropTypes.number.isRequired,
    top: PropTypes.number.isRequired
  }),

  /**
   * This determines which anchor prop to refer to to set
   * the position of the popover.
   */
  anchorReference: PropTypes.oneOf(['anchorEl', 'anchorPosition', 'none']),

  /**
   * The content of the component.
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * A HTML element, component instance, or function that returns either.
   * The `container` will passed to the Modal component.
   *
   * By default, it uses the body of the anchorEl's top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: PropTypes
  /* @typescript-to-proptypes-ignore */
  .oneOfType([HTMLElementType, PropTypes.instanceOf(React.Component), PropTypes.func]),

  /**
   * The elevation of the popover.
   */
  elevation: PropTypes.number,

  /**
   * This function is called in order to retrieve the content anchor element.
   * It's the opposite of the `anchorEl` prop.
   * The content anchor element should be an element inside the popover.
   * It's used to correctly scroll and set the position of the popover.
   * The positioning strategy tries to make the content anchor element just above the
   * anchor element.
   */
  getContentAnchorEl: PropTypes.func,

  /**
   * Specifies how close to the edge of the window the popover can appear.
   */
  marginThreshold: PropTypes.number,

  /**
   * Callback fired when the component requests to be closed.
   */
  onClose: PropTypes.func,

  /**
   * Callback fired before the component is entering.
   * @deprecated Use the `TransitionProps` prop instead.
   */
  onEnter: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

  /**
   * Callback fired when the component has entered.
   * @deprecated Use the `TransitionProps` prop instead.
   */
  onEntered: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

  /**
   * Callback fired when the component is entering.
   * @deprecated Use the `TransitionProps` prop instead.
   */
  onEntering: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

  /**
   * Callback fired before the component is exiting.
   * @deprecated Use the `TransitionProps` prop instead.
   */
  onExit: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

  /**
   * Callback fired when the component has exited.
   * @deprecated Use the `TransitionProps` prop instead.
   */
  onExited: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

  /**
   * Callback fired when the component is exiting.
   * @deprecated Use the `TransitionProps` prop instead.
   */
  onExiting: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

  /**
   * If `true`, the popover is visible.
   */
  open: PropTypes.bool.isRequired,

  /**
   * Props applied to the [`Paper`](/api/paper/) element.
   */
  PaperProps: PropTypes
  /* @typescript-to-proptypes-ignore */
  .shape({
    component: elementTypeAcceptingRef$1
  }),

  /**
   * This is the point on the popover which
   * will attach to the anchor's origin.
   *
   * Options:
   * vertical: [top, center, bottom, x(px)];
   * horizontal: [left, center, right, x(px)].
   */
  transformOrigin: PropTypes.shape({
    horizontal: PropTypes.oneOfType([PropTypes.oneOf(['center', 'left', 'right']), PropTypes.number]).isRequired,
    vertical: PropTypes.oneOfType([PropTypes.oneOf(['bottom', 'center', 'top']), PropTypes.number]).isRequired
  }),

  /**
   * The component used for the transition.
   * [Follow this guide](/components/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   */
  TransitionComponent: PropTypes.elementType,

  /**
   * Set to 'auto' to automatically calculate transition time based on height.
   */
  transitionDuration: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number, PropTypes.shape({
    appear: PropTypes.number,
    enter: PropTypes.number,
    exit: PropTypes.number
  })]),

  /**
   * Props applied to the [`Transition`](http://reactcommunity.org/react-transition-group/transition#Transition-props) element.
   */
  TransitionProps: PropTypes.object
} ;
var Popover$1 = withStyles(styles$7, {
  name: 'MuiPopover'
})(Popover);

/**
 * @ignore - internal component.
 */

var ListContext = React.createContext({});

{
  ListContext.displayName = 'ListContext';
}

var ListContext$1 = ListContext;

var styles$6 = {
  /* Styles applied to the root element. */
  root: {
    listStyle: 'none',
    margin: 0,
    padding: 0,
    position: 'relative'
  },

  /* Styles applied to the root element if `disablePadding={false}`. */
  padding: {
    paddingTop: 8,
    paddingBottom: 8
  },

  /* Styles applied to the root element if dense. */
  dense: {},

  /* Styles applied to the root element if a `subheader` is provided. */
  subheader: {
    paddingTop: 0
  }
};
var List = /*#__PURE__*/React.forwardRef(function List(props, ref) {
  var children = props.children,
      classes = props.classes,
      className = props.className,
      _props$component = props.component,
      Component = _props$component === void 0 ? 'ul' : _props$component,
      _props$dense = props.dense,
      dense = _props$dense === void 0 ? false : _props$dense,
      _props$disablePadding = props.disablePadding,
      disablePadding = _props$disablePadding === void 0 ? false : _props$disablePadding,
      subheader = props.subheader,
      other = _objectWithoutProperties(props, ["children", "classes", "className", "component", "dense", "disablePadding", "subheader"]);

  var context = React.useMemo(function () {
    return {
      dense: dense
    };
  }, [dense]);
  return /*#__PURE__*/React.createElement(ListContext$1.Provider, {
    value: context
  }, /*#__PURE__*/React.createElement(Component, _extends$1({
    className: clsx(classes.root, className, dense && classes.dense, !disablePadding && classes.padding, subheader && classes.subheader),
    ref: ref
  }, other), subheader, children));
});
List.propTypes = {
  /**
   * The content of the component.
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object.isRequired,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes
  /* @typescript-to-proptypes-ignore */
  .elementType,

  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input will be used for
   * the list and list items.
   * The prop is available to descendant components as the `dense` context.
   */
  dense: PropTypes.bool,

  /**
   * If `true`, vertical padding will be removed from the list.
   */
  disablePadding: PropTypes.bool,

  /**
   * The content of the subheader, normally `ListSubheader`.
   */
  subheader: PropTypes.node
} ;
var List$1 = withStyles(styles$6, {
  name: 'MuiList'
})(List);

function nextItem(list, item, disableListWrap) {
  if (list === item) {
    return list.firstChild;
  }

  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }

  return disableListWrap ? null : list.firstChild;
}

function previousItem(list, item, disableListWrap) {
  if (list === item) {
    return disableListWrap ? list.firstChild : list.lastChild;
  }

  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }

  return disableListWrap ? null : list.lastChild;
}

function textCriteriaMatches(nextFocus, textCriteria) {
  if (textCriteria === undefined) {
    return true;
  }

  var text = nextFocus.innerText;

  if (text === undefined) {
    // jsdom doesn't support innerText
    text = nextFocus.textContent;
  }

  text = text.trim().toLowerCase();

  if (text.length === 0) {
    return false;
  }

  if (textCriteria.repeating) {
    return text[0] === textCriteria.keys[0];
  }

  return text.indexOf(textCriteria.keys.join('')) === 0;
}

function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
  var wrappedOnce = false;
  var nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);

  while (nextFocus) {
    // Prevent infinite loop.
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return;
      }

      wrappedOnce = true;
    } // Same logic as useAutocomplete.js


    var nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true';

    if (!nextFocus.hasAttribute('tabindex') || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
      // Move to the next element.
      nextFocus = traversalFunction(list, nextFocus, disableListWrap);
    } else {
      nextFocus.focus();
      return;
    }
  }
}

var useEnhancedEffect = typeof window === 'undefined' ? React.useEffect : React.useLayoutEffect;
/**
 * A permanently displayed menu following https://www.w3.org/TR/wai-aria-practices/#menubutton.
 * It's exposed to help customization of the [`Menu`](/api/menu/) component. If you
 * use it separately you need to move focus into the component manually. Once
 * the focus is placed inside the component it is fully keyboard accessible.
 */

var MenuList = /*#__PURE__*/React.forwardRef(function MenuList(props, ref) {
  var actions = props.actions,
      _props$autoFocus = props.autoFocus,
      autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,
      _props$autoFocusItem = props.autoFocusItem,
      autoFocusItem = _props$autoFocusItem === void 0 ? false : _props$autoFocusItem,
      children = props.children,
      className = props.className,
      _props$disabledItemsF = props.disabledItemsFocusable,
      disabledItemsFocusable = _props$disabledItemsF === void 0 ? false : _props$disabledItemsF,
      _props$disableListWra = props.disableListWrap,
      disableListWrap = _props$disableListWra === void 0 ? false : _props$disableListWra,
      onKeyDown = props.onKeyDown,
      _props$variant = props.variant,
      variant = _props$variant === void 0 ? 'selectedMenu' : _props$variant,
      other = _objectWithoutProperties(props, ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"]);

  var listRef = React.useRef(null);
  var textCriteriaRef = React.useRef({
    keys: [],
    repeating: true,
    previousKeyMatched: true,
    lastTime: null
  });
  useEnhancedEffect(function () {
    if (autoFocus) {
      listRef.current.focus();
    }
  }, [autoFocus]);
  React.useImperativeHandle(actions, function () {
    return {
      adjustStyleForScrollbar: function adjustStyleForScrollbar(containerElement, theme) {
        // Let's ignore that piece of logic if users are already overriding the width
        // of the menu.
        var noExplicitWidth = !listRef.current.style.width;

        if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
          var scrollbarSize = "".concat(getScrollbarSize(), "px");
          listRef.current.style[theme.direction === 'rtl' ? 'paddingLeft' : 'paddingRight'] = scrollbarSize;
          listRef.current.style.width = "calc(100% + ".concat(scrollbarSize, ")");
        }

        return listRef.current;
      }
    };
  }, []);

  var handleKeyDown = function handleKeyDown(event) {
    var list = listRef.current;
    var key = event.key;
    /**
     * @type {Element} - will always be defined since we are in a keydown handler
     * attached to an element. A keydown event is either dispatched to the activeElement
     * or document.body or document.documentElement. Only the first case will
     * trigger this specific handler.
     */

    var currentFocus = ownerDocument(list).activeElement;

    if (key === 'ArrowDown') {
      // Prevent scroll of the page
      event.preventDefault();
      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
    } else if (key === 'ArrowUp') {
      event.preventDefault();
      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
    } else if (key === 'Home') {
      event.preventDefault();
      moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
    } else if (key === 'End') {
      event.preventDefault();
      moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
    } else if (key.length === 1) {
      var criteria = textCriteriaRef.current;
      var lowerKey = key.toLowerCase();
      var currTime = performance.now();

      if (criteria.keys.length > 0) {
        // Reset
        if (currTime - criteria.lastTime > 500) {
          criteria.keys = [];
          criteria.repeating = true;
          criteria.previousKeyMatched = true;
        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
          criteria.repeating = false;
        }
      }

      criteria.lastTime = currTime;
      criteria.keys.push(lowerKey);
      var keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);

      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {
        event.preventDefault();
      } else {
        criteria.previousKeyMatched = false;
      }
    }

    if (onKeyDown) {
      onKeyDown(event);
    }
  };

  var handleOwnRef = React.useCallback(function (instance) {
    // #StrictMode ready
    listRef.current = ReactDOM.findDOMNode(instance);
  }, []);
  var handleRef = useForkRef(handleOwnRef, ref);
  /**
   * the index of the item should receive focus
   * in a `variant="selectedMenu"` it's the first `selected` item
   * otherwise it's the very first item.
   */

  var activeItemIndex = -1; // since we inject focus related props into children we have to do a lookahead
  // to check if there is a `selected` item. We're looking for the last `selected`
  // item and use the first valid item as a fallback

  React.Children.forEach(children, function (child, index) {
    if (! /*#__PURE__*/React.isValidElement(child)) {
      return;
    }

    {
      if (reactIs$1.exports.isFragment(child)) {
        console.error(["Material-UI: The Menu component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
      }
    }

    if (!child.props.disabled) {
      if (variant === 'selectedMenu' && child.props.selected) {
        activeItemIndex = index;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index;
      }
    }
  });
  var items = React.Children.map(children, function (child, index) {
    if (index === activeItemIndex) {
      var newChildProps = {};

      if (autoFocusItem) {
        newChildProps.autoFocus = true;
      }

      if (child.props.tabIndex === undefined && variant === 'selectedMenu') {
        newChildProps.tabIndex = 0;
      }

      return /*#__PURE__*/React.cloneElement(child, newChildProps);
    }

    return child;
  });
  return /*#__PURE__*/React.createElement(List$1, _extends$1({
    role: "menu",
    ref: handleRef,
    className: className,
    onKeyDown: handleKeyDown,
    tabIndex: autoFocus ? 0 : -1
  }, other), items);
});
MenuList.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * If `true`, will focus the `[role="menu"]` container and move into tab order.
   */
  autoFocus: PropTypes.bool,

  /**
   * If `true`, will focus the first menuitem if `variant="menu"` or selected item
   * if `variant="selectedMenu"`.
   */
  autoFocusItem: PropTypes.bool,

  /**
   * MenuList contents, normally `MenuItem`s.
   */
  children: PropTypes.node,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * If `true`, will allow focus on disabled items.
   */
  disabledItemsFocusable: PropTypes.bool,

  /**
   * If `true`, the menu items will not wrap focus.
   */
  disableListWrap: PropTypes.bool,

  /**
   * @ignore
   */
  onKeyDown: PropTypes.func,

  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus
   * and the vertical alignment relative to the anchor element.
   */
  variant: PropTypes.oneOf(['menu', 'selectedMenu'])
} ;
var MenuList$1 = MenuList;

var RTL_ORIGIN = {
  vertical: 'top',
  horizontal: 'right'
};
var LTR_ORIGIN = {
  vertical: 'top',
  horizontal: 'left'
};
var styles$5 = {
  /* Styles applied to the `Paper` component. */
  paper: {
    // specZ: The maximum height of a simple menu should be one or more rows less than the view
    // height. This ensures a tapable area outside of the simple menu with which to dismiss
    // the menu.
    maxHeight: 'calc(100% - 96px)',
    // Add iOS momentum scrolling.
    WebkitOverflowScrolling: 'touch'
  },

  /* Styles applied to the `List` component via `MenuList`. */
  list: {
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  }
};
var Menu = /*#__PURE__*/React.forwardRef(function Menu(props, ref) {
  var _props$autoFocus = props.autoFocus,
      autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus,
      children = props.children,
      classes = props.classes,
      _props$disableAutoFoc = props.disableAutoFocusItem,
      disableAutoFocusItem = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc,
      _props$MenuListProps = props.MenuListProps,
      MenuListProps = _props$MenuListProps === void 0 ? {} : _props$MenuListProps,
      onClose = props.onClose,
      onEnteringProp = props.onEntering,
      open = props.open,
      _props$PaperProps = props.PaperProps,
      PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps,
      PopoverClasses = props.PopoverClasses,
      _props$transitionDura = props.transitionDuration,
      transitionDuration = _props$transitionDura === void 0 ? 'auto' : _props$transitionDura,
      _props$TransitionProp = props.TransitionProps;
  _props$TransitionProp = _props$TransitionProp === void 0 ? {} : _props$TransitionProp;

  var onEntering = _props$TransitionProp.onEntering,
      TransitionProps = _objectWithoutProperties(_props$TransitionProp, ["onEntering"]),
      _props$variant = props.variant,
      variant = _props$variant === void 0 ? 'selectedMenu' : _props$variant,
      other = _objectWithoutProperties(props, ["autoFocus", "children", "classes", "disableAutoFocusItem", "MenuListProps", "onClose", "onEntering", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant"]);

  var theme = useTheme();
  var autoFocusItem = autoFocus && !disableAutoFocusItem && open;
  var menuListActionsRef = React.useRef(null);
  var contentAnchorRef = React.useRef(null);

  var getContentAnchorEl = function getContentAnchorEl() {
    return contentAnchorRef.current;
  };

  var handleEntering = function handleEntering(element, isAppearing) {
    if (menuListActionsRef.current) {
      menuListActionsRef.current.adjustStyleForScrollbar(element, theme);
    }

    if (onEnteringProp) {
      onEnteringProp(element, isAppearing);
    }

    if (onEntering) {
      onEntering(element, isAppearing);
    }
  };

  var handleListKeyDown = function handleListKeyDown(event) {
    if (event.key === 'Tab') {
      event.preventDefault();

      if (onClose) {
        onClose(event, 'tabKeyDown');
      }
    }
  };
  /**
   * the index of the item should receive focus
   * in a `variant="selectedMenu"` it's the first `selected` item
   * otherwise it's the very first item.
   */


  var activeItemIndex = -1; // since we inject focus related props into children we have to do a lookahead
  // to check if there is a `selected` item. We're looking for the last `selected`
  // item and use the first valid item as a fallback

  React.Children.map(children, function (child, index) {
    if (! /*#__PURE__*/React.isValidElement(child)) {
      return;
    }

    {
      if (reactIs$1.exports.isFragment(child)) {
        console.error(["Material-UI: The Menu component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
      }
    }

    if (!child.props.disabled) {
      if (variant !== "menu" && child.props.selected) {
        activeItemIndex = index;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index;
      }
    }
  });
  var items = React.Children.map(children, function (child, index) {
    if (index === activeItemIndex) {
      return /*#__PURE__*/React.cloneElement(child, {
        ref: function ref(instance) {
          // #StrictMode ready
          contentAnchorRef.current = ReactDOM.findDOMNode(instance);
          setRef(child.ref, instance);
        }
      });
    }

    return child;
  });
  return /*#__PURE__*/React.createElement(Popover$1, _extends$1({
    getContentAnchorEl: getContentAnchorEl,
    classes: PopoverClasses,
    onClose: onClose,
    TransitionProps: _extends$1({
      onEntering: handleEntering
    }, TransitionProps),
    anchorOrigin: theme.direction === 'rtl' ? RTL_ORIGIN : LTR_ORIGIN,
    transformOrigin: theme.direction === 'rtl' ? RTL_ORIGIN : LTR_ORIGIN,
    PaperProps: _extends$1({}, PaperProps, {
      classes: _extends$1({}, PaperProps.classes, {
        root: classes.paper
      })
    }),
    open: open,
    ref: ref,
    transitionDuration: transitionDuration
  }, other), /*#__PURE__*/React.createElement(MenuList$1, _extends$1({
    onKeyDown: handleListKeyDown,
    actions: menuListActionsRef,
    autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
    autoFocusItem: autoFocusItem,
    variant: variant
  }, MenuListProps, {
    className: clsx(classes.list, MenuListProps.className)
  }), items));
});
Menu.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * A HTML element, or a function that returns it.
   * It's used to set the position of the menu.
   */
  anchorEl: PropTypes
  /* @typescript-to-proptypes-ignore */
  .oneOfType([HTMLElementType, PropTypes.func]),

  /**
   * If `true` (Default) will focus the `[role="menu"]` if no focusable child is found. Disabled
   * children are not focusable. If you set this prop to `false` focus will be placed
   * on the parent modal container. This has severe accessibility implications
   * and should only be considered if you manage focus otherwise.
   */
  autoFocus: PropTypes.bool,

  /**
   * Menu contents, normally `MenuItem`s.
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * When opening the menu will not focus the active item but the `[role="menu"]`
   * unless `autoFocus` is also set to `false`. Not using the default means not
   * following WAI-ARIA authoring practices. Please be considerate about possible
   * accessibility implications.
   */
  disableAutoFocusItem: PropTypes.bool,

  /**
   * Props applied to the [`MenuList`](/api/menu-list/) element.
   */
  MenuListProps: PropTypes.object,

  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`, `"tabKeyDown"`.
   */
  onClose: PropTypes.func,

  /**
   * Callback fired before the Menu enters.
   * @deprecated Use the `TransitionProps` prop instead.
   */
  onEnter: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

  /**
   * Callback fired when the Menu has entered.
   * @deprecated Use the `TransitionProps` prop instead.
   */
  onEntered: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

  /**
   * Callback fired when the Menu is entering.
   * @deprecated Use the `TransitionProps` prop instead.
   */
  onEntering: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

  /**
   * Callback fired before the Menu exits.
   * @deprecated Use the `TransitionProps` prop instead.
   */
  onExit: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

  /**
   * Callback fired when the Menu has exited.
   * @deprecated Use the `TransitionProps` prop instead.
   */
  onExited: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

  /**
   * Callback fired when the Menu is exiting.
   * @deprecated Use the `TransitionProps` prop instead.
   */
  onExiting: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

  /**
   * If `true`, the menu is visible.
   */
  open: PropTypes.bool.isRequired,

  /**
   * @ignore
   */
  PaperProps: PropTypes.object,

  /**
   * `classes` prop applied to the [`Popover`](/api/popover/) element.
   */
  PopoverClasses: PropTypes.object,

  /**
   * The length of the transition in `ms`, or 'auto'
   */
  transitionDuration: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number, PropTypes.shape({
    appear: PropTypes.number,
    enter: PropTypes.number,
    exit: PropTypes.number
  })]),

  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition) component.
   */
  TransitionProps: PropTypes.object,

  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus
   * and the vertical alignment relative to the anchor element.
   */
  variant: PropTypes.oneOf(['menu', 'selectedMenu'])
} ;
var Menu$1 = withStyles(styles$5, {
  name: 'MuiMenu'
})(Menu);

function areEqualValues(a, b) {
  if (_typeof$1(b) === 'object' && b !== null) {
    return a === b;
  }

  return String(a) === String(b);
}

function isEmpty(display) {
  return display == null || typeof display === 'string' && !display.trim();
}
/**
 * @ignore - internal component.
 */


var SelectInput = /*#__PURE__*/React.forwardRef(function SelectInput(props, ref) {
  var ariaLabel = props['aria-label'],
      autoFocus = props.autoFocus,
      autoWidth = props.autoWidth,
      children = props.children,
      classes = props.classes,
      className = props.className,
      defaultValue = props.defaultValue,
      disabled = props.disabled,
      displayEmpty = props.displayEmpty,
      IconComponent = props.IconComponent,
      inputRefProp = props.inputRef,
      labelId = props.labelId,
      _props$MenuProps = props.MenuProps,
      MenuProps = _props$MenuProps === void 0 ? {} : _props$MenuProps,
      multiple = props.multiple,
      name = props.name,
      onBlur = props.onBlur,
      onChange = props.onChange,
      onClose = props.onClose,
      onFocus = props.onFocus,
      onOpen = props.onOpen,
      openProp = props.open,
      readOnly = props.readOnly,
      renderValue = props.renderValue,
      _props$SelectDisplayP = props.SelectDisplayProps,
      SelectDisplayProps = _props$SelectDisplayP === void 0 ? {} : _props$SelectDisplayP,
      tabIndexProp = props.tabIndex;
      props.type;
      var valueProp = props.value,
      _props$variant = props.variant,
      variant = _props$variant === void 0 ? 'standard' : _props$variant,
      other = _objectWithoutProperties(props, ["aria-label", "autoFocus", "autoWidth", "children", "classes", "className", "defaultValue", "disabled", "displayEmpty", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"]);

  var _useControlled = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: 'Select'
  }),
      _useControlled2 = _slicedToArray(_useControlled, 2),
      value = _useControlled2[0],
      setValue = _useControlled2[1];

  var inputRef = React.useRef(null);

  var _React$useState = React.useState(null),
      displayNode = _React$useState[0],
      setDisplayNode = _React$useState[1];

  var _React$useRef = React.useRef(openProp != null),
      isOpenControlled = _React$useRef.current;

  var _React$useState2 = React.useState(),
      menuMinWidthState = _React$useState2[0],
      setMenuMinWidthState = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      openState = _React$useState3[0],
      setOpenState = _React$useState3[1];

  var handleRef = useForkRef(ref, inputRefProp);
  React.useImperativeHandle(handleRef, function () {
    return {
      focus: function focus() {
        displayNode.focus();
      },
      node: inputRef.current,
      value: value
    };
  }, [displayNode, value]);
  React.useEffect(function () {
    if (autoFocus && displayNode) {
      displayNode.focus();
    }
  }, [autoFocus, displayNode]);
  React.useEffect(function () {
    if (displayNode) {
      var label = ownerDocument(displayNode).getElementById(labelId);

      if (label) {
        var handler = function handler() {
          if (getSelection().isCollapsed) {
            displayNode.focus();
          }
        };

        label.addEventListener('click', handler);
        return function () {
          label.removeEventListener('click', handler);
        };
      }
    }

    return undefined;
  }, [labelId, displayNode]);

  var update = function update(open, event) {
    if (open) {
      if (onOpen) {
        onOpen(event);
      }
    } else if (onClose) {
      onClose(event);
    }

    if (!isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : displayNode.clientWidth);
      setOpenState(open);
    }
  };

  var handleMouseDown = function handleMouseDown(event) {
    // Ignore everything but left-click
    if (event.button !== 0) {
      return;
    } // Hijack the default focus behavior.


    event.preventDefault();
    displayNode.focus();
    update(true, event);
  };

  var handleClose = function handleClose(event) {
    update(false, event);
  };

  var childrenArray = React.Children.toArray(children); // Support autofill.

  var handleChange = function handleChange(event) {
    var index = childrenArray.map(function (child) {
      return child.props.value;
    }).indexOf(event.target.value);

    if (index === -1) {
      return;
    }

    var child = childrenArray[index];
    setValue(child.props.value);

    if (onChange) {
      onChange(event, child);
    }
  };

  var handleItemClick = function handleItemClick(child) {
    return function (event) {
      if (!multiple) {
        update(false, event);
      }

      var newValue;

      if (multiple) {
        newValue = Array.isArray(value) ? value.slice() : [];
        var itemIndex = value.indexOf(child.props.value);

        if (itemIndex === -1) {
          newValue.push(child.props.value);
        } else {
          newValue.splice(itemIndex, 1);
        }
      } else {
        newValue = child.props.value;
      }

      if (child.props.onClick) {
        child.props.onClick(event);
      }

      if (value === newValue) {
        return;
      }

      setValue(newValue);

      if (onChange) {
        event.persist(); // Preact support, target is read only property on a native event.

        Object.defineProperty(event, 'target', {
          writable: true,
          value: {
            value: newValue,
            name: name
          }
        });
        onChange(event, child);
      }
    };
  };

  var handleKeyDown = function handleKeyDown(event) {
    if (!readOnly) {
      var validKeys = [' ', 'ArrowUp', 'ArrowDown', // The native select doesn't respond to enter on MacOS, but it's recommended by
      // https://www.w3.org/TR/wai-aria-practices/examples/listbox/listbox-collapsible.html
      'Enter'];

      if (validKeys.indexOf(event.key) !== -1) {
        event.preventDefault();
        update(true, event);
      }
    }
  };

  var open = displayNode !== null && (isOpenControlled ? openProp : openState);

  var handleBlur = function handleBlur(event) {
    // if open event.stopImmediatePropagation
    if (!open && onBlur) {
      event.persist(); // Preact support, target is read only property on a native event.

      Object.defineProperty(event, 'target', {
        writable: true,
        value: {
          value: value,
          name: name
        }
      });
      onBlur(event);
    }
  };

  delete other['aria-invalid'];
  var display;
  var displaySingle;
  var displayMultiple = [];
  var computeDisplay = false;
  var foundMatch = false; // No need to display any value if the field is empty.

  if (isFilled({
    value: value
  }) || displayEmpty) {
    if (renderValue) {
      display = renderValue(value);
    } else {
      computeDisplay = true;
    }
  }

  var items = childrenArray.map(function (child) {
    if (! /*#__PURE__*/React.isValidElement(child)) {
      return null;
    }

    {
      if (reactIs$1.exports.isFragment(child)) {
        console.error(["Material-UI: The Select component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
      }
    }

    var selected;

    if (multiple) {
      if (!Array.isArray(value)) {
        throw new Error("Material-UI: The `value` prop must be an array when using the `Select` component with `multiple`." );
      }

      selected = value.some(function (v) {
        return areEqualValues(v, child.props.value);
      });

      if (selected && computeDisplay) {
        displayMultiple.push(child.props.children);
      }
    } else {
      selected = areEqualValues(value, child.props.value);

      if (selected && computeDisplay) {
        displaySingle = child.props.children;
      }
    }

    if (selected) {
      foundMatch = true;
    }

    return /*#__PURE__*/React.cloneElement(child, {
      'aria-selected': selected ? 'true' : undefined,
      onClick: handleItemClick(child),
      onKeyUp: function onKeyUp(event) {
        if (event.key === ' ') {
          // otherwise our MenuItems dispatches a click event
          // it's not behavior of the native <option> and causes
          // the select to close immediately since we open on space keydown
          event.preventDefault();
        }

        if (child.props.onKeyUp) {
          child.props.onKeyUp(event);
        }
      },
      role: 'option',
      selected: selected,
      value: undefined,
      // The value is most likely not a valid HTML attribute.
      'data-value': child.props.value // Instead, we provide it as a data attribute.

    });
  });

  {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useEffect(function () {
      if (!foundMatch && !multiple && value !== '') {
        var values = childrenArray.map(function (child) {
          return child.props.value;
        });
        console.warn(["Material-UI: You have provided an out-of-range value `".concat(value, "` for the select ").concat(name ? "(name=\"".concat(name, "\") ") : '', "component."), "Consider providing a value that matches one of the available options or ''.", "The available values are ".concat(values.filter(function (x) {
          return x != null;
        }).map(function (x) {
          return "`".concat(x, "`");
        }).join(', ') || '""', ".")].join('\n'));
      }
    }, [foundMatch, childrenArray, multiple, name, value]);
  }

  if (computeDisplay) {
    display = multiple ? displayMultiple.join(', ') : displaySingle;
  } // Avoid performing a layout computation in the render method.


  var menuMinWidth = menuMinWidthState;

  if (!autoWidth && isOpenControlled && displayNode) {
    menuMinWidth = displayNode.clientWidth;
  }

  var tabIndex;

  if (typeof tabIndexProp !== 'undefined') {
    tabIndex = tabIndexProp;
  } else {
    tabIndex = disabled ? null : 0;
  }

  var buttonId = SelectDisplayProps.id || (name ? "mui-component-select-".concat(name) : undefined);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", _extends$1({
    className: clsx(classes.root, // TODO v5: merge root and select
    classes.select, classes.selectMenu, classes[variant], className, disabled && classes.disabled),
    ref: setDisplayNode,
    tabIndex: tabIndex,
    role: "button",
    "aria-disabled": disabled ? 'true' : undefined,
    "aria-expanded": open ? 'true' : undefined,
    "aria-haspopup": "listbox",
    "aria-label": ariaLabel,
    "aria-labelledby": [labelId, buttonId].filter(Boolean).join(' ') || undefined,
    onKeyDown: handleKeyDown,
    onMouseDown: disabled || readOnly ? null : handleMouseDown,
    onBlur: handleBlur,
    onFocus: onFocus
  }, SelectDisplayProps, {
    // The id is required for proper a11y
    id: buttonId
  }), isEmpty(display) ?
  /*#__PURE__*/
  // eslint-disable-next-line react/no-danger
  React.createElement("span", {
    dangerouslySetInnerHTML: {
      __html: '&#8203;'
    }
  }) : display), /*#__PURE__*/React.createElement("input", _extends$1({
    value: Array.isArray(value) ? value.join(',') : value,
    name: name,
    ref: inputRef,
    "aria-hidden": true,
    onChange: handleChange,
    tabIndex: -1,
    className: classes.nativeInput,
    autoFocus: autoFocus
  }, other)), /*#__PURE__*/React.createElement(IconComponent, {
    className: clsx(classes.icon, classes["icon".concat(capitalize(variant))], open && classes.iconOpen, disabled && classes.disabled)
  }), /*#__PURE__*/React.createElement(Menu$1, _extends$1({
    id: "menu-".concat(name || ''),
    anchorEl: displayNode,
    open: open,
    onClose: handleClose
  }, MenuProps, {
    MenuListProps: _extends$1({
      'aria-labelledby': labelId,
      role: 'listbox',
      disableListWrap: true
    }, MenuProps.MenuListProps),
    PaperProps: _extends$1({}, MenuProps.PaperProps, {
      style: _extends$1({
        minWidth: menuMinWidth
      }, MenuProps.PaperProps != null ? MenuProps.PaperProps.style : null)
    })
  }), items));
});
SelectInput.propTypes = {
  /**
   * @ignore
   */
  'aria-label': PropTypes.string,

  /**
   * @ignore
   */
  autoFocus: PropTypes.bool,

  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   */
  autoWidth: PropTypes.bool,

  /**
   * The option elements to populate the select with.
   * Can be some `<MenuItem>` elements.
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object.isRequired,

  /**
   * The CSS class name of the select element.
   */
  className: PropTypes.string,

  /**
   * The default element value. Use when the component is not controlled.
   */
  defaultValue: PropTypes.any,

  /**
   * If `true`, the select will be disabled.
   */
  disabled: PropTypes.bool,

  /**
   * If `true`, the selected item is displayed even if its value is empty.
   */
  displayEmpty: PropTypes.bool,

  /**
   * The icon that displays the arrow.
   */
  IconComponent: PropTypes.elementType.isRequired,

  /**
   * Imperative handle implementing `{ value: T, node: HTMLElement, focus(): void }`
   * Equivalent to `ref`
   */
  inputRef: refType$1,

  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: PropTypes.string,

  /**
   * Props applied to the [`Menu`](/api/menu/) element.
   */
  MenuProps: PropTypes.object,

  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   */
  multiple: PropTypes.bool,

  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: PropTypes.string,

  /**
   * @ignore
   */
  onBlur: PropTypes.func,

  /**
   * Callback function fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * @param {object} [child] The react element that was selected.
   */
  onChange: PropTypes.func,

  /**
   * Callback fired when the component requests to be closed.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: PropTypes.func,

  /**
   * @ignore
   */
  onFocus: PropTypes.func,

  /**
   * Callback fired when the component requests to be opened.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: PropTypes.func,

  /**
   * Control `select` open state.
   */
  open: PropTypes.bool,

  /**
   * @ignore
   */
  readOnly: PropTypes.bool,

  /**
   * Render the selected value.
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: PropTypes.func,

  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: PropTypes.object,

  /**
   * @ignore
   */
  tabIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * @ignore
   */
  type: PropTypes.any,

  /**
   * The input value.
   */
  value: PropTypes.any,

  /**
   * The variant to use.
   */
  variant: PropTypes.oneOf(['standard', 'outlined', 'filled'])
} ;
var SelectInput$1 = SelectInput;

/**
 * @ignore - internal component.
 */

var ArrowDropDownIcon = createSvgIcon( /*#__PURE__*/React.createElement("path", {
  d: "M7 10l5 5 5-5z"
}), 'ArrowDropDown');

/**
 * @ignore - internal component.
 */

var NativeSelectInput = /*#__PURE__*/React.forwardRef(function NativeSelectInput(props, ref) {
  var classes = props.classes,
      className = props.className,
      disabled = props.disabled,
      IconComponent = props.IconComponent,
      inputRef = props.inputRef,
      _props$variant = props.variant,
      variant = _props$variant === void 0 ? 'standard' : _props$variant,
      other = _objectWithoutProperties(props, ["classes", "className", "disabled", "IconComponent", "inputRef", "variant"]);

  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("select", _extends$1({
    className: clsx(classes.root, // TODO v5: merge root and select
    classes.select, classes[variant], className, disabled && classes.disabled),
    disabled: disabled,
    ref: inputRef || ref
  }, other)), props.multiple ? null : /*#__PURE__*/React.createElement(IconComponent, {
    className: clsx(classes.icon, classes["icon".concat(capitalize(variant))], disabled && classes.disabled)
  }));
});
NativeSelectInput.propTypes = {
  /**
   * The option elements to populate the select with.
   * Can be some `<option>` elements.
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object.isRequired,

  /**
   * The CSS class name of the select element.
   */
  className: PropTypes.string,

  /**
   * If `true`, the select will be disabled.
   */
  disabled: PropTypes.bool,

  /**
   * The icon that displays the arrow.
   */
  IconComponent: PropTypes.elementType.isRequired,

  /**
   * Use that prop to pass a ref to the native select element.
   * @deprecated
   */
  inputRef: refType$1,

  /**
   * @ignore
   */
  multiple: PropTypes.bool,

  /**
   * Name attribute of the `select` or hidden `input` element.
   */
  name: PropTypes.string,

  /**
   * Callback function fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: PropTypes.func,

  /**
   * The input value.
   */
  value: PropTypes.any,

  /**
   * The variant to use.
   */
  variant: PropTypes.oneOf(['standard', 'outlined', 'filled'])
} ;
var NativeSelectInput$1 = NativeSelectInput;

var styles$4 = function styles(theme) {
  return {
    /* Styles applied to the select component `root` class. */
    root: {},

    /* Styles applied to the select component `select` class. */
    select: {
      '-moz-appearance': 'none',
      // Reset
      '-webkit-appearance': 'none',
      // Reset
      // When interacting quickly, the text can end up selected.
      // Native select can't be selected either.
      userSelect: 'none',
      borderRadius: 0,
      // Reset
      minWidth: 16,
      // So it doesn't collapse.
      cursor: 'pointer',
      '&:focus': {
        // Show that it's not an text input
        backgroundColor: theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)',
        borderRadius: 0 // Reset Chrome style

      },
      // Remove IE 11 arrow
      '&::-ms-expand': {
        display: 'none'
      },
      '&$disabled': {
        cursor: 'default'
      },
      '&[multiple]': {
        height: 'auto'
      },
      '&:not([multiple]) option, &:not([multiple]) optgroup': {
        backgroundColor: theme.palette.background.paper
      },
      '&&': {
        paddingRight: 24
      }
    },

    /* Styles applied to the select component if `variant="filled"`. */
    filled: {
      '&&': {
        paddingRight: 32
      }
    },

    /* Styles applied to the select component if `variant="outlined"`. */
    outlined: {
      borderRadius: theme.shape.borderRadius,
      '&&': {
        paddingRight: 32
      }
    },

    /* Styles applied to the select component `selectMenu` class. */
    selectMenu: {
      height: 'auto',
      // Resets for multpile select with chips
      minHeight: '1.1876em',
      // Required for select\text-field height consistency
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',
      overflow: 'hidden'
    },

    /* Pseudo-class applied to the select component `disabled` class. */
    disabled: {},

    /* Styles applied to the icon component. */
    icon: {
      // We use a position absolute over a flexbox in order to forward the pointer events
      // to the input and to support wrapping tags..
      position: 'absolute',
      right: 0,
      top: 'calc(50% - 12px)',
      // Center vertically
      pointerEvents: 'none',
      // Don't block pointer events on the select under the icon.
      color: theme.palette.action.active,
      '&$disabled': {
        color: theme.palette.action.disabled
      }
    },

    /* Styles applied to the icon component if the popup is open. */
    iconOpen: {
      transform: 'rotate(180deg)'
    },

    /* Styles applied to the icon component if `variant="filled"`. */
    iconFilled: {
      right: 7
    },

    /* Styles applied to the icon component if `variant="outlined"`. */
    iconOutlined: {
      right: 7
    },

    /* Styles applied to the underlying native input component. */
    nativeInput: {
      bottom: 0,
      left: 0,
      position: 'absolute',
      opacity: 0,
      pointerEvents: 'none',
      width: '100%'
    }
  };
};
var defaultInput = /*#__PURE__*/React.createElement(Input$1, null);
/**
 * An alternative to `<Select native />` with a much smaller bundle size footprint.
 */

var NativeSelect = /*#__PURE__*/React.forwardRef(function NativeSelect(props, ref) {
  var children = props.children,
      classes = props.classes,
      _props$IconComponent = props.IconComponent,
      IconComponent = _props$IconComponent === void 0 ? ArrowDropDownIcon : _props$IconComponent,
      _props$input = props.input,
      input = _props$input === void 0 ? defaultInput : _props$input,
      inputProps = props.inputProps;
      props.variant;
      var other = _objectWithoutProperties(props, ["children", "classes", "IconComponent", "input", "inputProps", "variant"]);

  var muiFormControl = useFormControl();
  var fcs = formControlState({
    props: props,
    muiFormControl: muiFormControl,
    states: ['variant']
  });
  return /*#__PURE__*/React.cloneElement(input, _extends$1({
    // Most of the logic is implemented in `NativeSelectInput`.
    // The `Select` component is a simple API wrapper to expose something better to play with.
    inputComponent: NativeSelectInput$1,
    inputProps: _extends$1({
      children: children,
      classes: classes,
      IconComponent: IconComponent,
      variant: fcs.variant,
      type: undefined
    }, inputProps, input ? input.props.inputProps : {}),
    ref: ref
  }, other));
});
NativeSelect.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * The option elements to populate the select with.
   * Can be some `<option>` elements.
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * The icon that displays the arrow.
   */
  IconComponent: PropTypes.elementType,

  /**
   * An `Input` element; does not have to be a material-ui specific `Input`.
   */
  input: PropTypes.element,

  /**
   * Attributes applied to the `select` element.
   */
  inputProps: PropTypes.object,

  /**
   * Callback function fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: PropTypes.func,

  /**
   * The input value. The DOM API casts this to a string.
   */
  value: PropTypes.any,

  /**
   * The variant to use.
   */
  variant: PropTypes.oneOf(['filled', 'outlined', 'standard'])
} ;
NativeSelect.muiName = 'Select';
withStyles(styles$4, {
  name: 'MuiNativeSelect'
})(NativeSelect);

var styles$3 = styles$4;

var _ref = /*#__PURE__*/React.createElement(Input$1, null);

var _ref2 = /*#__PURE__*/React.createElement(FilledInput$1, null);

var Select = /*#__PURE__*/React.forwardRef(function Select(props, ref) {
  var _props$autoWidth = props.autoWidth,
      autoWidth = _props$autoWidth === void 0 ? false : _props$autoWidth,
      children = props.children,
      classes = props.classes,
      _props$displayEmpty = props.displayEmpty,
      displayEmpty = _props$displayEmpty === void 0 ? false : _props$displayEmpty,
      _props$IconComponent = props.IconComponent,
      IconComponent = _props$IconComponent === void 0 ? ArrowDropDownIcon : _props$IconComponent,
      id = props.id,
      input = props.input,
      inputProps = props.inputProps,
      label = props.label,
      labelId = props.labelId,
      _props$labelWidth = props.labelWidth,
      labelWidth = _props$labelWidth === void 0 ? 0 : _props$labelWidth,
      MenuProps = props.MenuProps,
      _props$multiple = props.multiple,
      multiple = _props$multiple === void 0 ? false : _props$multiple,
      _props$native = props.native,
      native = _props$native === void 0 ? false : _props$native,
      onClose = props.onClose,
      onOpen = props.onOpen,
      open = props.open,
      renderValue = props.renderValue,
      SelectDisplayProps = props.SelectDisplayProps,
      _props$variant = props.variant,
      variantProps = _props$variant === void 0 ? 'standard' : _props$variant,
      other = _objectWithoutProperties(props, ["autoWidth", "children", "classes", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "labelWidth", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"]);

  var inputComponent = native ? NativeSelectInput$1 : SelectInput$1;
  var muiFormControl = useFormControl();
  var fcs = formControlState({
    props: props,
    muiFormControl: muiFormControl,
    states: ['variant']
  });
  var variant = fcs.variant || variantProps;
  var InputComponent = input || {
    standard: _ref,
    outlined: /*#__PURE__*/React.createElement(OutlinedInput$1, {
      label: label,
      labelWidth: labelWidth
    }),
    filled: _ref2
  }[variant];
  return /*#__PURE__*/React.cloneElement(InputComponent, _extends$1({
    // Most of the logic is implemented in `SelectInput`.
    // The `Select` component is a simple API wrapper to expose something better to play with.
    inputComponent: inputComponent,
    inputProps: _extends$1({
      children: children,
      IconComponent: IconComponent,
      variant: variant,
      type: undefined,
      // We render a select. We can ignore the type provided by the `Input`.
      multiple: multiple
    }, native ? {
      id: id
    } : {
      autoWidth: autoWidth,
      displayEmpty: displayEmpty,
      labelId: labelId,
      MenuProps: MenuProps,
      onClose: onClose,
      onOpen: onOpen,
      open: open,
      renderValue: renderValue,
      SelectDisplayProps: _extends$1({
        id: id
      }, SelectDisplayProps)
    }, inputProps, {
      classes: inputProps ? mergeClasses({
        baseClasses: classes,
        newClasses: inputProps.classes,
        Component: Select
      }) : classes
    }, input ? input.props.inputProps : {}),
    ref: ref
  }, other));
});
Select.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * If `true`, the width of the popover will automatically be set according to the items inside the
   * menu, otherwise it will be at least the width of the select input.
   */
  autoWidth: PropTypes.bool,

  /**
   * The option elements to populate the select with.
   * Can be some `MenuItem` when `native` is false and `option` when `native` is true.
   *
   * The `MenuItem` elements **must** be direct descendants when `native` is false.
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * The default element value. Use when the component is not controlled.
   */
  defaultValue: PropTypes.any,

  /**
   * If `true`, a value is displayed even if no items are selected.
   *
   * In order to display a meaningful value, a function should be passed to the `renderValue` prop which returns the value to be displayed when no items are selected.
   * You can only use it when the `native` prop is `false` (default).
   */
  displayEmpty: PropTypes.bool,

  /**
   * The icon that displays the arrow.
   */
  IconComponent: PropTypes.elementType,

  /**
   * The `id` of the wrapper element or the `select` element when `native`.
   */
  id: PropTypes.string,

  /**
   * An `Input` element; does not have to be a material-ui specific `Input`.
   */
  input: PropTypes.element,

  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * When `native` is `true`, the attributes are applied on the `select` element.
   */
  inputProps: PropTypes.object,

  /**
   * See [OutlinedInput#label](/api/outlined-input/#props)
   */
  label: PropTypes.node,

  /**
   * The ID of an element that acts as an additional label. The Select will
   * be labelled by the additional label and the selected value.
   */
  labelId: PropTypes.string,

  /**
   * See [OutlinedInput#label](/api/outlined-input/#props)
   */
  labelWidth: PropTypes.number,

  /**
   * Props applied to the [`Menu`](/api/menu/) element.
   */
  MenuProps: PropTypes.object,

  /**
   * If `true`, `value` must be an array and the menu will support multiple selections.
   */
  multiple: PropTypes.bool,

  /**
   * If `true`, the component will be using a native `select` element.
   */
  native: PropTypes.bool,

  /**
   * Callback function fired when a menu item is selected.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * @param {object} [child] The react element that was selected when `native` is `false` (default).
   */
  onChange: PropTypes.func,

  /**
   * Callback fired when the component requests to be closed.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: PropTypes.func,

  /**
   * Callback fired when the component requests to be opened.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: PropTypes.func,

  /**
   * Control `select` open state.
   * You can only use it when the `native` prop is `false` (default).
   */
  open: PropTypes.bool,

  /**
   * Render the selected value.
   * You can only use it when the `native` prop is `false` (default).
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderValue: PropTypes.func,

  /**
   * Props applied to the clickable div element.
   */
  SelectDisplayProps: PropTypes.object,

  /**
   * The input value. Providing an empty string will select no options.
   * This prop is required when the `native` prop is `false` (default).
   * Set to an empty string `''` if you don't want any of the available options to be selected.
   *
   * If the value is an object it must have reference equality with the option in order to be selected.
   * If the value is not an object, the string representation must match with the string representation of the option in order to be selected.
   */
  value: PropTypes.any,

  /**
   * The variant to use.
   */
  variant: PropTypes.oneOf(['filled', 'outlined', 'standard'])
} ;
Select.muiName = 'Select';
var Select$1 = withStyles(styles$3, {
  name: 'MuiSelect'
})(Select);

var variantComponent = {
  standard: Input$1,
  filled: FilledInput$1,
  outlined: OutlinedInput$1
};
var styles$2 = {
  /* Styles applied to the root element. */
  root: {}
};
/**
 * The `TextField` is a convenience wrapper for the most common cases (80%).
 * It cannot be all things to all people, otherwise the API would grow out of control.
 *
 * ## Advanced Configuration
 *
 * It's important to understand that the text field is a simple abstraction
 * on top of the following components:
 *
 * - [FormControl](/api/form-control/)
 * - [InputLabel](/api/input-label/)
 * - [FilledInput](/api/filled-input/)
 * - [OutlinedInput](/api/outlined-input/)
 * - [Input](/api/input/)
 * - [FormHelperText](/api/form-helper-text/)
 *
 * If you wish to alter the props applied to the `input` element, you can do so as follows:
 *
 * ```jsx
 * const inputProps = {
 *   step: 300,
 * };
 *
 * return <TextField id="time" type="time" inputProps={inputProps} />;
 * ```
 *
 * For advanced cases, please look at the source of TextField by clicking on the
 * "Edit this page" button above. Consider either:
 *
 * - using the upper case props for passing values directly to the components
 * - using the underlying components directly as shown in the demos
 */

var TextField = /*#__PURE__*/React.forwardRef(function TextField(props, ref) {
  var autoComplete = props.autoComplete,
      _props$autoFocus = props.autoFocus,
      autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,
      children = props.children,
      classes = props.classes,
      className = props.className,
      _props$color = props.color,
      color = _props$color === void 0 ? 'primary' : _props$color,
      defaultValue = props.defaultValue,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      _props$error = props.error,
      error = _props$error === void 0 ? false : _props$error,
      FormHelperTextProps = props.FormHelperTextProps,
      _props$fullWidth = props.fullWidth,
      fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
      helperText = props.helperText,
      hiddenLabel = props.hiddenLabel,
      id = props.id,
      InputLabelProps = props.InputLabelProps,
      inputProps = props.inputProps,
      InputProps = props.InputProps,
      inputRef = props.inputRef,
      label = props.label,
      _props$multiline = props.multiline,
      multiline = _props$multiline === void 0 ? false : _props$multiline,
      name = props.name,
      onBlur = props.onBlur,
      onChange = props.onChange,
      onFocus = props.onFocus,
      placeholder = props.placeholder,
      _props$required = props.required,
      required = _props$required === void 0 ? false : _props$required,
      rows = props.rows,
      rowsMax = props.rowsMax,
      maxRows = props.maxRows,
      minRows = props.minRows,
      _props$select = props.select,
      select = _props$select === void 0 ? false : _props$select,
      SelectProps = props.SelectProps,
      type = props.type,
      value = props.value,
      _props$variant = props.variant,
      variant = _props$variant === void 0 ? 'standard' : _props$variant,
      other = _objectWithoutProperties(props, ["autoComplete", "autoFocus", "children", "classes", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "hiddenLabel", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "rowsMax", "maxRows", "minRows", "select", "SelectProps", "type", "value", "variant"]);

  {
    if (select && !children) {
      console.error('Material-UI: `children` must be passed when using the `TextField` component with `select`.');
    }
  }

  var InputMore = {};

  if (variant === 'outlined') {
    if (InputLabelProps && typeof InputLabelProps.shrink !== 'undefined') {
      InputMore.notched = InputLabelProps.shrink;
    }

    if (label) {
      var _InputLabelProps$requ;

      var displayRequired = (_InputLabelProps$requ = InputLabelProps === null || InputLabelProps === void 0 ? void 0 : InputLabelProps.required) !== null && _InputLabelProps$requ !== void 0 ? _InputLabelProps$requ : required;
      InputMore.label = /*#__PURE__*/React.createElement(React.Fragment, null, label, displayRequired && "\xA0*");
    }
  }

  if (select) {
    // unset defaults from textbox inputs
    if (!SelectProps || !SelectProps.native) {
      InputMore.id = undefined;
    }

    InputMore['aria-describedby'] = undefined;
  }

  var helperTextId = helperText && id ? "".concat(id, "-helper-text") : undefined;
  var inputLabelId = label && id ? "".concat(id, "-label") : undefined;
  var InputComponent = variantComponent[variant];
  var InputElement = /*#__PURE__*/React.createElement(InputComponent, _extends$1({
    "aria-describedby": helperTextId,
    autoComplete: autoComplete,
    autoFocus: autoFocus,
    defaultValue: defaultValue,
    fullWidth: fullWidth,
    multiline: multiline,
    name: name,
    rows: rows,
    rowsMax: rowsMax,
    maxRows: maxRows,
    minRows: minRows,
    type: type,
    value: value,
    id: id,
    inputRef: inputRef,
    onBlur: onBlur,
    onChange: onChange,
    onFocus: onFocus,
    placeholder: placeholder,
    inputProps: inputProps
  }, InputMore, InputProps));
  return /*#__PURE__*/React.createElement(FormControl$1, _extends$1({
    className: clsx(classes.root, className),
    disabled: disabled,
    error: error,
    fullWidth: fullWidth,
    hiddenLabel: hiddenLabel,
    ref: ref,
    required: required,
    color: color,
    variant: variant
  }, other), label && /*#__PURE__*/React.createElement(InputLabel$1, _extends$1({
    htmlFor: id,
    id: inputLabelId
  }, InputLabelProps), label), select ? /*#__PURE__*/React.createElement(Select$1, _extends$1({
    "aria-describedby": helperTextId,
    id: id,
    labelId: inputLabelId,
    value: value,
    input: InputElement
  }, SelectProps), children) : InputElement, helperText && /*#__PURE__*/React.createElement(FormHelperText$1, _extends$1({
    id: helperTextId
  }, FormHelperTextProps), helperText));
});
TextField.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: PropTypes.string,

  /**
   * If `true`, the `input` element will be focused during the first mount.
   */
  autoFocus: PropTypes.bool,

  /**
   * @ignore
   */
  children: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */
  color: PropTypes.oneOf(['primary', 'secondary']),

  /**
   * The default value of the `input` element.
   */
  defaultValue: PropTypes.any,

  /**
   * If `true`, the `input` element will be disabled.
   */
  disabled: PropTypes.bool,

  /**
   * If `true`, the label will be displayed in an error state.
   */
  error: PropTypes.bool,

  /**
   * Props applied to the [`FormHelperText`](/api/form-helper-text/) element.
   */
  FormHelperTextProps: PropTypes.object,

  /**
   * If `true`, the input will take up the full width of its container.
   */
  fullWidth: PropTypes.bool,

  /**
   * The helper text content.
   */
  helperText: PropTypes.node,

  /**
   * @ignore
   */
  hiddenLabel: PropTypes.bool,

  /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */
  id: PropTypes.string,

  /**
   * Props applied to the [`InputLabel`](/api/input-label/) element.
   */
  InputLabelProps: PropTypes.object,

  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: PropTypes.object,

  /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](/api/filled-input/),
   * [`OutlinedInput`](/api/outlined-input/) or [`Input`](/api/input/)
   * component depending on the `variant` prop value.
   */
  InputProps: PropTypes.object,

  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType$1,

  /**
   * The label content.
   */
  label: PropTypes.node,

  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   */
  margin: PropTypes.oneOf(['dense', 'none', 'normal']),

  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Minimum number of rows to display.
   */
  minRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * If `true`, a textarea element will be rendered instead of an input.
   */
  multiline: PropTypes.bool,

  /**
   * Name attribute of the `input` element.
   */
  name: PropTypes.string,

  /**
   * @ignore
   */
  onBlur: PropTypes.func,

  /**
   * Callback fired when the value is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: PropTypes.func,

  /**
   * @ignore
   */
  onFocus: PropTypes.func,

  /**
   * The short hint displayed in the input before the user enters a value.
   */
  placeholder: PropTypes.string,

  /**
   * If `true`, the label is displayed as required and the `input` element` will be required.
   */
  required: PropTypes.bool,

  /**
   * Number of rows to display when multiline option is set to true.
   * @deprecated Use `minRows` instead.
   */
  rows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Maximum number of rows to display.
   * @deprecated Use `maxRows` instead.
   */
  rowsMax: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Render a [`Select`](/api/select/) element while passing the Input element to `Select` as `input` parameter.
   * If this option is set you must pass the options of the select as children.
   */
  select: PropTypes.bool,

  /**
   * Props applied to the [`Select`](/api/select/) element.
   */
  SelectProps: PropTypes.object,

  /**
   * The size of the text field.
   */
  size: PropTypes.oneOf(['medium', 'small']),

  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   */
  type: PropTypes.string,

  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: PropTypes.any,

  /**
   * The variant to use.
   */
  variant: PropTypes.oneOf(['filled', 'outlined', 'standard'])
} ;
var TextField$1 = withStyles(styles$2, {
  name: 'MuiTextField'
})(TextField);

var styles$1 = {
  root: {
    padding: 9
  },
  checked: {},
  disabled: {},
  input: {
    cursor: 'inherit',
    position: 'absolute',
    opacity: 0,
    width: '100%',
    height: '100%',
    top: 0,
    left: 0,
    margin: 0,
    padding: 0,
    zIndex: 1
  }
};
/**
 * @ignore - internal component.
 */

var SwitchBase = /*#__PURE__*/React.forwardRef(function SwitchBase(props, ref) {
  var autoFocus = props.autoFocus,
      checkedProp = props.checked,
      checkedIcon = props.checkedIcon,
      classes = props.classes,
      className = props.className,
      defaultChecked = props.defaultChecked,
      disabledProp = props.disabled,
      icon = props.icon,
      id = props.id,
      inputProps = props.inputProps,
      inputRef = props.inputRef,
      name = props.name,
      onBlur = props.onBlur,
      onChange = props.onChange,
      onFocus = props.onFocus,
      readOnly = props.readOnly,
      required = props.required,
      tabIndex = props.tabIndex,
      type = props.type,
      value = props.value,
      other = _objectWithoutProperties(props, ["autoFocus", "checked", "checkedIcon", "classes", "className", "defaultChecked", "disabled", "icon", "id", "inputProps", "inputRef", "name", "onBlur", "onChange", "onFocus", "readOnly", "required", "tabIndex", "type", "value"]);

  var _useControlled = useControlled({
    controlled: checkedProp,
    default: Boolean(defaultChecked),
    name: 'SwitchBase',
    state: 'checked'
  }),
      _useControlled2 = _slicedToArray(_useControlled, 2),
      checked = _useControlled2[0],
      setCheckedState = _useControlled2[1];

  var muiFormControl = useFormControl();

  var handleFocus = function handleFocus(event) {
    if (onFocus) {
      onFocus(event);
    }

    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    }
  };

  var handleBlur = function handleBlur(event) {
    if (onBlur) {
      onBlur(event);
    }

    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    }
  };

  var handleInputChange = function handleInputChange(event) {
    var newChecked = event.target.checked;
    setCheckedState(newChecked);

    if (onChange) {
      // TODO v5: remove the second argument.
      onChange(event, newChecked);
    }
  };

  var disabled = disabledProp;

  if (muiFormControl) {
    if (typeof disabled === 'undefined') {
      disabled = muiFormControl.disabled;
    }
  }

  var hasLabelFor = type === 'checkbox' || type === 'radio';
  return /*#__PURE__*/React.createElement(IconButton$1, _extends$1({
    component: "span",
    className: clsx(classes.root, className, checked && classes.checked, disabled && classes.disabled),
    disabled: disabled,
    tabIndex: null,
    role: undefined,
    onFocus: handleFocus,
    onBlur: handleBlur,
    ref: ref
  }, other), /*#__PURE__*/React.createElement("input", _extends$1({
    autoFocus: autoFocus,
    checked: checkedProp,
    defaultChecked: defaultChecked,
    className: classes.input,
    disabled: disabled,
    id: hasLabelFor && id,
    name: name,
    onChange: handleInputChange,
    readOnly: readOnly,
    ref: inputRef,
    required: required,
    tabIndex: tabIndex,
    type: type,
    value: value
  }, inputProps)), checked ? checkedIcon : icon);
}); // NB: If changed, please update Checkbox, Switch and Radio
// so that the API documentation is updated.

SwitchBase.propTypes = {
  /**
   * If `true`, the `input` element will be focused during the first mount.
   */
  autoFocus: PropTypes.bool,

  /**
   * If `true`, the component is checked.
   */
  checked: PropTypes.bool,

  /**
   * The icon to display when the component is checked.
   */
  checkedIcon: PropTypes.node.isRequired,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object.isRequired,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * @ignore
   */
  defaultChecked: PropTypes.bool,

  /**
   * If `true`, the switch will be disabled.
   */
  disabled: PropTypes.bool,

  /**
   * The icon to display when the component is unchecked.
   */
  icon: PropTypes.node.isRequired,

  /**
   * The id of the `input` element.
   */
  id: PropTypes.string,

  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: PropTypes.object,

  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType$1,

  /*
   * @ignore
   */
  name: PropTypes.string,

  /**
   * @ignore
   */
  onBlur: PropTypes.func,

  /**
   * Callback fired when the state is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new checked state by accessing `event.target.checked` (boolean).
   */
  onChange: PropTypes.func,

  /**
   * @ignore
   */
  onFocus: PropTypes.func,

  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: PropTypes.bool,

  /**
   * If `true`, the `input` element will be required.
   */
  required: PropTypes.bool,

  /**
   * @ignore
   */
  tabIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * The input component prop `type`.
   */
  type: PropTypes.string.isRequired,

  /**
   * The value of the component.
   */
  value: PropTypes.any
} ;
var SwitchBase$1 = withStyles(styles$1, {
  name: 'PrivateSwitchBase'
})(SwitchBase);

/**
 * @ignore - internal component.
 */

var CheckBoxOutlineBlankIcon = createSvgIcon( /*#__PURE__*/React.createElement("path", {
  d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
}), 'CheckBoxOutlineBlank');

/**
 * @ignore - internal component.
 */

var CheckBoxIcon = createSvgIcon( /*#__PURE__*/React.createElement("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}), 'CheckBox');

/**
 * @ignore - internal component.
 */

var IndeterminateCheckBoxIcon = createSvgIcon( /*#__PURE__*/React.createElement("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
}), 'IndeterminateCheckBox');

var styles = function styles(theme) {
  return {
    /* Styles applied to the root element. */
    root: {
      color: theme.palette.text.secondary
    },

    /* Pseudo-class applied to the root element if `checked={true}`. */
    checked: {},

    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},

    /* Pseudo-class applied to the root element if `indeterminate={true}`. */
    indeterminate: {},

    /* Styles applied to the root element if `color="primary"`. */
    colorPrimary: {
      '&$checked': {
        color: theme.palette.primary.main,
        '&:hover': {
          backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: 'transparent'
          }
        }
      },
      '&$disabled': {
        color: theme.palette.action.disabled
      }
    },

    /* Styles applied to the root element if `color="secondary"`. */
    colorSecondary: {
      '&$checked': {
        color: theme.palette.secondary.main,
        '&:hover': {
          backgroundColor: alpha(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: 'transparent'
          }
        }
      },
      '&$disabled': {
        color: theme.palette.action.disabled
      }
    }
  };
};
var defaultCheckedIcon = /*#__PURE__*/React.createElement(CheckBoxIcon, null);
var defaultIcon = /*#__PURE__*/React.createElement(CheckBoxOutlineBlankIcon, null);
var defaultIndeterminateIcon = /*#__PURE__*/React.createElement(IndeterminateCheckBoxIcon, null);
var Checkbox = /*#__PURE__*/React.forwardRef(function Checkbox(props, ref) {
  var _props$checkedIcon = props.checkedIcon,
      checkedIcon = _props$checkedIcon === void 0 ? defaultCheckedIcon : _props$checkedIcon,
      classes = props.classes,
      _props$color = props.color,
      color = _props$color === void 0 ? 'secondary' : _props$color,
      _props$icon = props.icon,
      iconProp = _props$icon === void 0 ? defaultIcon : _props$icon,
      _props$indeterminate = props.indeterminate,
      indeterminate = _props$indeterminate === void 0 ? false : _props$indeterminate,
      _props$indeterminateI = props.indeterminateIcon,
      indeterminateIconProp = _props$indeterminateI === void 0 ? defaultIndeterminateIcon : _props$indeterminateI,
      inputProps = props.inputProps,
      _props$size = props.size,
      size = _props$size === void 0 ? 'medium' : _props$size,
      other = _objectWithoutProperties(props, ["checkedIcon", "classes", "color", "icon", "indeterminate", "indeterminateIcon", "inputProps", "size"]);

  var icon = indeterminate ? indeterminateIconProp : iconProp;
  var indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon;
  return /*#__PURE__*/React.createElement(SwitchBase$1, _extends$1({
    type: "checkbox",
    classes: {
      root: clsx(classes.root, classes["color".concat(capitalize(color))], indeterminate && classes.indeterminate),
      checked: classes.checked,
      disabled: classes.disabled
    },
    color: color,
    inputProps: _extends$1({
      'data-indeterminate': indeterminate
    }, inputProps),
    icon: /*#__PURE__*/React.cloneElement(icon, {
      fontSize: icon.props.fontSize === undefined && size === "small" ? size : icon.props.fontSize
    }),
    checkedIcon: /*#__PURE__*/React.cloneElement(indeterminateIcon, {
      fontSize: indeterminateIcon.props.fontSize === undefined && size === "small" ? size : indeterminateIcon.props.fontSize
    }),
    ref: ref
  }, other));
});
Checkbox.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * If `true`, the component is checked.
   */
  checked: PropTypes.bool,

  /**
   * The icon to display when the component is checked.
   */
  checkedIcon: PropTypes.node,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: PropTypes.object,

  /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */
  color: PropTypes.oneOf(['default', 'primary', 'secondary']),

  /**
   * If `true`, the checkbox will be disabled.
   */
  disabled: PropTypes.bool,

  /**
   * If `true`, the ripple effect will be disabled.
   */
  disableRipple: PropTypes.bool,

  /**
   * The icon to display when the component is unchecked.
   */
  icon: PropTypes.node,

  /**
   * The id of the `input` element.
   */
  id: PropTypes.string,

  /**
   * If `true`, the component appears indeterminate.
   * This does not set the native input element to indeterminate due
   * to inconsistent behavior across browsers.
   * However, we set a `data-indeterminate` attribute on the input.
   */
  indeterminate: PropTypes.bool,

  /**
   * The icon to display when the component is indeterminate.
   */
  indeterminateIcon: PropTypes.node,

  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: PropTypes.object,

  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType$1,

  /**
   * Callback fired when the state is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new checked state by accessing `event.target.checked` (boolean).
   */
  onChange: PropTypes.func,

  /**
   * If `true`, the `input` element will be required.
   */
  required: PropTypes.bool,

  /**
   * The size of the checkbox.
   * `small` is equivalent to the dense checkbox styling.
   */
  size: PropTypes.oneOf(['medium', 'small']),

  /**
   * The value of the component. The DOM API casts this to a string.
   * The browser uses "on" as the default value.
   */
  value: PropTypes.any
} ;
var Checkbox$1 = withStyles(styles, {
  name: 'MuiCheckbox'
})(Checkbox);

class AutocompleteUI extends Component {
  render() {
    return createElement(Autocomplete$1, {
      key: this.props.key,
      multiple: this.props.multiple,
      size: "small",
      disabled: this.props.disabled,
      filterSelectedOptions: this.props.filterSelectedOptions,
      disableCloseOnSelect: this.props.disableCloseOnSelect,
      options: this.props.options,
      value: this.props.value,
      getOptionLabel: option => option.title,
      onChange: this.props.onChange,
      noOptionsText: this.props.noOptionsText,
      limitTags: this.props.limitTags,
      onOpen: this.props.onOpen,
      loading: this.props.loading,
      loadingText: this.props.loadingText,
      onInputChange: this.props.onInputChange,
      getOptionSelected: (option, value) => option.title === value.title && option.key === value.key,
      renderOption: (option, {
        selected
      }) => createElement(Fragment, null, this.props.showCheckboxes ? createElement(Checkbox$1, {
        checked: selected
      }) : null, option.title),
      renderInput: params => createElement(TextField$1, _extends$2({}, params, {
        variant: this.props.variant,
        label: this.props.label,
        placeholder: this.props.placeholder
      }))
    });
  }

}

class AutocompleteMultiselect extends Component {
  constructor(props) {
    super(props);

    _defineProperty$1(this, "inputChange", (event, value, reason) => {
      if (this.props.searchAfterXChars.value === undefined || value.length >= this.props.searchAfterXChars.value) {
        this.showToFewCharsText = false;
        const timeStamp = event.timeStamp;
        this.latestInputChange = timeStamp; //Check if no other inputchange will be done

        setTimeout((timeStamp, value, reason) => {
          if (this.latestInputChange === timeStamp) {
            if (this.props.searchValue) {
              this.props.searchValue.setValue(value);
            }

            if (this.props.onInputChangeAction && this.props.onInputChangeAction.canExecute) {
              this.props.onInputChangeAction.execute();
            }
          }
        }, this.props.onInputChangeDelay.value, timeStamp, value, reason);
      } else {
        this.showToFewCharsText = true;
      }

      this.loading = true; // make sure to rerender the widget

      this.setState({
        updateDate: new Date()
      });
    });

    this.state = {
      updateDate: null
    };
    this.autoCompleteKey = 0;
    this.onChange = this.changeValues.bind(this);
    this.onOpenDropdown = this.openDropdown.bind(this);
    this.onInputChange = this.inputChange.bind(this);
    this.options = [];
    this.optionsSelected = []; // Array for multiselect, otherwise object

    this.initialized = false; // Initialize to true to make sure data is retrieved when initializing widget

    this.refreshData = true;
    this.loading = true;
    this.showToFewCharsText = false;
    this.latestInputChange = undefined;
  }

  componentDidUpdate(prevProps) {
    let refreshState = false; // Refresh the data if the refreshAttribute has been set to true

    if (prevProps.refreshAttribute && this.props.refreshAttribute.value && !prevProps.refreshAttribute.value) {
      this.props.refreshAttribute.setValue(false);
      this.autoCompleteKey++; // Make sure data and state will be refreshed

      this.refreshData = true;
      refreshState = true;
    } // Check if data sourse or attribute is used


    if (this.props.JSONAttribute) {
      if (this.props.JSONAttribute.status === "available") {
        // check if the items has been changed or data needs to be refreshed
        if (this.refreshData || this.props.JSONAttribute !== prevProps.JSONAttribute) {
          let dataParsed = []; // parse the json

          if (this.props.JSONAttribute.value && this.props.JSONAttribute.value !== "") {
            dataParsed = JSON.parse(this.props.JSONAttribute.value);
          } // if data needs to be refreshed, reset defaults


          if (this.refreshData) {
            const defaultValue = dataParsed.filter(option => option.default);

            if (this.props.multiple) {
              this.optionsSelected = defaultValue;
            } else {
              this.optionsSelected = defaultValue[0] === undefined ? null : defaultValue[0];
            }
          } else {
            // If custom search is used, it can be that some options are not in the JSON
            // Add these options to make sure the defaults are in, they will be filtered out if not applicable to input value
            if (this.props.onInputChangeAction) {
              const optionsSelectedNotInList = this.optionsSelected.filter(selectedOption => {
                return dataParsed.find(option => option.title === selectedOption.title && option.key === selectedOption.key) === undefined;
              });
              dataParsed = dataParsed.concat(optionsSelectedNotInList);
            } else {
              if (this.props.multiple) {
                // Else check if optionSelected are still available. This is done since it can be the case that the options have been changed.
                this.optionsSelected = this.optionsSelected.filter(selectedOption => {
                  return dataParsed.find(option => option.title === selectedOption.title && option.key === selectedOption.key) !== undefined;
                });
              } else if (this.optionsSelected !== null) {
                this.optionsSelected = dataParsed.find(option => option.title === this.optionsSelected.title && option.key === this.optionsSelected.key);
              }

              if (this.optionsSelected === undefined) {
                this.optionsSelected = null;
              }
            }
          }

          this.options = dataParsed;
          refreshState = true;
          this.initialized = true;
          this.refreshData = false; // Store response in responseAttribute

          this.props.responseAttribute.setValue(JSON.stringify(this.optionsSelected));
          this.loading = false;
        }
      }
    } else if (this.props.dataSourceOptions !== prevProps.dataSourceOptions) {
      // Check if the datasource has been loaded
      if (this.props.dataSourceOptions.status === 'available') {
        // If the items have been changed or if date needs to be refreshed, change the options
        if (this.refreshData || this.props.dataSourceOptions.items !== prevProps.dataSourceOptions.items) {
          let warningGiven = false;
          const multiSelect = this.props.multiple;
          let optionsSelected = multiSelect ? [] : null;
          let defaultSelectedString = undefined; // Map the options and get the selected ones

          this.options = this.props.dataSourceOptions.items.map(item => {
            const optionTitle = this.props.titleAttr.get(item).value;
            const option = {
              title: optionTitle
            }; //If key is used, add key to the option

            if (this.props.keyAttr) {
              option.key = this.props.keyAttr.get(item).value;
            } // If data needs to be refreshed, get default options


            if (this.refreshData) {
              // If string is not yet filled, fill with either the json or with null
              if (defaultSelectedString === undefined) {
                if (this.props.defaultSelectedStringAttr !== undefined) {
                  try {
                    defaultSelectedString = JSON.parse(this.props.defaultSelectedStringAttr.value);
                    ;
                  } catch (e) {
                    defaultSelectedString = [];
                  }
                } else {
                  // set to null to not check this for every item again
                  defaultSelectedString = null;
                }
              }

              let isItemDefaultSelected = false; // Items can be set to default selected in two ways: defaultSelectedStringAttr prop or defaultSelectedAttr prop on an item. If the first option is chosen, the prop on the item is ignored.

              if (defaultSelectedString !== null) {
                isItemDefaultSelected = defaultSelectedString.indexOf(optionTitle) !== -1;
              } else {
                isItemDefaultSelected = this.props.defaultSelectedAttr && this.props.defaultSelectedAttr.get(item).value;
              }

              if (isItemDefaultSelected) {
                if (multiSelect) {
                  optionsSelected.push(option);
                } else {
                  if (optionsSelected === null) {
                    optionsSelected = option;
                  } else {
                    if (!warningGiven) {
                      console.warn("Autocomplete Multiselect: Multiple options are set as default for a single select. First option is set as the selected one.");
                      warningGiven = true;
                    }
                  }
                }
              }
            } else {
              // Else check if option is selected (based on the title). This is done since it can be the case that the options have been changed.
              if (multiSelect) {
                if (this.optionsSelected.find(option => option.title === optionTitle)) {
                  optionsSelected.push(option);
                }
              } else if (this.optionsSelected !== null) {
                if (this.optionsSelected.title === optionTitle) {
                  optionsSelected = option;
                }
              }
            }

            return option;
          });
          refreshState = true;
          this.initialized = true;
          this.refreshData = false;
          this.optionsSelected = optionsSelected; // Store response in responseAttribute

          this.props.responseAttribute.setValue(JSON.stringify(optionsSelected));
          this.loading = false;
        }
      }
    }

    if (refreshState) {
      this.setState({
        updateDate: new Date()
      });
    }
  }
  /**
   * Function called when a new value is selected or value(s) are deselected. 
   * 
   * @param {*} event - the event that triggered this action
   * @param {*} newValue - the new value of the dropdown
   * @param {*} reason - the reason that this action is triggered, either select-option, remove-option, create-option, blur or clear
   * @param {*} details - more details about the option for which this event is triggered
   */


  changeValues(event, newValue, reason, details) {
    // Store response in responseAttribute and call on change action
    this.props.responseAttribute.setValue(JSON.stringify(newValue));

    if (this.props.onChangeAction && this.props.onChangeAction.canExecute) {
      this.props.onChangeAction.execute();
    } // Update the widget with the new values selected


    this.optionsSelected = newValue;
    this.setState({
      updateDate: new Date()
    });
  }
  /**
   * Function calles when dropdown is opened
   */


  openDropdown() {
    let setLoading = false; // check if enough chars are filled

    if (this.props.onInputChangeAction) {
      if (this.props.searchAfterXChars.value && this.props.searchAfterXChars.value > 0) {
        this.showToFewCharsText = true;
        setLoading = true;
      }
    }

    if (this.props.onOpenAction && this.props.onOpenAction.canExecute) {
      this.props.onOpenAction.execute();
      setLoading = true;
    }

    if (setLoading) {
      // Rerender widget
      this.loading = true;
      this.setState({
        updateDate: new Date()
      });
    }
  }
  /**
   * Function called when a the input value changes
   * 
   * @param {*} event - the event that triggered this action
   * @param {*} value - the new value of the input
   * @param {*} reason - the reason that this action is triggered, either input, clear or reset
   */


  render() {
    // Do not render the widget if it is not initialized yet
    if (!this.initialized) {
      return '';
    } // If the disabled property is not filled, the widget will be editable


    let disabled = this.props.editable ? !this.props.editable.value : false; // Check if user has rights on response attribute

    if (!disabled && this.props.responseAttribute.readOnly) {
      console.warn('Autocomplete Multiselect: User has no rights to change the response attribute.');
      disabled = true;
    }

    const noOptionsText = this.props.noOptionsText ? this.props.noOptionsText.value : undefined;
    const placeholder = this.props.placeholder ? this.props.placeholder.value : undefined;
    const limitTags = this.props.limitTags > 0 ? this.props.limitTags : undefined;
    const label = this.props.label ? this.props.label.value : undefined; // Following options only used when json attribute is used

    let onOpen = undefined;
    let onInputChange = undefined;
    let loading = undefined;
    let loadingText = undefined;
    let options = this.options;

    if (this.props.JSONAttribute) {
      onOpen = this.onOpenDropdown;

      if (this.props.onInputChangeAction) {
        onInputChange = this.onInputChange;
      }

      loading = this.loading; // set loading text, if to few chars are filled use this text.

      if (this.showToFewCharsText) {
        loadingText = this.props.searchAfterXCharsText ? this.props.searchAfterXCharsText.value : "Enter at least " + this.props.searchAfterXChars.value + " characters";
      } else {
        loadingText = this.props.loadingText ? this.props.loadingText.value : undefined;
      } // if component is loading, hide options


      if (this.loading) {
        options = [];
      }
    }

    return createElement(AutocompleteUI, {
      key: this.autoCompleteKey,
      multiple: this.props.multiple,
      disabled: disabled,
      disableCloseOnSelect: this.props.disableCloseOnSelect,
      options: options,
      value: this.optionsSelected,
      onChange: this.onChange,
      noOptionsText: noOptionsText,
      limitTags: limitTags,
      showCheckboxes: this.props.showCheckboxes,
      variant: this.props.variant,
      label: label,
      placeholder: placeholder,
      filterSelectedOptions: this.props.filterSelectedOptions,
      onOpen: onOpen,
      loading: loading,
      loadingText: loadingText,
      onInputChange: onInputChange
    });
  }

}

export { AutocompleteMultiselect as default };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXV0b2NvbXBsZXRlTXVsdGlzZWxlY3QubWpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtaW5qZWN0L2Rpc3Qvc3R5bGUtaW5qZWN0LmVzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS91dGlscy9lc20vY2hhaW5Qcm9wVHlwZXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS91dGlscy9lc20vZGVlcG1lcmdlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS91dGlscy9lc20vZWxlbWVudEFjY2VwdGluZ1JlZi5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvdXRpbHMvZXNtL2VsZW1lbnRUeXBlQWNjZXB0aW5nUmVmLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS91dGlscy9lc20vZXhhY3RQcm9wLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS91dGlscy9lc20vZ2V0RGlzcGxheU5hbWUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3V0aWxzL2VzbS9IVE1MRWxlbWVudFR5cGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3V0aWxzL2VzbS9yZWZUeXBlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9zdHlsZXMvY29sb3JNYW5pcHVsYXRvci5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vc3R5bGVzL2NyZWF0ZUJyZWFrcG9pbnRzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9zdHlsZXMvY3JlYXRlTWl4aW5zLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9jb2xvcnMvY29tbW9uLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9jb2xvcnMvZ3JleS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vY29sb3JzL2luZGlnby5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vY29sb3JzL3BpbmsuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL2NvbG9ycy9yZWQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL2NvbG9ycy9vcmFuZ2UuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL2NvbG9ycy9ibHVlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9jb2xvcnMvZ3JlZW4uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3N0eWxlcy9jcmVhdGVQYWxldHRlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9zdHlsZXMvY3JlYXRlVHlwb2dyYXBoeS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vc3R5bGVzL3NoYWRvd3MuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3N0eWxlcy9zaGFwZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3lzdGVtL2VzbS9yZXNwb25zaXZlUHJvcFR5cGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXkuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVTcHJlYWQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRoSG9sZXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N5c3RlbS9lc20vc3BhY2luZy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vc3R5bGVzL2NyZWF0ZVNwYWNpbmcuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3N0eWxlcy90cmFuc2l0aW9ucy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vc3R5bGVzL3pJbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vc3R5bGVzL2NyZWF0ZVRoZW1lLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9zdHlsZXMvZXNtL1RoZW1lUHJvdmlkZXIvbmVzdGVkLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9zdHlsZXMvZXNtL2NyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lL2NyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9zdHlsZXMvZXNtL2dldFRoZW1lUHJvcHMvZ2V0VGhlbWVQcm9wcy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90aW55LXdhcm5pbmcvZGlzdC90aW55LXdhcm5pbmcuZXNtLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2lzLWluLWJyb3dzZXIvZGlzdC9tb2R1bGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2V0UHJvdG90eXBlT2YuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvanNzL2Rpc3QvanNzLmVzbS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLXJ1bGUtdmFsdWUtZnVuY3Rpb24vZGlzdC9qc3MtcGx1Z2luLXJ1bGUtdmFsdWUtZnVuY3Rpb24uZXNtLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tZ2xvYmFsL2Rpc3QvanNzLXBsdWdpbi1nbG9iYWwuZXNtLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tbmVzdGVkL2Rpc3QvanNzLXBsdWdpbi1uZXN0ZWQuZXNtLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h5cGhlbmF0ZS1zdHlsZS1uYW1lL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tY2FtZWwtY2FzZS9kaXN0L2pzcy1wbHVnaW4tY2FtZWwtY2FzZS5lc20uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvanNzLXBsdWdpbi1kZWZhdWx0LXVuaXQvZGlzdC9qc3MtcGx1Z2luLWRlZmF1bHQtdW5pdC5lc20uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLXZlbmRvci9kaXN0L2Nzcy12ZW5kb3IuZXNtLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tdmVuZG9yLXByZWZpeGVyL2Rpc3QvanNzLXBsdWdpbi12ZW5kb3ItcHJlZml4ZXIuZXNtLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tcHJvcHMtc29ydC9kaXN0L2pzcy1wbHVnaW4tcHJvcHMtc29ydC5lc20uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N0eWxlcy9lc20vanNzUHJlc2V0L2pzc1ByZXNldC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3R5bGVzL2VzbS9tZXJnZUNsYXNzZXMvbWVyZ2VDbGFzc2VzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9zdHlsZXMvZXNtL21ha2VTdHlsZXMvbXVsdGlLZXlTdG9yZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3R5bGVzL2VzbS91c2VUaGVtZS9UaGVtZUNvbnRleHQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N0eWxlcy9lc20vdXNlVGhlbWUvdXNlVGhlbWUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N0eWxlcy9lc20vU3R5bGVzUHJvdmlkZXIvU3R5bGVzUHJvdmlkZXIuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N0eWxlcy9lc20vbWFrZVN0eWxlcy9pbmRleENvdW50ZXIuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N0eWxlcy9lc20vZ2V0U3R5bGVzQ3JlYXRvci9ub29wVGhlbWUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N0eWxlcy9lc20vZ2V0U3R5bGVzQ3JlYXRvci9nZXRTdHlsZXNDcmVhdG9yLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9zdHlsZXMvZXNtL21ha2VTdHlsZXMvbWFrZVN0eWxlcy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjay5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9kaXN0L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzLmNqcy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3R5bGVzL2VzbS93aXRoU3R5bGVzL3dpdGhTdHlsZXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3N0eWxlcy9kZWZhdWx0VGhlbWUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3N0eWxlcy91c2VUaGVtZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vc3R5bGVzL3dpdGhTdHlsZXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvZXNtL3BvcHBlci5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdXRpbHMvZGVwcmVjYXRlZFByb3BUeXBlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy9zZXRSZWYuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3V0aWxzL3VzZUZvcmtSZWYuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL1BvcnRhbC9Qb3J0YWwuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3V0aWxzL2NyZWF0ZUNoYWluZWRGdW5jdGlvbi5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vUG9wcGVyL1BvcHBlci5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdXRpbHMvY2FwaXRhbGl6ZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vTGlzdFN1YmhlYWRlci9MaXN0U3ViaGVhZGVyLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9QYXBlci9QYXBlci5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdXRpbHMvdXNlRXZlbnRDYWxsYmFjay5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdXRpbHMvdXNlSXNGb2N1c1Zpc2libGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9lc20vY29uZmlnLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvZXNtL3V0aWxzL1Byb3BUeXBlcy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS9UcmFuc2l0aW9uR3JvdXBDb250ZXh0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvZXNtL1RyYW5zaXRpb24uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9lc20vdXRpbHMvQ2hpbGRNYXBwaW5nLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvZXNtL1RyYW5zaXRpb25Hcm91cC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vQnV0dG9uQmFzZS9SaXBwbGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0J1dHRvbkJhc2UvVG91Y2hSaXBwbGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0J1dHRvbkJhc2UvQnV0dG9uQmFzZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vSWNvbkJ1dHRvbi9JY29uQnV0dG9uLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9TdmdJY29uL1N2Z0ljb24uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3V0aWxzL2NyZWF0ZVN2Z0ljb24uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL2ludGVybmFsL3N2Zy1pY29ucy9DYW5jZWwuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3V0aWxzL3Vuc3VwcG9ydGVkUHJvcC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vQ2hpcC9DaGlwLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy9kZWJvdW5jZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdXRpbHMvaXNNdWlFbGVtZW50LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy9vd25lckRvY3VtZW50LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy9vd25lcldpbmRvdy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdXRpbHMvdXNlQ29udHJvbGxlZC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdXRpbHMvdW5zdGFibGVfdXNlSWQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2xhYi9lc20vaW50ZXJuYWwvc3ZnLWljb25zL0Nsb3NlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9sYWIvZXNtL2ludGVybmFsL3N2Zy1pY29ucy9BcnJvd0Ryb3BEb3duLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9sYWIvZXNtL3VzZUF1dG9jb21wbGV0ZS91c2VBdXRvY29tcGxldGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2xhYi9lc20vQXV0b2NvbXBsZXRlL0F1dG9jb21wbGV0ZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vRm9ybUNvbnRyb2wvZm9ybUNvbnRyb2xTdGF0ZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vRm9ybUNvbnRyb2wvRm9ybUNvbnRyb2xDb250ZXh0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9UZXh0YXJlYUF1dG9zaXplL1RleHRhcmVhQXV0b3NpemUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0lucHV0QmFzZS91dGlscy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vSW5wdXRCYXNlL0lucHV0QmFzZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vSW5wdXQvSW5wdXQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0ZpbGxlZElucHV0L0ZpbGxlZElucHV0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9PdXRsaW5lZElucHV0L05vdGNoZWRPdXRsaW5lLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9PdXRsaW5lZElucHV0L091dGxpbmVkSW5wdXQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0Zvcm1Db250cm9sL3VzZUZvcm1Db250cm9sLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9Gb3JtTGFiZWwvRm9ybUxhYmVsLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9JbnB1dExhYmVsL0lucHV0TGFiZWwuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0Zvcm1Db250cm9sL0Zvcm1Db250cm9sLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9Gb3JtSGVscGVyVGV4dC9Gb3JtSGVscGVyVGV4dC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdXRpbHMvZ2V0U2Nyb2xsYmFyU2l6ZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vTW9kYWwvTW9kYWxNYW5hZ2VyLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9VbnN0YWJsZV9UcmFwRm9jdXMvVW5zdGFibGVfVHJhcEZvY3VzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9Nb2RhbC9TaW1wbGVCYWNrZHJvcC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vTW9kYWwvTW9kYWwuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3RyYW5zaXRpb25zL3V0aWxzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9Hcm93L0dyb3cuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL1BvcG92ZXIvUG9wb3Zlci5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vTGlzdC9MaXN0Q29udGV4dC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vTGlzdC9MaXN0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9NZW51TGlzdC9NZW51TGlzdC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vTWVudS9NZW51LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9TZWxlY3QvU2VsZWN0SW5wdXQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL2ludGVybmFsL3N2Zy1pY29ucy9BcnJvd0Ryb3BEb3duLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9OYXRpdmVTZWxlY3QvTmF0aXZlU2VsZWN0SW5wdXQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL05hdGl2ZVNlbGVjdC9OYXRpdmVTZWxlY3QuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL1NlbGVjdC9TZWxlY3QuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL1RleHRGaWVsZC9UZXh0RmllbGQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL2ludGVybmFsL1N3aXRjaEJhc2UuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL2ludGVybmFsL3N2Zy1pY29ucy9DaGVja0JveE91dGxpbmVCbGFuay5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vaW50ZXJuYWwvc3ZnLWljb25zL0NoZWNrQm94LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9pbnRlcm5hbC9zdmctaWNvbnMvSW5kZXRlcm1pbmF0ZUNoZWNrQm94LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9DaGVja2JveC9DaGVja2JveC5qcyIsIi4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0F1dG9jb21wbGV0ZVVJLmpzeCIsIi4uLy4uLy4uLy4uLy4uL3NyYy9BdXRvY29tcGxldGVNdWx0aXNlbGVjdC5qc3giXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gc3R5bGVJbmplY3QoY3NzLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICB2YXIgaW5zZXJ0QXQgPSByZWYuaW5zZXJ0QXQ7XG5cbiAgaWYgKCFjc3MgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm47IH1cblxuICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cbiAgaWYgKGluc2VydEF0ID09PSAndG9wJykge1xuICAgIGlmIChoZWFkLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBzdHlsZUluamVjdDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsImltcG9ydCBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCIuL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsImZ1bmN0aW9uIHRvVmFsKG1peCkge1xuXHR2YXIgaywgeSwgc3RyPScnO1xuXG5cdGlmICh0eXBlb2YgbWl4ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbWl4ID09PSAnbnVtYmVyJykge1xuXHRcdHN0ciArPSBtaXg7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG1peCA9PT0gJ29iamVjdCcpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShtaXgpKSB7XG5cdFx0XHRmb3IgKGs9MDsgayA8IG1peC5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHRpZiAobWl4W2tdKSB7XG5cdFx0XHRcdFx0aWYgKHkgPSB0b1ZhbChtaXhba10pKSB7XG5cdFx0XHRcdFx0XHRzdHIgJiYgKHN0ciArPSAnICcpO1xuXHRcdFx0XHRcdFx0c3RyICs9IHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoayBpbiBtaXgpIHtcblx0XHRcdFx0aWYgKG1peFtrXSkge1xuXHRcdFx0XHRcdHN0ciAmJiAoc3RyICs9ICcgJyk7XG5cdFx0XHRcdFx0c3RyICs9IGs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3RyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG5cdHZhciBpPTAsIHRtcCwgeCwgc3RyPScnO1xuXHR3aGlsZSAoaSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRpZiAodG1wID0gYXJndW1lbnRzW2krK10pIHtcblx0XHRcdGlmICh4ID0gdG9WYWwodG1wKSkge1xuXHRcdFx0XHRzdHIgJiYgKHN0ciArPSAnICcpO1xuXHRcdFx0XHRzdHIgKz0geFxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gc3RyO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2hhaW5Qcm9wVHlwZXMocHJvcFR5cGUxLCBwcm9wVHlwZTIpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgICByZXR1cm4gcHJvcFR5cGUxLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKSB8fCBwcm9wVHlwZTIuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfdHlwZW9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2ZcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW0gJiYgX3R5cGVvZihpdGVtKSA9PT0gJ29iamVjdCcgJiYgaXRlbS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7XG4gICAgY2xvbmU6IHRydWVcbiAgfTtcbiAgdmFyIG91dHB1dCA9IG9wdGlvbnMuY2xvbmUgPyBfZXh0ZW5kcyh7fSwgdGFyZ2V0KSA6IHRhcmdldDtcblxuICBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIGlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvLyBBdm9pZCBwcm90b3R5cGUgcG9sbHV0aW9uXG4gICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSAmJiBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgIG91dHB1dFtrZXldID0gZGVlcG1lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn0iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNoYWluUHJvcFR5cGVzIGZyb20gJy4vY2hhaW5Qcm9wVHlwZXMnO1xuXG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KGVsZW1lbnRUeXBlKSB7XG4gIC8vIGVsZW1lbnRUeXBlLnByb3RvdHlwZT8uaXNSZWFjdENvbXBvbmVudFxuICB2YXIgX2VsZW1lbnRUeXBlJHByb3RvdHlwID0gZWxlbWVudFR5cGUucHJvdG90eXBlLFxuICAgICAgcHJvdG90eXBlID0gX2VsZW1lbnRUeXBlJHByb3RvdHlwID09PSB2b2lkIDAgPyB7fSA6IF9lbGVtZW50VHlwZSRwcm90b3R5cDtcbiAgcmV0dXJuIEJvb2xlYW4ocHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBhY2NlcHRpbmdSZWYocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gIHZhciBlbGVtZW50ID0gcHJvcHNbcHJvcE5hbWVdO1xuICB2YXIgc2FmZVByb3BOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciB3YXJuaW5nSGludDtcbiAgdmFyIGVsZW1lbnRUeXBlID0gZWxlbWVudC50eXBlO1xuICAvKipcbiAgICogQmxhY2tsaXN0aW5nIGluc3RlYWQgb2Ygd2hpdGVsaXN0aW5nXG4gICAqXG4gICAqIEJsYWNrbGlzdGluZyB3aWxsIG1pc3Mgc29tZSBjb21wb25lbnRzLCBzdWNoIGFzIFJlYWN0LkZyYWdtZW50LiBUaG9zZSB3aWxsIGF0IGxlYXN0XG4gICAqIHRyaWdnZXIgYSB3YXJuaW5nIGluIFJlYWN0LlxuICAgKiBXZSBjYW4ndCB3aGl0ZWxpc3QgYmVjYXVzZSB0aGVyZSBpcyBubyBzYWZlIHdheSB0byBkZXRlY3QgUmVhY3QuZm9yd2FyZFJlZlxuICAgKiBvciBjbGFzcyBjb21wb25lbnRzLiBcIlNhZmVcIiBtZWFucyB0aGVyZSdzIG5vIHB1YmxpYyBBUEkuXG4gICAqXG4gICAqL1xuXG4gIGlmICh0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdmdW5jdGlvbicgJiYgIWlzQ2xhc3NDb21wb25lbnQoZWxlbWVudFR5cGUpKSB7XG4gICAgd2FybmluZ0hpbnQgPSAnRGlkIHlvdSBhY2NpZGVudGFsbHkgdXNlIGEgcGxhaW4gZnVuY3Rpb24gY29tcG9uZW50IGZvciBhbiBlbGVtZW50IGluc3RlYWQ/JztcbiAgfVxuXG4gIGlmICh3YXJuaW5nSGludCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkludmFsaWQgXCIuY29uY2F0KGxvY2F0aW9uLCBcIiBgXCIpLmNvbmNhdChzYWZlUHJvcE5hbWUsIFwiYCBzdXBwbGllZCB0byBgXCIpLmNvbmNhdChjb21wb25lbnROYW1lLCBcImAuIFwiKSArIFwiRXhwZWN0ZWQgYW4gZWxlbWVudCB0aGF0IGNhbiBob2xkIGEgcmVmLiBcIi5jb25jYXQod2FybmluZ0hpbnQsIFwiIFwiKSArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgaHR0cHM6Ly9tYXRlcmlhbC11aS5jb20vci9jYXZlYXQtd2l0aC1yZWZzLWd1aWRlJyk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGVsZW1lbnRBY2NlcHRpbmdSZWYgPSBjaGFpblByb3BUeXBlcyhQcm9wVHlwZXMuZWxlbWVudCwgYWNjZXB0aW5nUmVmKTtcbmVsZW1lbnRBY2NlcHRpbmdSZWYuaXNSZXF1aXJlZCA9IGNoYWluUHJvcFR5cGVzKFByb3BUeXBlcy5lbGVtZW50LmlzUmVxdWlyZWQsIGFjY2VwdGluZ1JlZik7XG5leHBvcnQgZGVmYXVsdCBlbGVtZW50QWNjZXB0aW5nUmVmOyIsImltcG9ydCAqIGFzIFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjaGFpblByb3BUeXBlcyBmcm9tICcuL2NoYWluUHJvcFR5cGVzJztcblxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudChlbGVtZW50VHlwZSkge1xuICAvLyBlbGVtZW50VHlwZS5wcm90b3R5cGU/LmlzUmVhY3RDb21wb25lbnRcbiAgdmFyIF9lbGVtZW50VHlwZSRwcm90b3R5cCA9IGVsZW1lbnRUeXBlLnByb3RvdHlwZSxcbiAgICAgIHByb3RvdHlwZSA9IF9lbGVtZW50VHlwZSRwcm90b3R5cCA9PT0gdm9pZCAwID8ge30gOiBfZWxlbWVudFR5cGUkcHJvdG90eXA7XG4gIHJldHVybiBCb29sZWFuKHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudFR5cGVBY2NlcHRpbmdSZWYocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gIHZhciBzYWZlUHJvcE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgd2FybmluZ0hpbnQ7XG4gIC8qKlxuICAgKiBCbGFja2xpc3RpbmcgaW5zdGVhZCBvZiB3aGl0ZWxpc3RpbmdcbiAgICpcbiAgICogQmxhY2tsaXN0aW5nIHdpbGwgbWlzcyBzb21lIGNvbXBvbmVudHMsIHN1Y2ggYXMgUmVhY3QuRnJhZ21lbnQuIFRob3NlIHdpbGwgYXQgbGVhc3RcbiAgICogdHJpZ2dlciBhIHdhcm5pbmcgaW4gUmVhY3QuXG4gICAqIFdlIGNhbid0IHdoaXRlbGlzdCBiZWNhdXNlIHRoZXJlIGlzIG5vIHNhZmUgd2F5IHRvIGRldGVjdCBSZWFjdC5mb3J3YXJkUmVmXG4gICAqIG9yIGNsYXNzIGNvbXBvbmVudHMuIFwiU2FmZVwiIG1lYW5zIHRoZXJlJ3Mgbm8gcHVibGljIEFQSS5cbiAgICpcbiAgICovXG5cbiAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICdmdW5jdGlvbicgJiYgIWlzQ2xhc3NDb21wb25lbnQocHJvcFZhbHVlKSkge1xuICAgIHdhcm5pbmdIaW50ID0gJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHByb3ZpZGUgYSBwbGFpbiBmdW5jdGlvbiBjb21wb25lbnQgaW5zdGVhZD8nO1xuICB9XG5cbiAgaWYgKHdhcm5pbmdIaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiSW52YWxpZCBcIi5jb25jYXQobG9jYXRpb24sIFwiIGBcIikuY29uY2F0KHNhZmVQcm9wTmFtZSwgXCJgIHN1cHBsaWVkIHRvIGBcIikuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiYC4gXCIpICsgXCJFeHBlY3RlZCBhbiBlbGVtZW50IHR5cGUgdGhhdCBjYW4gaG9sZCBhIHJlZi4gXCIuY29uY2F0KHdhcm5pbmdIaW50LCBcIiBcIikgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIGh0dHBzOi8vbWF0ZXJpYWwtdWkuY29tL3IvY2F2ZWF0LXdpdGgtcmVmcy1ndWlkZScpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNoYWluUHJvcFR5cGVzKFByb3BUeXBlcy5lbGVtZW50VHlwZSwgZWxlbWVudFR5cGVBY2NlcHRpbmdSZWYpOyIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbi8vIFRoaXMgbW9kdWxlIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9haXJibmIvcHJvcC10eXBlcy1leGFjdCByZXBvc2l0b3J5LlxuLy8gSG93ZXZlciwgaW4gb3JkZXIgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2YgZGVwZW5kZW5jaWVzIGFuZCB0byByZW1vdmUgc29tZSBleHRyYSBzYWZlIGNoZWNrc1xuLy8gdGhlIG1vZHVsZSB3YXMgZm9ya2VkLlxuLy8gT25seSBleHBvcnRlZCBmb3IgdGVzdCBwdXJwb3Nlcy5cbmV4cG9ydCB2YXIgc3BlY2lhbFByb3BlcnR5ID0gXCJleGFjdC1wcm9wOiBcXHUyMDBCXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleGFjdFByb3AocHJvcFR5cGVzKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcmV0dXJuIHByb3BUeXBlcztcbiAgfVxuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgcHJvcFR5cGVzLCBfZGVmaW5lUHJvcGVydHkoe30sIHNwZWNpYWxQcm9wZXJ0eSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIHVuc3VwcG9ydGVkUHJvcHMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gIXByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKTtcbiAgICB9KTtcblxuICAgIGlmICh1bnN1cHBvcnRlZFByb3BzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJUaGUgZm9sbG93aW5nIHByb3BzIGFyZSBub3Qgc3VwcG9ydGVkOiBcIi5jb25jYXQodW5zdXBwb3J0ZWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIFwiYFwiLmNvbmNhdChwcm9wLCBcImBcIik7XG4gICAgICB9KS5qb2luKCcsICcpLCBcIi4gUGxlYXNlIHJlbW92ZSB0aGVtLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0pKTtcbn0iLCJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mXCI7XG5pbXBvcnQgeyBGb3J3YXJkUmVmLCBNZW1vIH0gZnJvbSAncmVhY3QtaXMnOyAvLyBTaW1wbGlmaWVkIHBvbHlmaWxsIGZvciBJRSAxMSBzdXBwb3J0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vSmFtZXNNR3JlZW5lL0Z1bmN0aW9uLm5hbWUvYmxvYi81OGIzMTRkNGE5ODMxMTBjMzY4MmYxMjI4Zjg0NWQzOWNjY2ExODE3L0Z1bmN0aW9uLm5hbWUuanMjTDNcblxudmFyIGZuTmFtZU1hdGNoUmVnZXggPSAvXlxccypmdW5jdGlvbig/Olxcc3xcXHMqXFwvXFwqLipcXCpcXC9cXHMqKSsoW14oXFxzL10qKVxccyovO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShmbikge1xuICB2YXIgbWF0Y2ggPSBcIlwiLmNvbmNhdChmbikubWF0Y2goZm5OYW1lTWF0Y2hSZWdleCk7XG4gIHZhciBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gIHJldHVybiBuYW1lIHx8ICcnO1xufVxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDb21wb25lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmYWxsYmFja1xuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRGdW5jdGlvbkNvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB7XG4gIHZhciBmYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gIHJldHVybiBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgZ2V0RnVuY3Rpb25OYW1lKENvbXBvbmVudCkgfHwgZmFsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gZ2V0RnVuY3Rpb25Db21wb25lbnROYW1lKGlubmVyVHlwZSk7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyBcIlwiLmNvbmNhdCh3cmFwcGVyTmFtZSwgXCIoXCIpLmNvbmNhdChmdW5jdGlvbk5hbWUsIFwiKVwiKSA6IHdyYXBwZXJOYW1lKTtcbn1cbi8qKlxuICogY2hlcnJ5LXBpY2sgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvNzY5YjFmMjcwZTEyNTFkOWRiZGNlMGZjYmQ5ZTkyZTUwMmQwNTliOC9wYWNrYWdlcy9zaGFyZWQvZ2V0Q29tcG9uZW50TmFtZS5qc1xuICogb3JpZ2luYWxseSBmb3JrZWQgZnJvbSByZWNvbXBvc2UvZ2V0RGlzcGxheU5hbWUgd2l0aCBhZGRlZCBJRSAxMSBzdXBwb3J0XG4gKlxuICogQHBhcmFtIHtSZWFjdC5SZWFjdFR5cGV9IENvbXBvbmVudFxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKENvbXBvbmVudCkge1xuICBpZiAoQ29tcG9uZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdldEZ1bmN0aW9uQ29tcG9uZW50TmFtZShDb21wb25lbnQsICdDb21wb25lbnQnKTtcbiAgfVxuXG4gIGlmIChfdHlwZW9mKENvbXBvbmVudCkgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoIChDb21wb25lbnQuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKENvbXBvbmVudCwgQ29tcG9uZW50LnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBNZW1vOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUoQ29tcG9uZW50LCBDb21wb25lbnQudHlwZSwgJ21lbW8nKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhUTUxFbGVtZW50VHlwZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gIHZhciBzYWZlUHJvcE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocHJvcFZhbHVlICYmIHByb3BWYWx1ZS5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJJbnZhbGlkIFwiLmNvbmNhdChsb2NhdGlvbiwgXCIgYFwiKS5jb25jYXQoc2FmZVByb3BOYW1lLCBcImAgc3VwcGxpZWQgdG8gYFwiKS5jb25jYXQoY29tcG9uZW50TmFtZSwgXCJgLiBcIikgKyBcIkV4cGVjdGVkIGFuIEhUTUxFbGVtZW50LlwiKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG52YXIgcmVmVHlwZSA9IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMub2JqZWN0XSk7XG5leHBvcnQgZGVmYXVsdCByZWZUeXBlOyIsImltcG9ydCB7IGZvcm1hdE11aUVycm9yTWVzc2FnZSBhcyBfZm9ybWF0TXVpRXJyb3JNZXNzYWdlIH0gZnJvbSBcIkBtYXRlcmlhbC11aS91dGlsc1wiO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgd2hvc2UgdmFsdWUgaXMgbGltaXRlZCB0byB0aGUgZ2l2ZW4gcmFuZ2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgb3V0cHV0IHJhbmdlXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSB1cHBlciBib3VuZGFyeSBvZiB0aGUgb3V0cHV0IHJhbmdlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBIG51bWJlciBpbiB0aGUgcmFuZ2UgW21pbiwgbWF4XVxuICovXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSkge1xuICB2YXIgbWluID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICB2YXIgbWF4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHZhbHVlIDwgbWluIHx8IHZhbHVlID4gbWF4KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTWF0ZXJpYWwtVUk6IFRoZSB2YWx1ZSBwcm92aWRlZCBcIi5jb25jYXQodmFsdWUsIFwiIGlzIG91dCBvZiByYW5nZSBbXCIpLmNvbmNhdChtaW4sIFwiLCBcIikuY29uY2F0KG1heCwgXCJdLlwiKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgdmFsdWUpLCBtYXgpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGNvbG9yIGZyb20gQ1NTIGhleCBmb3JtYXQgdG8gQ1NTIHJnYiBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gSGV4IGNvbG9yLCBpLmUuICNubm4gb3IgI25ubm5ublxuICogQHJldHVybnMge3N0cmluZ30gQSBDU1MgcmdiIGNvbG9yIHN0cmluZ1xuICovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvUmdiKGNvbG9yKSB7XG4gIGNvbG9yID0gY29sb3Iuc3Vic3RyKDEpO1xuICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiLnsxLFwiLmNvbmNhdChjb2xvci5sZW5ndGggPj0gNiA/IDIgOiAxLCBcIn1cIiksICdnJyk7XG4gIHZhciBjb2xvcnMgPSBjb2xvci5tYXRjaChyZSk7XG5cbiAgaWYgKGNvbG9ycyAmJiBjb2xvcnNbMF0ubGVuZ3RoID09PSAxKSB7XG4gICAgY29sb3JzID0gY29sb3JzLm1hcChmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIG4gKyBuO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNvbG9ycyA/IFwicmdiXCIuY29uY2F0KGNvbG9ycy5sZW5ndGggPT09IDQgPyAnYScgOiAnJywgXCIoXCIpLmNvbmNhdChjb2xvcnMubWFwKGZ1bmN0aW9uIChuLCBpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA8IDMgPyBwYXJzZUludChuLCAxNikgOiBNYXRoLnJvdW5kKHBhcnNlSW50KG4sIDE2KSAvIDI1NSAqIDEwMDApIC8gMTAwMDtcbiAgfSkuam9pbignLCAnKSwgXCIpXCIpIDogJyc7XG59XG5cbmZ1bmN0aW9uIGludFRvSGV4KGludCkge1xuICB2YXIgaGV4ID0gaW50LnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGhleC5sZW5ndGggPT09IDEgPyBcIjBcIi5jb25jYXQoaGV4KSA6IGhleDtcbn1cbi8qKlxuICogQ29udmVydHMgYSBjb2xvciBmcm9tIENTUyByZ2IgZm9ybWF0IHRvIENTUyBoZXggZm9ybWF0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIFJHQiBjb2xvciwgaS5lLiByZ2IobiwgbiwgbilcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIHJnYiBjb2xvciBzdHJpbmcsIGkuZS4gI25ubm5ublxuICovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYlRvSGV4KGNvbG9yKSB7XG4gIC8vIElkZW1wb3RlbnRcbiAgaWYgKGNvbG9yLmluZGV4T2YoJyMnKSA9PT0gMCkge1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG4gIHZhciBfZGVjb21wb3NlQ29sb3IgPSBkZWNvbXBvc2VDb2xvcihjb2xvciksXG4gICAgICB2YWx1ZXMgPSBfZGVjb21wb3NlQ29sb3IudmFsdWVzO1xuXG4gIHJldHVybiBcIiNcIi5jb25jYXQodmFsdWVzLm1hcChmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBpbnRUb0hleChuKTtcbiAgfSkuam9pbignJykpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGNvbG9yIGZyb20gaHNsIGZvcm1hdCB0byByZ2IgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIEhTTCBjb2xvciB2YWx1ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHJnYiBjb2xvciB2YWx1ZXNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaHNsVG9SZ2IoY29sb3IpIHtcbiAgY29sb3IgPSBkZWNvbXBvc2VDb2xvcihjb2xvcik7XG4gIHZhciBfY29sb3IgPSBjb2xvcixcbiAgICAgIHZhbHVlcyA9IF9jb2xvci52YWx1ZXM7XG4gIHZhciBoID0gdmFsdWVzWzBdO1xuICB2YXIgcyA9IHZhbHVlc1sxXSAvIDEwMDtcbiAgdmFyIGwgPSB2YWx1ZXNbMl0gLyAxMDA7XG4gIHZhciBhID0gcyAqIE1hdGgubWluKGwsIDEgLSBsKTtcblxuICB2YXIgZiA9IGZ1bmN0aW9uIGYobikge1xuICAgIHZhciBrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAobiArIGggLyAzMCkgJSAxMjtcbiAgICByZXR1cm4gbCAtIGEgKiBNYXRoLm1heChNYXRoLm1pbihrIC0gMywgOSAtIGssIDEpLCAtMSk7XG4gIH07XG5cbiAgdmFyIHR5cGUgPSAncmdiJztcbiAgdmFyIHJnYiA9IFtNYXRoLnJvdW5kKGYoMCkgKiAyNTUpLCBNYXRoLnJvdW5kKGYoOCkgKiAyNTUpLCBNYXRoLnJvdW5kKGYoNCkgKiAyNTUpXTtcblxuICBpZiAoY29sb3IudHlwZSA9PT0gJ2hzbGEnKSB7XG4gICAgdHlwZSArPSAnYSc7XG4gICAgcmdiLnB1c2godmFsdWVzWzNdKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbXBvc2VDb2xvcih7XG4gICAgdHlwZTogdHlwZSxcbiAgICB2YWx1ZXM6IHJnYlxuICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgdHlwZSBhbmQgdmFsdWVzIG9mIGEgY29sb3IuXG4gKlxuICogTm90ZTogRG9lcyBub3Qgc3VwcG9ydCByZ2IgJSB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKVxuICogQHJldHVybnMge29iamVjdH0gLSBBIE1VSSBjb2xvciBvYmplY3Q6IHt0eXBlOiBzdHJpbmcsIHZhbHVlczogbnVtYmVyW119XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29tcG9zZUNvbG9yKGNvbG9yKSB7XG4gIC8vIElkZW1wb3RlbnRcbiAgaWYgKGNvbG9yLnR5cGUpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICBpZiAoY29sb3IuY2hhckF0KDApID09PSAnIycpIHtcbiAgICByZXR1cm4gZGVjb21wb3NlQ29sb3IoaGV4VG9SZ2IoY29sb3IpKTtcbiAgfVxuXG4gIHZhciBtYXJrZXIgPSBjb2xvci5pbmRleE9mKCcoJyk7XG4gIHZhciB0eXBlID0gY29sb3Iuc3Vic3RyaW5nKDAsIG1hcmtlcik7XG5cbiAgaWYgKFsncmdiJywgJ3JnYmEnLCAnaHNsJywgJ2hzbGEnXS5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk1hdGVyaWFsLVVJOiBVbnN1cHBvcnRlZCBgXCIuY29uY2F0KGNvbG9yLCBcImAgY29sb3IuXFxuV2Ugc3VwcG9ydCB0aGUgZm9sbG93aW5nIGZvcm1hdHM6ICNubm4sICNubm5ubm4sIHJnYigpLCByZ2JhKCksIGhzbCgpLCBoc2xhKCkuXCIpIDogX2Zvcm1hdE11aUVycm9yTWVzc2FnZSgzLCBjb2xvcikpO1xuICB9XG5cbiAgdmFyIHZhbHVlcyA9IGNvbG9yLnN1YnN0cmluZyhtYXJrZXIgKyAxLCBjb2xvci5sZW5ndGggLSAxKS5zcGxpdCgnLCcpO1xuICB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB2YWx1ZXM6IHZhbHVlc1xuICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGNvbG9yIG9iamVjdCB3aXRoIHR5cGUgYW5kIHZhbHVlcyB0byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29sb3IgLSBEZWNvbXBvc2VkIGNvbG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IudHlwZSAtIE9uZSBvZjogJ3JnYicsICdyZ2JhJywgJ2hzbCcsICdoc2xhJ1xuICogQHBhcmFtIHthcnJheX0gY29sb3IudmFsdWVzIC0gW24sbixuXSBvciBbbixuLG4sbl1cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZ1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByZWNvbXBvc2VDb2xvcihjb2xvcikge1xuICB2YXIgdHlwZSA9IGNvbG9yLnR5cGU7XG4gIHZhciB2YWx1ZXMgPSBjb2xvci52YWx1ZXM7XG5cbiAgaWYgKHR5cGUuaW5kZXhPZigncmdiJykgIT09IC0xKSB7XG4gICAgLy8gT25seSBjb252ZXJ0IHRoZSBmaXJzdCAzIHZhbHVlcyB0byBpbnQgKGkuZS4gbm90IGFscGhhKVxuICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKG4sIGkpIHtcbiAgICAgIHJldHVybiBpIDwgMyA/IHBhcnNlSW50KG4sIDEwKSA6IG47XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZS5pbmRleE9mKCdoc2wnKSAhPT0gLTEpIHtcbiAgICB2YWx1ZXNbMV0gPSBcIlwiLmNvbmNhdCh2YWx1ZXNbMV0sIFwiJVwiKTtcbiAgICB2YWx1ZXNbMl0gPSBcIlwiLmNvbmNhdCh2YWx1ZXNbMl0sIFwiJVwiKTtcbiAgfVxuXG4gIHJldHVybiBcIlwiLmNvbmNhdCh0eXBlLCBcIihcIikuY29uY2F0KHZhbHVlcy5qb2luKCcsICcpLCBcIilcIik7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbnRyYXN0IHJhdGlvIGJldHdlZW4gdHdvIGNvbG9ycy5cbiAqXG4gKiBGb3JtdWxhOiBodHRwczovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0cxNy5odG1sI0cxNy10ZXN0c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JlZ3JvdW5kIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKVxuICogQHBhcmFtIHtzdHJpbmd9IGJhY2tncm91bmQgLSBDU1MgY29sb3IsIGkuZS4gb25lIG9mOiAjbm5uLCAjbm5ubm5uLCByZ2IoKSwgcmdiYSgpLCBoc2woKSwgaHNsYSgpXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBIGNvbnRyYXN0IHJhdGlvIHZhbHVlIGluIHRoZSByYW5nZSAwIC0gMjEuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRyYXN0UmF0aW8oZm9yZWdyb3VuZCwgYmFja2dyb3VuZCkge1xuICB2YXIgbHVtQSA9IGdldEx1bWluYW5jZShmb3JlZ3JvdW5kKTtcbiAgdmFyIGx1bUIgPSBnZXRMdW1pbmFuY2UoYmFja2dyb3VuZCk7XG4gIHJldHVybiAoTWF0aC5tYXgobHVtQSwgbHVtQikgKyAwLjA1KSAvIChNYXRoLm1pbihsdW1BLCBsdW1CKSArIDAuMDUpO1xufVxuLyoqXG4gKiBUaGUgcmVsYXRpdmUgYnJpZ2h0bmVzcyBvZiBhbnkgcG9pbnQgaW4gYSBjb2xvciBzcGFjZSxcbiAqIG5vcm1hbGl6ZWQgdG8gMCBmb3IgZGFya2VzdCBibGFjayBhbmQgMSBmb3IgbGlnaHRlc3Qgd2hpdGUuXG4gKlxuICogRm9ybXVsYTogaHR0cHM6Ly93d3cudzMub3JnL1RSL1dDQUcyMC1URUNIUy9HMTcuaHRtbCNHMTctdGVzdHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgLSBDU1MgY29sb3IsIGkuZS4gb25lIG9mOiAjbm5uLCAjbm5ubm5uLCByZ2IoKSwgcmdiYSgpLCBoc2woKSwgaHNsYSgpXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVsYXRpdmUgYnJpZ2h0bmVzcyBvZiB0aGUgY29sb3IgaW4gdGhlIHJhbmdlIDAgLSAxXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEx1bWluYW5jZShjb2xvcikge1xuICBjb2xvciA9IGRlY29tcG9zZUNvbG9yKGNvbG9yKTtcbiAgdmFyIHJnYiA9IGNvbG9yLnR5cGUgPT09ICdoc2wnID8gZGVjb21wb3NlQ29sb3IoaHNsVG9SZ2IoY29sb3IpKS52YWx1ZXMgOiBjb2xvci52YWx1ZXM7XG4gIHJnYiA9IHJnYi5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhbCAvPSAyNTU7IC8vIG5vcm1hbGl6ZWRcblxuICAgIHJldHVybiB2YWwgPD0gMC4wMzkyOCA/IHZhbCAvIDEyLjkyIDogTWF0aC5wb3coKHZhbCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICB9KTsgLy8gVHJ1bmNhdGUgYXQgMyBkaWdpdHNcblxuICByZXR1cm4gTnVtYmVyKCgwLjIxMjYgKiByZ2JbMF0gKyAwLjcxNTIgKiByZ2JbMV0gKyAwLjA3MjIgKiByZ2JbMl0pLnRvRml4ZWQoMykpO1xufVxuLyoqXG4gKiBEYXJrZW4gb3IgbGlnaHRlbiBhIGNvbG9yLCBkZXBlbmRpbmcgb24gaXRzIGx1bWluYW5jZS5cbiAqIExpZ2h0IGNvbG9ycyBhcmUgZGFya2VuZWQsIGRhcmsgY29sb3JzIGFyZSBsaWdodGVuZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKVxuICogQHBhcmFtIHtudW1iZXJ9IGNvZWZmaWNpZW50PTAuMTUgLSBtdWx0aXBsaWVyIGluIHRoZSByYW5nZSAwIC0gMVxuICogQHJldHVybnMge3N0cmluZ30gQSBDU1MgY29sb3Igc3RyaW5nLiBIZXggaW5wdXQgdmFsdWVzIGFyZSByZXR1cm5lZCBhcyByZ2JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZW1waGFzaXplKGNvbG9yKSB7XG4gIHZhciBjb2VmZmljaWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMC4xNTtcbiAgcmV0dXJuIGdldEx1bWluYW5jZShjb2xvcikgPiAwLjUgPyBkYXJrZW4oY29sb3IsIGNvZWZmaWNpZW50KSA6IGxpZ2h0ZW4oY29sb3IsIGNvZWZmaWNpZW50KTtcbn1cbnZhciB3YXJuZWRPbmNlID0gZmFsc2U7XG4vKipcbiAqIFNldCB0aGUgYWJzb2x1dGUgdHJhbnNwYXJlbmN5IG9mIGEgY29sb3IuXG4gKiBBbnkgZXhpc3RpbmcgYWxwaGEgdmFsdWVzIGFyZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgLSBDU1MgY29sb3IsIGkuZS4gb25lIG9mOiAjbm5uLCAjbm5ubm5uLCByZ2IoKSwgcmdiYSgpLCBoc2woKSwgaHNsYSgpXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB2YWx1ZSB0byBzZXQgdGhlIGFscGhhIGNoYW5uZWwgdG8gaW4gdGhlIHJhbmdlIDAgLTFcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZy4gSGV4IGlucHV0IHZhbHVlcyBhcmUgcmV0dXJuZWQgYXMgcmdiXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIFVzZSBgaW1wb3J0IHsgYWxwaGEgfSBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS9zdHlsZXMnYCBpbnN0ZWFkLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmYWRlKGNvbG9yLCB2YWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICghd2FybmVkT25jZSkge1xuICAgICAgd2FybmVkT25jZSA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKFsnTWF0ZXJpYWwtVUk6IFRoZSBgZmFkZWAgY29sb3IgdXRpbGl0eSB3YXMgcmVuYW1lZCB0byBgYWxwaGFgIHRvIGJldHRlciBkZXNjcmliZSBpdHMgZnVuY3Rpb25hbGl0eS4nLCAnJywgXCJZb3Ugc2hvdWxkIHVzZSBgaW1wb3J0IHsgYWxwaGEgfSBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS9zdHlsZXMnYFwiXS5qb2luKCdcXG4nKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFscGhhKGNvbG9yLCB2YWx1ZSk7XG59XG4vKipcbiAqIFNldCB0aGUgYWJzb2x1dGUgdHJhbnNwYXJlbmN5IG9mIGEgY29sb3IuXG4gKiBBbnkgZXhpc3RpbmcgYWxwaGEgdmFsdWUgaXMgb3ZlcndyaXR0ZW4uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdmFsdWUgdG8gc2V0IHRoZSBhbHBoYSBjaGFubmVsIHRvIGluIHRoZSByYW5nZSAwLTFcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZy4gSGV4IGlucHV0IHZhbHVlcyBhcmUgcmV0dXJuZWQgYXMgcmdiXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFscGhhKGNvbG9yLCB2YWx1ZSkge1xuICBjb2xvciA9IGRlY29tcG9zZUNvbG9yKGNvbG9yKTtcbiAgdmFsdWUgPSBjbGFtcCh2YWx1ZSk7XG5cbiAgaWYgKGNvbG9yLnR5cGUgPT09ICdyZ2InIHx8IGNvbG9yLnR5cGUgPT09ICdoc2wnKSB7XG4gICAgY29sb3IudHlwZSArPSAnYSc7XG4gIH1cblxuICBjb2xvci52YWx1ZXNbM10gPSB2YWx1ZTtcbiAgcmV0dXJuIHJlY29tcG9zZUNvbG9yKGNvbG9yKTtcbn1cbi8qKlxuICogRGFya2VucyBhIGNvbG9yLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIENTUyBjb2xvciwgaS5lLiBvbmUgb2Y6ICNubm4sICNubm5ubm4sIHJnYigpLCByZ2JhKCksIGhzbCgpLCBoc2xhKClcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2VmZmljaWVudCAtIG11bHRpcGxpZXIgaW4gdGhlIHJhbmdlIDAgLSAxXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIENTUyBjb2xvciBzdHJpbmcuIEhleCBpbnB1dCB2YWx1ZXMgYXJlIHJldHVybmVkIGFzIHJnYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkYXJrZW4oY29sb3IsIGNvZWZmaWNpZW50KSB7XG4gIGNvbG9yID0gZGVjb21wb3NlQ29sb3IoY29sb3IpO1xuICBjb2VmZmljaWVudCA9IGNsYW1wKGNvZWZmaWNpZW50KTtcblxuICBpZiAoY29sb3IudHlwZS5pbmRleE9mKCdoc2wnKSAhPT0gLTEpIHtcbiAgICBjb2xvci52YWx1ZXNbMl0gKj0gMSAtIGNvZWZmaWNpZW50O1xuICB9IGVsc2UgaWYgKGNvbG9yLnR5cGUuaW5kZXhPZigncmdiJykgIT09IC0xKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpICs9IDEpIHtcbiAgICAgIGNvbG9yLnZhbHVlc1tpXSAqPSAxIC0gY29lZmZpY2llbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlY29tcG9zZUNvbG9yKGNvbG9yKTtcbn1cbi8qKlxuICogTGlnaHRlbnMgYSBjb2xvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgLSBDU1MgY29sb3IsIGkuZS4gb25lIG9mOiAjbm5uLCAjbm5ubm5uLCByZ2IoKSwgcmdiYSgpLCBoc2woKSwgaHNsYSgpXG4gKiBAcGFyYW0ge251bWJlcn0gY29lZmZpY2llbnQgLSBtdWx0aXBsaWVyIGluIHRoZSByYW5nZSAwIC0gMVxuICogQHJldHVybnMge3N0cmluZ30gQSBDU1MgY29sb3Igc3RyaW5nLiBIZXggaW5wdXQgdmFsdWVzIGFyZSByZXR1cm5lZCBhcyByZ2JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGlnaHRlbihjb2xvciwgY29lZmZpY2llbnQpIHtcbiAgY29sb3IgPSBkZWNvbXBvc2VDb2xvcihjb2xvcik7XG4gIGNvZWZmaWNpZW50ID0gY2xhbXAoY29lZmZpY2llbnQpO1xuXG4gIGlmIChjb2xvci50eXBlLmluZGV4T2YoJ2hzbCcpICE9PSAtMSkge1xuICAgIGNvbG9yLnZhbHVlc1syXSArPSAoMTAwIC0gY29sb3IudmFsdWVzWzJdKSAqIGNvZWZmaWNpZW50O1xuICB9IGVsc2UgaWYgKGNvbG9yLnR5cGUuaW5kZXhPZigncmdiJykgIT09IC0xKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpICs9IDEpIHtcbiAgICAgIGNvbG9yLnZhbHVlc1tpXSArPSAoMjU1IC0gY29sb3IudmFsdWVzW2ldKSAqIGNvZWZmaWNpZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWNvbXBvc2VDb2xvcihjb2xvcik7XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuLy8gU29ydGVkIEFTQyBieSBzaXplLiBUaGF0J3MgaW1wb3J0YW50LlxuLy8gSXQgY2FuJ3QgYmUgY29uZmlndXJlZCBhcyBpdCdzIHVzZWQgc3RhdGljYWxseSBmb3IgcHJvcFR5cGVzLlxuZXhwb3J0IHZhciBrZXlzID0gWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddOyAvLyBLZWVwIGluIG1pbmQgdGhhdCBAbWVkaWEgaXMgaW5jbHVzaXZlIGJ5IHRoZSBDU1Mgc3BlY2lmaWNhdGlvbi5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlQnJlYWtwb2ludHMoYnJlYWtwb2ludHMpIHtcbiAgdmFyIF9icmVha3BvaW50cyR2YWx1ZXMgPSBicmVha3BvaW50cy52YWx1ZXMsXG4gICAgICB2YWx1ZXMgPSBfYnJlYWtwb2ludHMkdmFsdWVzID09PSB2b2lkIDAgPyB7XG4gICAgeHM6IDAsXG4gICAgc206IDYwMCxcbiAgICBtZDogOTYwLFxuICAgIGxnOiAxMjgwLFxuICAgIHhsOiAxOTIwXG4gIH0gOiBfYnJlYWtwb2ludHMkdmFsdWVzLFxuICAgICAgX2JyZWFrcG9pbnRzJHVuaXQgPSBicmVha3BvaW50cy51bml0LFxuICAgICAgdW5pdCA9IF9icmVha3BvaW50cyR1bml0ID09PSB2b2lkIDAgPyAncHgnIDogX2JyZWFrcG9pbnRzJHVuaXQsXG4gICAgICBfYnJlYWtwb2ludHMkc3RlcCA9IGJyZWFrcG9pbnRzLnN0ZXAsXG4gICAgICBzdGVwID0gX2JyZWFrcG9pbnRzJHN0ZXAgPT09IHZvaWQgMCA/IDUgOiBfYnJlYWtwb2ludHMkc3RlcCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGJyZWFrcG9pbnRzLCBbXCJ2YWx1ZXNcIiwgXCJ1bml0XCIsIFwic3RlcFwiXSk7XG5cbiAgZnVuY3Rpb24gdXAoa2V5KSB7XG4gICAgdmFyIHZhbHVlID0gdHlwZW9mIHZhbHVlc1trZXldID09PSAnbnVtYmVyJyA/IHZhbHVlc1trZXldIDoga2V5O1xuICAgIHJldHVybiBcIkBtZWRpYSAobWluLXdpZHRoOlwiLmNvbmNhdCh2YWx1ZSkuY29uY2F0KHVuaXQsIFwiKVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvd24oa2V5KSB7XG4gICAgdmFyIGVuZEluZGV4ID0ga2V5cy5pbmRleE9mKGtleSkgKyAxO1xuICAgIHZhciB1cHBlcmJvdW5kID0gdmFsdWVzW2tleXNbZW5kSW5kZXhdXTtcblxuICAgIGlmIChlbmRJbmRleCA9PT0ga2V5cy5sZW5ndGgpIHtcbiAgICAgIC8vIHhsIGRvd24gYXBwbGllcyB0byBhbGwgc2l6ZXNcbiAgICAgIHJldHVybiB1cCgneHMnKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSB0eXBlb2YgdXBwZXJib3VuZCA9PT0gJ251bWJlcicgJiYgZW5kSW5kZXggPiAwID8gdXBwZXJib3VuZCA6IGtleTtcbiAgICByZXR1cm4gXCJAbWVkaWEgKG1heC13aWR0aDpcIi5jb25jYXQodmFsdWUgLSBzdGVwIC8gMTAwKS5jb25jYXQodW5pdCwgXCIpXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gYmV0d2VlbihzdGFydCwgZW5kKSB7XG4gICAgdmFyIGVuZEluZGV4ID0ga2V5cy5pbmRleE9mKGVuZCk7XG5cbiAgICBpZiAoZW5kSW5kZXggPT09IGtleXMubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIHVwKHN0YXJ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJAbWVkaWEgKG1pbi13aWR0aDpcIi5jb25jYXQodHlwZW9mIHZhbHVlc1tzdGFydF0gPT09ICdudW1iZXInID8gdmFsdWVzW3N0YXJ0XSA6IHN0YXJ0KS5jb25jYXQodW5pdCwgXCIpIGFuZCBcIikgKyBcIihtYXgtd2lkdGg6XCIuY29uY2F0KChlbmRJbmRleCAhPT0gLTEgJiYgdHlwZW9mIHZhbHVlc1trZXlzW2VuZEluZGV4ICsgMV1dID09PSAnbnVtYmVyJyA/IHZhbHVlc1trZXlzW2VuZEluZGV4ICsgMV1dIDogZW5kKSAtIHN0ZXAgLyAxMDApLmNvbmNhdCh1bml0LCBcIilcIik7XG4gIH1cblxuICBmdW5jdGlvbiBvbmx5KGtleSkge1xuICAgIHJldHVybiBiZXR3ZWVuKGtleSwga2V5KTtcbiAgfVxuXG4gIHZhciB3YXJuZWRPbmNlID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2lkdGgoa2V5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghd2FybmVkT25jZSkge1xuICAgICAgICB3YXJuZWRPbmNlID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS53YXJuKFtcIk1hdGVyaWFsLVVJOiBUaGUgYHRoZW1lLmJyZWFrcG9pbnRzLndpZHRoYCB1dGlsaXR5IGlzIGRlcHJlY2F0ZWQgYmVjYXVzZSBpdCdzIHJlZHVuZGFudC5cIiwgJ1VzZSB0aGUgYHRoZW1lLmJyZWFrcG9pbnRzLnZhbHVlc2AgaW5zdGVhZC4nXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlc1trZXldO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICBrZXlzOiBrZXlzLFxuICAgIHZhbHVlczogdmFsdWVzLFxuICAgIHVwOiB1cCxcbiAgICBkb3duOiBkb3duLFxuICAgIGJldHdlZW46IGJldHdlZW4sXG4gICAgb25seTogb25seSxcbiAgICB3aWR0aDogd2lkdGhcbiAgfSwgb3RoZXIpO1xufSIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZU1peGlucyhicmVha3BvaW50cywgc3BhY2luZywgbWl4aW5zKSB7XG4gIHZhciBfdG9vbGJhcjtcblxuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIGd1dHRlcnM6IGZ1bmN0aW9uIGd1dHRlcnMoKSB7XG4gICAgICB2YXIgc3R5bGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIGNvbnNvbGUud2FybihbJ01hdGVyaWFsLVVJOiB0aGVtZS5taXhpbnMuZ3V0dGVycygpIGlzIGRlcHJlY2F0ZWQuJywgJ1lvdSBjYW4gdXNlIHRoZSBzb3VyY2Ugb2YgdGhlIG1peGluIGRpcmVjdGx5OicsIFwiXFxuICAgICAgcGFkZGluZ0xlZnQ6IHRoZW1lLnNwYWNpbmcoMiksXFxuICAgICAgcGFkZGluZ1JpZ2h0OiB0aGVtZS5zcGFjaW5nKDIpLFxcbiAgICAgIFt0aGVtZS5icmVha3BvaW50cy51cCgnc20nKV06IHtcXG4gICAgICAgIHBhZGRpbmdMZWZ0OiB0aGVtZS5zcGFjaW5nKDMpLFxcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiB0aGVtZS5zcGFjaW5nKDMpLFxcbiAgICAgIH0sXFxuICAgICAgXCJdLmpvaW4oJ1xcbicpKTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIHBhZGRpbmdMZWZ0OiBzcGFjaW5nKDIpLFxuICAgICAgICBwYWRkaW5nUmlnaHQ6IHNwYWNpbmcoMilcbiAgICAgIH0sIHN0eWxlcywgX2RlZmluZVByb3BlcnR5KHt9LCBicmVha3BvaW50cy51cCgnc20nKSwgX2V4dGVuZHMoe1xuICAgICAgICBwYWRkaW5nTGVmdDogc3BhY2luZygzKSxcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiBzcGFjaW5nKDMpXG4gICAgICB9LCBzdHlsZXNbYnJlYWtwb2ludHMudXAoJ3NtJyldKSkpO1xuICAgIH0sXG4gICAgdG9vbGJhcjogKF90b29sYmFyID0ge1xuICAgICAgbWluSGVpZ2h0OiA1NlxuICAgIH0sIF9kZWZpbmVQcm9wZXJ0eShfdG9vbGJhciwgXCJcIi5jb25jYXQoYnJlYWtwb2ludHMudXAoJ3hzJyksIFwiIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSlcIiksIHtcbiAgICAgIG1pbkhlaWdodDogNDhcbiAgICB9KSwgX2RlZmluZVByb3BlcnR5KF90b29sYmFyLCBicmVha3BvaW50cy51cCgnc20nKSwge1xuICAgICAgbWluSGVpZ2h0OiA2NFxuICAgIH0pLCBfdG9vbGJhcilcbiAgfSwgbWl4aW5zKTtcbn0iLCJ2YXIgY29tbW9uID0ge1xuICBibGFjazogJyMwMDAnLFxuICB3aGl0ZTogJyNmZmYnXG59O1xuZXhwb3J0IGRlZmF1bHQgY29tbW9uOyIsInZhciBncmV5ID0ge1xuICA1MDogJyNmYWZhZmEnLFxuICAxMDA6ICcjZjVmNWY1JyxcbiAgMjAwOiAnI2VlZWVlZScsXG4gIDMwMDogJyNlMGUwZTAnLFxuICA0MDA6ICcjYmRiZGJkJyxcbiAgNTAwOiAnIzllOWU5ZScsXG4gIDYwMDogJyM3NTc1NzUnLFxuICA3MDA6ICcjNjE2MTYxJyxcbiAgODAwOiAnIzQyNDI0MicsXG4gIDkwMDogJyMyMTIxMjEnLFxuICBBMTAwOiAnI2Q1ZDVkNScsXG4gIEEyMDA6ICcjYWFhYWFhJyxcbiAgQTQwMDogJyMzMDMwMzAnLFxuICBBNzAwOiAnIzYxNjE2MSdcbn07XG5leHBvcnQgZGVmYXVsdCBncmV5OyIsInZhciBpbmRpZ28gPSB7XG4gIDUwOiAnI2U4ZWFmNicsXG4gIDEwMDogJyNjNWNhZTknLFxuICAyMDA6ICcjOWZhOGRhJyxcbiAgMzAwOiAnIzc5ODZjYicsXG4gIDQwMDogJyM1YzZiYzAnLFxuICA1MDA6ICcjM2Y1MWI1JyxcbiAgNjAwOiAnIzM5NDlhYicsXG4gIDcwMDogJyMzMDNmOWYnLFxuICA4MDA6ICcjMjgzNTkzJyxcbiAgOTAwOiAnIzFhMjM3ZScsXG4gIEExMDA6ICcjOGM5ZWZmJyxcbiAgQTIwMDogJyM1MzZkZmUnLFxuICBBNDAwOiAnIzNkNWFmZScsXG4gIEE3MDA6ICcjMzA0ZmZlJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGluZGlnbzsiLCJ2YXIgcGluayA9IHtcbiAgNTA6ICcjZmNlNGVjJyxcbiAgMTAwOiAnI2Y4YmJkMCcsXG4gIDIwMDogJyNmNDhmYjEnLFxuICAzMDA6ICcjZjA2MjkyJyxcbiAgNDAwOiAnI2VjNDA3YScsXG4gIDUwMDogJyNlOTFlNjMnLFxuICA2MDA6ICcjZDgxYjYwJyxcbiAgNzAwOiAnI2MyMTg1YicsXG4gIDgwMDogJyNhZDE0NTcnLFxuICA5MDA6ICcjODgwZTRmJyxcbiAgQTEwMDogJyNmZjgwYWInLFxuICBBMjAwOiAnI2ZmNDA4MScsXG4gIEE0MDA6ICcjZjUwMDU3JyxcbiAgQTcwMDogJyNjNTExNjInXG59O1xuZXhwb3J0IGRlZmF1bHQgcGluazsiLCJ2YXIgcmVkID0ge1xuICA1MDogJyNmZmViZWUnLFxuICAxMDA6ICcjZmZjZGQyJyxcbiAgMjAwOiAnI2VmOWE5YScsXG4gIDMwMDogJyNlNTczNzMnLFxuICA0MDA6ICcjZWY1MzUwJyxcbiAgNTAwOiAnI2Y0NDMzNicsXG4gIDYwMDogJyNlNTM5MzUnLFxuICA3MDA6ICcjZDMyZjJmJyxcbiAgODAwOiAnI2M2MjgyOCcsXG4gIDkwMDogJyNiNzFjMWMnLFxuICBBMTAwOiAnI2ZmOGE4MCcsXG4gIEEyMDA6ICcjZmY1MjUyJyxcbiAgQTQwMDogJyNmZjE3NDQnLFxuICBBNzAwOiAnI2Q1MDAwMCdcbn07XG5leHBvcnQgZGVmYXVsdCByZWQ7IiwidmFyIG9yYW5nZSA9IHtcbiAgNTA6ICcjZmZmM2UwJyxcbiAgMTAwOiAnI2ZmZTBiMicsXG4gIDIwMDogJyNmZmNjODAnLFxuICAzMDA6ICcjZmZiNzRkJyxcbiAgNDAwOiAnI2ZmYTcyNicsXG4gIDUwMDogJyNmZjk4MDAnLFxuICA2MDA6ICcjZmI4YzAwJyxcbiAgNzAwOiAnI2Y1N2MwMCcsXG4gIDgwMDogJyNlZjZjMDAnLFxuICA5MDA6ICcjZTY1MTAwJyxcbiAgQTEwMDogJyNmZmQxODAnLFxuICBBMjAwOiAnI2ZmYWI0MCcsXG4gIEE0MDA6ICcjZmY5MTAwJyxcbiAgQTcwMDogJyNmZjZkMDAnXG59O1xuZXhwb3J0IGRlZmF1bHQgb3JhbmdlOyIsInZhciBibHVlID0ge1xuICA1MDogJyNlM2YyZmQnLFxuICAxMDA6ICcjYmJkZWZiJyxcbiAgMjAwOiAnIzkwY2FmOScsXG4gIDMwMDogJyM2NGI1ZjYnLFxuICA0MDA6ICcjNDJhNWY1JyxcbiAgNTAwOiAnIzIxOTZmMycsXG4gIDYwMDogJyMxZTg4ZTUnLFxuICA3MDA6ICcjMTk3NmQyJyxcbiAgODAwOiAnIzE1NjVjMCcsXG4gIDkwMDogJyMwZDQ3YTEnLFxuICBBMTAwOiAnIzgyYjFmZicsXG4gIEEyMDA6ICcjNDQ4YWZmJyxcbiAgQTQwMDogJyMyOTc5ZmYnLFxuICBBNzAwOiAnIzI5NjJmZidcbn07XG5leHBvcnQgZGVmYXVsdCBibHVlOyIsInZhciBncmVlbiA9IHtcbiAgNTA6ICcjZThmNWU5JyxcbiAgMTAwOiAnI2M4ZTZjOScsXG4gIDIwMDogJyNhNWQ2YTcnLFxuICAzMDA6ICcjODFjNzg0JyxcbiAgNDAwOiAnIzY2YmI2YScsXG4gIDUwMDogJyM0Y2FmNTAnLFxuICA2MDA6ICcjNDNhMDQ3JyxcbiAgNzAwOiAnIzM4OGUzYycsXG4gIDgwMDogJyMyZTdkMzInLFxuICA5MDA6ICcjMWI1ZTIwJyxcbiAgQTEwMDogJyNiOWY2Y2EnLFxuICBBMjAwOiAnIzY5ZjBhZScsXG4gIEE0MDA6ICcjMDBlNjc2JyxcbiAgQTcwMDogJyMwMGM4NTMnXG59O1xuZXhwb3J0IGRlZmF1bHQgZ3JlZW47IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0IHsgZm9ybWF0TXVpRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRNdWlFcnJvck1lc3NhZ2UgfSBmcm9tIFwiQG1hdGVyaWFsLXVpL3V0aWxzXCI7XG5pbXBvcnQgeyBkZWVwbWVyZ2UgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IGNvbW1vbiBmcm9tICcuLi9jb2xvcnMvY29tbW9uJztcbmltcG9ydCBncmV5IGZyb20gJy4uL2NvbG9ycy9ncmV5JztcbmltcG9ydCBpbmRpZ28gZnJvbSAnLi4vY29sb3JzL2luZGlnbyc7XG5pbXBvcnQgcGluayBmcm9tICcuLi9jb2xvcnMvcGluayc7XG5pbXBvcnQgcmVkIGZyb20gJy4uL2NvbG9ycy9yZWQnO1xuaW1wb3J0IG9yYW5nZSBmcm9tICcuLi9jb2xvcnMvb3JhbmdlJztcbmltcG9ydCBibHVlIGZyb20gJy4uL2NvbG9ycy9ibHVlJztcbmltcG9ydCBncmVlbiBmcm9tICcuLi9jb2xvcnMvZ3JlZW4nO1xuaW1wb3J0IHsgZGFya2VuLCBnZXRDb250cmFzdFJhdGlvLCBsaWdodGVuIH0gZnJvbSAnLi9jb2xvck1hbmlwdWxhdG9yJztcbmV4cG9ydCB2YXIgbGlnaHQgPSB7XG4gIC8vIFRoZSBjb2xvcnMgdXNlZCB0byBzdHlsZSB0aGUgdGV4dC5cbiAgdGV4dDoge1xuICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCB0ZXh0LlxuICAgIHByaW1hcnk6ICdyZ2JhKDAsIDAsIDAsIDAuODcpJyxcbiAgICAvLyBTZWNvbmRhcnkgdGV4dC5cbiAgICBzZWNvbmRhcnk6ICdyZ2JhKDAsIDAsIDAsIDAuNTQpJyxcbiAgICAvLyBEaXNhYmxlZCB0ZXh0IGhhdmUgZXZlbiBsb3dlciB2aXN1YWwgcHJvbWluZW5jZS5cbiAgICBkaXNhYmxlZDogJ3JnYmEoMCwgMCwgMCwgMC4zOCknLFxuICAgIC8vIFRleHQgaGludHMuXG4gICAgaGludDogJ3JnYmEoMCwgMCwgMCwgMC4zOCknXG4gIH0sXG4gIC8vIFRoZSBjb2xvciB1c2VkIHRvIGRpdmlkZSBkaWZmZXJlbnQgZWxlbWVudHMuXG4gIGRpdmlkZXI6ICdyZ2JhKDAsIDAsIDAsIDAuMTIpJyxcbiAgLy8gVGhlIGJhY2tncm91bmQgY29sb3JzIHVzZWQgdG8gc3R5bGUgdGhlIHN1cmZhY2VzLlxuICAvLyBDb25zaXN0ZW5jeSBiZXR3ZWVuIHRoZXNlIHZhbHVlcyBpcyBpbXBvcnRhbnQuXG4gIGJhY2tncm91bmQ6IHtcbiAgICBwYXBlcjogY29tbW9uLndoaXRlLFxuICAgIGRlZmF1bHQ6IGdyZXlbNTBdXG4gIH0sXG4gIC8vIFRoZSBjb2xvcnMgdXNlZCB0byBzdHlsZSB0aGUgYWN0aW9uIGVsZW1lbnRzLlxuICBhY3Rpb246IHtcbiAgICAvLyBUaGUgY29sb3Igb2YgYW4gYWN0aXZlIGFjdGlvbiBsaWtlIGFuIGljb24gYnV0dG9uLlxuICAgIGFjdGl2ZTogJ3JnYmEoMCwgMCwgMCwgMC41NCknLFxuICAgIC8vIFRoZSBjb2xvciBvZiBhbiBob3ZlcmVkIGFjdGlvbi5cbiAgICBob3ZlcjogJ3JnYmEoMCwgMCwgMCwgMC4wNCknLFxuICAgIGhvdmVyT3BhY2l0eTogMC4wNCxcbiAgICAvLyBUaGUgY29sb3Igb2YgYSBzZWxlY3RlZCBhY3Rpb24uXG4gICAgc2VsZWN0ZWQ6ICdyZ2JhKDAsIDAsIDAsIDAuMDgpJyxcbiAgICBzZWxlY3RlZE9wYWNpdHk6IDAuMDgsXG4gICAgLy8gVGhlIGNvbG9yIG9mIGEgZGlzYWJsZWQgYWN0aW9uLlxuICAgIGRpc2FibGVkOiAncmdiYSgwLCAwLCAwLCAwLjI2KScsXG4gICAgLy8gVGhlIGJhY2tncm91bmQgY29sb3Igb2YgYSBkaXNhYmxlZCBhY3Rpb24uXG4gICAgZGlzYWJsZWRCYWNrZ3JvdW5kOiAncmdiYSgwLCAwLCAwLCAwLjEyKScsXG4gICAgZGlzYWJsZWRPcGFjaXR5OiAwLjM4LFxuICAgIGZvY3VzOiAncmdiYSgwLCAwLCAwLCAwLjEyKScsXG4gICAgZm9jdXNPcGFjaXR5OiAwLjEyLFxuICAgIGFjdGl2YXRlZE9wYWNpdHk6IDAuMTJcbiAgfVxufTtcbmV4cG9ydCB2YXIgZGFyayA9IHtcbiAgdGV4dDoge1xuICAgIHByaW1hcnk6IGNvbW1vbi53aGl0ZSxcbiAgICBzZWNvbmRhcnk6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyknLFxuICAgIGRpc2FibGVkOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpJyxcbiAgICBoaW50OiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpJyxcbiAgICBpY29uOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpJ1xuICB9LFxuICBkaXZpZGVyOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEyKScsXG4gIGJhY2tncm91bmQ6IHtcbiAgICBwYXBlcjogZ3JleVs4MDBdLFxuICAgIGRlZmF1bHQ6ICcjMzAzMDMwJ1xuICB9LFxuICBhY3Rpb246IHtcbiAgICBhY3RpdmU6IGNvbW1vbi53aGl0ZSxcbiAgICBob3ZlcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4wOCknLFxuICAgIGhvdmVyT3BhY2l0eTogMC4wOCxcbiAgICBzZWxlY3RlZDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4xNiknLFxuICAgIHNlbGVjdGVkT3BhY2l0eTogMC4xNixcbiAgICBkaXNhYmxlZDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKScsXG4gICAgZGlzYWJsZWRCYWNrZ3JvdW5kOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEyKScsXG4gICAgZGlzYWJsZWRPcGFjaXR5OiAwLjM4LFxuICAgIGZvY3VzOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEyKScsXG4gICAgZm9jdXNPcGFjaXR5OiAwLjEyLFxuICAgIGFjdGl2YXRlZE9wYWNpdHk6IDAuMjRcbiAgfVxufTtcblxuZnVuY3Rpb24gYWRkTGlnaHRPckRhcmsoaW50ZW50LCBkaXJlY3Rpb24sIHNoYWRlLCB0b25hbE9mZnNldCkge1xuICB2YXIgdG9uYWxPZmZzZXRMaWdodCA9IHRvbmFsT2Zmc2V0LmxpZ2h0IHx8IHRvbmFsT2Zmc2V0O1xuICB2YXIgdG9uYWxPZmZzZXREYXJrID0gdG9uYWxPZmZzZXQuZGFyayB8fCB0b25hbE9mZnNldCAqIDEuNTtcblxuICBpZiAoIWludGVudFtkaXJlY3Rpb25dKSB7XG4gICAgaWYgKGludGVudC5oYXNPd25Qcm9wZXJ0eShzaGFkZSkpIHtcbiAgICAgIGludGVudFtkaXJlY3Rpb25dID0gaW50ZW50W3NoYWRlXTtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2xpZ2h0Jykge1xuICAgICAgaW50ZW50LmxpZ2h0ID0gbGlnaHRlbihpbnRlbnQubWFpbiwgdG9uYWxPZmZzZXRMaWdodCk7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdkYXJrJykge1xuICAgICAgaW50ZW50LmRhcmsgPSBkYXJrZW4oaW50ZW50Lm1haW4sIHRvbmFsT2Zmc2V0RGFyayk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVBhbGV0dGUocGFsZXR0ZSkge1xuICB2YXIgX3BhbGV0dGUkcHJpbWFyeSA9IHBhbGV0dGUucHJpbWFyeSxcbiAgICAgIHByaW1hcnkgPSBfcGFsZXR0ZSRwcmltYXJ5ID09PSB2b2lkIDAgPyB7XG4gICAgbGlnaHQ6IGluZGlnb1szMDBdLFxuICAgIG1haW46IGluZGlnb1s1MDBdLFxuICAgIGRhcms6IGluZGlnb1s3MDBdXG4gIH0gOiBfcGFsZXR0ZSRwcmltYXJ5LFxuICAgICAgX3BhbGV0dGUkc2Vjb25kYXJ5ID0gcGFsZXR0ZS5zZWNvbmRhcnksXG4gICAgICBzZWNvbmRhcnkgPSBfcGFsZXR0ZSRzZWNvbmRhcnkgPT09IHZvaWQgMCA/IHtcbiAgICBsaWdodDogcGluay5BMjAwLFxuICAgIG1haW46IHBpbmsuQTQwMCxcbiAgICBkYXJrOiBwaW5rLkE3MDBcbiAgfSA6IF9wYWxldHRlJHNlY29uZGFyeSxcbiAgICAgIF9wYWxldHRlJGVycm9yID0gcGFsZXR0ZS5lcnJvcixcbiAgICAgIGVycm9yID0gX3BhbGV0dGUkZXJyb3IgPT09IHZvaWQgMCA/IHtcbiAgICBsaWdodDogcmVkWzMwMF0sXG4gICAgbWFpbjogcmVkWzUwMF0sXG4gICAgZGFyazogcmVkWzcwMF1cbiAgfSA6IF9wYWxldHRlJGVycm9yLFxuICAgICAgX3BhbGV0dGUkd2FybmluZyA9IHBhbGV0dGUud2FybmluZyxcbiAgICAgIHdhcm5pbmcgPSBfcGFsZXR0ZSR3YXJuaW5nID09PSB2b2lkIDAgPyB7XG4gICAgbGlnaHQ6IG9yYW5nZVszMDBdLFxuICAgIG1haW46IG9yYW5nZVs1MDBdLFxuICAgIGRhcms6IG9yYW5nZVs3MDBdXG4gIH0gOiBfcGFsZXR0ZSR3YXJuaW5nLFxuICAgICAgX3BhbGV0dGUkaW5mbyA9IHBhbGV0dGUuaW5mbyxcbiAgICAgIGluZm8gPSBfcGFsZXR0ZSRpbmZvID09PSB2b2lkIDAgPyB7XG4gICAgbGlnaHQ6IGJsdWVbMzAwXSxcbiAgICBtYWluOiBibHVlWzUwMF0sXG4gICAgZGFyazogYmx1ZVs3MDBdXG4gIH0gOiBfcGFsZXR0ZSRpbmZvLFxuICAgICAgX3BhbGV0dGUkc3VjY2VzcyA9IHBhbGV0dGUuc3VjY2VzcyxcbiAgICAgIHN1Y2Nlc3MgPSBfcGFsZXR0ZSRzdWNjZXNzID09PSB2b2lkIDAgPyB7XG4gICAgbGlnaHQ6IGdyZWVuWzMwMF0sXG4gICAgbWFpbjogZ3JlZW5bNTAwXSxcbiAgICBkYXJrOiBncmVlbls3MDBdXG4gIH0gOiBfcGFsZXR0ZSRzdWNjZXNzLFxuICAgICAgX3BhbGV0dGUkdHlwZSA9IHBhbGV0dGUudHlwZSxcbiAgICAgIHR5cGUgPSBfcGFsZXR0ZSR0eXBlID09PSB2b2lkIDAgPyAnbGlnaHQnIDogX3BhbGV0dGUkdHlwZSxcbiAgICAgIF9wYWxldHRlJGNvbnRyYXN0VGhyZSA9IHBhbGV0dGUuY29udHJhc3RUaHJlc2hvbGQsXG4gICAgICBjb250cmFzdFRocmVzaG9sZCA9IF9wYWxldHRlJGNvbnRyYXN0VGhyZSA9PT0gdm9pZCAwID8gMyA6IF9wYWxldHRlJGNvbnRyYXN0VGhyZSxcbiAgICAgIF9wYWxldHRlJHRvbmFsT2Zmc2V0ID0gcGFsZXR0ZS50b25hbE9mZnNldCxcbiAgICAgIHRvbmFsT2Zmc2V0ID0gX3BhbGV0dGUkdG9uYWxPZmZzZXQgPT09IHZvaWQgMCA/IDAuMiA6IF9wYWxldHRlJHRvbmFsT2Zmc2V0LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocGFsZXR0ZSwgW1wicHJpbWFyeVwiLCBcInNlY29uZGFyeVwiLCBcImVycm9yXCIsIFwid2FybmluZ1wiLCBcImluZm9cIiwgXCJzdWNjZXNzXCIsIFwidHlwZVwiLCBcImNvbnRyYXN0VGhyZXNob2xkXCIsIFwidG9uYWxPZmZzZXRcIl0pOyAvLyBVc2UgdGhlIHNhbWUgbG9naWMgYXNcbiAgLy8gQm9vdHN0cmFwOiBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi8xZDZlMzcxMGRkNDQ3ZGUxYTIwMGYyOWU4ZmE1MjFmOGEwOTA4ZjcwL3Njc3MvX2Z1bmN0aW9ucy5zY3NzI0w1OVxuICAvLyBhbmQgbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIgaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9hYzQ2Yjg4NjNjNGRhYjlmYzIyYzRjNjYyZGM2YmQxYjY1ZGQ2NTJmL3BhY2thZ2VzL21kYy10aGVtZS9fZnVuY3Rpb25zLnNjc3MjTDU0XG5cblxuICBmdW5jdGlvbiBnZXRDb250cmFzdFRleHQoYmFja2dyb3VuZCkge1xuICAgIHZhciBjb250cmFzdFRleHQgPSBnZXRDb250cmFzdFJhdGlvKGJhY2tncm91bmQsIGRhcmsudGV4dC5wcmltYXJ5KSA+PSBjb250cmFzdFRocmVzaG9sZCA/IGRhcmsudGV4dC5wcmltYXJ5IDogbGlnaHQudGV4dC5wcmltYXJ5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBjb250cmFzdCA9IGdldENvbnRyYXN0UmF0aW8oYmFja2dyb3VuZCwgY29udHJhc3RUZXh0KTtcblxuICAgICAgaWYgKGNvbnRyYXN0IDwgMykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFtcIk1hdGVyaWFsLVVJOiBUaGUgY29udHJhc3QgcmF0aW8gb2YgXCIuY29uY2F0KGNvbnRyYXN0LCBcIjoxIGZvciBcIikuY29uY2F0KGNvbnRyYXN0VGV4dCwgXCIgb24gXCIpLmNvbmNhdChiYWNrZ3JvdW5kKSwgJ2ZhbGxzIGJlbG93IHRoZSBXQ0FHIHJlY29tbWVuZGVkIGFic29sdXRlIG1pbmltdW0gY29udHJhc3QgcmF0aW8gb2YgMzoxLicsICdodHRwczovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMtV0NBRzIwLTIwMDgxMjExLyN2aXN1YWwtYXVkaW8tY29udHJhc3QtY29udHJhc3QnXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRyYXN0VGV4dDtcbiAgfVxuXG4gIHZhciBhdWdtZW50Q29sb3IgPSBmdW5jdGlvbiBhdWdtZW50Q29sb3IoY29sb3IpIHtcbiAgICB2YXIgbWFpblNoYWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA1MDA7XG4gICAgdmFyIGxpZ2h0U2hhZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDMwMDtcbiAgICB2YXIgZGFya1NoYWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiA3MDA7XG4gICAgY29sb3IgPSBfZXh0ZW5kcyh7fSwgY29sb3IpO1xuXG4gICAgaWYgKCFjb2xvci5tYWluICYmIGNvbG9yW21haW5TaGFkZV0pIHtcbiAgICAgIGNvbG9yLm1haW4gPSBjb2xvclttYWluU2hhZGVdO1xuICAgIH1cblxuICAgIGlmICghY29sb3IubWFpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiTWF0ZXJpYWwtVUk6IFRoZSBjb2xvciBwcm92aWRlZCB0byBhdWdtZW50Q29sb3IoY29sb3IpIGlzIGludmFsaWQuXFxuVGhlIGNvbG9yIG9iamVjdCBuZWVkcyB0byBoYXZlIGEgYG1haW5gIHByb3BlcnR5IG9yIGEgYFwiLmNvbmNhdChtYWluU2hhZGUsIFwiYCBwcm9wZXJ0eS5cIikgOiBfZm9ybWF0TXVpRXJyb3JNZXNzYWdlKDQsIG1haW5TaGFkZSkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29sb3IubWFpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk1hdGVyaWFsLVVJOiBUaGUgY29sb3IgcHJvdmlkZWQgdG8gYXVnbWVudENvbG9yKGNvbG9yKSBpcyBpbnZhbGlkLlxcbmBjb2xvci5tYWluYCBzaG91bGQgYmUgYSBzdHJpbmcsIGJ1dCBgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGNvbG9yLm1haW4pLCBcImAgd2FzIHByb3ZpZGVkIGluc3RlYWQuXFxuXFxuRGlkIHlvdSBpbnRlbmQgdG8gdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGFwcHJvYWNoZXM/XFxuXFxuaW1wb3J0IHtcXHhBMGdyZWVuIH0gZnJvbSBcXFwiQG1hdGVyaWFsLXVpL2NvcmUvY29sb3JzXFxcIjtcXG5cXG5jb25zdCB0aGVtZTEgPSBjcmVhdGVUaGVtZSh7IHBhbGV0dGU6IHtcXG4gIHByaW1hcnk6IGdyZWVuLFxcbn0gfSk7XFxuXFxuY29uc3QgdGhlbWUyID0gY3JlYXRlVGhlbWUoeyBwYWxldHRlOiB7XFxuICBwcmltYXJ5OiB7IG1haW46IGdyZWVuWzUwMF0gfSxcXG59IH0pO1wiKSA6IF9mb3JtYXRNdWlFcnJvck1lc3NhZ2UoNSwgSlNPTi5zdHJpbmdpZnkoY29sb3IubWFpbikpKTtcbiAgICB9XG5cbiAgICBhZGRMaWdodE9yRGFyayhjb2xvciwgJ2xpZ2h0JywgbGlnaHRTaGFkZSwgdG9uYWxPZmZzZXQpO1xuICAgIGFkZExpZ2h0T3JEYXJrKGNvbG9yLCAnZGFyaycsIGRhcmtTaGFkZSwgdG9uYWxPZmZzZXQpO1xuXG4gICAgaWYgKCFjb2xvci5jb250cmFzdFRleHQpIHtcbiAgICAgIGNvbG9yLmNvbnRyYXN0VGV4dCA9IGdldENvbnRyYXN0VGV4dChjb2xvci5tYWluKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sb3I7XG4gIH07XG5cbiAgdmFyIHR5cGVzID0ge1xuICAgIGRhcms6IGRhcmssXG4gICAgbGlnaHQ6IGxpZ2h0XG4gIH07XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoIXR5cGVzW3R5cGVdKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTWF0ZXJpYWwtVUk6IFRoZSBwYWxldHRlIHR5cGUgYFwiLmNvbmNhdCh0eXBlLCBcImAgaXMgbm90IHN1cHBvcnRlZC5cIikpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwYWxldHRlT3V0cHV0ID0gZGVlcG1lcmdlKF9leHRlbmRzKHtcbiAgICAvLyBBIGNvbGxlY3Rpb24gb2YgY29tbW9uIGNvbG9ycy5cbiAgICBjb21tb246IGNvbW1vbixcbiAgICAvLyBUaGUgcGFsZXR0ZSB0eXBlLCBjYW4gYmUgbGlnaHQgb3IgZGFyay5cbiAgICB0eXBlOiB0eXBlLFxuICAgIC8vIFRoZSBjb2xvcnMgdXNlZCB0byByZXByZXNlbnQgcHJpbWFyeSBpbnRlcmZhY2UgZWxlbWVudHMgZm9yIGEgdXNlci5cbiAgICBwcmltYXJ5OiBhdWdtZW50Q29sb3IocHJpbWFyeSksXG4gICAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIHJlcHJlc2VudCBzZWNvbmRhcnkgaW50ZXJmYWNlIGVsZW1lbnRzIGZvciBhIHVzZXIuXG4gICAgc2Vjb25kYXJ5OiBhdWdtZW50Q29sb3Ioc2Vjb25kYXJ5LCAnQTQwMCcsICdBMjAwJywgJ0E3MDAnKSxcbiAgICAvLyBUaGUgY29sb3JzIHVzZWQgdG8gcmVwcmVzZW50IGludGVyZmFjZSBlbGVtZW50cyB0aGF0IHRoZSB1c2VyIHNob3VsZCBiZSBtYWRlIGF3YXJlIG9mLlxuICAgIGVycm9yOiBhdWdtZW50Q29sb3IoZXJyb3IpLFxuICAgIC8vIFRoZSBjb2xvcnMgdXNlZCB0byByZXByZXNlbnQgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIGFjdGlvbnMgb3IgaW1wb3J0YW50IG1lc3NhZ2VzLlxuICAgIHdhcm5pbmc6IGF1Z21lbnRDb2xvcih3YXJuaW5nKSxcbiAgICAvLyBUaGUgY29sb3JzIHVzZWQgdG8gcHJlc2VudCBpbmZvcm1hdGlvbiB0byB0aGUgdXNlciB0aGF0IGlzIG5ldXRyYWwgYW5kIG5vdCBuZWNlc3NhcmlseSBpbXBvcnRhbnQuXG4gICAgaW5mbzogYXVnbWVudENvbG9yKGluZm8pLFxuICAgIC8vIFRoZSBjb2xvcnMgdXNlZCB0byBpbmRpY2F0ZSB0aGUgc3VjY2Vzc2Z1bCBjb21wbGV0aW9uIG9mIGFuIGFjdGlvbiB0aGF0IHVzZXIgdHJpZ2dlcmVkLlxuICAgIHN1Y2Nlc3M6IGF1Z21lbnRDb2xvcihzdWNjZXNzKSxcbiAgICAvLyBUaGUgZ3JleSBjb2xvcnMuXG4gICAgZ3JleTogZ3JleSxcbiAgICAvLyBVc2VkIGJ5IGBnZXRDb250cmFzdFRleHQoKWAgdG8gbWF4aW1pemUgdGhlIGNvbnRyYXN0IGJldHdlZW5cbiAgICAvLyB0aGUgYmFja2dyb3VuZCBhbmQgdGhlIHRleHQuXG4gICAgY29udHJhc3RUaHJlc2hvbGQ6IGNvbnRyYXN0VGhyZXNob2xkLFxuICAgIC8vIFRha2VzIGEgYmFja2dyb3VuZCBjb2xvciBhbmQgcmV0dXJucyB0aGUgdGV4dCBjb2xvciB0aGF0IG1heGltaXplcyB0aGUgY29udHJhc3QuXG4gICAgZ2V0Q29udHJhc3RUZXh0OiBnZXRDb250cmFzdFRleHQsXG4gICAgLy8gR2VuZXJhdGUgYSByaWNoIGNvbG9yIG9iamVjdC5cbiAgICBhdWdtZW50Q29sb3I6IGF1Z21lbnRDb2xvcixcbiAgICAvLyBVc2VkIGJ5IHRoZSBmdW5jdGlvbnMgYmVsb3cgdG8gc2hpZnQgYSBjb2xvcidzIGx1bWluYW5jZSBieSBhcHByb3hpbWF0ZWx5XG4gICAgLy8gdHdvIGluZGV4ZXMgd2l0aGluIGl0cyB0b25hbCBwYWxldHRlLlxuICAgIC8vIEUuZy4sIHNoaWZ0IGZyb20gUmVkIDUwMCB0byBSZWQgMzAwIG9yIFJlZCA3MDAuXG4gICAgdG9uYWxPZmZzZXQ6IHRvbmFsT2Zmc2V0XG4gIH0sIHR5cGVzW3R5cGVdKSwgb3RoZXIpO1xuICByZXR1cm4gcGFsZXR0ZU91dHB1dDtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBkZWVwbWVyZ2UgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuXG5mdW5jdGlvbiByb3VuZCh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDFlNSkgLyAxZTU7XG59XG5cbnZhciB3YXJuZWRPbmNlID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHJvdW5kV2l0aERlcHJlY2F0aW9uV2FybmluZyh2YWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICghd2FybmVkT25jZSkge1xuICAgICAgY29uc29sZS53YXJuKFsnTWF0ZXJpYWwtVUk6IFRoZSBgdGhlbWUudHlwb2dyYXBoeS5yb3VuZGAgaGVscGVyIGlzIGRlcHJlY2F0ZWQuJywgJ0hlYWQgdG8gaHR0cHM6Ly9tYXRlcmlhbC11aS5jb20vci9taWdyYXRpb24tdjQvI3RoZW1lIGZvciBhIG1pZ3JhdGlvbiBwYXRoLiddLmpvaW4oJ1xcbicpKTtcbiAgICAgIHdhcm5lZE9uY2UgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb3VuZCh2YWx1ZSk7XG59XG5cbnZhciBjYXNlQWxsQ2FwcyA9IHtcbiAgdGV4dFRyYW5zZm9ybTogJ3VwcGVyY2FzZSdcbn07XG52YXIgZGVmYXVsdEZvbnRGYW1pbHkgPSAnXCJSb2JvdG9cIiwgXCJIZWx2ZXRpY2FcIiwgXCJBcmlhbFwiLCBzYW5zLXNlcmlmJztcbi8qKlxuICogQHNlZSBAbGlua3todHRwczovL21hdGVyaWFsLmlvL2Rlc2lnbi90eXBvZ3JhcGh5L3RoZS10eXBlLXN5c3RlbS5odG1sfVxuICogQHNlZSBAbGlua3todHRwczovL21hdGVyaWFsLmlvL2Rlc2lnbi90eXBvZ3JhcGh5L3VuZGVyc3RhbmRpbmctdHlwb2dyYXBoeS5odG1sfVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVR5cG9ncmFwaHkocGFsZXR0ZSwgdHlwb2dyYXBoeSkge1xuICB2YXIgX3JlZiA9IHR5cGVvZiB0eXBvZ3JhcGh5ID09PSAnZnVuY3Rpb24nID8gdHlwb2dyYXBoeShwYWxldHRlKSA6IHR5cG9ncmFwaHksXG4gICAgICBfcmVmJGZvbnRGYW1pbHkgPSBfcmVmLmZvbnRGYW1pbHksXG4gICAgICBmb250RmFtaWx5ID0gX3JlZiRmb250RmFtaWx5ID09PSB2b2lkIDAgPyBkZWZhdWx0Rm9udEZhbWlseSA6IF9yZWYkZm9udEZhbWlseSxcbiAgICAgIF9yZWYkZm9udFNpemUgPSBfcmVmLmZvbnRTaXplLFxuICAgICAgZm9udFNpemUgPSBfcmVmJGZvbnRTaXplID09PSB2b2lkIDAgPyAxNCA6IF9yZWYkZm9udFNpemUsXG4gICAgICBfcmVmJGZvbnRXZWlnaHRMaWdodCA9IF9yZWYuZm9udFdlaWdodExpZ2h0LFxuICAgICAgZm9udFdlaWdodExpZ2h0ID0gX3JlZiRmb250V2VpZ2h0TGlnaHQgPT09IHZvaWQgMCA/IDMwMCA6IF9yZWYkZm9udFdlaWdodExpZ2h0LFxuICAgICAgX3JlZiRmb250V2VpZ2h0UmVndWxhID0gX3JlZi5mb250V2VpZ2h0UmVndWxhcixcbiAgICAgIGZvbnRXZWlnaHRSZWd1bGFyID0gX3JlZiRmb250V2VpZ2h0UmVndWxhID09PSB2b2lkIDAgPyA0MDAgOiBfcmVmJGZvbnRXZWlnaHRSZWd1bGEsXG4gICAgICBfcmVmJGZvbnRXZWlnaHRNZWRpdW0gPSBfcmVmLmZvbnRXZWlnaHRNZWRpdW0sXG4gICAgICBmb250V2VpZ2h0TWVkaXVtID0gX3JlZiRmb250V2VpZ2h0TWVkaXVtID09PSB2b2lkIDAgPyA1MDAgOiBfcmVmJGZvbnRXZWlnaHRNZWRpdW0sXG4gICAgICBfcmVmJGZvbnRXZWlnaHRCb2xkID0gX3JlZi5mb250V2VpZ2h0Qm9sZCxcbiAgICAgIGZvbnRXZWlnaHRCb2xkID0gX3JlZiRmb250V2VpZ2h0Qm9sZCA9PT0gdm9pZCAwID8gNzAwIDogX3JlZiRmb250V2VpZ2h0Qm9sZCxcbiAgICAgIF9yZWYkaHRtbEZvbnRTaXplID0gX3JlZi5odG1sRm9udFNpemUsXG4gICAgICBodG1sRm9udFNpemUgPSBfcmVmJGh0bWxGb250U2l6ZSA9PT0gdm9pZCAwID8gMTYgOiBfcmVmJGh0bWxGb250U2l6ZSxcbiAgICAgIGFsbFZhcmlhbnRzID0gX3JlZi5hbGxWYXJpYW50cyxcbiAgICAgIHB4VG9SZW0yID0gX3JlZi5weFRvUmVtLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW1wiZm9udEZhbWlseVwiLCBcImZvbnRTaXplXCIsIFwiZm9udFdlaWdodExpZ2h0XCIsIFwiZm9udFdlaWdodFJlZ3VsYXJcIiwgXCJmb250V2VpZ2h0TWVkaXVtXCIsIFwiZm9udFdlaWdodEJvbGRcIiwgXCJodG1sRm9udFNpemVcIiwgXCJhbGxWYXJpYW50c1wiLCBcInB4VG9SZW1cIl0pO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiBmb250U2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01hdGVyaWFsLVVJOiBgZm9udFNpemVgIGlzIHJlcXVpcmVkIHRvIGJlIGEgbnVtYmVyLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaHRtbEZvbnRTaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgY29uc29sZS5lcnJvcignTWF0ZXJpYWwtVUk6IGBodG1sRm9udFNpemVgIGlzIHJlcXVpcmVkIHRvIGJlIGEgbnVtYmVyLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb2VmID0gZm9udFNpemUgLyAxNDtcblxuICB2YXIgcHhUb1JlbSA9IHB4VG9SZW0yIHx8IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHNpemUgLyBodG1sRm9udFNpemUgKiBjb2VmLCBcInJlbVwiKTtcbiAgfTtcblxuICB2YXIgYnVpbGRWYXJpYW50ID0gZnVuY3Rpb24gYnVpbGRWYXJpYW50KGZvbnRXZWlnaHQsIHNpemUsIGxpbmVIZWlnaHQsIGxldHRlclNwYWNpbmcsIGNhc2luZykge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBmb250RmFtaWx5OiBmb250RmFtaWx5LFxuICAgICAgZm9udFdlaWdodDogZm9udFdlaWdodCxcbiAgICAgIGZvbnRTaXplOiBweFRvUmVtKHNpemUpLFxuICAgICAgLy8gVW5pdGxlc3MgZm9sbG93aW5nIGh0dHBzOi8vbWV5ZXJ3ZWIuY29tL2VyaWMvdGhvdWdodHMvMjAwNi8wMi8wOC91bml0bGVzcy1saW5lLWhlaWdodHMvXG4gICAgICBsaW5lSGVpZ2h0OiBsaW5lSGVpZ2h0XG4gICAgfSwgZm9udEZhbWlseSA9PT0gZGVmYXVsdEZvbnRGYW1pbHkgPyB7XG4gICAgICBsZXR0ZXJTcGFjaW5nOiBcIlwiLmNvbmNhdChyb3VuZChsZXR0ZXJTcGFjaW5nIC8gc2l6ZSksIFwiZW1cIilcbiAgICB9IDoge30sIGNhc2luZywgYWxsVmFyaWFudHMpO1xuICB9O1xuXG4gIHZhciB2YXJpYW50cyA9IHtcbiAgICBoMTogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRMaWdodCwgOTYsIDEuMTY3LCAtMS41KSxcbiAgICBoMjogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRMaWdodCwgNjAsIDEuMiwgLTAuNSksXG4gICAgaDM6IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0UmVndWxhciwgNDgsIDEuMTY3LCAwKSxcbiAgICBoNDogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRSZWd1bGFyLCAzNCwgMS4yMzUsIDAuMjUpLFxuICAgIGg1OiBidWlsZFZhcmlhbnQoZm9udFdlaWdodFJlZ3VsYXIsIDI0LCAxLjMzNCwgMCksXG4gICAgaDY6IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0TWVkaXVtLCAyMCwgMS42LCAwLjE1KSxcbiAgICBzdWJ0aXRsZTE6IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0UmVndWxhciwgMTYsIDEuNzUsIDAuMTUpLFxuICAgIHN1YnRpdGxlMjogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRNZWRpdW0sIDE0LCAxLjU3LCAwLjEpLFxuICAgIGJvZHkxOiBidWlsZFZhcmlhbnQoZm9udFdlaWdodFJlZ3VsYXIsIDE2LCAxLjUsIDAuMTUpLFxuICAgIGJvZHkyOiBidWlsZFZhcmlhbnQoZm9udFdlaWdodFJlZ3VsYXIsIDE0LCAxLjQzLCAwLjE1KSxcbiAgICBidXR0b246IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0TWVkaXVtLCAxNCwgMS43NSwgMC40LCBjYXNlQWxsQ2FwcyksXG4gICAgY2FwdGlvbjogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRSZWd1bGFyLCAxMiwgMS42NiwgMC40KSxcbiAgICBvdmVybGluZTogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRSZWd1bGFyLCAxMiwgMi42NiwgMSwgY2FzZUFsbENhcHMpXG4gIH07XG4gIHJldHVybiBkZWVwbWVyZ2UoX2V4dGVuZHMoe1xuICAgIGh0bWxGb250U2l6ZTogaHRtbEZvbnRTaXplLFxuICAgIHB4VG9SZW06IHB4VG9SZW0sXG4gICAgcm91bmQ6IHJvdW5kV2l0aERlcHJlY2F0aW9uV2FybmluZyxcbiAgICAvLyBUT0RPIHY1OiByZW1vdmVcbiAgICBmb250RmFtaWx5OiBmb250RmFtaWx5LFxuICAgIGZvbnRTaXplOiBmb250U2l6ZSxcbiAgICBmb250V2VpZ2h0TGlnaHQ6IGZvbnRXZWlnaHRMaWdodCxcbiAgICBmb250V2VpZ2h0UmVndWxhcjogZm9udFdlaWdodFJlZ3VsYXIsXG4gICAgZm9udFdlaWdodE1lZGl1bTogZm9udFdlaWdodE1lZGl1bSxcbiAgICBmb250V2VpZ2h0Qm9sZDogZm9udFdlaWdodEJvbGRcbiAgfSwgdmFyaWFudHMpLCBvdGhlciwge1xuICAgIGNsb25lOiBmYWxzZSAvLyBObyBuZWVkIHRvIGNsb25lIGRlZXBcblxuICB9KTtcbn0iLCJ2YXIgc2hhZG93S2V5VW1icmFPcGFjaXR5ID0gMC4yO1xudmFyIHNoYWRvd0tleVBlbnVtYnJhT3BhY2l0eSA9IDAuMTQ7XG52YXIgc2hhZG93QW1iaWVudFNoYWRvd09wYWNpdHkgPSAwLjEyO1xuXG5mdW5jdGlvbiBjcmVhdGVTaGFkb3coKSB7XG4gIHJldHVybiBbXCJcIi5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdLCBcInB4IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdLCBcInB4IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdLCBcInB4IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSAzID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzNdLCBcInB4IHJnYmEoMCwwLDAsXCIpLmNvbmNhdChzaGFkb3dLZXlVbWJyYU9wYWNpdHksIFwiKVwiKSwgXCJcIi5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSA0ID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzRdLCBcInB4IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSA1ID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzVdLCBcInB4IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSA2ID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzZdLCBcInB4IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSA3ID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzddLCBcInB4IHJnYmEoMCwwLDAsXCIpLmNvbmNhdChzaGFkb3dLZXlQZW51bWJyYU9wYWNpdHksIFwiKVwiKSwgXCJcIi5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSA4ID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzhdLCBcInB4IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSA5ID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzldLCBcInB4IFwiKS5jb25jYXQoYXJndW1lbnRzLmxlbmd0aCA8PSAxMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxMF0sIFwicHggXCIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoIDw9IDExID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzExXSwgXCJweCByZ2JhKDAsMCwwLFwiKS5jb25jYXQoc2hhZG93QW1iaWVudFNoYWRvd09wYWNpdHksIFwiKVwiKV0uam9pbignLCcpO1xufSAvLyBWYWx1ZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL2JlODc0N2Y5NDU3NDY2OWNiNWU3YWRkMWE3YzU0ZmE0MWE4OWNlYzcvcGFja2FnZXMvbWRjLWVsZXZhdGlvbi9fdmFyaWFibGVzLnNjc3NcblxuXG52YXIgc2hhZG93cyA9IFsnbm9uZScsIGNyZWF0ZVNoYWRvdygwLCAyLCAxLCAtMSwgMCwgMSwgMSwgMCwgMCwgMSwgMywgMCksIGNyZWF0ZVNoYWRvdygwLCAzLCAxLCAtMiwgMCwgMiwgMiwgMCwgMCwgMSwgNSwgMCksIGNyZWF0ZVNoYWRvdygwLCAzLCAzLCAtMiwgMCwgMywgNCwgMCwgMCwgMSwgOCwgMCksIGNyZWF0ZVNoYWRvdygwLCAyLCA0LCAtMSwgMCwgNCwgNSwgMCwgMCwgMSwgMTAsIDApLCBjcmVhdGVTaGFkb3coMCwgMywgNSwgLTEsIDAsIDUsIDgsIDAsIDAsIDEsIDE0LCAwKSwgY3JlYXRlU2hhZG93KDAsIDMsIDUsIC0xLCAwLCA2LCAxMCwgMCwgMCwgMSwgMTgsIDApLCBjcmVhdGVTaGFkb3coMCwgNCwgNSwgLTIsIDAsIDcsIDEwLCAxLCAwLCAyLCAxNiwgMSksIGNyZWF0ZVNoYWRvdygwLCA1LCA1LCAtMywgMCwgOCwgMTAsIDEsIDAsIDMsIDE0LCAyKSwgY3JlYXRlU2hhZG93KDAsIDUsIDYsIC0zLCAwLCA5LCAxMiwgMSwgMCwgMywgMTYsIDIpLCBjcmVhdGVTaGFkb3coMCwgNiwgNiwgLTMsIDAsIDEwLCAxNCwgMSwgMCwgNCwgMTgsIDMpLCBjcmVhdGVTaGFkb3coMCwgNiwgNywgLTQsIDAsIDExLCAxNSwgMSwgMCwgNCwgMjAsIDMpLCBjcmVhdGVTaGFkb3coMCwgNywgOCwgLTQsIDAsIDEyLCAxNywgMiwgMCwgNSwgMjIsIDQpLCBjcmVhdGVTaGFkb3coMCwgNywgOCwgLTQsIDAsIDEzLCAxOSwgMiwgMCwgNSwgMjQsIDQpLCBjcmVhdGVTaGFkb3coMCwgNywgOSwgLTQsIDAsIDE0LCAyMSwgMiwgMCwgNSwgMjYsIDQpLCBjcmVhdGVTaGFkb3coMCwgOCwgOSwgLTUsIDAsIDE1LCAyMiwgMiwgMCwgNiwgMjgsIDUpLCBjcmVhdGVTaGFkb3coMCwgOCwgMTAsIC01LCAwLCAxNiwgMjQsIDIsIDAsIDYsIDMwLCA1KSwgY3JlYXRlU2hhZG93KDAsIDgsIDExLCAtNSwgMCwgMTcsIDI2LCAyLCAwLCA2LCAzMiwgNSksIGNyZWF0ZVNoYWRvdygwLCA5LCAxMSwgLTUsIDAsIDE4LCAyOCwgMiwgMCwgNywgMzQsIDYpLCBjcmVhdGVTaGFkb3coMCwgOSwgMTIsIC02LCAwLCAxOSwgMjksIDIsIDAsIDcsIDM2LCA2KSwgY3JlYXRlU2hhZG93KDAsIDEwLCAxMywgLTYsIDAsIDIwLCAzMSwgMywgMCwgOCwgMzgsIDcpLCBjcmVhdGVTaGFkb3coMCwgMTAsIDEzLCAtNiwgMCwgMjEsIDMzLCAzLCAwLCA4LCA0MCwgNyksIGNyZWF0ZVNoYWRvdygwLCAxMCwgMTQsIC02LCAwLCAyMiwgMzUsIDMsIDAsIDgsIDQyLCA3KSwgY3JlYXRlU2hhZG93KDAsIDExLCAxNCwgLTcsIDAsIDIzLCAzNiwgMywgMCwgOSwgNDQsIDgpLCBjcmVhdGVTaGFkb3coMCwgMTEsIDE1LCAtNywgMCwgMjQsIDM4LCAzLCAwLCA5LCA0NiwgOCldO1xuZXhwb3J0IGRlZmF1bHQgc2hhZG93czsiLCJ2YXIgc2hhcGUgPSB7XG4gIGJvcmRlclJhZGl1czogNFxufTtcbmV4cG9ydCBkZWZhdWx0IHNoYXBlOyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG52YXIgcmVzcG9uc2l2ZVByb3BUeXBlID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5hcnJheV0pIDoge307XG5leHBvcnQgZGVmYXVsdCByZXNwb25zaXZlUHJvcFR5cGU7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufSIsImltcG9ydCBhcnJheUxpa2VUb0FycmF5IGZyb20gXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59IiwiaW1wb3J0IGFycmF5TGlrZVRvQXJyYXkgZnJvbSBcIi4vYXJyYXlMaWtlVG9BcnJheS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufSIsImltcG9ydCBhcnJheVdpdGhvdXRIb2xlcyBmcm9tIFwiLi9hcnJheVdpdGhvdXRIb2xlcy5qc1wiO1xuaW1wb3J0IGl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiLi9pdGVyYWJsZVRvQXJyYXkuanNcIjtcbmltcG9ydCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiO1xuaW1wb3J0IG5vbkl0ZXJhYmxlU3ByZWFkIGZyb20gXCIuL25vbkl0ZXJhYmxlU3ByZWFkLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59IiwiaW1wb3J0IGFycmF5V2l0aEhvbGVzIGZyb20gXCIuL2FycmF5V2l0aEhvbGVzLmpzXCI7XG5pbXBvcnQgaXRlcmFibGVUb0FycmF5TGltaXQgZnJvbSBcIi4vaXRlcmFibGVUb0FycmF5TGltaXQuanNcIjtcbmltcG9ydCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiO1xuaW1wb3J0IG5vbkl0ZXJhYmxlUmVzdCBmcm9tIFwiLi9ub25JdGVyYWJsZVJlc3QuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59IiwiaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgcmVzcG9uc2l2ZVByb3BUeXBlIGZyb20gJy4vcmVzcG9uc2l2ZVByb3BUeXBlJztcbmltcG9ydCB7IGhhbmRsZUJyZWFrcG9pbnRzIH0gZnJvbSAnLi9icmVha3BvaW50cyc7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnLi9tZXJnZSc7XG5pbXBvcnQgbWVtb2l6ZSBmcm9tICcuL21lbW9pemUnO1xudmFyIHByb3BlcnRpZXMgPSB7XG4gIG06ICdtYXJnaW4nLFxuICBwOiAncGFkZGluZydcbn07XG52YXIgZGlyZWN0aW9ucyA9IHtcbiAgdDogJ1RvcCcsXG4gIHI6ICdSaWdodCcsXG4gIGI6ICdCb3R0b20nLFxuICBsOiAnTGVmdCcsXG4gIHg6IFsnTGVmdCcsICdSaWdodCddLFxuICB5OiBbJ1RvcCcsICdCb3R0b20nXVxufTtcbnZhciBhbGlhc2VzID0ge1xuICBtYXJnaW5YOiAnbXgnLFxuICBtYXJnaW5ZOiAnbXknLFxuICBwYWRkaW5nWDogJ3B4JyxcbiAgcGFkZGluZ1k6ICdweSdcbn07IC8vIG1lbW9pemUoKSBpbXBhY3Q6XG4vLyBGcm9tIDMwMCwwMDAgb3BzL3NlY1xuLy8gVG8gMzUwLDAwMCBvcHMvc2VjXG5cbnZhciBnZXRDc3NQcm9wZXJ0aWVzID0gbWVtb2l6ZShmdW5jdGlvbiAocHJvcCkge1xuICAvLyBJdCdzIG5vdCBhIHNob3J0aGFuZCBub3RhdGlvbi5cbiAgaWYgKHByb3AubGVuZ3RoID4gMikge1xuICAgIGlmIChhbGlhc2VzW3Byb3BdKSB7XG4gICAgICBwcm9wID0gYWxpYXNlc1twcm9wXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtwcm9wXTtcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3Akc3BsaXQgPSBwcm9wLnNwbGl0KCcnKSxcbiAgICAgIF9wcm9wJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9wcm9wJHNwbGl0LCAyKSxcbiAgICAgIGEgPSBfcHJvcCRzcGxpdDJbMF0sXG4gICAgICBiID0gX3Byb3Akc3BsaXQyWzFdO1xuXG4gIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbYV07XG4gIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25zW2JdIHx8ICcnO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkaXJlY3Rpb24pID8gZGlyZWN0aW9uLm1hcChmdW5jdGlvbiAoZGlyKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5ICsgZGlyO1xuICB9KSA6IFtwcm9wZXJ0eSArIGRpcmVjdGlvbl07XG59KTtcbnZhciBzcGFjaW5nS2V5cyA9IFsnbScsICdtdCcsICdtcicsICdtYicsICdtbCcsICdteCcsICdteScsICdwJywgJ3B0JywgJ3ByJywgJ3BiJywgJ3BsJywgJ3B4JywgJ3B5JywgJ21hcmdpbicsICdtYXJnaW5Ub3AnLCAnbWFyZ2luUmlnaHQnLCAnbWFyZ2luQm90dG9tJywgJ21hcmdpbkxlZnQnLCAnbWFyZ2luWCcsICdtYXJnaW5ZJywgJ3BhZGRpbmcnLCAncGFkZGluZ1RvcCcsICdwYWRkaW5nUmlnaHQnLCAncGFkZGluZ0JvdHRvbScsICdwYWRkaW5nTGVmdCcsICdwYWRkaW5nWCcsICdwYWRkaW5nWSddO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVuYXJ5U3BhY2luZyh0aGVtZSkge1xuICB2YXIgdGhlbWVTcGFjaW5nID0gdGhlbWUuc3BhY2luZyB8fCA4O1xuXG4gIGlmICh0eXBlb2YgdGhlbWVTcGFjaW5nID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYWJzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIGFicyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTWF0ZXJpYWwtVUk6IEV4cGVjdGVkIHNwYWNpbmcgYXJndW1lbnQgdG8gYmUgYSBudW1iZXIsIGdvdCBcIi5jb25jYXQoYWJzLCBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGVtZVNwYWNpbmcgKiBhYnM7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHRoZW1lU3BhY2luZykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFicykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGFicyA+IHRoZW1lU3BhY2luZy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihbXCJNYXRlcmlhbC1VSTogVGhlIHZhbHVlIHByb3ZpZGVkIChcIi5jb25jYXQoYWJzLCBcIikgb3ZlcmZsb3dzLlwiKSwgXCJUaGUgc3VwcG9ydGVkIHZhbHVlcyBhcmU6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeSh0aGVtZVNwYWNpbmcpLCBcIi5cIiksIFwiXCIuY29uY2F0KGFicywgXCIgPiBcIikuY29uY2F0KHRoZW1lU3BhY2luZy5sZW5ndGggLSAxLCBcIiwgeW91IG5lZWQgdG8gYWRkIHRoZSBtaXNzaW5nIHZhbHVlcy5cIildLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhlbWVTcGFjaW5nW2Fic107XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdGhlbWVTcGFjaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRoZW1lU3BhY2luZztcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihbXCJNYXRlcmlhbC1VSTogVGhlIGB0aGVtZS5zcGFjaW5nYCB2YWx1ZSAoXCIuY29uY2F0KHRoZW1lU3BhY2luZywgXCIpIGlzIGludmFsaWQuXCIpLCAnSXQgc2hvdWxkIGJlIGEgbnVtYmVyLCBhbiBhcnJheSBvciBhIGZ1bmN0aW9uLiddLmpvaW4oJ1xcbicpKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUodHJhbnNmb3JtZXIsIHByb3BWYWx1ZSkge1xuICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3N0cmluZycgfHwgcHJvcFZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gcHJvcFZhbHVlO1xuICB9XG5cbiAgdmFyIGFicyA9IE1hdGguYWJzKHByb3BWYWx1ZSk7XG4gIHZhciB0cmFuc2Zvcm1lZCA9IHRyYW5zZm9ybWVyKGFicyk7XG5cbiAgaWYgKHByb3BWYWx1ZSA+PSAwKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0cmFuc2Zvcm1lZCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gLXRyYW5zZm9ybWVkO1xuICB9XG5cbiAgcmV0dXJuIFwiLVwiLmNvbmNhdCh0cmFuc2Zvcm1lZCk7XG59XG5cbmZ1bmN0aW9uIGdldFN0eWxlRnJvbVByb3BWYWx1ZShjc3NQcm9wZXJ0aWVzLCB0cmFuc2Zvcm1lcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHByb3BWYWx1ZSkge1xuICAgIHJldHVybiBjc3NQcm9wZXJ0aWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjc3NQcm9wZXJ0eSkge1xuICAgICAgYWNjW2Nzc1Byb3BlcnR5XSA9IGdldFZhbHVlKHRyYW5zZm9ybWVyLCBwcm9wVmFsdWUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNwYWNpbmcocHJvcHMpIHtcbiAgdmFyIHRoZW1lID0gcHJvcHMudGhlbWU7XG4gIHZhciB0cmFuc2Zvcm1lciA9IGNyZWF0ZVVuYXJ5U3BhY2luZyh0aGVtZSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhwcm9wcykubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgLy8gVXNpbmcgYSBoYXNoIGNvbXB1dGF0aW9uIG92ZXIgYW4gYXJyYXkgaXRlcmF0aW9uIGNvdWxkIGJlIGZhc3RlciwgYnV0IHdpdGggb25seSAyOCBpdGVtcyxcbiAgICAvLyBpdCdzIGRvZXNuJ3Qgd29ydGggdGhlIGJ1bmRsZSBzaXplLlxuICAgIGlmIChzcGFjaW5nS2V5cy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGNzc1Byb3BlcnRpZXMgPSBnZXRDc3NQcm9wZXJ0aWVzKHByb3ApO1xuICAgIHZhciBzdHlsZUZyb21Qcm9wVmFsdWUgPSBnZXRTdHlsZUZyb21Qcm9wVmFsdWUoY3NzUHJvcGVydGllcywgdHJhbnNmb3JtZXIpO1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wXTtcbiAgICByZXR1cm4gaGFuZGxlQnJlYWtwb2ludHMocHJvcHMsIHByb3BWYWx1ZSwgc3R5bGVGcm9tUHJvcFZhbHVlKTtcbiAgfSkucmVkdWNlKG1lcmdlLCB7fSk7XG59XG5cbnNwYWNpbmcucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHNwYWNpbmdLZXlzLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgb2JqW2tleV0gPSByZXNwb25zaXZlUHJvcFR5cGU7XG4gIHJldHVybiBvYmo7XG59LCB7fSkgOiB7fTtcbnNwYWNpbmcuZmlsdGVyUHJvcHMgPSBzcGFjaW5nS2V5cztcbmV4cG9ydCBkZWZhdWx0IHNwYWNpbmc7IiwiaW1wb3J0IHsgY3JlYXRlVW5hcnlTcGFjaW5nIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3N5c3RlbSc7XG52YXIgd2Fybk9uY2U7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVTcGFjaW5nKCkge1xuICB2YXIgc3BhY2luZ0lucHV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiA4O1xuXG4gIC8vIEFscmVhZHkgdHJhbnNmb3JtZWQuXG4gIGlmIChzcGFjaW5nSW5wdXQubXVpKSB7XG4gICAgcmV0dXJuIHNwYWNpbmdJbnB1dDtcbiAgfSAvLyBNYXRlcmlhbCBEZXNpZ24gbGF5b3V0cyBhcmUgdmlzdWFsbHkgYmFsYW5jZWQuIE1vc3QgbWVhc3VyZW1lbnRzIGFsaWduIHRvIGFuIDhkcCBncmlkIGFwcGxpZWQsIHdoaWNoIGFsaWducyBib3RoIHNwYWNpbmcgYW5kIHRoZSBvdmVyYWxsIGxheW91dC5cbiAgLy8gU21hbGxlciBjb21wb25lbnRzLCBzdWNoIGFzIGljb25zIGFuZCB0eXBlLCBjYW4gYWxpZ24gdG8gYSA0ZHAgZ3JpZC5cbiAgLy8gaHR0cHM6Ly9tYXRlcmlhbC5pby9kZXNpZ24vbGF5b3V0L3VuZGVyc3RhbmRpbmctbGF5b3V0Lmh0bWwjdXNhZ2VcblxuXG4gIHZhciB0cmFuc2Zvcm0gPSBjcmVhdGVVbmFyeVNwYWNpbmcoe1xuICAgIHNwYWNpbmc6IHNwYWNpbmdJbnB1dFxuICB9KTtcblxuICB2YXIgc3BhY2luZyA9IGZ1bmN0aW9uIHNwYWNpbmcoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIShhcmdzLmxlbmd0aCA8PSA0KSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTWF0ZXJpYWwtVUk6IFRvbyBtYW55IGFyZ3VtZW50cyBwcm92aWRlZCwgZXhwZWN0ZWQgYmV0d2VlbiAwIGFuZCA0LCBnb3QgXCIuY29uY2F0KGFyZ3MubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtKDEpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybShhcmdzWzBdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJncy5tYXAoZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXRwdXQgPSB0cmFuc2Zvcm0oYXJndW1lbnQpO1xuICAgICAgcmV0dXJuIHR5cGVvZiBvdXRwdXQgPT09ICdudW1iZXInID8gXCJcIi5jb25jYXQob3V0cHV0LCBcInB4XCIpIDogb3V0cHV0O1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfTsgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdG8gcmVtb3ZlIGluIHY1LlxuXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNwYWNpbmcsICd1bml0Jywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKCF3YXJuT25jZSB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihbJ01hdGVyaWFsLVVJOiB0aGVtZS5zcGFjaW5nLnVuaXQgdXNhZ2UgaGFzIGJlZW4gZGVwcmVjYXRlZC4nLCAnSXQgd2lsbCBiZSByZW1vdmVkIGluIHY1LicsICdZb3UgY2FuIHJlcGxhY2UgYHRoZW1lLnNwYWNpbmcudW5pdCAqIHlgIHdpdGggYHRoZW1lLnNwYWNpbmcoeSlgLicsICcnLCAnWW91IGNhbiB1c2UgdGhlIGBodHRwczovL2dpdGh1Yi5jb20vbXVpLW9yZy9tYXRlcmlhbC11aS90cmVlL21hc3Rlci9wYWNrYWdlcy9tYXRlcmlhbC11aS1jb2RlbW9kL1JFQURNRS5tZCN0aGVtZS1zcGFjaW5nLWFwaWAgbWlncmF0aW9uIGhlbHBlciB0byBtYWtlIHRoZSBwcm9jZXNzIHNtb290aGVyLiddLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhcm5PbmNlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNwYWNpbmdJbnB1dDtcbiAgICB9XG4gIH0pO1xuICBzcGFjaW5nLm11aSA9IHRydWU7XG4gIHJldHVybiBzcGFjaW5nO1xufSIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG4vLyBGb2xsb3cgaHR0cHM6Ly9tYXRlcmlhbC5nb29nbGUuY29tL21vdGlvbi9kdXJhdGlvbi1lYXNpbmcuaHRtbCNkdXJhdGlvbi1lYXNpbmctbmF0dXJhbC1lYXNpbmctY3VydmVzXG4vLyB0byBsZWFybiB0aGUgY29udGV4dCBpbiB3aGljaCBlYWNoIGVhc2luZyBzaG91bGQgYmUgdXNlZC5cbmV4cG9ydCB2YXIgZWFzaW5nID0ge1xuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGNvbW1vbiBlYXNpbmcgY3VydmUuXG4gIGVhc2VJbk91dDogJ2N1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSknLFxuICAvLyBPYmplY3RzIGVudGVyIHRoZSBzY3JlZW4gYXQgZnVsbCB2ZWxvY2l0eSBmcm9tIG9mZi1zY3JlZW4gYW5kXG4gIC8vIHNsb3dseSBkZWNlbGVyYXRlIHRvIGEgcmVzdGluZyBwb2ludC5cbiAgZWFzZU91dDogJ2N1YmljLWJlemllcigwLjAsIDAsIDAuMiwgMSknLFxuICAvLyBPYmplY3RzIGxlYXZlIHRoZSBzY3JlZW4gYXQgZnVsbCB2ZWxvY2l0eS4gVGhleSBkbyBub3QgZGVjZWxlcmF0ZSB3aGVuIG9mZi1zY3JlZW4uXG4gIGVhc2VJbjogJ2N1YmljLWJlemllcigwLjQsIDAsIDEsIDEpJyxcbiAgLy8gVGhlIHNoYXJwIGN1cnZlIGlzIHVzZWQgYnkgb2JqZWN0cyB0aGF0IG1heSByZXR1cm4gdG8gdGhlIHNjcmVlbiBhdCBhbnkgdGltZS5cbiAgc2hhcnA6ICdjdWJpYy1iZXppZXIoMC40LCAwLCAwLjYsIDEpJ1xufTsgLy8gRm9sbG93IGh0dHBzOi8vbWF0ZXJpYWwuaW8vZ3VpZGVsaW5lcy9tb3Rpb24vZHVyYXRpb24tZWFzaW5nLmh0bWwjZHVyYXRpb24tZWFzaW5nLWNvbW1vbi1kdXJhdGlvbnNcbi8vIHRvIGxlYXJuIHdoZW4gdXNlIHdoYXQgdGltaW5nXG5cbmV4cG9ydCB2YXIgZHVyYXRpb24gPSB7XG4gIHNob3J0ZXN0OiAxNTAsXG4gIHNob3J0ZXI6IDIwMCxcbiAgc2hvcnQ6IDI1MCxcbiAgLy8gbW9zdCBiYXNpYyByZWNvbW1lbmRlZCB0aW1pbmdcbiAgc3RhbmRhcmQ6IDMwMCxcbiAgLy8gdGhpcyBpcyB0byBiZSB1c2VkIGluIGNvbXBsZXggYW5pbWF0aW9uc1xuICBjb21wbGV4OiAzNzUsXG4gIC8vIHJlY29tbWVuZGVkIHdoZW4gc29tZXRoaW5nIGlzIGVudGVyaW5nIHNjcmVlblxuICBlbnRlcmluZ1NjcmVlbjogMjI1LFxuICAvLyByZWNvbW1lbmRlZCB3aGVuIHNvbWV0aGluZyBpcyBsZWF2aW5nIHNjcmVlblxuICBsZWF2aW5nU2NyZWVuOiAxOTVcbn07XG5cbmZ1bmN0aW9uIGZvcm1hdE1zKG1pbGxpc2Vjb25kcykge1xuICByZXR1cm4gXCJcIi5jb25jYXQoTWF0aC5yb3VuZChtaWxsaXNlY29uZHMpLCBcIm1zXCIpO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gcHJvcHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbVxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtLnByb3BcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbS5kdXJhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtLmVhc2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtLmRlbGF5XG4gKi9cblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGVhc2luZzogZWFzaW5nLFxuICBkdXJhdGlvbjogZHVyYXRpb24sXG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogWydhbGwnXTtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICB2YXIgX29wdGlvbnMkZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICBkdXJhdGlvbk9wdGlvbiA9IF9vcHRpb25zJGR1cmF0aW9uID09PSB2b2lkIDAgPyBkdXJhdGlvbi5zdGFuZGFyZCA6IF9vcHRpb25zJGR1cmF0aW9uLFxuICAgICAgICBfb3B0aW9ucyRlYXNpbmcgPSBvcHRpb25zLmVhc2luZyxcbiAgICAgICAgZWFzaW5nT3B0aW9uID0gX29wdGlvbnMkZWFzaW5nID09PSB2b2lkIDAgPyBlYXNpbmcuZWFzZUluT3V0IDogX29wdGlvbnMkZWFzaW5nLFxuICAgICAgICBfb3B0aW9ucyRkZWxheSA9IG9wdGlvbnMuZGVsYXksXG4gICAgICAgIGRlbGF5ID0gX29wdGlvbnMkZGVsYXkgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRkZWxheSxcbiAgICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3B0aW9ucywgW1wiZHVyYXRpb25cIiwgXCJlYXNpbmdcIiwgXCJkZWxheVwiXSk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgICB9O1xuXG4gICAgICB2YXIgaXNOdW1iZXIgPSBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICghaXNTdHJpbmcocHJvcHMpICYmICFBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdNYXRlcmlhbC1VSTogQXJndW1lbnQgXCJwcm9wc1wiIG11c3QgYmUgYSBzdHJpbmcgb3IgQXJyYXkuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOdW1iZXIoZHVyYXRpb25PcHRpb24pICYmICFpc1N0cmluZyhkdXJhdGlvbk9wdGlvbikpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk1hdGVyaWFsLVVJOiBBcmd1bWVudCBcXFwiZHVyYXRpb25cXFwiIG11c3QgYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcgYnV0IGZvdW5kIFwiLmNvbmNhdChkdXJhdGlvbk9wdGlvbiwgXCIuXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1N0cmluZyhlYXNpbmdPcHRpb24pKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ01hdGVyaWFsLVVJOiBBcmd1bWVudCBcImVhc2luZ1wiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOdW1iZXIoZGVsYXkpICYmICFpc1N0cmluZyhkZWxheSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTWF0ZXJpYWwtVUk6IEFyZ3VtZW50IFwiZGVsYXlcIiBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0LmtleXMob3RoZXIpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTWF0ZXJpYWwtVUk6IFVucmVjb2duaXplZCBhcmd1bWVudChzKSBbXCIuY29uY2F0KE9iamVjdC5rZXlzKG90aGVyKS5qb2luKCcsJyksIFwiXS5cIikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShwcm9wcykgPyBwcm9wcyA6IFtwcm9wc10pLm1hcChmdW5jdGlvbiAoYW5pbWF0ZWRQcm9wKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQoYW5pbWF0ZWRQcm9wLCBcIiBcIikuY29uY2F0KHR5cGVvZiBkdXJhdGlvbk9wdGlvbiA9PT0gJ3N0cmluZycgPyBkdXJhdGlvbk9wdGlvbiA6IGZvcm1hdE1zKGR1cmF0aW9uT3B0aW9uKSwgXCIgXCIpLmNvbmNhdChlYXNpbmdPcHRpb24sIFwiIFwiKS5jb25jYXQodHlwZW9mIGRlbGF5ID09PSAnc3RyaW5nJyA/IGRlbGF5IDogZm9ybWF0TXMoZGVsYXkpKTtcbiAgICB9KS5qb2luKCcsJyk7XG4gIH0sXG4gIGdldEF1dG9IZWlnaHREdXJhdGlvbjogZnVuY3Rpb24gZ2V0QXV0b0hlaWdodER1cmF0aW9uKGhlaWdodCkge1xuICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgY29uc3RhbnQgPSBoZWlnaHQgLyAzNjsgLy8gaHR0cHM6Ly93d3cud29sZnJhbWFscGhhLmNvbS9pbnB1dC8/aT0oNCslMkIrMTUrKisoeCslMkYrMzYrKSsqKiswLjI1KyUyQisoeCslMkYrMzYpKyUyRis1KSsqKzEwXG5cbiAgICByZXR1cm4gTWF0aC5yb3VuZCgoNCArIDE1ICogTWF0aC5wb3coY29uc3RhbnQsIDAuMjUpICsgY29uc3RhbnQgLyA1KSAqIDEwKTtcbiAgfVxufTsiLCIvLyBXZSBuZWVkIHRvIGNlbnRyYWxpemUgdGhlIHpJbmRleCBkZWZpbml0aW9ucyBhcyB0aGV5IHdvcmtcbi8vIGxpa2UgZ2xvYmFsIHZhbHVlcyBpbiB0aGUgYnJvd3Nlci5cbnZhciB6SW5kZXggPSB7XG4gIG1vYmlsZVN0ZXBwZXI6IDEwMDAsXG4gIHNwZWVkRGlhbDogMTA1MCxcbiAgYXBwQmFyOiAxMTAwLFxuICBkcmF3ZXI6IDEyMDAsXG4gIG1vZGFsOiAxMzAwLFxuICBzbmFja2JhcjogMTQwMCxcbiAgdG9vbHRpcDogMTUwMFxufTtcbmV4cG9ydCBkZWZhdWx0IHpJbmRleDsiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCB7IGRlZXBtZXJnZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgY3JlYXRlQnJlYWtwb2ludHMgZnJvbSAnLi9jcmVhdGVCcmVha3BvaW50cyc7XG5pbXBvcnQgY3JlYXRlTWl4aW5zIGZyb20gJy4vY3JlYXRlTWl4aW5zJztcbmltcG9ydCBjcmVhdGVQYWxldHRlIGZyb20gJy4vY3JlYXRlUGFsZXR0ZSc7XG5pbXBvcnQgY3JlYXRlVHlwb2dyYXBoeSBmcm9tICcuL2NyZWF0ZVR5cG9ncmFwaHknO1xuaW1wb3J0IHNoYWRvd3MgZnJvbSAnLi9zaGFkb3dzJztcbmltcG9ydCBzaGFwZSBmcm9tICcuL3NoYXBlJztcbmltcG9ydCBjcmVhdGVTcGFjaW5nIGZyb20gJy4vY3JlYXRlU3BhY2luZyc7XG5pbXBvcnQgdHJhbnNpdGlvbnMgZnJvbSAnLi90cmFuc2l0aW9ucyc7XG5pbXBvcnQgekluZGV4IGZyb20gJy4vekluZGV4JztcblxuZnVuY3Rpb24gY3JlYXRlVGhlbWUoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgX29wdGlvbnMkYnJlYWtwb2ludHMgPSBvcHRpb25zLmJyZWFrcG9pbnRzLFxuICAgICAgYnJlYWtwb2ludHNJbnB1dCA9IF9vcHRpb25zJGJyZWFrcG9pbnRzID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zJGJyZWFrcG9pbnRzLFxuICAgICAgX29wdGlvbnMkbWl4aW5zID0gb3B0aW9ucy5taXhpbnMsXG4gICAgICBtaXhpbnNJbnB1dCA9IF9vcHRpb25zJG1peGlucyA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9ucyRtaXhpbnMsXG4gICAgICBfb3B0aW9ucyRwYWxldHRlID0gb3B0aW9ucy5wYWxldHRlLFxuICAgICAgcGFsZXR0ZUlucHV0ID0gX29wdGlvbnMkcGFsZXR0ZSA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9ucyRwYWxldHRlLFxuICAgICAgc3BhY2luZ0lucHV0ID0gb3B0aW9ucy5zcGFjaW5nLFxuICAgICAgX29wdGlvbnMkdHlwb2dyYXBoeSA9IG9wdGlvbnMudHlwb2dyYXBoeSxcbiAgICAgIHR5cG9ncmFwaHlJbnB1dCA9IF9vcHRpb25zJHR5cG9ncmFwaHkgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnMkdHlwb2dyYXBoeSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9wdGlvbnMsIFtcImJyZWFrcG9pbnRzXCIsIFwibWl4aW5zXCIsIFwicGFsZXR0ZVwiLCBcInNwYWNpbmdcIiwgXCJ0eXBvZ3JhcGh5XCJdKTtcblxuICB2YXIgcGFsZXR0ZSA9IGNyZWF0ZVBhbGV0dGUocGFsZXR0ZUlucHV0KTtcbiAgdmFyIGJyZWFrcG9pbnRzID0gY3JlYXRlQnJlYWtwb2ludHMoYnJlYWtwb2ludHNJbnB1dCk7XG4gIHZhciBzcGFjaW5nID0gY3JlYXRlU3BhY2luZyhzcGFjaW5nSW5wdXQpO1xuICB2YXIgbXVpVGhlbWUgPSBkZWVwbWVyZ2Uoe1xuICAgIGJyZWFrcG9pbnRzOiBicmVha3BvaW50cyxcbiAgICBkaXJlY3Rpb246ICdsdHInLFxuICAgIG1peGluczogY3JlYXRlTWl4aW5zKGJyZWFrcG9pbnRzLCBzcGFjaW5nLCBtaXhpbnNJbnB1dCksXG4gICAgb3ZlcnJpZGVzOiB7fSxcbiAgICAvLyBJbmplY3QgY3VzdG9tIHN0eWxlc1xuICAgIHBhbGV0dGU6IHBhbGV0dGUsXG4gICAgcHJvcHM6IHt9LFxuICAgIC8vIFByb3ZpZGUgZGVmYXVsdCBwcm9wc1xuICAgIHNoYWRvd3M6IHNoYWRvd3MsXG4gICAgdHlwb2dyYXBoeTogY3JlYXRlVHlwb2dyYXBoeShwYWxldHRlLCB0eXBvZ3JhcGh5SW5wdXQpLFxuICAgIHNwYWNpbmc6IHNwYWNpbmcsXG4gICAgc2hhcGU6IHNoYXBlLFxuICAgIHRyYW5zaXRpb25zOiB0cmFuc2l0aW9ucyxcbiAgICB6SW5kZXg6IHpJbmRleFxuICB9LCBvdGhlcik7XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgbXVpVGhlbWUgPSBhcmdzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhcmd1bWVudCkge1xuICAgIHJldHVybiBkZWVwbWVyZ2UoYWNjLCBhcmd1bWVudCk7XG4gIH0sIG11aVRoZW1lKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBwc2V1ZG9DbGFzc2VzID0gWydjaGVja2VkJywgJ2Rpc2FibGVkJywgJ2Vycm9yJywgJ2ZvY3VzZWQnLCAnZm9jdXNWaXNpYmxlJywgJ3JlcXVpcmVkJywgJ2V4cGFuZGVkJywgJ3NlbGVjdGVkJ107XG5cbiAgICB2YXIgdHJhdmVyc2UgPSBmdW5jdGlvbiB0cmF2ZXJzZShub2RlLCBwYXJlbnRLZXkpIHtcbiAgICAgIHZhciBkZXB0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgICAgIHZhciBrZXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW4sIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG5cbiAgICAgIGZvciAoa2V5IGluIG5vZGUpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtrZXldO1xuXG4gICAgICAgIGlmIChkZXB0aCA9PT0gMSkge1xuICAgICAgICAgIGlmIChrZXkuaW5kZXhPZignTXVpJykgPT09IDAgJiYgY2hpbGQpIHtcbiAgICAgICAgICAgIHRyYXZlcnNlKGNoaWxkLCBrZXksIGRlcHRoICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBzZXVkb0NsYXNzZXMuaW5kZXhPZihrZXkpICE9PSAtMSAmJiBPYmplY3Qua2V5cyhjaGlsZCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFtcIk1hdGVyaWFsLVVJOiBUaGUgYFwiLmNvbmNhdChwYXJlbnRLZXksIFwiYCBjb21wb25lbnQgaW5jcmVhc2VzIFwiKSArIFwidGhlIENTUyBzcGVjaWZpY2l0eSBvZiB0aGUgYFwiLmNvbmNhdChrZXksIFwiYCBpbnRlcm5hbCBzdGF0ZS5cIiksICdZb3UgY2FuIG5vdCBvdmVycmlkZSBpdCBsaWtlIHRoaXM6ICcsIEpTT04uc3RyaW5naWZ5KG5vZGUsIG51bGwsIDIpLCAnJywgJ0luc3RlYWQsIHlvdSBuZWVkIHRvIHVzZSB0aGUgJHJ1bGVOYW1lIHN5bnRheDonLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIHJvb3Q6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgXCImJFwiLmNvbmNhdChrZXkpLCBjaGlsZClcbiAgICAgICAgICAgIH0sIG51bGwsIDIpLCAnJywgJ2h0dHBzOi8vbWF0ZXJpYWwtdWkuY29tL3IvcHNldWRvLWNsYXNzZXMtZ3VpZGUnXS5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgfSAvLyBSZW1vdmUgdGhlIHN0eWxlIHRvIHByZXZlbnQgZ2xvYmFsIGNvbmZsaWN0cy5cblxuXG4gICAgICAgICAgbm9kZVtrZXldID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdHJhdmVyc2UobXVpVGhlbWUub3ZlcnJpZGVzKTtcbiAgfVxuXG4gIHJldHVybiBtdWlUaGVtZTtcbn1cblxudmFyIHdhcm5lZE9uY2UgPSBmYWxzZTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNdWlUaGVtZSgpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoIXdhcm5lZE9uY2UpIHtcbiAgICAgIHdhcm5lZE9uY2UgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcihbJ01hdGVyaWFsLVVJOiB0aGUgY3JlYXRlTXVpVGhlbWUgZnVuY3Rpb24gd2FzIHJlbmFtZWQgdG8gY3JlYXRlVGhlbWUuJywgJycsIFwiWW91IHNob3VsZCB1c2UgYGltcG9ydCB7IGNyZWF0ZVRoZW1lIH0gZnJvbSAnQG1hdGVyaWFsLXVpL2NvcmUvc3R5bGVzJ2BcIl0uam9pbignXFxuJykpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjcmVhdGVUaGVtZS5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG59XG5leHBvcnQgZGVmYXVsdCBjcmVhdGVUaGVtZTsiLCJ2YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xuZXhwb3J0IGRlZmF1bHQgaGFzU3ltYm9sID8gU3ltYm9sLmZvcignbXVpLm5lc3RlZCcpIDogJ19fVEhFTUVfTkVTVEVEX18nOyIsImltcG9ydCBuZXN0ZWQgZnJvbSAnLi4vVGhlbWVQcm92aWRlci9uZXN0ZWQnO1xuLyoqXG4gKiBUaGlzIGlzIHRoZSBsaXN0IG9mIHRoZSBzdHlsZSBydWxlIG5hbWUgd2UgdXNlIGFzIGRyb3AgaW4gcmVwbGFjZW1lbnQgZm9yIHRoZSBidWlsdC1pblxuICogcHNldWRvIGNsYXNzZXMgKDpjaGVja2VkLCA6ZGlzYWJsZWQsIDpmb2N1c2VkLCBldGMuKS5cbiAqXG4gKiBXaHkgZG8gdGhleSBleGlzdCBpbiB0aGUgZmlyc3QgcGxhY2U/XG4gKiBUaGVzZSBjbGFzc2VzIGFyZSB1c2VkIGF0IGEgc3BlY2lmaWNpdHkgb2YgMi5cbiAqIEl0IGFsbG93cyB0aGVtIHRvIG92ZXJyaWRlIHByZXZpb3VzbHkgZGVmaW5pZWQgc3R5bGVzIGFzIHdlbGwgYXNcbiAqIGJlaW5nIHVudG91Y2hlZCBieSBzaW1wbGUgdXNlciBvdmVycmlkZXMuXG4gKi9cblxudmFyIHBzZXVkb0NsYXNzZXMgPSBbJ2NoZWNrZWQnLCAnZGlzYWJsZWQnLCAnZXJyb3InLCAnZm9jdXNlZCcsICdmb2N1c1Zpc2libGUnLCAncmVxdWlyZWQnLCAnZXhwYW5kZWQnLCAnc2VsZWN0ZWQnXTsgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlcyB1bmlxdWUgY2xhc3MgbmFtZXMgYmFzZWQgb24gY291bnRlcnMuXG4vLyBXaGVuIG5ldyBnZW5lcmF0b3IgZnVuY3Rpb24gaXMgY3JlYXRlZCwgcnVsZSBjb3VudGVyIGlzIHJlc2V0LlxuLy8gV2UgbmVlZCB0byByZXNldCB0aGUgcnVsZSBjb3VudGVyIGZvciBTU1IgZm9yIGVhY2ggcmVxdWVzdC5cbi8vXG4vLyBJdCdzIGluc3BpcmVkIGJ5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vY3NzaW5qcy9qc3MvYmxvYi80ZTZhMDVkZDNmN2I2NTcyZmRkM2FiMjE2ODYxZDllNDQ2YzIwMzMxL3NyYy91dGlscy9jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZS5qc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgX29wdGlvbnMkZGlzYWJsZUdsb2JhID0gb3B0aW9ucy5kaXNhYmxlR2xvYmFsLFxuICAgICAgZGlzYWJsZUdsb2JhbCA9IF9vcHRpb25zJGRpc2FibGVHbG9iYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRkaXNhYmxlR2xvYmEsXG4gICAgICBfb3B0aW9ucyRwcm9kdWN0aW9uUHIgPSBvcHRpb25zLnByb2R1Y3Rpb25QcmVmaXgsXG4gICAgICBwcm9kdWN0aW9uUHJlZml4ID0gX29wdGlvbnMkcHJvZHVjdGlvblByID09PSB2b2lkIDAgPyAnanNzJyA6IF9vcHRpb25zJHByb2R1Y3Rpb25QcixcbiAgICAgIF9vcHRpb25zJHNlZWQgPSBvcHRpb25zLnNlZWQsXG4gICAgICBzZWVkID0gX29wdGlvbnMkc2VlZCA9PT0gdm9pZCAwID8gJycgOiBfb3B0aW9ucyRzZWVkO1xuICB2YXIgc2VlZFByZWZpeCA9IHNlZWQgPT09ICcnID8gJycgOiBcIlwiLmNvbmNhdChzZWVkLCBcIi1cIik7XG4gIHZhciBydWxlQ291bnRlciA9IDA7XG5cbiAgdmFyIGdldE5leHRDb3VudGVySWQgPSBmdW5jdGlvbiBnZXROZXh0Q291bnRlcklkKCkge1xuICAgIHJ1bGVDb3VudGVyICs9IDE7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHJ1bGVDb3VudGVyID49IDFlMTApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFsnTWF0ZXJpYWwtVUk6IFlvdSBtaWdodCBoYXZlIGEgbWVtb3J5IGxlYWsuJywgJ1RoZSBydWxlQ291bnRlciBpcyBub3Qgc3VwcG9zZWQgdG8gZ3JvdyB0aGF0IG11Y2guJ10uam9pbignJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBydWxlQ291bnRlcjtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKHJ1bGUsIHN0eWxlU2hlZXQpIHtcbiAgICB2YXIgbmFtZSA9IHN0eWxlU2hlZXQub3B0aW9ucy5uYW1lOyAvLyBJcyBhIGdsb2JhbCBzdGF0aWMgTVVJIHN0eWxlP1xuXG4gICAgaWYgKG5hbWUgJiYgbmFtZS5pbmRleE9mKCdNdWknKSA9PT0gMCAmJiAhc3R5bGVTaGVldC5vcHRpb25zLmxpbmsgJiYgIWRpc2FibGVHbG9iYWwpIHtcbiAgICAgIC8vIFdlIGNhbiB1c2UgYSBzaG9ydGhhbmQgY2xhc3MgbmFtZSwgd2UgbmV2ZXIgdXNlIHRoZSBrZXlzIHRvIHN0eWxlIHRoZSBjb21wb25lbnRzLlxuICAgICAgaWYgKHBzZXVkb0NsYXNzZXMuaW5kZXhPZihydWxlLmtleSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBcIk11aS1cIi5jb25jYXQocnVsZS5rZXkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJlZml4ID0gXCJcIi5jb25jYXQoc2VlZFByZWZpeCkuY29uY2F0KG5hbWUsIFwiLVwiKS5jb25jYXQocnVsZS5rZXkpO1xuXG4gICAgICBpZiAoIXN0eWxlU2hlZXQub3B0aW9ucy50aGVtZVtuZXN0ZWRdIHx8IHNlZWQgIT09ICcnKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLVwiKS5jb25jYXQoZ2V0TmV4dENvdW50ZXJJZCgpKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHNlZWRQcmVmaXgpLmNvbmNhdChwcm9kdWN0aW9uUHJlZml4KS5jb25jYXQoZ2V0TmV4dENvdW50ZXJJZCgpKTtcbiAgICB9XG5cbiAgICB2YXIgc3VmZml4ID0gXCJcIi5jb25jYXQocnVsZS5rZXksIFwiLVwiKS5jb25jYXQoZ2V0TmV4dENvdW50ZXJJZCgpKTsgLy8gSGVscCB3aXRoIGRlYnVnZ2FiaWxpdHkuXG5cbiAgICBpZiAoc3R5bGVTaGVldC5vcHRpb25zLmNsYXNzTmFtZVByZWZpeCkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHNlZWRQcmVmaXgpLmNvbmNhdChzdHlsZVNoZWV0Lm9wdGlvbnMuY2xhc3NOYW1lUHJlZml4LCBcIi1cIikuY29uY2F0KHN1ZmZpeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHNlZWRQcmVmaXgpLmNvbmNhdChzdWZmaXgpO1xuICB9O1xufSIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRUaGVtZVByb3BzKHBhcmFtcykge1xuICB2YXIgdGhlbWUgPSBwYXJhbXMudGhlbWUsXG4gICAgICBuYW1lID0gcGFyYW1zLm5hbWUsXG4gICAgICBwcm9wcyA9IHBhcmFtcy5wcm9wcztcblxuICBpZiAoIXRoZW1lIHx8ICF0aGVtZS5wcm9wcyB8fCAhdGhlbWUucHJvcHNbbmFtZV0pIHtcbiAgICByZXR1cm4gcHJvcHM7XG4gIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzLCBjb2RlIGJvcnJvdyBmcm9tIFJlYWN0IHNvdXJjZS5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvMTVhOGYwMzE4MzhhNTUzZTQxYzBiNjZlYjFiY2YxZGE4NDQ4MTA0ZC9wYWNrYWdlcy9yZWFjdC9zcmMvUmVhY3RFbGVtZW50LmpzI0wyMjFcblxuXG4gIHZhciBkZWZhdWx0UHJvcHMgPSB0aGVtZS5wcm9wc1tuYW1lXTtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn0iLCJ2YXIgaXNQcm9kdWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbmZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghaXNQcm9kdWN0aW9uKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZXh0ID0gXCJXYXJuaW5nOiBcIiArIG1lc3NhZ2U7XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4odGV4dCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRocm93IEVycm9yKHRleHQpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgd2FybmluZztcbiIsInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0IHZhciBpc0Jyb3dzZXIgPSAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHdpbmRvdykpID09PSBcIm9iamVjdFwiICYmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihkb2N1bWVudCkpID09PSAnb2JqZWN0JyAmJiBkb2N1bWVudC5ub2RlVHlwZSA9PT0gOTtcblxuZXhwb3J0IGRlZmF1bHQgaXNCcm93c2VyO1xuIiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufSIsImltcG9ydCBzZXRQcm90b3R5cGVPZiBmcm9tIFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgaXNJbkJyb3dzZXIgZnJvbSAnaXMtaW4tYnJvd3Nlcic7XG5pbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyc7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZSc7XG5pbXBvcnQgX2Fzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQnO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UnO1xuXG52YXIgcGxhaW5PYmplY3RDb25zdHJ1cmN0b3IgPSB7fS5jb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIGNsb25lU3R5bGUoc3R5bGUpIHtcbiAgaWYgKHN0eWxlID09IG51bGwgfHwgdHlwZW9mIHN0eWxlICE9PSAnb2JqZWN0JykgcmV0dXJuIHN0eWxlO1xuICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkpIHJldHVybiBzdHlsZS5tYXAoY2xvbmVTdHlsZSk7XG4gIGlmIChzdHlsZS5jb25zdHJ1Y3RvciAhPT0gcGxhaW5PYmplY3RDb25zdHJ1cmN0b3IpIHJldHVybiBzdHlsZTtcbiAgdmFyIG5ld1N0eWxlID0ge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZSkge1xuICAgIG5ld1N0eWxlW25hbWVdID0gY2xvbmVTdHlsZShzdHlsZVtuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gbmV3U3R5bGU7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcnVsZSBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgIG5hbWUgPSAndW5uYW1lZCc7XG4gIH1cblxuICB2YXIganNzID0gb3B0aW9ucy5qc3M7XG4gIHZhciBkZWNsQ29weSA9IGNsb25lU3R5bGUoZGVjbCk7XG4gIHZhciBydWxlID0ganNzLnBsdWdpbnMub25DcmVhdGVSdWxlKG5hbWUsIGRlY2xDb3B5LCBvcHRpb25zKTtcbiAgaWYgKHJ1bGUpIHJldHVybiBydWxlOyAvLyBJdCBpcyBhbiBhdC1ydWxlIGFuZCBpdCBoYXMgbm8gaW5zdGFuY2UuXG5cbiAgaWYgKG5hbWVbMF0gPT09ICdAJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gVW5rbm93biBydWxlIFwiICsgbmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGpvaW4gPSBmdW5jdGlvbiBqb2luKHZhbHVlLCBieSkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIC8vIFJlbW92ZSAhaW1wb3J0YW50IGZyb20gdGhlIHZhbHVlLCBpdCB3aWxsIGJlIHJlYWRkZWQgbGF0ZXIuXG4gICAgaWYgKHZhbHVlW2ldID09PSAnIWltcG9ydGFudCcpIGJyZWFrO1xuICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSBieTtcbiAgICByZXN1bHQgKz0gdmFsdWVbaV07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQ29udmVydHMgSlNTIGFycmF5IHZhbHVlIHRvIGEgQ1NTIHN0cmluZy5cbiAqXG4gKiBgbWFyZ2luOiBbWyc1cHgnLCAnMTBweCddXWAgPiBgbWFyZ2luOiA1cHggMTBweDtgXG4gKiBgYm9yZGVyOiBbJzFweCcsICcycHgnXWAgPiBgYm9yZGVyOiAxcHgsIDJweDtgXG4gKiBgbWFyZ2luOiBbWyc1cHgnLCAnMTBweCddLCAnIWltcG9ydGFudCddYCA+IGBtYXJnaW46IDVweCAxMHB4ICFpbXBvcnRhbnQ7YFxuICogYGNvbG9yOiBbJ3JlZCcsICFpbXBvcnRhbnRdYCA+IGBjb2xvcjogcmVkICFpbXBvcnRhbnQ7YFxuICovXG5cblxudmFyIHRvQ3NzVmFsdWUgPSBmdW5jdGlvbiB0b0Nzc1ZhbHVlKHZhbHVlLCBpZ25vcmVJbXBvcnRhbnQpIHtcbiAgaWYgKGlnbm9yZUltcG9ydGFudCA9PT0gdm9pZCAwKSB7XG4gICAgaWdub3JlSW1wb3J0YW50ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gIHZhciBjc3NWYWx1ZSA9ICcnOyAvLyBTdXBwb3J0IHNwYWNlIHNlcGFyYXRlZCB2YWx1ZXMgdmlhIGBbWyc1cHgnLCAnMTBweCddXWAuXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVbMF0pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlW2ldID09PSAnIWltcG9ydGFudCcpIGJyZWFrO1xuICAgICAgaWYgKGNzc1ZhbHVlKSBjc3NWYWx1ZSArPSAnLCAnO1xuICAgICAgY3NzVmFsdWUgKz0gam9pbih2YWx1ZVtpXSwgJyAnKTtcbiAgICB9XG4gIH0gZWxzZSBjc3NWYWx1ZSA9IGpvaW4odmFsdWUsICcsICcpOyAvLyBBZGQgIWltcG9ydGFudCwgYmVjYXVzZSBpdCB3YXMgaWdub3JlZC5cblxuXG4gIGlmICghaWdub3JlSW1wb3J0YW50ICYmIHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnIWltcG9ydGFudCcpIHtcbiAgICBjc3NWYWx1ZSArPSAnICFpbXBvcnRhbnQnO1xuICB9XG5cbiAgcmV0dXJuIGNzc1ZhbHVlO1xufTtcblxuZnVuY3Rpb24gZ2V0V2hpdGVzcGFjZVN5bWJvbHMob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZvcm1hdCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZWJyZWFrOiAnJyxcbiAgICAgIHNwYWNlOiAnJ1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxpbmVicmVhazogJ1xcbicsXG4gICAgc3BhY2U6ICcgJ1xuICB9O1xufVxuXG4vKipcbiAqIEluZGVudCBhIHN0cmluZy5cbiAqIGh0dHA6Ly9qc3BlcmYuY29tL2FycmF5LWpvaW4tdnMtZm9yXG4gKi9cblxuZnVuY3Rpb24gaW5kZW50U3RyKHN0ciwgaW5kZW50KSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaW5kZW50OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ICs9ICcgICc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0ICsgc3RyO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFJ1bGUgdG8gQ1NTIHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQ3NzKHNlbGVjdG9yLCBzdHlsZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAoIXN0eWxlKSByZXR1cm4gcmVzdWx0O1xuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkaW5kZW50ID0gX29wdGlvbnMuaW5kZW50LFxuICAgICAgaW5kZW50ID0gX29wdGlvbnMkaW5kZW50ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkaW5kZW50O1xuICB2YXIgZmFsbGJhY2tzID0gc3R5bGUuZmFsbGJhY2tzO1xuXG4gIGlmIChvcHRpb25zLmZvcm1hdCA9PT0gZmFsc2UpIHtcbiAgICBpbmRlbnQgPSAtSW5maW5pdHk7XG4gIH1cblxuICB2YXIgX2dldFdoaXRlc3BhY2VTeW1ib2xzID0gZ2V0V2hpdGVzcGFjZVN5bWJvbHMob3B0aW9ucyksXG4gICAgICBsaW5lYnJlYWsgPSBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMubGluZWJyZWFrLFxuICAgICAgc3BhY2UgPSBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMuc3BhY2U7XG5cbiAgaWYgKHNlbGVjdG9yKSBpbmRlbnQrKzsgLy8gQXBwbHkgZmFsbGJhY2tzIGZpcnN0LlxuXG4gIGlmIChmYWxsYmFja3MpIHtcbiAgICAvLyBBcnJheSBzeW50YXgge2ZhbGxiYWNrczogW3twcm9wOiB2YWx1ZX1dfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGZhbGxiYWNrcykpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBmYWxsYmFja3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBmYWxsYmFjayA9IGZhbGxiYWNrc1tpbmRleF07XG5cbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBmYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGZhbGxiYWNrW3Byb3BdO1xuXG4gICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSBsaW5lYnJlYWs7XG4gICAgICAgICAgICByZXN1bHQgKz0gaW5kZW50U3RyKHByb3AgKyBcIjpcIiArIHNwYWNlICsgdG9Dc3NWYWx1ZSh2YWx1ZSkgKyBcIjtcIiwgaW5kZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT2JqZWN0IHN5bnRheCB7ZmFsbGJhY2tzOiB7cHJvcDogdmFsdWV9fVxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gZmFsbGJhY2tzKSB7XG4gICAgICAgIHZhciBfdmFsdWUgPSBmYWxsYmFja3NbX3Byb3BdO1xuXG4gICAgICAgIGlmIChfdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSBsaW5lYnJlYWs7XG4gICAgICAgICAgcmVzdWx0ICs9IGluZGVudFN0cihfcHJvcCArIFwiOlwiICsgc3BhY2UgKyB0b0Nzc1ZhbHVlKF92YWx1ZSkgKyBcIjtcIiwgaW5kZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9wcm9wMiBpbiBzdHlsZSkge1xuICAgIHZhciBfdmFsdWUyID0gc3R5bGVbX3Byb3AyXTtcblxuICAgIGlmIChfdmFsdWUyICE9IG51bGwgJiYgX3Byb3AyICE9PSAnZmFsbGJhY2tzJykge1xuICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9IGxpbmVicmVhaztcbiAgICAgIHJlc3VsdCArPSBpbmRlbnRTdHIoX3Byb3AyICsgXCI6XCIgKyBzcGFjZSArIHRvQ3NzVmFsdWUoX3ZhbHVlMikgKyBcIjtcIiwgaW5kZW50KTtcbiAgICB9XG4gIH0gLy8gQWxsb3cgZW1wdHkgc3R5bGUgaW4gdGhpcyBjYXNlLCBiZWNhdXNlIHByb3BlcnRpZXMgd2lsbCBiZSBhZGRlZCBkeW5hbWljYWxseS5cblxuXG4gIGlmICghcmVzdWx0ICYmICFvcHRpb25zLmFsbG93RW1wdHkpIHJldHVybiByZXN1bHQ7IC8vIFdoZW4gcnVsZSBpcyBiZWluZyBzdHJpbmdpZmllZCBiZWZvcmUgc2VsZWN0b3Igd2FzIGRlZmluZWQuXG5cbiAgaWYgKCFzZWxlY3RvcikgcmV0dXJuIHJlc3VsdDtcbiAgaW5kZW50LS07XG4gIGlmIChyZXN1bHQpIHJlc3VsdCA9IFwiXCIgKyBsaW5lYnJlYWsgKyByZXN1bHQgKyBsaW5lYnJlYWs7XG4gIHJldHVybiBpbmRlbnRTdHIoXCJcIiArIHNlbGVjdG9yICsgc3BhY2UgKyBcIntcIiArIHJlc3VsdCwgaW5kZW50KSArIGluZGVudFN0cignfScsIGluZGVudCk7XG59XG5cbnZhciBlc2NhcGVSZWdleCA9IC8oW1tcXF0uIyokPjwrfj18XjooKSxcIidgXFxzXSkvZztcbnZhciBuYXRpdmVFc2NhcGUgPSB0eXBlb2YgQ1NTICE9PSAndW5kZWZpbmVkJyAmJiBDU1MuZXNjYXBlO1xudmFyIGVzY2FwZSA9IChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBuYXRpdmVFc2NhcGUgPyBuYXRpdmVFc2NhcGUoc3RyKSA6IHN0ci5yZXBsYWNlKGVzY2FwZVJlZ2V4LCAnXFxcXCQxJyk7XG59KTtcblxudmFyIEJhc2VTdHlsZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlU3R5bGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnc3R5bGUnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB2YXIgc2hlZXQgPSBvcHRpb25zLnNoZWV0LFxuICAgICAgICBSZW5kZXJlciA9IG9wdGlvbnMuUmVuZGVyZXI7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgaWYgKHNoZWV0KSB0aGlzLnJlbmRlcmVyID0gc2hlZXQucmVuZGVyZXI7ZWxzZSBpZiAoUmVuZGVyZXIpIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IG9yIHNldCBhIHN0eWxlIHByb3BlcnR5LlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBCYXNlU3R5bGVSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucHJvcCA9IGZ1bmN0aW9uIHByb3AobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAvLyBJdCdzIGEgZ2V0dGVyLlxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5zdHlsZVtuYW1lXTsgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIHZhbHVlIGhhcyBub3QgY2hhbmdlZC5cblxuICAgIHZhciBmb3JjZSA9IG9wdGlvbnMgPyBvcHRpb25zLmZvcmNlIDogZmFsc2U7XG4gICAgaWYgKCFmb3JjZSAmJiB0aGlzLnN0eWxlW25hbWVdID09PSB2YWx1ZSkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5wcm9jZXNzICE9PSBmYWxzZSkge1xuICAgICAgbmV3VmFsdWUgPSB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25DaGFuZ2VWYWx1ZSh2YWx1ZSwgbmFtZSwgdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIGlzRW1wdHkgPSBuZXdWYWx1ZSA9PSBudWxsIHx8IG5ld1ZhbHVlID09PSBmYWxzZTtcbiAgICB2YXIgaXNEZWZpbmVkID0gbmFtZSBpbiB0aGlzLnN0eWxlOyAvLyBWYWx1ZSBpcyBlbXB0eSBhbmQgd2Fzbid0IGRlZmluZWQgYmVmb3JlLlxuXG4gICAgaWYgKGlzRW1wdHkgJiYgIWlzRGVmaW5lZCAmJiAhZm9yY2UpIHJldHVybiB0aGlzOyAvLyBXZSBhcmUgZ29pbmcgdG8gcmVtb3ZlIHRoaXMgdmFsdWUuXG5cbiAgICB2YXIgcmVtb3ZlID0gaXNFbXB0eSAmJiBpc0RlZmluZWQ7XG4gICAgaWYgKHJlbW92ZSkgZGVsZXRlIHRoaXMuc3R5bGVbbmFtZV07ZWxzZSB0aGlzLnN0eWxlW25hbWVdID0gbmV3VmFsdWU7IC8vIFJlbmRlcmFibGUgaXMgZGVmaW5lZCBpZiBTdHlsZVNoZWV0IG9wdGlvbiBgbGlua2AgaXMgdHJ1ZS5cblxuICAgIGlmICh0aGlzLnJlbmRlcmFibGUgJiYgdGhpcy5yZW5kZXJlcikge1xuICAgICAgaWYgKHJlbW92ZSkgdGhpcy5yZW5kZXJlci5yZW1vdmVQcm9wZXJ0eSh0aGlzLnJlbmRlcmFibGUsIG5hbWUpO2Vsc2UgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLnJlbmRlcmFibGUsIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcblxuICAgIGlmIChzaGVldCAmJiBzaGVldC5hdHRhY2hlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ1tKU1NdIFJ1bGUgaXMgbm90IGxpbmtlZC4gTWlzc2luZyBzaGVldCBvcHRpb24gXCJsaW5rOiB0cnVlXCIuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIEJhc2VTdHlsZVJ1bGU7XG59KCk7XG52YXIgU3R5bGVSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZVN0eWxlUnVsZSkge1xuICBfaW5oZXJpdHNMb29zZShTdHlsZVJ1bGUsIF9CYXNlU3R5bGVSdWxlKTtcblxuICBmdW5jdGlvbiBTdHlsZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2VTdHlsZVJ1bGUuY2FsbCh0aGlzLCBrZXksIHN0eWxlLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgIHZhciBzZWxlY3RvciA9IG9wdGlvbnMuc2VsZWN0b3IsXG4gICAgICAgIHNjb3BlZCA9IG9wdGlvbnMuc2NvcGVkLFxuICAgICAgICBzaGVldCA9IG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIGdlbmVyYXRlSWQgPSBvcHRpb25zLmdlbmVyYXRlSWQ7XG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIF90aGlzLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yO1xuICAgIH0gZWxzZSBpZiAoc2NvcGVkICE9PSBmYWxzZSkge1xuICAgICAgX3RoaXMuaWQgPSBnZW5lcmF0ZUlkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBzaGVldCk7XG4gICAgICBfdGhpcy5zZWxlY3RvclRleHQgPSBcIi5cIiArIGVzY2FwZShfdGhpcy5pZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgc2VsZWN0b3Igc3RyaW5nLlxuICAgKiBBdHRlbnRpb246IHVzZSB0aGlzIHdpdGggY2F1dGlvbi4gTW9zdCBicm93c2VycyBkaWRuJ3QgaW1wbGVtZW50XG4gICAqIHNlbGVjdG9yVGV4dCBzZXR0ZXIsIHNvIHRoaXMgbWF5IHJlc3VsdCBpbiByZXJlbmRlcmluZyBvZiBlbnRpcmUgU3R5bGUgU2hlZXQuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90bzIgPSBTdHlsZVJ1bGUucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBBcHBseSBydWxlIHRvIGFuIGVsZW1lbnQgaW5saW5lLlxuICAgKi9cbiAgX3Byb3RvMi5hcHBseVRvID0gZnVuY3Rpb24gYXBwbHlUbyhyZW5kZXJhYmxlKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcblxuICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgdmFyIGpzb24gPSB0aGlzLnRvSlNPTigpO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIGpzb24pIHtcbiAgICAgICAgcmVuZGVyZXIuc2V0UHJvcGVydHkocmVuZGVyYWJsZSwgcHJvcCwganNvbltwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgcnVsZS5cbiAgICogRmFsbGJhY2tzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgKiBVc2VmdWwgZm9yIGlubGluZSBzdHlsZXMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvMi50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgdmFyIGpzb24gPSB7fTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5zdHlsZVtwcm9wXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSBqc29uW3Byb3BdID0gdmFsdWU7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIGpzb25bcHJvcF0gPSB0b0Nzc1ZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8yLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcbiAgICB2YXIgbGluayA9IHNoZWV0ID8gc2hlZXQub3B0aW9ucy5saW5rIDogZmFsc2U7XG4gICAgdmFyIG9wdHMgPSBsaW5rID8gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIGFsbG93RW1wdHk6IHRydWVcbiAgICB9KSA6IG9wdGlvbnM7XG4gICAgcmV0dXJuIHRvQ3NzKHRoaXMuc2VsZWN0b3JUZXh0LCB0aGlzLnN0eWxlLCBvcHRzKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU3R5bGVSdWxlLCBbe1xuICAgIGtleTogXCJzZWxlY3RvclwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc2VsZWN0b3IgPT09IHRoaXMuc2VsZWN0b3JUZXh0KSByZXR1cm47XG4gICAgICB0aGlzLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yO1xuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcixcbiAgICAgICAgICByZW5kZXJhYmxlID0gdGhpcy5yZW5kZXJhYmxlO1xuICAgICAgaWYgKCFyZW5kZXJhYmxlIHx8ICFyZW5kZXJlcikgcmV0dXJuO1xuICAgICAgdmFyIGhhc0NoYW5nZWQgPSByZW5kZXJlci5zZXRTZWxlY3RvcihyZW5kZXJhYmxlLCBzZWxlY3Rvcik7IC8vIElmIHNlbGVjdG9yIHNldHRlciBpcyBub3QgaW1wbGVtZW50ZWQsIHJlcmVuZGVyIHRoZSBydWxlLlxuXG4gICAgICBpZiAoIWhhc0NoYW5nZWQpIHtcbiAgICAgICAgcmVuZGVyZXIucmVwbGFjZVJ1bGUocmVuZGVyYWJsZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzZWxlY3RvciBzdHJpbmcuXG4gICAgICovXG4gICAgLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3JUZXh0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdHlsZVJ1bGU7XG59KEJhc2VTdHlsZVJ1bGUpO1xudmFyIHBsdWdpblN0eWxlUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChrZXlbMF0gPT09ICdAJyB8fCBvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC50eXBlID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTdHlsZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0VG9TdHJpbmdPcHRpb25zID0ge1xuICBpbmRlbnQ6IDEsXG4gIGNoaWxkcmVuOiB0cnVlXG59O1xudmFyIGF0UmVnRXhwID0gL0AoW1xcdy1dKykvO1xuLyoqXG4gKiBDb25kaXRpb25hbCBydWxlIGZvciBAbWVkaWEsIEBzdXBwb3J0c1xuICovXG5cbnZhciBDb25kaXRpb25hbFJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb25kaXRpb25hbFJ1bGUoa2V5LCBzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnY29uZGl0aW9uYWwnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB2YXIgYXRNYXRjaCA9IGtleS5tYXRjaChhdFJlZ0V4cCk7XG4gICAgdGhpcy5hdCA9IGF0TWF0Y2ggPyBhdE1hdGNoWzFdIDogJ3Vua25vd24nOyAvLyBLZXkgbWlnaHQgY29udGFpbiBhIHVuaXF1ZSBzdWZmaXggaW4gY2FzZSB0aGUgYG5hbWVgIHBhc3NlZCBieSB1c2VyIHdhcyBkdXBsaWNhdGUuXG5cbiAgICB0aGlzLnF1ZXJ5ID0gb3B0aW9ucy5uYW1lIHx8IFwiQFwiICsgdGhpcy5hdDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZXNbbmFtZV0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBDb25kaXRpb25hbFJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRSdWxlID0gZnVuY3Rpb24gZ2V0UnVsZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuZ2V0KG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuaW5kZXhPZihydWxlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZWdpc3RlciBydWxlLCBydW4gcGx1Z2lucy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZSA9IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlLCBvcHRpb25zKTtcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBudWxsO1xuICAgIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgX2dldFdoaXRlc3BhY2VTeW1ib2xzID0gZ2V0V2hpdGVzcGFjZVN5bWJvbHMob3B0aW9ucyksXG4gICAgICAgIGxpbmVicmVhayA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5saW5lYnJlYWs7XG5cbiAgICBpZiAob3B0aW9ucy5pbmRlbnQgPT0gbnVsbCkgb3B0aW9ucy5pbmRlbnQgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zLmluZGVudDtcbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PSBudWxsKSBvcHRpb25zLmNoaWxkcmVuID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucy5jaGlsZHJlbjtcblxuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMucXVlcnkgKyBcIiB7fVwiO1xuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgcmV0dXJuIGNoaWxkcmVuID8gdGhpcy5xdWVyeSArIFwiIHtcIiArIGxpbmVicmVhayArIGNoaWxkcmVuICsgbGluZWJyZWFrICsgXCJ9XCIgOiAnJztcbiAgfTtcblxuICByZXR1cm4gQ29uZGl0aW9uYWxSdWxlO1xufSgpO1xudmFyIGtleVJlZ0V4cCA9IC9AbWVkaWF8QHN1cHBvcnRzXFxzKy87XG52YXIgcGx1Z2luQ29uZGl0aW9uYWxSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBrZXlSZWdFeHAudGVzdChrZXkpID8gbmV3IENvbmRpdGlvbmFsUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxID0ge1xuICBpbmRlbnQ6IDEsXG4gIGNoaWxkcmVuOiB0cnVlXG59O1xudmFyIG5hbWVSZWdFeHAgPSAvQGtleWZyYW1lc1xccysoW1xcdy1dKykvO1xuLyoqXG4gKiBSdWxlIGZvciBAa2V5ZnJhbWVzXG4gKi9cblxudmFyIEtleWZyYW1lc1J1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBLZXlmcmFtZXNSdWxlKGtleSwgZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2tleWZyYW1lcyc7XG4gICAgdGhpcy5hdCA9ICdAa2V5ZnJhbWVzJztcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdmFyIG5hbWVNYXRjaCA9IGtleS5tYXRjaChuYW1lUmVnRXhwKTtcblxuICAgIGlmIChuYW1lTWF0Y2ggJiYgbmFtZU1hdGNoWzFdKSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lTWF0Y2hbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmFtZSA9ICdub25hbWUnO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBCYWQga2V5ZnJhbWVzIG5hbWUgXCIgKyBrZXkpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHRoaXMua2V5ID0gdGhpcy50eXBlICsgXCItXCIgKyB0aGlzLm5hbWU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB2YXIgc2NvcGVkID0gb3B0aW9ucy5zY29wZWQsXG4gICAgICAgIHNoZWV0ID0gb3B0aW9ucy5zaGVldCxcbiAgICAgICAgZ2VuZXJhdGVJZCA9IG9wdGlvbnMuZ2VuZXJhdGVJZDtcbiAgICB0aGlzLmlkID0gc2NvcGVkID09PSBmYWxzZSA/IHRoaXMubmFtZSA6IGVzY2FwZShnZW5lcmF0ZUlkKHRoaXMsIHNoZWV0KSk7XG4gICAgdGhpcy5ydWxlcyA9IG5ldyBSdWxlTGlzdChfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgcGFyZW50OiB0aGlzXG4gICAgfSkpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBmcmFtZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKG5hbWUsIGZyYW1lc1tuYW1lXSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgcGFyZW50OiB0aGlzXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5wcm9jZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IEtleWZyYW1lc1J1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxO1xuICAgIH1cblxuICAgIHZhciBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMgPSBnZXRXaGl0ZXNwYWNlU3ltYm9scyhvcHRpb25zKSxcbiAgICAgICAgbGluZWJyZWFrID0gX2dldFdoaXRlc3BhY2VTeW1ib2xzLmxpbmVicmVhaztcblxuICAgIGlmIChvcHRpb25zLmluZGVudCA9PSBudWxsKSBvcHRpb25zLmluZGVudCA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnMkMS5pbmRlbnQ7XG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gPT0gbnVsbCkgb3B0aW9ucy5jaGlsZHJlbiA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnMkMS5jaGlsZHJlbjtcblxuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXQgKyBcIiBcIiArIHRoaXMuaWQgKyBcIiB7fVwiO1xuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgaWYgKGNoaWxkcmVuKSBjaGlsZHJlbiA9IFwiXCIgKyBsaW5lYnJlYWsgKyBjaGlsZHJlbiArIGxpbmVicmVhaztcbiAgICByZXR1cm4gdGhpcy5hdCArIFwiIFwiICsgdGhpcy5pZCArIFwiIHtcIiArIGNoaWxkcmVuICsgXCJ9XCI7XG4gIH07XG5cbiAgcmV0dXJuIEtleWZyYW1lc1J1bGU7XG59KCk7XG52YXIga2V5UmVnRXhwJDEgPSAvQGtleWZyYW1lc1xccysvO1xudmFyIHJlZlJlZ0V4cCA9IC9cXCQoW1xcdy1dKykvZztcblxudmFyIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUgPSBmdW5jdGlvbiBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbCwga2V5ZnJhbWVzKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWwucmVwbGFjZShyZWZSZWdFeHAsIGZ1bmN0aW9uIChtYXRjaCwgbmFtZSkge1xuICAgICAgaWYgKG5hbWUgaW4ga2V5ZnJhbWVzKSB7XG4gICAgICAgIHJldHVybiBrZXlmcmFtZXNbbmFtZV07XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gUmVmZXJlbmNlZCBrZXlmcmFtZXMgcnVsZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkLlwiKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuLyoqXG4gKiBSZXBsYWNlIHRoZSByZWZlcmVuY2UgZm9yIGEgYW5pbWF0aW9uIG5hbWUuXG4gKi9cblxuXG52YXIgcmVwbGFjZVJlZiA9IGZ1bmN0aW9uIHJlcGxhY2VSZWYoc3R5bGUsIHByb3AsIGtleWZyYW1lcykge1xuICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wXTtcbiAgdmFyIHJlZktleWZyYW1lID0gZmluZFJlZmVyZW5jZWRLZXlmcmFtZSh2YWx1ZSwga2V5ZnJhbWVzKTtcblxuICBpZiAocmVmS2V5ZnJhbWUgIT09IHZhbHVlKSB7XG4gICAgc3R5bGVbcHJvcF0gPSByZWZLZXlmcmFtZTtcbiAgfVxufTtcblxudmFyIHBsdWdpbktleWZyYW1lc1J1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleVJlZ0V4cCQxLnRlc3Qoa2V5KSA/IG5ldyBLZXlmcmFtZXNSdWxlKGtleSwgZnJhbWVzLCBvcHRpb25zKSA6IG51bGw7XG4gIH0sXG4gIC8vIEFuaW1hdGlvbiBuYW1lIHJlZiByZXBsYWNlci5cbiAgb25Qcm9jZXNzU3R5bGU6IGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlLCBzaGVldCkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScgfHwgIXNoZWV0KSByZXR1cm4gc3R5bGU7XG4gICAgaWYgKCdhbmltYXRpb24tbmFtZScgaW4gc3R5bGUpIHJlcGxhY2VSZWYoc3R5bGUsICdhbmltYXRpb24tbmFtZScsIHNoZWV0LmtleWZyYW1lcyk7XG4gICAgaWYgKCdhbmltYXRpb24nIGluIHN0eWxlKSByZXBsYWNlUmVmKHN0eWxlLCAnYW5pbWF0aW9uJywgc2hlZXQua2V5ZnJhbWVzKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH0sXG4gIG9uQ2hhbmdlVmFsdWU6IGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsLCBwcm9wLCBydWxlKSB7XG4gICAgdmFyIHNoZWV0ID0gcnVsZS5vcHRpb25zLnNoZWV0O1xuXG4gICAgaWYgKCFzaGVldCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgIGNhc2UgJ2FuaW1hdGlvbic6XG4gICAgICAgIHJldHVybiBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbCwgc2hlZXQua2V5ZnJhbWVzKTtcblxuICAgICAgY2FzZSAnYW5pbWF0aW9uLW5hbWUnOlxuICAgICAgICByZXR1cm4gZmluZFJlZmVyZW5jZWRLZXlmcmFtZSh2YWwsIHNoZWV0LmtleWZyYW1lcyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgS2V5ZnJhbWVSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZVN0eWxlUnVsZSkge1xuICBfaW5oZXJpdHNMb29zZShLZXlmcmFtZVJ1bGUsIF9CYXNlU3R5bGVSdWxlKTtcblxuICBmdW5jdGlvbiBLZXlmcmFtZVJ1bGUoKSB7XG4gICAgcmV0dXJuIF9CYXNlU3R5bGVSdWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBLZXlmcmFtZVJ1bGUucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcbiAgICB2YXIgbGluayA9IHNoZWV0ID8gc2hlZXQub3B0aW9ucy5saW5rIDogZmFsc2U7XG4gICAgdmFyIG9wdHMgPSBsaW5rID8gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIGFsbG93RW1wdHk6IHRydWVcbiAgICB9KSA6IG9wdGlvbnM7XG4gICAgcmV0dXJuIHRvQ3NzKHRoaXMua2V5LCB0aGlzLnN0eWxlLCBvcHRzKTtcbiAgfTtcblxuICByZXR1cm4gS2V5ZnJhbWVSdWxlO1xufShCYXNlU3R5bGVSdWxlKTtcbnZhciBwbHVnaW5LZXlmcmFtZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5wYXJlbnQgJiYgb3B0aW9ucy5wYXJlbnQudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgIHJldHVybiBuZXcgS2V5ZnJhbWVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG52YXIgRm9udEZhY2VSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRm9udEZhY2VSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnZm9udC1mYWNlJztcbiAgICB0aGlzLmF0ID0gJ0Bmb250LWZhY2UnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gRm9udEZhY2VSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIF9nZXRXaGl0ZXNwYWNlU3ltYm9scyA9IGdldFdoaXRlc3BhY2VTeW1ib2xzKG9wdGlvbnMpLFxuICAgICAgICBsaW5lYnJlYWsgPSBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMubGluZWJyZWFrO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5zdHlsZSkpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuc3R5bGUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0ciArPSB0b0Nzcyh0aGlzLmF0LCB0aGlzLnN0eWxlW2luZGV4XSk7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlW2luZGV4ICsgMV0pIHN0ciArPSBsaW5lYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvQ3NzKHRoaXMuYXQsIHRoaXMuc3R5bGUsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBGb250RmFjZVJ1bGU7XG59KCk7XG52YXIga2V5UmVnRXhwJDIgPSAvQGZvbnQtZmFjZS87XG52YXIgcGx1Z2luRm9udEZhY2VSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGtleVJlZ0V4cCQyLnRlc3Qoa2V5KSA/IG5ldyBGb250RmFjZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgVmlld3BvcnRSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmlld3BvcnRSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAndmlld3BvcnQnO1xuICAgIHRoaXMuYXQgPSAnQHZpZXdwb3J0JztcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFZpZXdwb3J0UnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0b0Nzcyh0aGlzLmtleSwgdGhpcy5zdHlsZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIFZpZXdwb3J0UnVsZTtcbn0oKTtcbnZhciBwbHVnaW5WaWV3cG9ydFJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5ID09PSAnQHZpZXdwb3J0JyB8fCBrZXkgPT09ICdALW1zLXZpZXdwb3J0JyA/IG5ldyBWaWV3cG9ydFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgU2ltcGxlUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNpbXBsZVJ1bGUoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdzaW1wbGUnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG5cbiAgdmFyIF9wcm90byA9IFNpbXBsZVJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSkge1xuICAgICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy52YWx1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc3RyICs9IHRoaXMua2V5ICsgXCIgXCIgKyB0aGlzLnZhbHVlW2luZGV4XSArIFwiO1wiO1xuICAgICAgICBpZiAodGhpcy52YWx1ZVtpbmRleCArIDFdKSBzdHIgKz0gJ1xcbic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMua2V5ICsgXCIgXCIgKyB0aGlzLnZhbHVlICsgXCI7XCI7XG4gIH07XG5cbiAgcmV0dXJuIFNpbXBsZVJ1bGU7XG59KCk7XG52YXIga2V5c01hcCA9IHtcbiAgJ0BjaGFyc2V0JzogdHJ1ZSxcbiAgJ0BpbXBvcnQnOiB0cnVlLFxuICAnQG5hbWVzcGFjZSc6IHRydWVcbn07XG52YXIgcGx1Z2luU2ltcGxlUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBrZXkgaW4ga2V5c01hcCA/IG5ldyBTaW1wbGVSdWxlKGtleSwgdmFsdWUsIG9wdGlvbnMpIDogbnVsbDtcbiAgfVxufTtcblxudmFyIHBsdWdpbnMgPSBbcGx1Z2luU3R5bGVSdWxlLCBwbHVnaW5Db25kaXRpb25hbFJ1bGUsIHBsdWdpbktleWZyYW1lc1J1bGUsIHBsdWdpbktleWZyYW1lUnVsZSwgcGx1Z2luRm9udEZhY2VSdWxlLCBwbHVnaW5WaWV3cG9ydFJ1bGUsIHBsdWdpblNpbXBsZVJ1bGVdO1xuXG52YXIgZGVmYXVsdFVwZGF0ZU9wdGlvbnMgPSB7XG4gIHByb2Nlc3M6IHRydWVcbn07XG52YXIgZm9yY2VVcGRhdGVPcHRpb25zID0ge1xuICBmb3JjZTogdHJ1ZSxcbiAgcHJvY2VzczogdHJ1ZVxuICAvKipcbiAgICogQ29udGFpbnMgcnVsZXMgb2JqZWN0cyBhbmQgYWxsb3dzIGFkZGluZy9yZW1vdmluZyBldGMuXG4gICAqIElzIHVzZWQgZm9yIGUuZy4gYnkgYFN0eWxlU2hlZXRgIG9yIGBDb25kaXRpb25hbFJ1bGVgLlxuICAgKi9cblxufTtcblxudmFyIFJ1bGVMaXN0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gUnVsZXMgcmVnaXN0cnkgZm9yIGFjY2VzcyBieSAuZ2V0KCkgbWV0aG9kLlxuICAvLyBJdCBjb250YWlucyB0aGUgc2FtZSBydWxlIHJlZ2lzdGVyZWQgYnkgbmFtZSBhbmQgYnkgc2VsZWN0b3IuXG4gIC8vIE9yaWdpbmFsIHN0eWxlcyBvYmplY3QuXG4gIC8vIFVzZWQgdG8gZW5zdXJlIGNvcnJlY3QgcnVsZXMgb3JkZXIuXG4gIGZ1bmN0aW9uIFJ1bGVMaXN0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuICAgIHRoaXMucmF3ID0ge307XG4gICAgdGhpcy5pbmRleCA9IFtdO1xuICAgIHRoaXMuY291bnRlciA9IDA7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNsYXNzZXMgPSBvcHRpb25zLmNsYXNzZXM7XG4gICAgdGhpcy5rZXlmcmFtZXMgPSBvcHRpb25zLmtleWZyYW1lcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZWdpc3RlciBydWxlLlxuICAgKlxuICAgKiBXaWxsIG5vdCByZW5kZXIgYWZ0ZXIgU3R5bGUgU2hlZXQgd2FzIHJlbmRlcmVkIHRoZSBmaXJzdCB0aW1lLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBSdWxlTGlzdC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChuYW1lLCBkZWNsLCBydWxlT3B0aW9ucykge1xuICAgIHZhciBfdGhpcyRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBwYXJlbnQgPSBfdGhpcyRvcHRpb25zLnBhcmVudCxcbiAgICAgICAgc2hlZXQgPSBfdGhpcyRvcHRpb25zLnNoZWV0LFxuICAgICAgICBqc3MgPSBfdGhpcyRvcHRpb25zLmpzcyxcbiAgICAgICAgUmVuZGVyZXIgPSBfdGhpcyRvcHRpb25zLlJlbmRlcmVyLFxuICAgICAgICBnZW5lcmF0ZUlkID0gX3RoaXMkb3B0aW9ucy5nZW5lcmF0ZUlkLFxuICAgICAgICBzY29wZWQgPSBfdGhpcyRvcHRpb25zLnNjb3BlZDtcblxuICAgIHZhciBvcHRpb25zID0gX2V4dGVuZHMoe1xuICAgICAgY2xhc3NlczogdGhpcy5jbGFzc2VzLFxuICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICBzaGVldDogc2hlZXQsXG4gICAgICBqc3M6IGpzcyxcbiAgICAgIFJlbmRlcmVyOiBSZW5kZXJlcixcbiAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQsXG4gICAgICBzY29wZWQ6IHNjb3BlZCxcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBrZXlmcmFtZXM6IHRoaXMua2V5ZnJhbWVzLFxuICAgICAgc2VsZWN0b3I6IHVuZGVmaW5lZFxuICAgIH0sIHJ1bGVPcHRpb25zKTsgLy8gV2hlbiB1c2VyIHVzZXMgLmNyZWF0ZVN0eWxlU2hlZXQoKSwgZHVwbGljYXRlIG5hbWVzIGFyZSBub3QgcG9zc2libGUsIGJ1dFxuICAgIC8vIGBzaGVldC5hZGRSdWxlKClgIG9wZW5zIHRoZSBkb29yIGZvciBhbnkgZHVwbGljYXRlIHJ1bGUgbmFtZS4gV2hlbiB0aGlzIGhhcHBlbnNcbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2UgdGhlIGtleSB1bmlxdWUgd2l0aGluIHRoaXMgUnVsZUxpc3QgaW5zdGFuY2Ugc2NvcGUuXG5cblxuICAgIHZhciBrZXkgPSBuYW1lO1xuXG4gICAgaWYgKG5hbWUgaW4gdGhpcy5yYXcpIHtcbiAgICAgIGtleSA9IG5hbWUgKyBcIi1kXCIgKyB0aGlzLmNvdW50ZXIrKztcbiAgICB9IC8vIFdlIG5lZWQgdG8gc2F2ZSB0aGUgb3JpZ2luYWwgZGVjbCBiZWZvcmUgY3JlYXRpbmcgdGhlIHJ1bGVcbiAgICAvLyBiZWNhdXNlIGNhY2hlIHBsdWdpbiBuZWVkcyB0byB1c2UgaXQgYXMgYSBrZXkgdG8gcmV0dXJuIGEgY2FjaGVkIHJ1bGUuXG5cblxuICAgIHRoaXMucmF3W2tleV0gPSBkZWNsO1xuXG4gICAgaWYgKGtleSBpbiB0aGlzLmNsYXNzZXMpIHtcbiAgICAgIC8vIEUuZy4gcnVsZXMgaW5zaWRlIG9mIEBtZWRpYSBjb250YWluZXJcbiAgICAgIG9wdGlvbnMuc2VsZWN0b3IgPSBcIi5cIiArIGVzY2FwZSh0aGlzLmNsYXNzZXNba2V5XSk7XG4gICAgfVxuXG4gICAgdmFyIHJ1bGUgPSBjcmVhdGVSdWxlKGtleSwgZGVjbCwgb3B0aW9ucyk7XG4gICAgaWYgKCFydWxlKSByZXR1cm4gbnVsbDtcbiAgICB0aGlzLnJlZ2lzdGVyKHJ1bGUpO1xuICAgIHZhciBpbmRleCA9IG9wdGlvbnMuaW5kZXggPT09IHVuZGVmaW5lZCA/IHRoaXMuaW5kZXgubGVuZ3RoIDogb3B0aW9ucy5pbmRleDtcbiAgICB0aGlzLmluZGV4LnNwbGljZShpbmRleCwgMCwgcnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW25hbWVdO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUocnVsZSkge1xuICAgIHRoaXMudW5yZWdpc3RlcihydWxlKTtcbiAgICBkZWxldGUgdGhpcy5yYXdbcnVsZS5rZXldO1xuICAgIHRoaXMuaW5kZXguc3BsaWNlKHRoaXMuaW5kZXguaW5kZXhPZihydWxlKSwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleC5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBSdW4gYG9uUHJvY2Vzc1J1bGUoKWAgcGx1Z2lucyBvbiBldmVyeSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICB2YXIgcGx1Z2lucyA9IHRoaXMub3B0aW9ucy5qc3MucGx1Z2luczsgLy8gV2UgbmVlZCB0byBjbG9uZSBhcnJheSBiZWNhdXNlIGlmIHdlIG1vZGlmeSB0aGUgaW5kZXggc29tZXdoZXJlIGVsc2UgZHVyaW5nIGEgbG9vcFxuICAgIC8vIHdlIGVuZCB1cCB3aXRoIHZlcnkgaGFyZC10by10cmFjay1kb3duIHNpZGUgZWZmZWN0cy5cblxuICAgIHRoaXMuaW5kZXguc2xpY2UoMCkuZm9yRWFjaChwbHVnaW5zLm9uUHJvY2Vzc1J1bGUsIHBsdWdpbnMpO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHJ1bGUgaW4gYC5tYXBgLCBgLmNsYXNzZXNgIGFuZCBgLmtleWZyYW1lc2AgbWFwcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihydWxlKSB7XG4gICAgdGhpcy5tYXBbcnVsZS5rZXldID0gcnVsZTtcblxuICAgIGlmIChydWxlIGluc3RhbmNlb2YgU3R5bGVSdWxlKSB7XG4gICAgICB0aGlzLm1hcFtydWxlLnNlbGVjdG9yXSA9IHJ1bGU7XG4gICAgICBpZiAocnVsZS5pZCkgdGhpcy5jbGFzc2VzW3J1bGUua2V5XSA9IHJ1bGUuaWQ7XG4gICAgfSBlbHNlIGlmIChydWxlIGluc3RhbmNlb2YgS2V5ZnJhbWVzUnVsZSAmJiB0aGlzLmtleWZyYW1lcykge1xuICAgICAgdGhpcy5rZXlmcmFtZXNbcnVsZS5uYW1lXSA9IHJ1bGUuaWQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udW5yZWdpc3RlciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXIocnVsZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtydWxlLmtleV07XG5cbiAgICBpZiAocnVsZSBpbnN0YW5jZW9mIFN0eWxlUnVsZSkge1xuICAgICAgZGVsZXRlIHRoaXMubWFwW3J1bGUuc2VsZWN0b3JdO1xuICAgICAgZGVsZXRlIHRoaXMuY2xhc3Nlc1tydWxlLmtleV07XG4gICAgfSBlbHNlIGlmIChydWxlIGluc3RhbmNlb2YgS2V5ZnJhbWVzUnVsZSkge1xuICAgICAgZGVsZXRlIHRoaXMua2V5ZnJhbWVzW3J1bGUubmFtZV07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGZ1bmN0aW9uIHZhbHVlcyB3aXRoIGEgbmV3IGRhdGEuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgb3B0aW9ucztcblxuICAgIGlmICh0eXBlb2YgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXTtcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdO1xuICAgICAgbmFtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHRoaXMudXBkYXRlT25lKHRoaXMubWFwW25hbWVdLCBkYXRhLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuaW5kZXgubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHRoaXMudXBkYXRlT25lKHRoaXMuaW5kZXhbaW5kZXhdLCBkYXRhLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGUgcGx1Z2lucywgdXBkYXRlIHJ1bGUgcHJvcHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZU9uZSA9IGZ1bmN0aW9uIHVwZGF0ZU9uZShydWxlLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRVcGRhdGVPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyRvcHRpb25zMiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgcGx1Z2lucyA9IF90aGlzJG9wdGlvbnMyLmpzcy5wbHVnaW5zLFxuICAgICAgICBzaGVldCA9IF90aGlzJG9wdGlvbnMyLnNoZWV0OyAvLyBJdCBpcyBhIHJ1bGVzIGNvbnRhaW5lciBsaWtlIGZvciBlLmcuIENvbmRpdGlvbmFsUnVsZS5cblxuICAgIGlmIChydWxlLnJ1bGVzIGluc3RhbmNlb2YgUnVsZUxpc3QpIHtcbiAgICAgIHJ1bGUucnVsZXMudXBkYXRlKGRhdGEsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHJ1bGUuc3R5bGU7XG4gICAgcGx1Z2lucy5vblVwZGF0ZShkYXRhLCBydWxlLCBzaGVldCwgb3B0aW9ucyk7IC8vIFdlIHJlbHkgb24gYSBuZXcgYHN0eWxlYCByZWYgaW4gY2FzZSBpdCB3YXMgbXV0YXRlZCBkdXJpbmcgb25VcGRhdGUgaG9vay5cblxuICAgIGlmIChvcHRpb25zLnByb2Nlc3MgJiYgc3R5bGUgJiYgc3R5bGUgIT09IHJ1bGUuc3R5bGUpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gcnVuIHRoZSBwbHVnaW5zIGluIGNhc2UgbmV3IGBzdHlsZWAgcmVsaWVzIG9uIHN5bnRheCBwbHVnaW5zLlxuICAgICAgcGx1Z2lucy5vblByb2Nlc3NTdHlsZShydWxlLnN0eWxlLCBydWxlLCBzaGVldCk7IC8vIFVwZGF0ZSBhbmQgYWRkIHByb3BzLlxuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHJ1bGUuc3R5bGUpIHtcbiAgICAgICAgdmFyIG5leHRWYWx1ZSA9IHJ1bGUuc3R5bGVbcHJvcF07XG4gICAgICAgIHZhciBwcmV2VmFsdWUgPSBzdHlsZVtwcm9wXTsgLy8gV2UgbmVlZCB0byB1c2UgYGZvcmNlOiB0cnVlYCBiZWNhdXNlIGBydWxlLnN0eWxlYCBoYXMgYmVlbiB1cGRhdGVkIGR1cmluZyBvblVwZGF0ZSBob29rLCBzbyBgcnVsZS5wcm9wKClgIHdpbGwgbm90IHVwZGF0ZSB0aGUgQ1NTT00gcnVsZS5cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBjb21wYXJpc29uIHRvIGF2b2lkIHVubmVlZGVkIGBydWxlLnByb3AoKWAgY2FsbHMsIHNpbmNlIHdlIGhhdmUgdGhlIG9sZCBgc3R5bGVgIG9iamVjdCBoZXJlLlxuXG4gICAgICAgIGlmIChuZXh0VmFsdWUgIT09IHByZXZWYWx1ZSkge1xuICAgICAgICAgIHJ1bGUucHJvcChwcm9wLCBuZXh0VmFsdWUsIGZvcmNlVXBkYXRlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmVtb3ZlIHByb3BzLlxuXG5cbiAgICAgIGZvciAodmFyIF9wcm9wIGluIHN0eWxlKSB7XG4gICAgICAgIHZhciBfbmV4dFZhbHVlID0gcnVsZS5zdHlsZVtfcHJvcF07XG4gICAgICAgIHZhciBfcHJldlZhbHVlID0gc3R5bGVbX3Byb3BdOyAvLyBXZSBuZWVkIHRvIHVzZSBgZm9yY2U6IHRydWVgIGJlY2F1c2UgYHJ1bGUuc3R5bGVgIGhhcyBiZWVuIHVwZGF0ZWQgZHVyaW5nIG9uVXBkYXRlIGhvb2ssIHNvIGBydWxlLnByb3AoKWAgd2lsbCBub3QgdXBkYXRlIHRoZSBDU1NPTSBydWxlLlxuICAgICAgICAvLyBXZSBkbyB0aGlzIGNvbXBhcmlzb24gdG8gYXZvaWQgdW5uZWVkZWQgYHJ1bGUucHJvcCgpYCBjYWxscywgc2luY2Ugd2UgaGF2ZSB0aGUgb2xkIGBzdHlsZWAgb2JqZWN0IGhlcmUuXG5cbiAgICAgICAgaWYgKF9uZXh0VmFsdWUgPT0gbnVsbCAmJiBfbmV4dFZhbHVlICE9PSBfcHJldlZhbHVlKSB7XG4gICAgICAgICAgcnVsZS5wcm9wKF9wcm9wLCBudWxsLCBmb3JjZVVwZGF0ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHJ1bGVzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcbiAgICB2YXIgbGluayA9IHNoZWV0ID8gc2hlZXQub3B0aW9ucy5saW5rIDogZmFsc2U7XG5cbiAgICB2YXIgX2dldFdoaXRlc3BhY2VTeW1ib2xzID0gZ2V0V2hpdGVzcGFjZVN5bWJvbHMob3B0aW9ucyksXG4gICAgICAgIGxpbmVicmVhayA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5saW5lYnJlYWs7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5pbmRleC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBydWxlID0gdGhpcy5pbmRleFtpbmRleF07XG4gICAgICB2YXIgY3NzID0gcnVsZS50b1N0cmluZyhvcHRpb25zKTsgLy8gTm8gbmVlZCB0byByZW5kZXIgYW4gZW1wdHkgcnVsZS5cblxuICAgICAgaWYgKCFjc3MgJiYgIWxpbmspIGNvbnRpbnVlO1xuICAgICAgaWYgKHN0cikgc3RyICs9IGxpbmVicmVhaztcbiAgICAgIHN0ciArPSBjc3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICByZXR1cm4gUnVsZUxpc3Q7XG59KCk7XG5cbnZhciBTdHlsZVNoZWV0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3R5bGVTaGVldChzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5kZXBsb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xhc3NlcyA9IHt9O1xuICAgIHRoaXMua2V5ZnJhbWVzID0ge307XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHNoZWV0OiB0aGlzLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgY2xhc3NlczogdGhpcy5jbGFzc2VzLFxuICAgICAga2V5ZnJhbWVzOiB0aGlzLmtleWZyYW1lc1xuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMuUmVuZGVyZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgb3B0aW9ucy5SZW5kZXJlcih0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzID0gbmV3IFJ1bGVMaXN0KHRoaXMub3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGVzW25hbWVdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogQXR0YWNoIHJlbmRlcmFibGUgdG8gdGhlIHJlbmRlciB0cmVlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBTdHlsZVNoZWV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uYXR0YWNoID0gZnVuY3Rpb24gYXR0YWNoKCkge1xuICAgIGlmICh0aGlzLmF0dGFjaGVkKSByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5yZW5kZXJlcikgdGhpcy5yZW5kZXJlci5hdHRhY2goKTtcbiAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTsgLy8gT3JkZXIgaXMgaW1wb3J0YW50LCBiZWNhdXNlIHdlIGNhbid0IHVzZSBpbnNlcnRSdWxlIEFQSSBpZiBzdHlsZSBlbGVtZW50IGlzIG5vdCBhdHRhY2hlZC5cblxuICAgIGlmICghdGhpcy5kZXBsb3llZCkgdGhpcy5kZXBsb3koKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHJlbmRlcmFibGUgZnJvbSByZW5kZXIgdHJlZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgIGlmICghdGhpcy5hdHRhY2hlZCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHRoaXMucmVuZGVyZXIuZGV0YWNoKCk7XG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBydWxlIHRvIHRoZSBjdXJyZW50IHN0eWxlc2hlZXQuXG4gICAqIFdpbGwgaW5zZXJ0IGEgcnVsZSBhbHNvIGFmdGVyIHRoZSBzdHlsZXNoZWV0IGhhcyBiZWVuIHJlbmRlcmVkIGZpcnN0IHRpbWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZFJ1bGUgPSBmdW5jdGlvbiBhZGRSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlOyAvLyBQbHVnaW5zIGNhbiBjcmVhdGUgcnVsZXMuXG4gICAgLy8gSW4gb3JkZXIgdG8gcHJlc2VydmUgdGhlIHJpZ2h0IG9yZGVyLCB3ZSBuZWVkIHRvIHF1ZXVlIGFsbCBgLmFkZFJ1bGVgIGNhbGxzLFxuICAgIC8vIHdoaWNoIGhhcHBlbiBhZnRlciB0aGUgZmlyc3QgYHJ1bGVzLmFkZCgpYCBjYWxsLlxuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQgJiYgIXF1ZXVlKSB0aGlzLnF1ZXVlID0gW107XG4gICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzLmFkZChuYW1lLCBkZWNsLCBvcHRpb25zKTtcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBudWxsO1xuICAgIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIGlmICghdGhpcy5kZXBsb3llZCkgcmV0dXJuIHJ1bGU7IC8vIERvbid0IGluc2VydCBydWxlIGRpcmVjdGx5IGlmIHRoZXJlIGlzIG5vIHN0cmluZ2lmaWVkIHZlcnNpb24geWV0LlxuICAgICAgLy8gSXQgd2lsbCBiZSBpbnNlcnRlZCBhbGwgdG9nZXRoZXIgd2hlbiAuYXR0YWNoIGlzIGNhbGxlZC5cblxuICAgICAgaWYgKHF1ZXVlKSBxdWV1ZS5wdXNoKHJ1bGUpO2Vsc2Uge1xuICAgICAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG5cbiAgICAgICAgaWYgKHRoaXMucXVldWUpIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlLmZvckVhY2godGhpcy5pbnNlcnRSdWxlLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLnF1ZXVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9IC8vIFdlIGNhbid0IGFkZCBydWxlcyB0byBhIGRldGFjaGVkIHN0eWxlIG5vZGUuXG4gICAgLy8gV2Ugd2lsbCByZWRlcGxveSB0aGUgc2hlZXQgb25jZSB1c2VyIHdpbGwgYXR0YWNoIGl0LlxuXG5cbiAgICB0aGlzLmRlcGxveWVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBydWxlIGludG8gdGhlIFN0eWxlU2hlZXRcbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIGluc2VydFJ1bGUocnVsZSkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmluc2VydFJ1bGUocnVsZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIGFkZCBydWxlcy5cbiAgICogV2lsbCByZW5kZXIgYWxzbyBhZnRlciBTdHlsZSBTaGVldCB3YXMgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZFJ1bGVzID0gZnVuY3Rpb24gYWRkUnVsZXMoc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGFkZGVkID0gW107XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLmFkZFJ1bGUobmFtZSwgc3R5bGVzW25hbWVdLCBvcHRpb25zKTtcbiAgICAgIGlmIChydWxlKSBhZGRlZC5wdXNoKHJ1bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRlZDtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcnVsZSBieSBuYW1lLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRSdWxlID0gZnVuY3Rpb24gZ2V0UnVsZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuZ2V0KG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBydWxlIGJ5IG5hbWUuXG4gICAqIFJldHVybnMgYHRydWVgOiBpZiBydWxlIGhhcyBiZWVuIGRlbGV0ZWQgZnJvbSB0aGUgRE9NLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZWxldGVSdWxlID0gZnVuY3Rpb24gZGVsZXRlUnVsZShuYW1lKSB7XG4gICAgdmFyIHJ1bGUgPSB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcgPyBuYW1lIDogdGhpcy5ydWxlcy5nZXQobmFtZSk7XG5cbiAgICBpZiAoIXJ1bGUgfHwgLy8gU3R5bGUgc2hlZXQgd2FzIGNyZWF0ZWQgd2l0aG91dCBsaW5rOiB0cnVlIGFuZCBhdHRhY2hlZCwgaW4gdGhpcyBjYXNlIHdlXG4gICAgLy8gd29uJ3QgYmUgYWJsZSB0byByZW1vdmUgdGhlIENTUyBydWxlIGZyb20gdGhlIERPTS5cbiAgICB0aGlzLmF0dGFjaGVkICYmICFydWxlLnJlbmRlcmFibGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnJlbW92ZShydWxlKTtcblxuICAgIGlmICh0aGlzLmF0dGFjaGVkICYmIHJ1bGUucmVuZGVyYWJsZSAmJiB0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5kZWxldGVSdWxlKHJ1bGUucmVuZGVyYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBEZXBsb3kgcHVyZSBDU1Mgc3RyaW5nIHRvIGEgcmVuZGVyYWJsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVwbG95ID0gZnVuY3Rpb24gZGVwbG95KCkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyLmRlcGxveSgpO1xuICAgIHRoaXMuZGVwbG95ZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGZ1bmN0aW9uIHZhbHVlcyB3aXRoIGEgbmV3IGRhdGEuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMkcnVsZXM7XG5cbiAgICAoX3RoaXMkcnVsZXMgPSB0aGlzLnJ1bGVzKS51cGRhdGUuYXBwbHkoX3RoaXMkcnVsZXMsIGFyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBhIHNpbmdsZSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGVPbmUgPSBmdW5jdGlvbiB1cGRhdGVPbmUocnVsZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMucnVsZXMudXBkYXRlT25lKHJ1bGUsIGRhdGEsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHJ1bGVzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5cbnZhciBQbHVnaW5zUmVnaXN0cnkgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbHVnaW5zUmVnaXN0cnkoKSB7XG4gICAgdGhpcy5wbHVnaW5zID0ge1xuICAgICAgaW50ZXJuYWw6IFtdLFxuICAgICAgZXh0ZXJuYWw6IFtdXG4gICAgfTtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0ge307XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUGx1Z2luc1JlZ2lzdHJ5LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQ2FsbCBgb25DcmVhdGVSdWxlYCBob29rcyBhbmQgcmV0dXJuIGFuIG9iamVjdCBpZiByZXR1cm5lZCBieSBhIGhvb2suXG4gICAqL1xuICBfcHJvdG8ub25DcmVhdGVSdWxlID0gZnVuY3Rpb24gb25DcmVhdGVSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25DcmVhdGVSdWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcnVsZSA9IHRoaXMucmVnaXN0cnkub25DcmVhdGVSdWxlW2ldKG5hbWUsIGRlY2wsIG9wdGlvbnMpO1xuICAgICAgaWYgKHJ1bGUpIHJldHVybiBydWxlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBvblByb2Nlc3NSdWxlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25Qcm9jZXNzUnVsZSA9IGZ1bmN0aW9uIG9uUHJvY2Vzc1J1bGUocnVsZSkge1xuICAgIGlmIChydWxlLmlzUHJvY2Vzc2VkKSByZXR1cm47XG4gICAgdmFyIHNoZWV0ID0gcnVsZS5vcHRpb25zLnNoZWV0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1J1bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucmVnaXN0cnkub25Qcm9jZXNzUnVsZVtpXShydWxlLCBzaGVldCk7XG4gICAgfVxuXG4gICAgaWYgKHJ1bGUuc3R5bGUpIHRoaXMub25Qcm9jZXNzU3R5bGUocnVsZS5zdHlsZSwgcnVsZSwgc2hlZXQpO1xuICAgIHJ1bGUuaXNQcm9jZXNzZWQgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBvblByb2Nlc3NTdHlsZWAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uUHJvY2Vzc1N0eWxlID0gZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1N0eWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBydWxlLnN0eWxlID0gdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NTdHlsZVtpXShydWxlLnN0eWxlLCBydWxlLCBzaGVldCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBvblByb2Nlc3NTaGVldGAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uUHJvY2Vzc1NoZWV0ID0gZnVuY3Rpb24gb25Qcm9jZXNzU2hlZXQoc2hlZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU2hlZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU2hlZXRbaV0oc2hlZXQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25VcGRhdGVgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblVwZGF0ZSA9IGZ1bmN0aW9uIG9uVXBkYXRlKGRhdGEsIHJ1bGUsIHNoZWV0LCBvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uVXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJ5Lm9uVXBkYXRlW2ldKGRhdGEsIHJ1bGUsIHNoZWV0LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uQ2hhbmdlVmFsdWVgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vbkNoYW5nZVZhbHVlID0gZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCwgcnVsZSkge1xuICAgIHZhciBwcm9jZXNzZWRWYWx1ZSA9IHZhbHVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uQ2hhbmdlVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb2Nlc3NlZFZhbHVlID0gdGhpcy5yZWdpc3RyeS5vbkNoYW5nZVZhbHVlW2ldKHByb2Nlc3NlZFZhbHVlLCBwcm9wLCBydWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvY2Vzc2VkVmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgcGx1Z2luLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51c2UgPSBmdW5jdGlvbiB1c2UobmV3UGx1Z2luLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgcXVldWU6ICdleHRlcm5hbCdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHBsdWdpbnMgPSB0aGlzLnBsdWdpbnNbb3B0aW9ucy5xdWV1ZV07IC8vIEF2b2lkcyBhcHBseWluZyBzYW1lIHBsdWdpbiB0d2ljZSwgYXQgbGVhc3QgYmFzZWQgb24gcmVmLlxuXG4gICAgaWYgKHBsdWdpbnMuaW5kZXhPZihuZXdQbHVnaW4pICE9PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBsdWdpbnMucHVzaChuZXdQbHVnaW4pO1xuICAgIHRoaXMucmVnaXN0cnkgPSBbXS5jb25jYXQodGhpcy5wbHVnaW5zLmV4dGVybmFsLCB0aGlzLnBsdWdpbnMuaW50ZXJuYWwpLnJlZHVjZShmdW5jdGlvbiAocmVnaXN0cnksIHBsdWdpbikge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBwbHVnaW4pIHtcbiAgICAgICAgaWYgKG5hbWUgaW4gcmVnaXN0cnkpIHtcbiAgICAgICAgICByZWdpc3RyeVtuYW1lXS5wdXNoKHBsdWdpbltuYW1lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBVbmtub3duIGhvb2sgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIikgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2lzdHJ5O1xuICAgIH0sIHtcbiAgICAgIG9uQ3JlYXRlUnVsZTogW10sXG4gICAgICBvblByb2Nlc3NSdWxlOiBbXSxcbiAgICAgIG9uUHJvY2Vzc1N0eWxlOiBbXSxcbiAgICAgIG9uUHJvY2Vzc1NoZWV0OiBbXSxcbiAgICAgIG9uQ2hhbmdlVmFsdWU6IFtdLFxuICAgICAgb25VcGRhdGU6IFtdXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFBsdWdpbnNSZWdpc3RyeTtcbn0oKTtcblxuLyoqXG4gKiBTaGVldHMgcmVnaXN0cnkgdG8gYWNjZXNzIGFsbCBpbnN0YW5jZXMgaW4gb25lIHBsYWNlLlxuICovXG5cbnZhciBTaGVldHNSZWdpc3RyeSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNoZWV0c1JlZ2lzdHJ5KCkge1xuICAgIHRoaXMucmVnaXN0cnkgPSBbXTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTaGVldHNSZWdpc3RyeS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgU3R5bGUgU2hlZXQuXG4gICAqL1xuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKHNoZWV0KSB7XG4gICAgdmFyIHJlZ2lzdHJ5ID0gdGhpcy5yZWdpc3RyeTtcbiAgICB2YXIgaW5kZXggPSBzaGVldC5vcHRpb25zLmluZGV4O1xuICAgIGlmIChyZWdpc3RyeS5pbmRleE9mKHNoZWV0KSAhPT0gLTEpIHJldHVybjtcblxuICAgIGlmIChyZWdpc3RyeS5sZW5ndGggPT09IDAgfHwgaW5kZXggPj0gdGhpcy5pbmRleCkge1xuICAgICAgcmVnaXN0cnkucHVzaChzaGVldCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGaW5kIGEgcG9zaXRpb24uXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWdpc3RyeVtpXS5vcHRpb25zLmluZGV4ID4gaW5kZXgpIHtcbiAgICAgICAgcmVnaXN0cnkuc3BsaWNlKGksIDAsIHNoZWV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVzZXQgdGhlIHJlZ2lzdHJ5LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMucmVnaXN0cnkgPSBbXTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGEgU3R5bGUgU2hlZXQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShzaGVldCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMucmVnaXN0cnkuaW5kZXhPZihzaGVldCk7XG4gICAgdGhpcy5yZWdpc3RyeS5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IGFsbCBhdHRhY2hlZCBzaGVldHMgdG8gYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKF90ZW1wKSB7XG4gICAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgICAgYXR0YWNoZWQgPSBfcmVmLmF0dGFjaGVkLFxuICAgICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW1wiYXR0YWNoZWRcIl0pO1xuXG4gICAgdmFyIF9nZXRXaGl0ZXNwYWNlU3ltYm9scyA9IGdldFdoaXRlc3BhY2VTeW1ib2xzKG9wdGlvbnMpLFxuICAgICAgICBsaW5lYnJlYWsgPSBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMubGluZWJyZWFrO1xuXG4gICAgdmFyIGNzcyA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2hlZXQgPSB0aGlzLnJlZ2lzdHJ5W2ldO1xuXG4gICAgICBpZiAoYXR0YWNoZWQgIT0gbnVsbCAmJiBzaGVldC5hdHRhY2hlZCAhPT0gYXR0YWNoZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjc3MpIGNzcyArPSBsaW5lYnJlYWs7XG4gICAgICBjc3MgKz0gc2hlZXQudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNzcztcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU2hlZXRzUmVnaXN0cnksIFt7XG4gICAga2V5OiBcImluZGV4XCIsXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGhpZ2hlc3QgaW5kZXggbnVtYmVyLlxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnkubGVuZ3RoID09PSAwID8gMCA6IHRoaXMucmVnaXN0cnlbdGhpcy5yZWdpc3RyeS5sZW5ndGggLSAxXS5vcHRpb25zLmluZGV4O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTaGVldHNSZWdpc3RyeTtcbn0oKTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgZ2xvYmFsIHNoZWV0cyByZWdpc3RyeS4gT25seSBEb21SZW5kZXJlciB3aWxsIGFkZCBzaGVldHMgdG8gaXQuXG4gKiBPbiB0aGUgc2VydmVyIG9uZSBzaG91bGQgdXNlIGFuIG93biBTaGVldHNSZWdpc3RyeSBpbnN0YW5jZSBhbmQgYWRkIHRoZVxuICogc2hlZXRzIHRvIGl0LCBiZWNhdXNlIHlvdSBuZWVkIHRvIG1ha2Ugc3VyZSB0byBjcmVhdGUgYSBuZXcgcmVnaXN0cnkgZm9yXG4gKiBlYWNoIHJlcXVlc3QgaW4gb3JkZXIgdG8gbm90IGxlYWsgc2hlZXRzIGFjcm9zcyByZXF1ZXN0cy5cbiAqL1xuXG52YXIgc2hlZXRzID0gbmV3IFNoZWV0c1JlZ2lzdHJ5KCk7XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbi8qKlxuICogTm93IHRoYXQgYGdsb2JhbFRoaXNgIGlzIGF2YWlsYWJsZSBvbiBtb3N0IHBsYXRmb3Jtc1xuICogKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL2dsb2JhbFRoaXMjYnJvd3Nlcl9jb21wYXRpYmlsaXR5KVxuICogd2UgY2hlY2sgZm9yIGBnbG9iYWxUaGlzYCBmaXJzdC4gYGdsb2JhbFRoaXNgIGlzIG5lY2Vzc2FyeSBmb3IganNzXG4gKiB0byBydW4gaW4gQWdvcmljJ3Mgc2VjdXJlIHZlcnNpb24gb2YgSmF2YVNjcmlwdCAoU0VTKS4gVW5kZXIgU0VTLFxuICogYGdsb2JhbFRoaXNgIGV4aXN0cywgYnV0IGB3aW5kb3dgLCBgc2VsZmAsIGFuZCBgRnVuY3Rpb24oJ3JldHVyblxuICogdGhpcycpKClgIGFyZSBhbGwgdW5kZWZpbmVkIGZvciBzZWN1cml0eSByZWFzb25zLlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG4gKi9cbnZhciBnbG9iYWxUaGlzJDEgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT09IE1hdGggPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbnZhciBucyA9ICcyZjFhY2M2YzNhNjA2YjA4MmU1ZWVmNWU1NDQxNGZmYic7XG5pZiAoZ2xvYmFsVGhpcyQxW25zXSA9PSBudWxsKSBnbG9iYWxUaGlzJDFbbnNdID0gMDsgLy8gQnVuZGxlIG1heSBjb250YWluIG11bHRpcGxlIEpTUyB2ZXJzaW9ucyBhdCB0aGUgc2FtZSB0aW1lLiBJbiBvcmRlciB0byBpZGVudGlmeVxuLy8gdGhlIGN1cnJlbnQgdmVyc2lvbiB3aXRoIGp1c3Qgb25lIHNob3J0IG51bWJlciBhbmQgdXNlIGl0IGZvciBjbGFzc2VzIGdlbmVyYXRpb25cbi8vIHdlIHVzZSBhIGNvdW50ZXIuIEFsc28gaXQgaXMgbW9yZSBhY2N1cmF0ZSwgYmVjYXVzZSB1c2VyIGNhbiBtYW51YWxseSByZWV2YWx1YXRlXG4vLyB0aGUgbW9kdWxlLlxuXG52YXIgbW9kdWxlSWQgPSBnbG9iYWxUaGlzJDFbbnNdKys7XG5cbnZhciBtYXhSdWxlcyA9IDFlMTA7XG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBnZW5lcmF0ZXMgdW5pcXVlIGNsYXNzIG5hbWVzIGJhc2VkIG9uIGNvdW50ZXJzLlxuICogV2hlbiBuZXcgZ2VuZXJhdG9yIGZ1bmN0aW9uIGlzIGNyZWF0ZWQsIHJ1bGUgY291bnRlciBpcyByZXNldGVkLlxuICogV2UgbmVlZCB0byByZXNldCB0aGUgcnVsZSBjb3VudGVyIGZvciBTU1IgZm9yIGVhY2ggcmVxdWVzdC5cbiAqL1xuXG52YXIgY3JlYXRlR2VuZXJhdGVJZCA9IGZ1bmN0aW9uIGNyZWF0ZUdlbmVyYXRlSWQob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHJ1bGVDb3VudGVyID0gMDtcblxuICB2YXIgZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uIGdlbmVyYXRlSWQocnVsZSwgc2hlZXQpIHtcbiAgICBydWxlQ291bnRlciArPSAxO1xuXG4gICAgaWYgKHJ1bGVDb3VudGVyID4gbWF4UnVsZXMpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gWW91IG1pZ2h0IGhhdmUgYSBtZW1vcnkgbGVhay4gUnVsZSBjb3VudGVyIGlzIGF0IFwiICsgcnVsZUNvdW50ZXIgKyBcIi5cIikgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGpzc0lkID0gJyc7XG4gICAgdmFyIHByZWZpeCA9ICcnO1xuXG4gICAgaWYgKHNoZWV0KSB7XG4gICAgICBpZiAoc2hlZXQub3B0aW9ucy5jbGFzc05hbWVQcmVmaXgpIHtcbiAgICAgICAgcHJlZml4ID0gc2hlZXQub3B0aW9ucy5jbGFzc05hbWVQcmVmaXg7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGVldC5vcHRpb25zLmpzcy5pZCAhPSBudWxsKSB7XG4gICAgICAgIGpzc0lkID0gU3RyaW5nKHNoZWV0Lm9wdGlvbnMuanNzLmlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5taW5pZnkpIHtcbiAgICAgIC8vIFVzaW5nIFwiY1wiIGJlY2F1c2UgYSBudW1iZXIgY2FuJ3QgYmUgdGhlIGZpcnN0IGNoYXIgaW4gYSBjbGFzcyBuYW1lLlxuICAgICAgcmV0dXJuIFwiXCIgKyAocHJlZml4IHx8ICdjJykgKyBtb2R1bGVJZCArIGpzc0lkICsgcnVsZUNvdW50ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZpeCArIHJ1bGUua2V5ICsgXCItXCIgKyBtb2R1bGVJZCArIChqc3NJZCA/IFwiLVwiICsganNzSWQgOiAnJykgKyBcIi1cIiArIHJ1bGVDb3VudGVyO1xuICB9O1xuXG4gIHJldHVybiBnZW5lcmF0ZUlkO1xufTtcblxuLyoqXG4gKiBDYWNoZSB0aGUgdmFsdWUgZnJvbSB0aGUgZmlyc3QgdGltZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAqL1xuXG52YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgdmFyIHZhbHVlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdmFsdWUpIHZhbHVlID0gZm4oKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59O1xuLyoqXG4gKiBHZXQgYSBzdHlsZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuXG5cbnZhciBnZXRQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24gZ2V0UHJvcGVydHlWYWx1ZShjc3NSdWxlLCBwcm9wKSB7XG4gIHRyeSB7XG4gICAgLy8gU3VwcG9ydCBDU1NUT00uXG4gICAgaWYgKGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXApIHtcbiAgICAgIHJldHVybiBjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwLmdldChwcm9wKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzUnVsZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJRSBtYXkgdGhyb3cgaWYgcHJvcGVydHkgaXMgdW5rbm93bi5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG4vKipcbiAqIFNldCBhIHN0eWxlIHByb3BlcnR5LlxuICovXG5cblxudmFyIHNldFByb3BlcnR5ID0gZnVuY3Rpb24gc2V0UHJvcGVydHkoY3NzUnVsZSwgcHJvcCwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgY3NzVmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY3NzVmFsdWUgPSB0b0Nzc1ZhbHVlKHZhbHVlLCB0cnVlKTtcblxuICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnIWltcG9ydGFudCcpIHtcbiAgICAgICAgY3NzUnVsZS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBjc3NWYWx1ZSwgJ2ltcG9ydGFudCcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIFN1cHBvcnQgQ1NTVE9NLlxuXG5cbiAgICBpZiAoY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcCkge1xuICAgICAgY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcC5zZXQocHJvcCwgY3NzVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjc3NSdWxlLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIGNzc1ZhbHVlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElFIG1heSB0aHJvdyBpZiBwcm9wZXJ0eSBpcyB1bmtub3duLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogUmVtb3ZlIGEgc3R5bGUgcHJvcGVydHkuXG4gKi9cblxuXG52YXIgcmVtb3ZlUHJvcGVydHkgPSBmdW5jdGlvbiByZW1vdmVQcm9wZXJ0eShjc3NSdWxlLCBwcm9wKSB7XG4gIHRyeSB7XG4gICAgLy8gU3VwcG9ydCBDU1NUT00uXG4gICAgaWYgKGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXApIHtcbiAgICAgIGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXAuZGVsZXRlKHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjc3NSdWxlLnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3ApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBET01FeGNlcHRpb24gXFxcIlwiICsgZXJyLm1lc3NhZ2UgKyBcIlxcXCIgd2FzIHRocm93bi4gVHJpZWQgdG8gcmVtb3ZlIHByb3BlcnR5IFxcXCJcIiArIHByb3AgKyBcIlxcXCIuXCIpIDogdm9pZCAwO1xuICB9XG59O1xuLyoqXG4gKiBTZXQgdGhlIHNlbGVjdG9yLlxuICovXG5cblxudmFyIHNldFNlbGVjdG9yID0gZnVuY3Rpb24gc2V0U2VsZWN0b3IoY3NzUnVsZSwgc2VsZWN0b3JUZXh0KSB7XG4gIGNzc1J1bGUuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3JUZXh0OyAvLyBSZXR1cm4gZmFsc2UgaWYgc2V0dGVyIHdhcyBub3Qgc3VjY2Vzc2Z1bC5cbiAgLy8gQ3VycmVudGx5IHdvcmtzIGluIGNocm9tZSBvbmx5LlxuXG4gIHJldHVybiBjc3NSdWxlLnNlbGVjdG9yVGV4dCA9PT0gc2VsZWN0b3JUZXh0O1xufTtcbi8qKlxuICogR2V0cyB0aGUgYGhlYWRgIGVsZW1lbnQgdXBvbiB0aGUgZmlyc3QgY2FsbCBhbmQgY2FjaGVzIGl0LlxuICogV2UgYXNzdW1lIGl0IGNhbid0IGJlIG51bGwuXG4gKi9cblxuXG52YXIgZ2V0SGVhZCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpO1xufSk7XG4vKipcbiAqIEZpbmQgYXR0YWNoZWQgc2hlZXQgd2l0aCBhbiBpbmRleCBoaWdoZXIgdGhhbiB0aGUgcGFzc2VkIG9uZS5cbiAqL1xuXG5mdW5jdGlvbiBmaW5kSGlnaGVyU2hlZXQocmVnaXN0cnksIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzaGVldCA9IHJlZ2lzdHJ5W2ldO1xuXG4gICAgaWYgKHNoZWV0LmF0dGFjaGVkICYmIHNoZWV0Lm9wdGlvbnMuaW5kZXggPiBvcHRpb25zLmluZGV4ICYmIHNoZWV0Lm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgPT09IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQpIHtcbiAgICAgIHJldHVybiBzaGVldDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRmluZCBhdHRhY2hlZCBzaGVldCB3aXRoIHRoZSBoaWdoZXN0IGluZGV4LlxuICovXG5cblxuZnVuY3Rpb24gZmluZEhpZ2hlc3RTaGVldChyZWdpc3RyeSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gcmVnaXN0cnkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgc2hlZXQgPSByZWdpc3RyeVtpXTtcblxuICAgIGlmIChzaGVldC5hdHRhY2hlZCAmJiBzaGVldC5vcHRpb25zLmluc2VydGlvblBvaW50ID09PSBvcHRpb25zLmluc2VydGlvblBvaW50KSB7XG4gICAgICByZXR1cm4gc2hlZXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEZpbmQgYSBjb21tZW50IHdpdGggXCJqc3NcIiBpbnNpZGUuXG4gKi9cblxuXG5mdW5jdGlvbiBmaW5kQ29tbWVudE5vZGUodGV4dCkge1xuICB2YXIgaGVhZCA9IGdldEhlYWQoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gaGVhZC5jaGlsZE5vZGVzW2ldO1xuXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUudHJpbSgpID09PSB0ZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRmluZCBhIG5vZGUgYmVmb3JlIHdoaWNoIHdlIGNhbiBpbnNlcnQgdGhlIHNoZWV0LlxuICovXG5cblxuZnVuY3Rpb24gZmluZFByZXZOb2RlKG9wdGlvbnMpIHtcbiAgdmFyIHJlZ2lzdHJ5ID0gc2hlZXRzLnJlZ2lzdHJ5O1xuXG4gIGlmIChyZWdpc3RyeS5sZW5ndGggPiAwKSB7XG4gICAgLy8gVHJ5IHRvIGluc2VydCBiZWZvcmUgdGhlIG5leHQgaGlnaGVyIHNoZWV0LlxuICAgIHZhciBzaGVldCA9IGZpbmRIaWdoZXJTaGVldChyZWdpc3RyeSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoc2hlZXQgJiYgc2hlZXQucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcmVudDogc2hlZXQucmVuZGVyZXIuZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgICBub2RlOiBzaGVldC5yZW5kZXJlci5lbGVtZW50XG4gICAgICB9O1xuICAgIH0gLy8gT3RoZXJ3aXNlIGluc2VydCBhZnRlciB0aGUgbGFzdCBhdHRhY2hlZC5cblxuXG4gICAgc2hlZXQgPSBmaW5kSGlnaGVzdFNoZWV0KHJlZ2lzdHJ5LCBvcHRpb25zKTtcblxuICAgIGlmIChzaGVldCAmJiBzaGVldC5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFyZW50OiBzaGVldC5yZW5kZXJlci5lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICAgIG5vZGU6IHNoZWV0LnJlbmRlcmVyLmVsZW1lbnQubmV4dFNpYmxpbmdcbiAgICAgIH07XG4gICAgfVxuICB9IC8vIFRyeSB0byBmaW5kIGEgY29tbWVudCBwbGFjZWhvbGRlciBpZiByZWdpc3RyeSBpcyBlbXB0eS5cblxuXG4gIHZhciBpbnNlcnRpb25Qb2ludCA9IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQ7XG5cbiAgaWYgKGluc2VydGlvblBvaW50ICYmIHR5cGVvZiBpbnNlcnRpb25Qb2ludCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgY29tbWVudCA9IGZpbmRDb21tZW50Tm9kZShpbnNlcnRpb25Qb2ludCk7XG5cbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFyZW50OiBjb21tZW50LnBhcmVudE5vZGUsXG4gICAgICAgIG5vZGU6IGNvbW1lbnQubmV4dFNpYmxpbmdcbiAgICAgIH07XG4gICAgfSAvLyBJZiB1c2VyIHNwZWNpZmllcyBhbiBpbnNlcnRpb24gcG9pbnQgYW5kIGl0IGNhbid0IGJlIGZvdW5kIGluIHRoZSBkb2N1bWVudCAtXG4gICAgLy8gYmFkIHNwZWNpZmljaXR5IGlzc3VlcyBtYXkgYXBwZWFyLlxuXG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIEluc2VydGlvbiBwb2ludCBcXFwiXCIgKyBpbnNlcnRpb25Qb2ludCArIFwiXFxcIiBub3QgZm91bmQuXCIpIDogdm9pZCAwO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBJbnNlcnQgc3R5bGUgZWxlbWVudCBpbnRvIHRoZSBET00uXG4gKi9cblxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZShzdHlsZSwgb3B0aW9ucykge1xuICB2YXIgaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuICB2YXIgbmV4dE5vZGUgPSBmaW5kUHJldk5vZGUob3B0aW9ucyk7XG5cbiAgaWYgKG5leHROb2RlICE9PSBmYWxzZSAmJiBuZXh0Tm9kZS5wYXJlbnQpIHtcbiAgICBuZXh0Tm9kZS5wYXJlbnQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0Tm9kZS5ub2RlKTtcbiAgICByZXR1cm47XG4gIH0gLy8gV29ya3Mgd2l0aCBpZnJhbWVzIGFuZCBhbnkgbm9kZSB0eXBlcy5cblxuXG4gIGlmIChpbnNlcnRpb25Qb2ludCAmJiB0eXBlb2YgaW5zZXJ0aW9uUG9pbnQubm9kZVR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgdmFyIGluc2VydGlvblBvaW50RWxlbWVudCA9IGluc2VydGlvblBvaW50O1xuICAgIHZhciBwYXJlbnROb2RlID0gaW5zZXJ0aW9uUG9pbnRFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlLCBpbnNlcnRpb25Qb2ludEVsZW1lbnQubmV4dFNpYmxpbmcpO2Vsc2UgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ1tKU1NdIEluc2VydGlvbiBwb2ludCBpcyBub3QgaW4gdGhlIERPTS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm47XG4gIH1cblxuICBnZXRIZWFkKCkuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxuLyoqXG4gKiBSZWFkIGpzcyBub25jZSBzZXR0aW5nIGZyb20gdGhlIHBhZ2UgaWYgdGhlIHVzZXIgaGFzIHNldCBpdC5cbiAqL1xuXG5cbnZhciBnZXROb25jZSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbcHJvcGVydHk9XCJjc3Atbm9uY2VcIl0nKTtcbiAgcmV0dXJuIG5vZGUgPyBub2RlLmdldEF0dHJpYnV0ZSgnY29udGVudCcpIDogbnVsbDtcbn0pO1xuXG52YXIgX2luc2VydFJ1bGUgPSBmdW5jdGlvbiBpbnNlcnRSdWxlKGNvbnRhaW5lciwgcnVsZSwgaW5kZXgpIHtcbiAgdHJ5IHtcbiAgICBpZiAoJ2luc2VydFJ1bGUnIGluIGNvbnRhaW5lcikge1xuICAgICAgY29udGFpbmVyLmluc2VydFJ1bGUocnVsZSwgaW5kZXgpO1xuICAgIH0gLy8gS2V5ZnJhbWVzIHJ1bGUuXG4gICAgZWxzZSBpZiAoJ2FwcGVuZFJ1bGUnIGluIGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kUnVsZShydWxlKTtcbiAgICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBcIiArIGVyci5tZXNzYWdlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyLmNzc1J1bGVzW2luZGV4XTtcbn07XG5cbnZhciBnZXRWYWxpZFJ1bGVJbnNlcnRpb25JbmRleCA9IGZ1bmN0aW9uIGdldFZhbGlkUnVsZUluc2VydGlvbkluZGV4KGNvbnRhaW5lciwgaW5kZXgpIHtcbiAgdmFyIG1heEluZGV4ID0gY29udGFpbmVyLmNzc1J1bGVzLmxlbmd0aDsgLy8gSW4gY2FzZSBwcmV2aW91cyBpbnNlcnRpb24gZmFpbHMsIHBhc3NlZCBpbmRleCBtaWdodCBiZSB3cm9uZ1xuXG4gIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID4gbWF4SW5kZXgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICByZXR1cm4gbWF4SW5kZXg7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuXG52YXIgY3JlYXRlU3R5bGUgPSBmdW5jdGlvbiBjcmVhdGVTdHlsZSgpIHtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTsgLy8gV2l0aG91dCBpdCwgSUUgd2lsbCBoYXZlIGEgYnJva2VuIHNvdXJjZSBvcmRlciBzcGVjaWZpY2l0eSBpZiB3ZVxuICAvLyBpbnNlcnQgcnVsZXMgYWZ0ZXIgd2UgaW5zZXJ0IHRoZSBzdHlsZSB0YWcuXG4gIC8vIEl0IHNlZW1zIHRvIGtpY2stb2ZmIHRoZSBzb3VyY2Ugb3JkZXIgc3BlY2lmaWNpdHkgYWxnb3JpdGhtLlxuXG4gIGVsLnRleHRDb250ZW50ID0gJ1xcbic7XG4gIHJldHVybiBlbDtcbn07XG5cbnZhciBEb21SZW5kZXJlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8vIFdpbGwgYmUgZW1wdHkgaWYgbGluazogdHJ1ZSBvcHRpb24gaXMgbm90IHNldCwgYmVjYXVzZVxuICAvLyBpdCBpcyBvbmx5IGZvciB1c2UgdG9nZXRoZXIgd2l0aCBpbnNlcnRSdWxlIEFQSS5cbiAgZnVuY3Rpb24gRG9tUmVuZGVyZXIoc2hlZXQpIHtcbiAgICB0aGlzLmdldFByb3BlcnR5VmFsdWUgPSBnZXRQcm9wZXJ0eVZhbHVlO1xuICAgIHRoaXMuc2V0UHJvcGVydHkgPSBzZXRQcm9wZXJ0eTtcbiAgICB0aGlzLnJlbW92ZVByb3BlcnR5ID0gcmVtb3ZlUHJvcGVydHk7XG4gICAgdGhpcy5zZXRTZWxlY3RvciA9IHNldFNlbGVjdG9yO1xuICAgIHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyA9IGZhbHNlO1xuICAgIHRoaXMuY3NzUnVsZXMgPSBbXTtcbiAgICAvLyBUaGVyZSBpcyBubyBzaGVldCB3aGVuIHRoZSByZW5kZXJlciBpcyB1c2VkIGZyb20gYSBzdGFuZGFsb25lIFN0eWxlUnVsZS5cbiAgICBpZiAoc2hlZXQpIHNoZWV0cy5hZGQoc2hlZXQpO1xuICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcblxuICAgIHZhciBfcmVmID0gdGhpcy5zaGVldCA/IHRoaXMuc2hlZXQub3B0aW9ucyA6IHt9LFxuICAgICAgICBtZWRpYSA9IF9yZWYubWVkaWEsXG4gICAgICAgIG1ldGEgPSBfcmVmLm1ldGEsXG4gICAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQ7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50IHx8IGNyZWF0ZVN0eWxlKCk7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1qc3MnLCAnJyk7XG4gICAgaWYgKG1lZGlhKSB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgICBpZiAobWV0YSkgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1tZXRhJywgbWV0YSk7XG4gICAgdmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcbiAgICBpZiAobm9uY2UpIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgc3R5bGUgZWxlbWVudCBpbnRvIHJlbmRlciB0cmVlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBEb21SZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmF0dGFjaCA9IGZ1bmN0aW9uIGF0dGFjaCgpIHtcbiAgICAvLyBJbiB0aGUgY2FzZSB0aGUgZWxlbWVudCBub2RlIGlzIGV4dGVybmFsIGFuZCBpdCBpcyBhbHJlYWR5IGluIHRoZSBET00uXG4gICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnROb2RlIHx8ICF0aGlzLnNoZWV0KSByZXR1cm47XG4gICAgaW5zZXJ0U3R5bGUodGhpcy5lbGVtZW50LCB0aGlzLnNoZWV0Lm9wdGlvbnMpOyAvLyBXaGVuIHJ1bGVzIGFyZSBpbnNlcnRlZCB1c2luZyBgaW5zZXJ0UnVsZWAgQVBJLCBhZnRlciBgc2hlZXQuZGV0YWNoKCkuYXR0YWNoKClgXG4gICAgLy8gbW9zdCBicm93c2VycyBjcmVhdGUgYSBuZXcgQ1NTU3R5bGVTaGVldCwgZXhjZXB0IG9mIGFsbCBJRXMuXG5cbiAgICB2YXIgZGVwbG95ZWQgPSBCb29sZWFuKHRoaXMuc2hlZXQgJiYgdGhpcy5zaGVldC5kZXBsb3llZCk7XG5cbiAgICBpZiAodGhpcy5oYXNJbnNlcnRlZFJ1bGVzICYmIGRlcGxveWVkKSB7XG4gICAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVwbG95KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgc3R5bGUgZWxlbWVudCBmcm9tIHJlbmRlciB0cmVlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgaWYgKCF0aGlzLnNoZWV0KSByZXR1cm47XG4gICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpOyAvLyBJbiB0aGUgbW9zdCBicm93c2VycywgcnVsZXMgaW5zZXJ0ZWQgdXNpbmcgaW5zZXJ0UnVsZSgpIEFQSSB3aWxsIGJlIGxvc3Qgd2hlbiBzdHlsZSBlbGVtZW50IGlzIHJlbW92ZWQuXG4gICAgLy8gVGhvdWdoIElFIHdpbGwga2VlcCB0aGVtIGFuZCB3ZSBuZWVkIGEgY29uc2lzdGVudCBiZWhhdmlvci5cblxuICAgIGlmICh0aGlzLnNoZWV0Lm9wdGlvbnMubGluaykge1xuICAgICAgdGhpcy5jc3NSdWxlcyA9IFtdO1xuICAgICAgdGhpcy5lbGVtZW50LnRleHRDb250ZW50ID0gJ1xcbic7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmplY3QgQ1NTIHN0cmluZyBpbnRvIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlcGxveSA9IGZ1bmN0aW9uIGRlcGxveSgpIHtcbiAgICB2YXIgc2hlZXQgPSB0aGlzLnNoZWV0O1xuICAgIGlmICghc2hlZXQpIHJldHVybjtcblxuICAgIGlmIChzaGVldC5vcHRpb25zLmxpbmspIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZXMoc2hlZXQucnVsZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC50ZXh0Q29udGVudCA9IFwiXFxuXCIgKyBzaGVldC50b1N0cmluZygpICsgXCJcXG5cIjtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IFJ1bGVMaXN0IGludG8gYW4gZWxlbWVudC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5zZXJ0UnVsZXMgPSBmdW5jdGlvbiBpbnNlcnRSdWxlcyhydWxlcywgbmF0aXZlUGFyZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5pbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGVzLmluZGV4W2ldLCBpLCBuYXRpdmVQYXJlbnQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IGEgcnVsZSBpbnRvIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluc2VydFJ1bGUgPSBmdW5jdGlvbiBpbnNlcnRSdWxlKHJ1bGUsIGluZGV4LCBuYXRpdmVQYXJlbnQpIHtcbiAgICBpZiAobmF0aXZlUGFyZW50ID09PSB2b2lkIDApIHtcbiAgICAgIG5hdGl2ZVBhcmVudCA9IHRoaXMuZWxlbWVudC5zaGVldDtcbiAgICB9XG5cbiAgICBpZiAocnVsZS5ydWxlcykge1xuICAgICAgdmFyIHBhcmVudCA9IHJ1bGU7XG4gICAgICB2YXIgbGF0ZXN0TmF0aXZlUGFyZW50ID0gbmF0aXZlUGFyZW50O1xuXG4gICAgICBpZiAocnVsZS50eXBlID09PSAnY29uZGl0aW9uYWwnIHx8IHJ1bGUudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgICAgdmFyIF9pbnNlcnRpb25JbmRleCA9IGdldFZhbGlkUnVsZUluc2VydGlvbkluZGV4KG5hdGl2ZVBhcmVudCwgaW5kZXgpOyAvLyBXZSBuZWVkIHRvIHJlbmRlciB0aGUgY29udGFpbmVyIHdpdGhvdXQgY2hpbGRyZW4gZmlyc3QuXG5cblxuICAgICAgICBsYXRlc3ROYXRpdmVQYXJlbnQgPSBfaW5zZXJ0UnVsZShuYXRpdmVQYXJlbnQsIHBhcmVudC50b1N0cmluZyh7XG4gICAgICAgICAgY2hpbGRyZW46IGZhbHNlXG4gICAgICAgIH0pLCBfaW5zZXJ0aW9uSW5kZXgpO1xuXG4gICAgICAgIGlmIChsYXRlc3ROYXRpdmVQYXJlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWZDc3NSdWxlKHJ1bGUsIF9pbnNlcnRpb25JbmRleCwgbGF0ZXN0TmF0aXZlUGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnNlcnRSdWxlcyhwYXJlbnQucnVsZXMsIGxhdGVzdE5hdGl2ZVBhcmVudCk7XG4gICAgICByZXR1cm4gbGF0ZXN0TmF0aXZlUGFyZW50O1xuICAgIH1cblxuICAgIHZhciBydWxlU3RyID0gcnVsZS50b1N0cmluZygpO1xuICAgIGlmICghcnVsZVN0cikgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBpbnNlcnRpb25JbmRleCA9IGdldFZhbGlkUnVsZUluc2VydGlvbkluZGV4KG5hdGl2ZVBhcmVudCwgaW5kZXgpO1xuXG4gICAgdmFyIG5hdGl2ZVJ1bGUgPSBfaW5zZXJ0UnVsZShuYXRpdmVQYXJlbnQsIHJ1bGVTdHIsIGluc2VydGlvbkluZGV4KTtcblxuICAgIGlmIChuYXRpdmVSdWxlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyA9IHRydWU7XG4gICAgdGhpcy5yZWZDc3NSdWxlKHJ1bGUsIGluc2VydGlvbkluZGV4LCBuYXRpdmVSdWxlKTtcbiAgICByZXR1cm4gbmF0aXZlUnVsZTtcbiAgfTtcblxuICBfcHJvdG8ucmVmQ3NzUnVsZSA9IGZ1bmN0aW9uIHJlZkNzc1J1bGUocnVsZSwgaW5kZXgsIGNzc1J1bGUpIHtcbiAgICBydWxlLnJlbmRlcmFibGUgPSBjc3NSdWxlOyAvLyBXZSBvbmx5IHdhbnQgdG8gcmVmZXJlbmNlIHRoZSB0b3AgbGV2ZWwgcnVsZXMsIGRlbGV0ZVJ1bGUgQVBJIGRvZXNuJ3Qgc3VwcG9ydCByZW1vdmluZyBuZXN0ZWQgcnVsZXNcbiAgICAvLyBsaWtlIHJ1bGVzIGluc2lkZSBtZWRpYSBxdWVyaWVzIG9yIGtleWZyYW1lc1xuXG4gICAgaWYgKHJ1bGUub3B0aW9ucy5wYXJlbnQgaW5zdGFuY2VvZiBTdHlsZVNoZWV0KSB7XG4gICAgICB0aGlzLmNzc1J1bGVzW2luZGV4XSA9IGNzc1J1bGU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZWxldGVSdWxlID0gZnVuY3Rpb24gZGVsZXRlUnVsZShjc3NSdWxlKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5lbGVtZW50LnNoZWV0O1xuICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZihjc3NSdWxlKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gZmFsc2U7XG4gICAgc2hlZXQuZGVsZXRlUnVsZShpbmRleCk7XG4gICAgdGhpcy5jc3NSdWxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBDU1MgUnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YoY3NzUnVsZSkge1xuICAgIHJldHVybiB0aGlzLmNzc1J1bGVzLmluZGV4T2YoY3NzUnVsZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IENTUyBydWxlIGFuZCByZXBsYWNlIHRoZSBleGlzdGluZyBvbmUuXG4gICAqXG4gICAqIE9ubHkgdXNlZCBmb3Igc29tZSBvbGQgYnJvd3NlcnMgYmVjYXVzZSB0aGV5IGNhbid0IHNldCBhIHNlbGVjdG9yLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBsYWNlUnVsZSA9IGZ1bmN0aW9uIHJlcGxhY2VSdWxlKGNzc1J1bGUsIHJ1bGUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoY3NzUnVsZSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuZWxlbWVudC5zaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICB0aGlzLmNzc1J1bGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwgcnVsZXMgZWxlbWVudHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldFJ1bGVzID0gZnVuY3Rpb24gZ2V0UnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5zaGVldC5jc3NSdWxlcztcbiAgfTtcblxuICByZXR1cm4gRG9tUmVuZGVyZXI7XG59KCk7XG5cbnZhciBpbnN0YW5jZUNvdW50ZXIgPSAwO1xuXG52YXIgSnNzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSnNzKG9wdGlvbnMpIHtcbiAgICB0aGlzLmlkID0gaW5zdGFuY2VDb3VudGVyKys7XG4gICAgdGhpcy52ZXJzaW9uID0gXCIxMC44LjBcIjtcbiAgICB0aGlzLnBsdWdpbnMgPSBuZXcgUGx1Z2luc1JlZ2lzdHJ5KCk7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgaWQ6IHtcbiAgICAgICAgbWluaWZ5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGNyZWF0ZUdlbmVyYXRlSWQ6IGNyZWF0ZUdlbmVyYXRlSWQsXG4gICAgICBSZW5kZXJlcjogaXNJbkJyb3dzZXIgPyBEb21SZW5kZXJlciA6IG51bGwsXG4gICAgICBwbHVnaW5zOiBbXVxuICAgIH07XG4gICAgdGhpcy5nZW5lcmF0ZUlkID0gY3JlYXRlR2VuZXJhdGVJZCh7XG4gICAgICBtaW5pZnk6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucGx1Z2lucy51c2UocGx1Z2luc1tpXSwge1xuICAgICAgICBxdWV1ZTogJ2ludGVybmFsJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXR1cChvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogUHJlcGFyZXMgdmFyaW91cyBvcHRpb25zLCBhcHBsaWVzIHBsdWdpbnMuXG4gICAqIFNob3VsZCBub3QgYmUgdXNlZCB0d2ljZSBvbiB0aGUgc2FtZSBpbnN0YW5jZSwgYmVjYXVzZSB0aGVyZSBpcyBubyBwbHVnaW5zXG4gICAqIGRlZHVwbGljYXRpb24gbG9naWMuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IEpzcy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldHVwID0gZnVuY3Rpb24gc2V0dXAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZCA9IG9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmlkID0gX2V4dGVuZHMoe30sIHRoaXMub3B0aW9ucy5pZCwgb3B0aW9ucy5pZCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZCB8fCBvcHRpb25zLmlkKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlSWQgPSB0aGlzLm9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZCh0aGlzLm9wdGlvbnMuaWQpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluc2VydGlvblBvaW50ICE9IG51bGwpIHRoaXMub3B0aW9ucy5pbnNlcnRpb25Qb2ludCA9IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQ7XG5cbiAgICBpZiAoJ1JlbmRlcmVyJyBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuUmVuZGVyZXIgPSBvcHRpb25zLlJlbmRlcmVyO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcblxuXG4gICAgaWYgKG9wdGlvbnMucGx1Z2lucykgdGhpcy51c2UuYXBwbHkodGhpcywgb3B0aW9ucy5wbHVnaW5zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgU3R5bGUgU2hlZXQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNyZWF0ZVN0eWxlU2hlZXQgPSBmdW5jdGlvbiBjcmVhdGVTdHlsZVNoZWV0KHN0eWxlcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgICBpbmRleCA9IF9vcHRpb25zLmluZGV4O1xuXG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGluZGV4ID0gc2hlZXRzLmluZGV4ID09PSAwID8gMCA6IHNoZWV0cy5pbmRleCArIDE7XG4gICAgfVxuXG4gICAgdmFyIHNoZWV0ID0gbmV3IFN0eWxlU2hlZXQoc3R5bGVzLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAganNzOiB0aGlzLFxuICAgICAgZ2VuZXJhdGVJZDogb3B0aW9ucy5nZW5lcmF0ZUlkIHx8IHRoaXMuZ2VuZXJhdGVJZCxcbiAgICAgIGluc2VydGlvblBvaW50OiB0aGlzLm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQsXG4gICAgICBSZW5kZXJlcjogdGhpcy5vcHRpb25zLlJlbmRlcmVyLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSkpO1xuICAgIHRoaXMucGx1Z2lucy5vblByb2Nlc3NTaGVldChzaGVldCk7XG4gICAgcmV0dXJuIHNoZWV0O1xuICB9XG4gIC8qKlxuICAgKiBEZXRhY2ggdGhlIFN0eWxlIFNoZWV0IGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcmVnaXN0cnkuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlbW92ZVN0eWxlU2hlZXQgPSBmdW5jdGlvbiByZW1vdmVTdHlsZVNoZWV0KHNoZWV0KSB7XG4gICAgc2hlZXQuZGV0YWNoKCk7XG4gICAgc2hlZXRzLnJlbW92ZShzaGVldCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJ1bGUgd2l0aG91dCBhIFN0eWxlIFNoZWV0LlxuICAgKiBbRGVwcmVjYXRlZF0gd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNyZWF0ZVJ1bGUgPSBmdW5jdGlvbiBjcmVhdGVSdWxlJDEobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoc3R5bGUgPT09IHZvaWQgMCkge1xuICAgICAgc3R5bGUgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgLy8gRW5hYmxlIHJ1bGUgd2l0aG91dCBuYW1lIGZvciBpbmxpbmUgc3R5bGVzLlxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJ1bGUodW5kZWZpbmVkLCBuYW1lLCBzdHlsZSk7XG4gICAgfVxuXG4gICAgdmFyIHJ1bGVPcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBqc3M6IHRoaXMsXG4gICAgICBSZW5kZXJlcjogdGhpcy5vcHRpb25zLlJlbmRlcmVyXG4gICAgfSk7XG5cbiAgICBpZiAoIXJ1bGVPcHRpb25zLmdlbmVyYXRlSWQpIHJ1bGVPcHRpb25zLmdlbmVyYXRlSWQgPSB0aGlzLmdlbmVyYXRlSWQ7XG4gICAgaWYgKCFydWxlT3B0aW9ucy5jbGFzc2VzKSBydWxlT3B0aW9ucy5jbGFzc2VzID0ge307XG4gICAgaWYgKCFydWxlT3B0aW9ucy5rZXlmcmFtZXMpIHJ1bGVPcHRpb25zLmtleWZyYW1lcyA9IHt9O1xuXG4gICAgdmFyIHJ1bGUgPSBjcmVhdGVSdWxlKG5hbWUsIHN0eWxlLCBydWxlT3B0aW9ucyk7XG5cbiAgICBpZiAocnVsZSkgdGhpcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHBsdWdpbi4gUGFzc2VkIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCB3aXRoIGEgcnVsZSBpbnN0YW5jZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXNlID0gZnVuY3Rpb24gdXNlKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGx1Z2lucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIF90aGlzLnBsdWdpbnMudXNlKHBsdWdpbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIEpzcztcbn0oKTtcblxudmFyIGNyZWF0ZUpzcyA9IGZ1bmN0aW9uIGNyZWF0ZUpzcyhvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgSnNzKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBTaGVldHNNYW5hZ2VyIGlzIGxpa2UgYSBXZWFrTWFwIHdoaWNoIGlzIGRlc2lnbmVkIHRvIGNvdW50IFN0eWxlU2hlZXRcbiAqIGluc3RhbmNlcyBhbmQgYXR0YWNoL2RldGFjaCBhdXRvbWF0aWNhbGx5LlxuICogVXNlZCBpbiByZWFjdC1qc3MuXG4gKi9cblxudmFyIFNoZWV0c01hbmFnZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaGVldHNNYW5hZ2VyKCkge1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnNoZWV0cyA9IG5ldyBXZWFrTWFwKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2hlZXRzTWFuYWdlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLnNoZWV0cy5nZXQoa2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkuc2hlZXQ7XG4gIH07XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChrZXksIHNoZWV0KSB7XG4gICAgaWYgKHRoaXMuc2hlZXRzLmhhcyhrZXkpKSByZXR1cm47XG4gICAgdGhpcy5sZW5ndGgrKztcbiAgICB0aGlzLnNoZWV0cy5zZXQoa2V5LCB7XG4gICAgICBzaGVldDogc2hlZXQsXG4gICAgICByZWZzOiAwXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLm1hbmFnZSA9IGZ1bmN0aW9uIG1hbmFnZShrZXkpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLnNoZWV0cy5nZXQoa2V5KTtcblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgaWYgKGVudHJ5LnJlZnMgPT09IDApIHtcbiAgICAgICAgZW50cnkuc2hlZXQuYXR0YWNoKCk7XG4gICAgICB9XG5cbiAgICAgIGVudHJ5LnJlZnMrKztcbiAgICAgIHJldHVybiBlbnRyeS5zaGVldDtcbiAgICB9XG5cbiAgICB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFNoZWV0c01hbmFnZXI6IGNhbid0IGZpbmQgc2hlZXQgdG8gbWFuYWdlXCIpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgX3Byb3RvLnVubWFuYWdlID0gZnVuY3Rpb24gdW5tYW5hZ2Uoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5zaGVldHMuZ2V0KGtleSk7XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGlmIChlbnRyeS5yZWZzID4gMCkge1xuICAgICAgICBlbnRyeS5yZWZzLS07XG4gICAgICAgIGlmIChlbnRyeS5yZWZzID09PSAwKSBlbnRyeS5zaGVldC5kZXRhY2goKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgXCJTaGVldHNNYW5hZ2VyOiBjYW4ndCBmaW5kIHNoZWV0IHRvIHVubWFuYWdlXCIpO1xuICAgIH1cbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU2hlZXRzTWFuYWdlciwgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTaGVldHNNYW5hZ2VyO1xufSgpO1xuXG4vKipcbiogRXhwb3J0IGEgY29uc3RhbnQgaW5kaWNhdGluZyBpZiB0aGlzIGJyb3dzZXIgaGFzIENTU1RPTSBzdXBwb3J0LlxuKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE4LzAzL2Nzc29tXG4qL1xudmFyIGhhc0NTU1RPTVN1cHBvcnQgPSB0eXBlb2YgQ1NTID09PSAnb2JqZWN0JyAmJiBDU1MgIT0gbnVsbCAmJiAnbnVtYmVyJyBpbiBDU1M7XG5cbi8qKlxuICogRXh0cmFjdHMgYSBzdHlsZXMgb2JqZWN0IHdpdGggb25seSBwcm9wcyB0aGF0IGNvbnRhaW4gZnVuY3Rpb24gdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXREeW5hbWljU3R5bGVzKHN0eWxlcykge1xuICB2YXIgdG8gPSBudWxsO1xuXG4gIGZvciAodmFyIGtleSBpbiBzdHlsZXMpIHtcbiAgICB2YXIgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoIXRvKSB0byA9IHt9O1xuICAgICAgdG9ba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YXIgZXh0cmFjdGVkID0gZ2V0RHluYW1pY1N0eWxlcyh2YWx1ZSk7XG5cbiAgICAgIGlmIChleHRyYWN0ZWQpIHtcbiAgICAgICAgaWYgKCF0bykgdG8gPSB7fTtcbiAgICAgICAgdG9ba2V5XSA9IGV4dHJhY3RlZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG87XG59XG5cbi8qKlxuICogQSBiZXR0ZXIgYWJzdHJhY3Rpb24gb3ZlciBDU1MuXG4gKlxuICogQGNvcHlyaWdodCBPbGVnIElzb25lbiAoU2xvYm9kc2tvaSkgLyBJc29uZW4gMjAxNC1wcmVzZW50XG4gKiBAd2Vic2l0ZSBodHRwczovL2dpdGh1Yi5jb20vY3NzaW5qcy9qc3NcbiAqIEBsaWNlbnNlIE1JVFxuICovXG52YXIgaW5kZXggPSBjcmVhdGVKc3MoKTtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG5leHBvcnQgeyBSdWxlTGlzdCwgU2hlZXRzTWFuYWdlciwgU2hlZXRzUmVnaXN0cnksIGNyZWF0ZUpzcyBhcyBjcmVhdGUsIGNyZWF0ZUdlbmVyYXRlSWQsIGNyZWF0ZVJ1bGUsIGdldER5bmFtaWNTdHlsZXMsIGhhc0NTU1RPTVN1cHBvcnQsIHNoZWV0cywgdG9Dc3NWYWx1ZSB9O1xuIiwiaW1wb3J0IHdhcm5pbmcgZnJvbSAndGlueS13YXJuaW5nJztcbmltcG9ydCB7IGNyZWF0ZVJ1bGUgfSBmcm9tICdqc3MnO1xuXG52YXIgbm93ID0gRGF0ZS5ub3coKTtcbnZhciBmblZhbHVlc05zID0gXCJmblZhbHVlc1wiICsgbm93O1xudmFyIGZuUnVsZU5zID0gXCJmblN0eWxlXCIgKyArK25vdztcblxudmFyIGZ1bmN0aW9uUGx1Z2luID0gZnVuY3Rpb24gZnVuY3Rpb25QbHVnaW4oKSB7XG4gIHJldHVybiB7XG4gICAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBkZWNsICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBydWxlID0gY3JlYXRlUnVsZShuYW1lLCB7fSwgb3B0aW9ucyk7XG4gICAgICBydWxlW2ZuUnVsZU5zXSA9IGRlY2w7XG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9LFxuICAgIG9uUHJvY2Vzc1N0eWxlOiBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBleHRyYWN0IGZ1bmN0aW9uIHZhbHVlcyBmcm9tIHRoZSBkZWNsYXJhdGlvbiwgc28gdGhhdCB3ZSBjYW4ga2VlcCBjb3JlIHVuYXdhcmUgb2YgdGhlbS5cbiAgICAgIC8vIFdlIG5lZWQgdG8gZG8gdGhhdCBvbmx5IG9uY2UuXG4gICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGV4dHJhY3QgZnVuY3Rpb25zIG9uIGVhY2ggc3R5bGUgdXBkYXRlLCBzaW5jZSB0aGlzIGNhbiBoYXBwZW4gb25seSBvbmNlLlxuICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBmdW5jdGlvbiB2YWx1ZXMgaW5zaWRlIG9mIGZ1bmN0aW9uIHJ1bGVzLlxuICAgICAgaWYgKGZuVmFsdWVzTnMgaW4gcnVsZSB8fCBmblJ1bGVOcyBpbiBydWxlKSByZXR1cm4gc3R5bGU7XG4gICAgICB2YXIgZm5WYWx1ZXMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykgY29udGludWU7XG4gICAgICAgIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgICAgICAgZm5WYWx1ZXNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcnVsZVtmblZhbHVlc05zXSA9IGZuVmFsdWVzO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG4gICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKGRhdGEsIHJ1bGUsIHNoZWV0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgc3R5bGVSdWxlID0gcnVsZTtcbiAgICAgIHZhciBmblJ1bGUgPSBzdHlsZVJ1bGVbZm5SdWxlTnNdOyAvLyBJZiB3ZSBoYXZlIGEgc3R5bGUgZnVuY3Rpb24sIHRoZSBlbnRpcmUgcnVsZSBpcyBkeW5hbWljIGFuZCBzdHlsZSBvYmplY3RcbiAgICAgIC8vIHdpbGwgYmUgcmV0dXJuZWQgZnJvbSB0aGF0IGZ1bmN0aW9uLlxuXG4gICAgICBpZiAoZm5SdWxlKSB7XG4gICAgICAgIC8vIEVtcHR5IG9iamVjdCB3aWxsIHJlbW92ZSBhbGwgY3VycmVudGx5IGRlZmluZWQgcHJvcHNcbiAgICAgICAgLy8gaW4gY2FzZSBmdW5jdGlvbiBydWxlIHJldHVybnMgYSBmYWxzeSB2YWx1ZS5cbiAgICAgICAgc3R5bGVSdWxlLnN0eWxlID0gZm5SdWxlKGRhdGEpIHx8IHt9O1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGVSdWxlLnN0eWxlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlUnVsZS5zdHlsZVtwcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAnW0pTU10gRnVuY3Rpb24gdmFsdWVzIGluc2lkZSBmdW5jdGlvbiBydWxlcyBhcmUgbm90IHN1cHBvcnRlZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBmblZhbHVlcyA9IHN0eWxlUnVsZVtmblZhbHVlc05zXTsgLy8gSWYgd2UgaGF2ZSBhIGZuIHZhbHVlcyBtYXAsIGl0IGlzIGEgcnVsZSB3aXRoIGZ1bmN0aW9uIHZhbHVlcy5cblxuICAgICAgaWYgKGZuVmFsdWVzKSB7XG4gICAgICAgIGZvciAodmFyIF9wcm9wIGluIGZuVmFsdWVzKSB7XG4gICAgICAgICAgc3R5bGVSdWxlLnByb3AoX3Byb3AsIGZuVmFsdWVzW19wcm9wXShkYXRhKSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvblBsdWdpbjtcbiIsImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCB7IFJ1bGVMaXN0IH0gZnJvbSAnanNzJztcblxudmFyIGF0ID0gJ0BnbG9iYWwnO1xudmFyIGF0UHJlZml4ID0gJ0BnbG9iYWwgJztcblxudmFyIEdsb2JhbENvbnRhaW5lclJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHbG9iYWxDb250YWluZXJSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2dsb2JhbCc7XG4gICAgdGhpcy5hdCA9IGF0O1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcblxuICAgIGZvciAodmFyIHNlbGVjdG9yIGluIHN0eWxlcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQoc2VsZWN0b3IsIHN0eWxlc1tzZWxlY3Rvcl0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBHbG9iYWxDb250YWluZXJSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0UnVsZSA9IGZ1bmN0aW9uIGdldFJ1bGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZWdpc3RlciBydWxlLCBydW4gcGx1Z2lucy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZSA9IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlLCBvcHRpb25zKTtcbiAgICBpZiAocnVsZSkgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgcmV0dXJuIEdsb2JhbENvbnRhaW5lclJ1bGU7XG59KCk7XG5cbnZhciBHbG9iYWxQcmVmaXhlZFJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHbG9iYWxQcmVmaXhlZFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdnbG9iYWwnO1xuICAgIHRoaXMuYXQgPSBhdDtcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB2YXIgc2VsZWN0b3IgPSBrZXkuc3Vic3RyKGF0UHJlZml4Lmxlbmd0aCk7XG4gICAgdGhpcy5ydWxlID0gb3B0aW9ucy5qc3MuY3JlYXRlUnVsZShzZWxlY3Rvciwgc3R5bGUsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IEdsb2JhbFByZWZpeGVkUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlID8gdGhpcy5ydWxlLnRvU3RyaW5nKG9wdGlvbnMpIDogJyc7XG4gIH07XG5cbiAgcmV0dXJuIEdsb2JhbFByZWZpeGVkUnVsZTtcbn0oKTtcblxudmFyIHNlcGFyYXRvclJlZ0V4cCA9IC9cXHMqLFxccyovZztcblxuZnVuY3Rpb24gYWRkU2NvcGUoc2VsZWN0b3IsIHNjb3BlKSB7XG4gIHZhciBwYXJ0cyA9IHNlbGVjdG9yLnNwbGl0KHNlcGFyYXRvclJlZ0V4cCk7XG4gIHZhciBzY29wZWQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgc2NvcGVkICs9IHNjb3BlICsgXCIgXCIgKyBwYXJ0c1tpXS50cmltKCk7XG4gICAgaWYgKHBhcnRzW2kgKyAxXSkgc2NvcGVkICs9ICcsICc7XG4gIH1cblxuICByZXR1cm4gc2NvcGVkO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVOZXN0ZWRHbG9iYWxDb250YWluZXJSdWxlKHJ1bGUsIHNoZWV0KSB7XG4gIHZhciBvcHRpb25zID0gcnVsZS5vcHRpb25zLFxuICAgICAgc3R5bGUgPSBydWxlLnN0eWxlO1xuICB2YXIgcnVsZXMgPSBzdHlsZSA/IHN0eWxlW2F0XSA6IG51bGw7XG4gIGlmICghcnVsZXMpIHJldHVybjtcblxuICBmb3IgKHZhciBuYW1lIGluIHJ1bGVzKSB7XG4gICAgc2hlZXQuYWRkUnVsZShuYW1lLCBydWxlc1tuYW1lXSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHNlbGVjdG9yOiBhZGRTY29wZShuYW1lLCBydWxlLnNlbGVjdG9yKVxuICAgIH0pKTtcbiAgfVxuXG4gIGRlbGV0ZSBzdHlsZVthdF07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVByZWZpeGVkR2xvYmFsUnVsZShydWxlLCBzaGVldCkge1xuICB2YXIgb3B0aW9ucyA9IHJ1bGUub3B0aW9ucyxcbiAgICAgIHN0eWxlID0gcnVsZS5zdHlsZTtcblxuICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgaWYgKHByb3BbMF0gIT09ICdAJyB8fCBwcm9wLnN1YnN0cigwLCBhdC5sZW5ndGgpICE9PSBhdCkgY29udGludWU7XG4gICAgdmFyIHNlbGVjdG9yID0gYWRkU2NvcGUocHJvcC5zdWJzdHIoYXQubGVuZ3RoKSwgcnVsZS5zZWxlY3Rvcik7XG4gICAgc2hlZXQuYWRkUnVsZShzZWxlY3Rvciwgc3R5bGVbcHJvcF0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBzZWxlY3Rvcjogc2VsZWN0b3JcbiAgICB9KSk7XG4gICAgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICB9XG59XG4vKipcbiAqIENvbnZlcnQgbmVzdGVkIHJ1bGVzIHRvIHNlcGFyYXRlLCByZW1vdmUgdGhlbSBmcm9tIG9yaWdpbmFsIHN0eWxlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGpzc0dsb2JhbCgpIHtcbiAgZnVuY3Rpb24gb25DcmVhdGVSdWxlKG5hbWUsIHN0eWxlcywgb3B0aW9ucykge1xuICAgIGlmICghbmFtZSkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAobmFtZSA9PT0gYXQpIHtcbiAgICAgIHJldHVybiBuZXcgR2xvYmFsQ29udGFpbmVyUnVsZShuYW1lLCBzdHlsZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChuYW1lWzBdID09PSAnQCcgJiYgbmFtZS5zdWJzdHIoMCwgYXRQcmVmaXgubGVuZ3RoKSA9PT0gYXRQcmVmaXgpIHtcbiAgICAgIHJldHVybiBuZXcgR2xvYmFsUHJlZml4ZWRSdWxlKG5hbWUsIHN0eWxlcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC50eXBlID09PSAnZ2xvYmFsJyB8fCBwYXJlbnQub3B0aW9ucy5wYXJlbnQgJiYgcGFyZW50Lm9wdGlvbnMucGFyZW50LnR5cGUgPT09ICdnbG9iYWwnKSB7XG4gICAgICAgIG9wdGlvbnMuc2NvcGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2NvcGVkID09PSBmYWxzZSkge1xuICAgICAgb3B0aW9ucy5zZWxlY3RvciA9IG5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBvblByb2Nlc3NSdWxlKHJ1bGUsIHNoZWV0KSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJyB8fCAhc2hlZXQpIHJldHVybjtcbiAgICBoYW5kbGVOZXN0ZWRHbG9iYWxDb250YWluZXJSdWxlKHJ1bGUsIHNoZWV0KTtcbiAgICBoYW5kbGVQcmVmaXhlZEdsb2JhbFJ1bGUocnVsZSwgc2hlZXQpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvbkNyZWF0ZVJ1bGU6IG9uQ3JlYXRlUnVsZSxcbiAgICBvblByb2Nlc3NSdWxlOiBvblByb2Nlc3NSdWxlXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGpzc0dsb2JhbDtcbiIsImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3Rpbnktd2FybmluZyc7XG5cbnZhciBzZXBhcmF0b3JSZWdFeHAgPSAvXFxzKixcXHMqL2c7XG52YXIgcGFyZW50UmVnRXhwID0gLyYvZztcbnZhciByZWZSZWdFeHAgPSAvXFwkKFtcXHctXSspL2c7XG4vKipcbiAqIENvbnZlcnQgbmVzdGVkIHJ1bGVzIHRvIHNlcGFyYXRlLCByZW1vdmUgdGhlbSBmcm9tIG9yaWdpbmFsIHN0eWxlcy5cbiAqL1xuXG5mdW5jdGlvbiBqc3NOZXN0ZWQoKSB7XG4gIC8vIEdldCBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yICRyZWYgcmVwbGFjZW1lbnQuXG4gIGZ1bmN0aW9uIGdldFJlcGxhY2VSZWYoY29udGFpbmVyLCBzaGVldCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWF0Y2gsIGtleSkge1xuICAgICAgdmFyIHJ1bGUgPSBjb250YWluZXIuZ2V0UnVsZShrZXkpIHx8IHNoZWV0ICYmIHNoZWV0LmdldFJ1bGUoa2V5KTtcblxuICAgICAgaWYgKHJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIHJ1bGUuc2VsZWN0b3I7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gQ291bGQgbm90IGZpbmQgdGhlIHJlZmVyZW5jZWQgcnVsZSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaW4gXFxcIlwiICsgKGNvbnRhaW5lci5vcHRpb25zLm1ldGEgfHwgY29udGFpbmVyLnRvU3RyaW5nKCkpICsgXCJcXFwiLlwiKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VQYXJlbnRSZWZzKG5lc3RlZFByb3AsIHBhcmVudFByb3ApIHtcbiAgICB2YXIgcGFyZW50U2VsZWN0b3JzID0gcGFyZW50UHJvcC5zcGxpdChzZXBhcmF0b3JSZWdFeHApO1xuICAgIHZhciBuZXN0ZWRTZWxlY3RvcnMgPSBuZXN0ZWRQcm9wLnNwbGl0KHNlcGFyYXRvclJlZ0V4cCk7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRTZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRTZWxlY3RvcnNbaV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmVzdGVkU2VsZWN0b3JzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBuZXN0ZWQgPSBuZXN0ZWRTZWxlY3RvcnNbal07XG4gICAgICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSAnLCAnOyAvLyBSZXBsYWNlIGFsbCAmIGJ5IHRoZSBwYXJlbnQgb3IgcHJlZml4ICYgd2l0aCB0aGUgcGFyZW50LlxuXG4gICAgICAgIHJlc3VsdCArPSBuZXN0ZWQuaW5kZXhPZignJicpICE9PSAtMSA/IG5lc3RlZC5yZXBsYWNlKHBhcmVudFJlZ0V4cCwgcGFyZW50KSA6IHBhcmVudCArIFwiIFwiICsgbmVzdGVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRPcHRpb25zKHJ1bGUsIGNvbnRhaW5lciwgcHJldk9wdGlvbnMpIHtcbiAgICAvLyBPcHRpb25zIGhhcyBiZWVuIGFscmVhZHkgY3JlYXRlZCwgbm93IHdlIG9ubHkgaW5jcmVhc2UgaW5kZXguXG4gICAgaWYgKHByZXZPcHRpb25zKSByZXR1cm4gX2V4dGVuZHMoe30sIHByZXZPcHRpb25zLCB7XG4gICAgICBpbmRleDogcHJldk9wdGlvbnMuaW5kZXggKyAxXG4gICAgfSk7XG4gICAgdmFyIG5lc3RpbmdMZXZlbCA9IHJ1bGUub3B0aW9ucy5uZXN0aW5nTGV2ZWw7XG4gICAgbmVzdGluZ0xldmVsID0gbmVzdGluZ0xldmVsID09PSB1bmRlZmluZWQgPyAxIDogbmVzdGluZ0xldmVsICsgMTtcblxuICAgIHZhciBvcHRpb25zID0gX2V4dGVuZHMoe30sIHJ1bGUub3B0aW9ucywge1xuICAgICAgbmVzdGluZ0xldmVsOiBuZXN0aW5nTGV2ZWwsXG4gICAgICBpbmRleDogY29udGFpbmVyLmluZGV4T2YocnVsZSkgKyAxIC8vIFdlIGRvbid0IG5lZWQgdGhlIHBhcmVudCBuYW1lIHRvIGJlIHNldCBvcHRpb25zIGZvciBjaGxpZC5cblxuICAgIH0pO1xuXG4gICAgZGVsZXRlIG9wdGlvbnMubmFtZTtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlLCBzaGVldCkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybiBzdHlsZTtcbiAgICB2YXIgc3R5bGVSdWxlID0gcnVsZTtcbiAgICB2YXIgY29udGFpbmVyID0gc3R5bGVSdWxlLm9wdGlvbnMucGFyZW50O1xuICAgIHZhciBvcHRpb25zO1xuICAgIHZhciByZXBsYWNlUmVmO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgdmFyIGlzTmVzdGVkID0gcHJvcC5pbmRleE9mKCcmJykgIT09IC0xO1xuICAgICAgdmFyIGlzTmVzdGVkQ29uZGl0aW9uYWwgPSBwcm9wWzBdID09PSAnQCc7XG4gICAgICBpZiAoIWlzTmVzdGVkICYmICFpc05lc3RlZENvbmRpdGlvbmFsKSBjb250aW51ZTtcbiAgICAgIG9wdGlvbnMgPSBnZXRPcHRpb25zKHN0eWxlUnVsZSwgY29udGFpbmVyLCBvcHRpb25zKTtcblxuICAgICAgaWYgKGlzTmVzdGVkKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHJlcGxhY2VQYXJlbnRSZWZzKHByb3AsIHN0eWxlUnVsZS5zZWxlY3Rvcik7IC8vIExhemlseSBjcmVhdGUgdGhlIHJlZiByZXBsYWNlciBmdW5jdGlvbiBqdXN0IG9uY2UgZm9yXG4gICAgICAgIC8vIGFsbCBuZXN0ZWQgcnVsZXMgd2l0aGluIHRoZSBzaGVldC5cblxuICAgICAgICBpZiAoIXJlcGxhY2VSZWYpIHJlcGxhY2VSZWYgPSBnZXRSZXBsYWNlUmVmKGNvbnRhaW5lciwgc2hlZXQpOyAvLyBSZXBsYWNlIGFsbCAkcmVmcy5cblxuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UocmVmUmVnRXhwLCByZXBsYWNlUmVmKTtcbiAgICAgICAgY29udGFpbmVyLmFkZFJ1bGUoc2VsZWN0b3IsIHN0eWxlW3Byb3BdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvclxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2UgaWYgKGlzTmVzdGVkQ29uZGl0aW9uYWwpIHtcbiAgICAgICAgLy8gUGxhY2UgY29uZGl0aW9uYWwgcmlnaHQgYWZ0ZXIgdGhlIHBhcmVudCBydWxlIHRvIGVuc3VyZSByaWdodCBvcmRlcmluZy5cbiAgICAgICAgY29udGFpbmVyLmFkZFJ1bGUocHJvcCwge30sIG9wdGlvbnMpLmFkZFJ1bGUoc3R5bGVSdWxlLmtleSwgc3R5bGVbcHJvcF0sIHtcbiAgICAgICAgICBzZWxlY3Rvcjogc3R5bGVSdWxlLnNlbGVjdG9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGVcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQganNzTmVzdGVkO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdmFyLCBwcmVmZXItdGVtcGxhdGUgKi9cbnZhciB1cHBlcmNhc2VQYXR0ZXJuID0gL1tBLVpdL2dcbnZhciBtc1BhdHRlcm4gPSAvXm1zLS9cbnZhciBjYWNoZSA9IHt9XG5cbmZ1bmN0aW9uIHRvSHlwaGVuTG93ZXIobWF0Y2gpIHtcbiAgcmV0dXJuICctJyArIG1hdGNoLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpIHtcbiAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIGNhY2hlW25hbWVdXG4gIH1cblxuICB2YXIgaE5hbWUgPSBuYW1lLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwgdG9IeXBoZW5Mb3dlcilcbiAgcmV0dXJuIChjYWNoZVtuYW1lXSA9IG1zUGF0dGVybi50ZXN0KGhOYW1lKSA/ICctJyArIGhOYW1lIDogaE5hbWUpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGh5cGhlbmF0ZVN0eWxlTmFtZVxuIiwiaW1wb3J0IGh5cGhlbmF0ZSBmcm9tICdoeXBoZW5hdGUtc3R5bGUtbmFtZSc7XG5cbi8qKlxuICogQ29udmVydCBjYW1lbCBjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBkYXNoIHNlcGFyYXRlZC5cbiAqL1xuXG5mdW5jdGlvbiBjb252ZXJ0Q2FzZShzdHlsZSkge1xuICB2YXIgY29udmVydGVkID0ge307XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgIHZhciBrZXkgPSBwcm9wLmluZGV4T2YoJy0tJykgPT09IDAgPyBwcm9wIDogaHlwaGVuYXRlKHByb3ApO1xuICAgIGNvbnZlcnRlZFtrZXldID0gc3R5bGVbcHJvcF07XG4gIH1cblxuICBpZiAoc3R5bGUuZmFsbGJhY2tzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUuZmFsbGJhY2tzKSkgY29udmVydGVkLmZhbGxiYWNrcyA9IHN0eWxlLmZhbGxiYWNrcy5tYXAoY29udmVydENhc2UpO2Vsc2UgY29udmVydGVkLmZhbGxiYWNrcyA9IGNvbnZlcnRDYXNlKHN0eWxlLmZhbGxiYWNrcyk7XG4gIH1cblxuICByZXR1cm4gY29udmVydGVkO1xufVxuLyoqXG4gKiBBbGxvdyBjYW1lbCBjYXNlZCBwcm9wZXJ0eSBuYW1lcyBieSBjb252ZXJ0aW5nIHRoZW0gYmFjayB0byBkYXNoZXJpemVkLlxuICovXG5cblxuZnVuY3Rpb24gY2FtZWxDYXNlKCkge1xuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlKSkge1xuICAgICAgLy8gSGFuZGxlIHJ1bGVzIGxpa2UgQGZvbnQtZmFjZSwgd2hpY2ggY2FuIGhhdmUgbXVsdGlwbGUgc3R5bGVzIGluIGFuIGFycmF5XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3R5bGUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0eWxlW2luZGV4XSA9IGNvbnZlcnRDYXNlKHN0eWxlW2luZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udmVydENhc2Uoc3R5bGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCwgcnVsZSkge1xuICAgIGlmIChwcm9wLmluZGV4T2YoJy0tJykgPT09IDApIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgaHlwaGVuYXRlZFByb3AgPSBoeXBoZW5hdGUocHJvcCk7IC8vIFRoZXJlIHdhcyBubyBjYW1lbCBjYXNlIGluIHBsYWNlXG5cbiAgICBpZiAocHJvcCA9PT0gaHlwaGVuYXRlZFByb3ApIHJldHVybiB2YWx1ZTtcbiAgICBydWxlLnByb3AoaHlwaGVuYXRlZFByb3AsIHZhbHVlKTsgLy8gQ29yZSB3aWxsIGlnbm9yZSB0aGF0IHByb3BlcnR5IHZhbHVlIHdlIHNldCB0aGUgcHJvcGVyIG9uZSBhYm92ZS5cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUsXG4gICAgb25DaGFuZ2VWYWx1ZTogb25DaGFuZ2VWYWx1ZVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjYW1lbENhc2U7XG4iLCJpbXBvcnQgeyBoYXNDU1NUT01TdXBwb3J0IH0gZnJvbSAnanNzJztcblxudmFyIHB4ID0gaGFzQ1NTVE9NU3VwcG9ydCAmJiBDU1MgPyBDU1MucHggOiAncHgnO1xudmFyIG1zID0gaGFzQ1NTVE9NU3VwcG9ydCAmJiBDU1MgPyBDU1MubXMgOiAnbXMnO1xudmFyIHBlcmNlbnQgPSBoYXNDU1NUT01TdXBwb3J0ICYmIENTUyA/IENTUy5wZXJjZW50IDogJyUnO1xuLyoqXG4gKiBHZW5lcmF0ZWQganNzLXBsdWdpbi1kZWZhdWx0LXVuaXQgQ1NTIHByb3BlcnR5IHVuaXRzXG4gKi9cblxudmFyIGRlZmF1bHRVbml0cyA9IHtcbiAgLy8gQW5pbWF0aW9uIHByb3BlcnRpZXNcbiAgJ2FuaW1hdGlvbi1kZWxheSc6IG1zLFxuICAnYW5pbWF0aW9uLWR1cmF0aW9uJzogbXMsXG4gIC8vIEJhY2tncm91bmQgcHJvcGVydGllc1xuICAnYmFja2dyb3VuZC1wb3NpdGlvbic6IHB4LFxuICAnYmFja2dyb3VuZC1wb3NpdGlvbi14JzogcHgsXG4gICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknOiBweCxcbiAgJ2JhY2tncm91bmQtc2l6ZSc6IHB4LFxuICAvLyBCb3JkZXIgUHJvcGVydGllc1xuICBib3JkZXI6IHB4LFxuICAnYm9yZGVyLWJvdHRvbSc6IHB4LFxuICAnYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci1ib3R0b20td2lkdGgnOiBweCxcbiAgJ2JvcmRlci1sZWZ0JzogcHgsXG4gICdib3JkZXItbGVmdC13aWR0aCc6IHB4LFxuICAnYm9yZGVyLXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLXJpZ2h0JzogcHgsXG4gICdib3JkZXItcmlnaHQtd2lkdGgnOiBweCxcbiAgJ2JvcmRlci10b3AnOiBweCxcbiAgJ2JvcmRlci10b3AtbGVmdC1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci10b3AtcmlnaHQtcmFkaXVzJzogcHgsXG4gICdib3JkZXItdG9wLXdpZHRoJzogcHgsXG4gICdib3JkZXItd2lkdGgnOiBweCxcbiAgJ2JvcmRlci1ibG9jayc6IHB4LFxuICAnYm9yZGVyLWJsb2NrLWVuZCc6IHB4LFxuICAnYm9yZGVyLWJsb2NrLWVuZC13aWR0aCc6IHB4LFxuICAnYm9yZGVyLWJsb2NrLXN0YXJ0JzogcHgsXG4gICdib3JkZXItYmxvY2stc3RhcnQtd2lkdGgnOiBweCxcbiAgJ2JvcmRlci1ibG9jay13aWR0aCc6IHB4LFxuICAnYm9yZGVyLWlubGluZSc6IHB4LFxuICAnYm9yZGVyLWlubGluZS1lbmQnOiBweCxcbiAgJ2JvcmRlci1pbmxpbmUtZW5kLXdpZHRoJzogcHgsXG4gICdib3JkZXItaW5saW5lLXN0YXJ0JzogcHgsXG4gICdib3JkZXItaW5saW5lLXN0YXJ0LXdpZHRoJzogcHgsXG4gICdib3JkZXItaW5saW5lLXdpZHRoJzogcHgsXG4gICdib3JkZXItc3RhcnQtc3RhcnQtcmFkaXVzJzogcHgsXG4gICdib3JkZXItc3RhcnQtZW5kLXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLWVuZC1zdGFydC1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci1lbmQtZW5kLXJhZGl1cyc6IHB4LFxuICAvLyBNYXJnaW4gcHJvcGVydGllc1xuICBtYXJnaW46IHB4LFxuICAnbWFyZ2luLWJvdHRvbSc6IHB4LFxuICAnbWFyZ2luLWxlZnQnOiBweCxcbiAgJ21hcmdpbi1yaWdodCc6IHB4LFxuICAnbWFyZ2luLXRvcCc6IHB4LFxuICAnbWFyZ2luLWJsb2NrJzogcHgsXG4gICdtYXJnaW4tYmxvY2stZW5kJzogcHgsXG4gICdtYXJnaW4tYmxvY2stc3RhcnQnOiBweCxcbiAgJ21hcmdpbi1pbmxpbmUnOiBweCxcbiAgJ21hcmdpbi1pbmxpbmUtZW5kJzogcHgsXG4gICdtYXJnaW4taW5saW5lLXN0YXJ0JzogcHgsXG4gIC8vIFBhZGRpbmcgcHJvcGVydGllc1xuICBwYWRkaW5nOiBweCxcbiAgJ3BhZGRpbmctYm90dG9tJzogcHgsXG4gICdwYWRkaW5nLWxlZnQnOiBweCxcbiAgJ3BhZGRpbmctcmlnaHQnOiBweCxcbiAgJ3BhZGRpbmctdG9wJzogcHgsXG4gICdwYWRkaW5nLWJsb2NrJzogcHgsXG4gICdwYWRkaW5nLWJsb2NrLWVuZCc6IHB4LFxuICAncGFkZGluZy1ibG9jay1zdGFydCc6IHB4LFxuICAncGFkZGluZy1pbmxpbmUnOiBweCxcbiAgJ3BhZGRpbmctaW5saW5lLWVuZCc6IHB4LFxuICAncGFkZGluZy1pbmxpbmUtc3RhcnQnOiBweCxcbiAgLy8gTWFzayBwcm9wZXJ0aWVzXG4gICdtYXNrLXBvc2l0aW9uLXgnOiBweCxcbiAgJ21hc2stcG9zaXRpb24teSc6IHB4LFxuICAnbWFzay1zaXplJzogcHgsXG4gIC8vIFdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllc1xuICBoZWlnaHQ6IHB4LFxuICB3aWR0aDogcHgsXG4gICdtaW4taGVpZ2h0JzogcHgsXG4gICdtYXgtaGVpZ2h0JzogcHgsXG4gICdtaW4td2lkdGgnOiBweCxcbiAgJ21heC13aWR0aCc6IHB4LFxuICAvLyBQb3NpdGlvbiBwcm9wZXJ0aWVzXG4gIGJvdHRvbTogcHgsXG4gIGxlZnQ6IHB4LFxuICB0b3A6IHB4LFxuICByaWdodDogcHgsXG4gIGluc2V0OiBweCxcbiAgJ2luc2V0LWJsb2NrJzogcHgsXG4gICdpbnNldC1ibG9jay1lbmQnOiBweCxcbiAgJ2luc2V0LWJsb2NrLXN0YXJ0JzogcHgsXG4gICdpbnNldC1pbmxpbmUnOiBweCxcbiAgJ2luc2V0LWlubGluZS1lbmQnOiBweCxcbiAgJ2luc2V0LWlubGluZS1zdGFydCc6IHB4LFxuICAvLyBTaGFkb3cgcHJvcGVydGllc1xuICAnYm94LXNoYWRvdyc6IHB4LFxuICAndGV4dC1zaGFkb3cnOiBweCxcbiAgLy8gQ29sdW1uIHByb3BlcnRpZXNcbiAgJ2NvbHVtbi1nYXAnOiBweCxcbiAgJ2NvbHVtbi1ydWxlJzogcHgsXG4gICdjb2x1bW4tcnVsZS13aWR0aCc6IHB4LFxuICAnY29sdW1uLXdpZHRoJzogcHgsXG4gIC8vIEZvbnQgYW5kIHRleHQgcHJvcGVydGllc1xuICAnZm9udC1zaXplJzogcHgsXG4gICdmb250LXNpemUtZGVsdGEnOiBweCxcbiAgJ2xldHRlci1zcGFjaW5nJzogcHgsXG4gICd0ZXh0LWRlY29yYXRpb24tdGhpY2tuZXNzJzogcHgsXG4gICd0ZXh0LWluZGVudCc6IHB4LFxuICAndGV4dC1zdHJva2UnOiBweCxcbiAgJ3RleHQtc3Ryb2tlLXdpZHRoJzogcHgsXG4gICd3b3JkLXNwYWNpbmcnOiBweCxcbiAgLy8gTW90aW9uIHByb3BlcnRpZXNcbiAgbW90aW9uOiBweCxcbiAgJ21vdGlvbi1vZmZzZXQnOiBweCxcbiAgLy8gT3V0bGluZSBwcm9wZXJ0aWVzXG4gIG91dGxpbmU6IHB4LFxuICAnb3V0bGluZS1vZmZzZXQnOiBweCxcbiAgJ291dGxpbmUtd2lkdGgnOiBweCxcbiAgLy8gUGVyc3BlY3RpdmUgcHJvcGVydGllc1xuICBwZXJzcGVjdGl2ZTogcHgsXG4gICdwZXJzcGVjdGl2ZS1vcmlnaW4teCc6IHBlcmNlbnQsXG4gICdwZXJzcGVjdGl2ZS1vcmlnaW4teSc6IHBlcmNlbnQsXG4gIC8vIFRyYW5zZm9ybSBwcm9wZXJ0aWVzXG4gICd0cmFuc2Zvcm0tb3JpZ2luJzogcGVyY2VudCxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4teCc6IHBlcmNlbnQsXG4gICd0cmFuc2Zvcm0tb3JpZ2luLXknOiBwZXJjZW50LFxuICAndHJhbnNmb3JtLW9yaWdpbi16JzogcGVyY2VudCxcbiAgLy8gVHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gICd0cmFuc2l0aW9uLWRlbGF5JzogbXMsXG4gICd0cmFuc2l0aW9uLWR1cmF0aW9uJzogbXMsXG4gIC8vIEFsaWdubWVudCBwcm9wZXJ0aWVzXG4gICd2ZXJ0aWNhbC1hbGlnbic6IHB4LFxuICAnZmxleC1iYXNpcyc6IHB4LFxuICAvLyBTb21lIHJhbmRvbSBwcm9wZXJ0aWVzXG4gICdzaGFwZS1tYXJnaW4nOiBweCxcbiAgc2l6ZTogcHgsXG4gIGdhcDogcHgsXG4gIC8vIEdyaWQgcHJvcGVydGllc1xuICBncmlkOiBweCxcbiAgJ2dyaWQtZ2FwJzogcHgsXG4gICdyb3ctZ2FwJzogcHgsXG4gICdncmlkLXJvdy1nYXAnOiBweCxcbiAgJ2dyaWQtY29sdW1uLWdhcCc6IHB4LFxuICAnZ3JpZC10ZW1wbGF0ZS1yb3dzJzogcHgsXG4gICdncmlkLXRlbXBsYXRlLWNvbHVtbnMnOiBweCxcbiAgJ2dyaWQtYXV0by1yb3dzJzogcHgsXG4gICdncmlkLWF1dG8tY29sdW1ucyc6IHB4LFxuICAvLyBOb3QgZXhpc3RpbmcgcHJvcGVydGllcy5cbiAgLy8gVXNlZCB0byBhdm9pZCBpc3N1ZXMgd2l0aCBqc3MtcGx1Z2luLWV4cGFuZCBpbnRlZ3JhdGlvbi5cbiAgJ2JveC1zaGFkb3cteCc6IHB4LFxuICAnYm94LXNoYWRvdy15JzogcHgsXG4gICdib3gtc2hhZG93LWJsdXInOiBweCxcbiAgJ2JveC1zaGFkb3ctc3ByZWFkJzogcHgsXG4gICdmb250LWxpbmUtaGVpZ2h0JzogcHgsXG4gICd0ZXh0LXNoYWRvdy14JzogcHgsXG4gICd0ZXh0LXNoYWRvdy15JzogcHgsXG4gICd0ZXh0LXNoYWRvdy1ibHVyJzogcHhcbn07XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBvYmplY3QgYW5kIGFkZHMgYSBjYW1lbCBjYXNlZCBwcm9wZXJ0eSB2ZXJzaW9uLlxuICovXG5cbmZ1bmN0aW9uIGFkZENhbWVsQ2FzZWRWZXJzaW9uKG9iaikge1xuICB2YXIgcmVnRXhwID0gLygtW2Etel0pL2c7XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHN0cikge1xuICAgIHJldHVybiBzdHJbMV0udG9VcHBlckNhc2UoKTtcbiAgfTtcblxuICB2YXIgbmV3T2JqID0ge307XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgbmV3T2JqW2tleS5yZXBsYWNlKHJlZ0V4cCwgcmVwbGFjZSldID0gb2JqW2tleV07XG4gIH1cblxuICByZXR1cm4gbmV3T2JqO1xufVxuXG52YXIgdW5pdHMgPSBhZGRDYW1lbENhc2VkVmVyc2lvbihkZWZhdWx0VW5pdHMpO1xuLyoqXG4gKiBSZWN1cnNpdmUgZGVlcCBzdHlsZSBwYXNzaW5nIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaXRlcmF0ZShwcm9wLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlW2ldID0gaXRlcmF0ZShwcm9wLCB2YWx1ZVtpXSwgb3B0aW9ucyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAocHJvcCA9PT0gJ2ZhbGxiYWNrcycpIHtcbiAgICAgIGZvciAodmFyIGlubmVyUHJvcCBpbiB2YWx1ZSkge1xuICAgICAgICB2YWx1ZVtpbm5lclByb3BdID0gaXRlcmF0ZShpbm5lclByb3AsIHZhbHVlW2lubmVyUHJvcF0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBfaW5uZXJQcm9wIGluIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlW19pbm5lclByb3BdID0gaXRlcmF0ZShwcm9wICsgXCItXCIgKyBfaW5uZXJQcm9wLCB2YWx1ZVtfaW5uZXJQcm9wXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG5cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICB2YXIgdW5pdCA9IG9wdGlvbnNbcHJvcF0gfHwgdW5pdHNbcHJvcF07IC8vIEFkZCB0aGUgdW5pdCBpZiBhdmFpbGFibGUsIGV4Y2VwdCBmb3IgdGhlIHNwZWNpYWwgY2FzZSBvZiAwcHguXG5cbiAgICBpZiAodW5pdCAmJiAhKHZhbHVlID09PSAwICYmIHVuaXQgPT09IHB4KSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB1bml0ID09PSAnZnVuY3Rpb24nID8gdW5pdCh2YWx1ZSkudG9TdHJpbmcoKSA6IFwiXCIgKyB2YWx1ZSArIHVuaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEFkZCB1bml0IHRvIG51bWVyaWMgdmFsdWVzLlxuICovXG5cblxuZnVuY3Rpb24gZGVmYXVsdFVuaXQob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIGNhbWVsQ2FzZWRPcHRpb25zID0gYWRkQ2FtZWxDYXNlZFZlcnNpb24ob3B0aW9ucyk7XG5cbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm4gc3R5bGU7XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICBzdHlsZVtwcm9wXSA9IGl0ZXJhdGUocHJvcCwgc3R5bGVbcHJvcF0sIGNhbWVsQ2FzZWRPcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKHZhbHVlLCBwcm9wKSB7XG4gICAgcmV0dXJuIGl0ZXJhdGUocHJvcCwgdmFsdWUsIGNhbWVsQ2FzZWRPcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlLFxuICAgIG9uQ2hhbmdlVmFsdWU6IG9uQ2hhbmdlVmFsdWVcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdFVuaXQ7XG4iLCJpbXBvcnQgaXNJbkJyb3dzZXIgZnJvbSAnaXMtaW4tYnJvd3Nlcic7XG5pbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5JztcblxuLy8gRXhwb3J0IGphdmFzY3JpcHQgc3R5bGUgYW5kIGNzcyBzdHlsZSB2ZW5kb3IgcHJlZml4ZXMuXG52YXIganMgPSAnJztcbnZhciBjc3MgPSAnJztcbnZhciB2ZW5kb3IgPSAnJztcbnZhciBicm93c2VyID0gJyc7XG52YXIgaXNUb3VjaCA9IGlzSW5Ccm93c2VyICYmICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsgLy8gV2Ugc2hvdWxkIG5vdCBkbyBhbnl0aGluZyBpZiByZXF1aXJlZCBzZXJ2ZXJzaWRlLlxuXG5pZiAoaXNJbkJyb3dzZXIpIHtcbiAgLy8gT3JkZXIgbWF0dGVycy4gV2UgbmVlZCB0byBjaGVjayBXZWJraXQgdGhlIGxhc3Qgb25lIGJlY2F1c2VcbiAgLy8gb3RoZXIgdmVuZG9ycyB1c2UgdG8gYWRkIFdlYmtpdCBwcmVmaXhlcyB0byBzb21lIHByb3BlcnRpZXNcbiAgdmFyIGpzQ3NzTWFwID0ge1xuICAgIE1vejogJy1tb3otJyxcbiAgICBtczogJy1tcy0nLFxuICAgIE86ICctby0nLFxuICAgIFdlYmtpdDogJy13ZWJraXQtJ1xuICB9O1xuXG4gIHZhciBfZG9jdW1lbnQkY3JlYXRlRWxlbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyksXG4gICAgICBzdHlsZSA9IF9kb2N1bWVudCRjcmVhdGVFbGVtZS5zdHlsZTtcblxuICB2YXIgdGVzdFByb3AgPSAnVHJhbnNmb3JtJztcblxuICBmb3IgKHZhciBrZXkgaW4ganNDc3NNYXApIHtcbiAgICBpZiAoa2V5ICsgdGVzdFByb3AgaW4gc3R5bGUpIHtcbiAgICAgIGpzID0ga2V5O1xuICAgICAgY3NzID0ganNDc3NNYXBba2V5XTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSAvLyBDb3JyZWN0bHkgZGV0ZWN0IHRoZSBFZGdlIGJyb3dzZXIuXG5cblxuICBpZiAoanMgPT09ICdXZWJraXQnICYmICdtc0h5cGhlbnMnIGluIHN0eWxlKSB7XG4gICAganMgPSAnbXMnO1xuICAgIGNzcyA9IGpzQ3NzTWFwLm1zO1xuICAgIGJyb3dzZXIgPSAnZWRnZSc7XG4gIH0gLy8gQ29ycmVjdGx5IGRldGVjdCB0aGUgU2FmYXJpIGJyb3dzZXIuXG5cblxuICBpZiAoanMgPT09ICdXZWJraXQnICYmICctYXBwbGUtdHJhaWxpbmctd29yZCcgaW4gc3R5bGUpIHtcbiAgICB2ZW5kb3IgPSAnYXBwbGUnO1xuICB9XG59XG4vKipcbiAqIFZlbmRvciBwcmVmaXggc3RyaW5nIGZvciB0aGUgY3VycmVudCBicm93c2VyLlxuICpcbiAqIEB0eXBlIHt7anM6IFN0cmluZywgY3NzOiBTdHJpbmcsIHZlbmRvcjogU3RyaW5nLCBicm93c2VyOiBTdHJpbmd9fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbnZhciBwcmVmaXggPSB7XG4gIGpzOiBqcyxcbiAgY3NzOiBjc3MsXG4gIHZlbmRvcjogdmVuZG9yLFxuICBicm93c2VyOiBicm93c2VyLFxuICBpc1RvdWNoOiBpc1RvdWNoXG59O1xuXG4vKipcbiAqIFRlc3QgaWYgYSBrZXlmcmFtZSBhdC1ydWxlIHNob3VsZCBiZSBwcmVmaXhlZCBvciBub3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmVuZG9yIHByZWZpeCBzdHJpbmcgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRlZEtleWZyYW1lcyhrZXkpIHtcbiAgLy8gS2V5ZnJhbWVzIGlzIGFscmVhZHkgcHJlZml4ZWQuIGUuZy4ga2V5ID0gJ0Atd2Via2l0LWtleWZyYW1lcyBhJ1xuICBpZiAoa2V5WzFdID09PSAnLScpIHJldHVybiBrZXk7IC8vIE5vIG5lZWQgdG8gcHJlZml4IElFL0VkZ2UuIE9sZGVyIGJyb3dzZXJzIHdpbGwgaWdub3JlIHVuc3VwcG9ydGVkIHJ1bGVzLlxuICAvLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9a2V5ZnJhbWVzXG5cbiAgaWYgKHByZWZpeC5qcyA9PT0gJ21zJykgcmV0dXJuIGtleTtcbiAgcmV0dXJuIFwiQFwiICsgcHJlZml4LmNzcyArIFwia2V5ZnJhbWVzXCIgKyBrZXkuc3Vic3RyKDEwKTtcbn1cblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPWFwcGVhcmFuY2VcblxudmFyIGFwcGVhcmVuY2UgPSB7XG4gIG5vUHJlZmlsbDogWydhcHBlYXJhbmNlJ10sXG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKSB7XG4gICAgaWYgKHByb3AgIT09ICdhcHBlYXJhbmNlJykgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwcmVmaXguanMgPT09ICdtcycpIHJldHVybiBcIi13ZWJraXQtXCIgKyBwcm9wO1xuICAgIHJldHVybiBwcmVmaXguY3NzICsgcHJvcDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPWNvbG9yLWFkanVzdFxuXG52YXIgY29sb3JBZGp1c3QgPSB7XG4gIG5vUHJlZmlsbDogWydjb2xvci1hZGp1c3QnXSxcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3ApIHtcbiAgICBpZiAocHJvcCAhPT0gJ2NvbG9yLWFkanVzdCcpIHJldHVybiBmYWxzZTtcbiAgICBpZiAocHJlZml4LmpzID09PSAnV2Via2l0JykgcmV0dXJuIHByZWZpeC5jc3MgKyBcInByaW50LVwiICsgcHJvcDtcbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufTtcblxudmFyIHJlZ0V4cCA9IC9bLVxcc10rKC4pPy9nO1xuLyoqXG4gKiBSZXBsYWNlcyB0aGUgbGV0dGVyIHdpdGggdGhlIGNhcGl0YWwgbGV0dGVyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1hdGNoXG4gKiBAcGFyYW0ge1N0cmluZ30gY1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdG9VcHBlcihtYXRjaCwgYykge1xuICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnO1xufVxuLyoqXG4gKiBDb252ZXJ0IGRhc2ggc2VwYXJhdGVkIHN0cmluZ3MgdG8gY2FtZWwtY2FzZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlZ0V4cCwgdG9VcHBlcik7XG59XG5cbi8qKlxuICogQ29udmVydCBkYXNoIHNlcGFyYXRlZCBzdHJpbmdzIHRvIHBhc2NhbCBjYXNlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXNjYWxpemUoc3RyKSB7XG4gIHJldHVybiBjYW1lbGl6ZShcIi1cIiArIHN0cik7XG59XG5cbi8vIGJ1dCB3ZSBjYW4gdXNlIGEgbG9uZ2hhbmQgcHJvcGVydHkgaW5zdGVhZC5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1tYXNrXG5cbnZhciBtYXNrID0ge1xuICBub1ByZWZpbGw6IFsnbWFzayddLFxuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCwgc3R5bGUpIHtcbiAgICBpZiAoIS9ebWFzay8udGVzdChwcm9wKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ1dlYmtpdCcpIHtcbiAgICAgIHZhciBsb25naGFuZCA9ICdtYXNrLWltYWdlJztcblxuICAgICAgaWYgKGNhbWVsaXplKGxvbmdoYW5kKSBpbiBzdHlsZSkge1xuICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZWZpeC5qcyArIHBhc2NhbGl6ZShsb25naGFuZCkgaW4gc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeC5jc3MgKyBwcm9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wO1xuICB9XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9dGV4dC1vcmllbnRhdGlvblxuXG52YXIgdGV4dE9yaWVudGF0aW9uID0ge1xuICBub1ByZWZpbGw6IFsndGV4dC1vcmllbnRhdGlvbiddLFxuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCkge1xuICAgIGlmIChwcm9wICE9PSAndGV4dC1vcmllbnRhdGlvbicpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwcmVmaXgudmVuZG9yID09PSAnYXBwbGUnICYmICFwcmVmaXguaXNUb3VjaCkge1xuICAgICAgcmV0dXJuIHByZWZpeC5jc3MgKyBwcm9wO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wO1xuICB9XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9dHJhbnNmb3JtXG5cbnZhciB0cmFuc2Zvcm0gPSB7XG4gIG5vUHJlZmlsbDogWyd0cmFuc2Zvcm0nXSxcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKHByb3AgIT09ICd0cmFuc2Zvcm0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy50cmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXguY3NzICsgcHJvcDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXRyYW5zaXRpb25cblxudmFyIHRyYW5zaXRpb24gPSB7XG4gIG5vUHJlZmlsbDogWyd0cmFuc2l0aW9uJ10sXG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChwcm9wICE9PSAndHJhbnNpdGlvbicpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXguY3NzICsgcHJvcDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXdyaXRpbmctbW9kZVxuXG52YXIgd3JpdGluZ01vZGUgPSB7XG4gIG5vUHJlZmlsbDogWyd3cml0aW5nLW1vZGUnXSxcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3ApIHtcbiAgICBpZiAocHJvcCAhPT0gJ3dyaXRpbmctbW9kZScpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwcmVmaXguanMgPT09ICdXZWJraXQnIHx8IHByZWZpeC5qcyA9PT0gJ21zJyAmJiBwcmVmaXguYnJvd3NlciAhPT0gJ2VkZ2UnKSB7XG4gICAgICByZXR1cm4gcHJlZml4LmNzcyArIHByb3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD11c2VyLXNlbGVjdFxuXG52YXIgdXNlclNlbGVjdCA9IHtcbiAgbm9QcmVmaWxsOiBbJ3VzZXItc2VsZWN0J10sXG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKSB7XG4gICAgaWYgKHByb3AgIT09ICd1c2VyLXNlbGVjdCcpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwcmVmaXguanMgPT09ICdNb3onIHx8IHByZWZpeC5qcyA9PT0gJ21zJyB8fCBwcmVmaXgudmVuZG9yID09PSAnYXBwbGUnKSB7XG4gICAgICByZXR1cm4gcHJlZml4LmNzcyArIHByb3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1tdWx0aWNvbHVtblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bvc3Rjc3MvYXV0b3ByZWZpeGVyL2lzc3Vlcy80OTFcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3N0Y3NzL2F1dG9wcmVmaXhlci9pc3N1ZXMvMTc3XG5cbnZhciBicmVha1Byb3BzT2xkID0ge1xuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCwgc3R5bGUpIHtcbiAgICBpZiAoIS9eYnJlYWstLy50ZXN0KHByb3ApKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAocHJlZml4LmpzID09PSAnV2Via2l0Jykge1xuICAgICAgdmFyIGpzUHJvcCA9IFwiV2Via2l0Q29sdW1uXCIgKyBwYXNjYWxpemUocHJvcCk7XG4gICAgICByZXR1cm4ganNQcm9wIGluIHN0eWxlID8gcHJlZml4LmNzcyArIFwiY29sdW1uLVwiICsgcHJvcCA6IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwcmVmaXguanMgPT09ICdNb3onKSB7XG4gICAgICB2YXIgX2pzUHJvcCA9IFwicGFnZVwiICsgcGFzY2FsaXplKHByb3ApO1xuXG4gICAgICByZXR1cm4gX2pzUHJvcCBpbiBzdHlsZSA/IFwicGFnZS1cIiArIHByb3AgOiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcG9zdGNzcy9hdXRvcHJlZml4ZXIvaXNzdWVzLzMyNC5cblxudmFyIGlubGluZUxvZ2ljYWxPbGQgPSB7XG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBzdHlsZSkge1xuICAgIGlmICghL14oYm9yZGVyfG1hcmdpbnxwYWRkaW5nKS1pbmxpbmUvLnRlc3QocHJvcCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAocHJlZml4LmpzID09PSAnTW96JykgcmV0dXJuIHByb3A7XG4gICAgdmFyIG5ld1Byb3AgPSBwcm9wLnJlcGxhY2UoJy1pbmxpbmUnLCAnJyk7XG4gICAgcmV0dXJuIHByZWZpeC5qcyArIHBhc2NhbGl6ZShuZXdQcm9wKSBpbiBzdHlsZSA/IHByZWZpeC5jc3MgKyBuZXdQcm9wIDogZmFsc2U7XG4gIH1cbn07XG5cbi8vIENhbWVsaXphdGlvbiBpcyByZXF1aXJlZCBiZWNhdXNlIHdlIGNhbid0IHRlc3QgdXNpbmcuXG4vLyBDU1Mgc3ludGF4IGZvciBlLmcuIGluIEZGLlxuXG52YXIgdW5wcmVmaXhlZCA9IHtcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIHN0eWxlKSB7XG4gICAgcmV0dXJuIGNhbWVsaXplKHByb3ApIGluIHN0eWxlID8gcHJvcCA6IGZhbHNlO1xuICB9XG59O1xuXG52YXIgcHJlZml4ZWQgPSB7XG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBzdHlsZSkge1xuICAgIHZhciBwYXNjYWxpemVkID0gcGFzY2FsaXplKHByb3ApOyAvLyBSZXR1cm4gY3VzdG9tIENTUyB2YXJpYWJsZSB3aXRob3V0IHByZWZpeGluZy5cblxuICAgIGlmIChwcm9wWzBdID09PSAnLScpIHJldHVybiBwcm9wOyAvLyBSZXR1cm4gYWxyZWFkeSBwcmVmaXhlZCB2YWx1ZSB3aXRob3V0IHByZWZpeGluZy5cblxuICAgIGlmIChwcm9wWzBdID09PSAnLScgJiYgcHJvcFsxXSA9PT0gJy0nKSByZXR1cm4gcHJvcDtcbiAgICBpZiAocHJlZml4LmpzICsgcGFzY2FsaXplZCBpbiBzdHlsZSkgcmV0dXJuIHByZWZpeC5jc3MgKyBwcm9wOyAvLyBUcnkgd2Via2l0IGZhbGxiYWNrLlxuXG4gICAgaWYgKHByZWZpeC5qcyAhPT0gJ1dlYmtpdCcgJiYgXCJXZWJraXRcIiArIHBhc2NhbGl6ZWQgaW4gc3R5bGUpIHJldHVybiBcIi13ZWJraXQtXCIgKyBwcm9wO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXNjcm9sbC1zbmFwXG5cbnZhciBzY3JvbGxTbmFwID0ge1xuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCkge1xuICAgIGlmIChwcm9wLnN1YnN0cmluZygwLCAxMSkgIT09ICdzY3JvbGwtc25hcCcpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwcmVmaXguanMgPT09ICdtcycpIHtcbiAgICAgIHJldHVybiBcIlwiICsgcHJlZml4LmNzcyArIHByb3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1vdmVyc2Nyb2xsLWJlaGF2aW9yXG5cbnZhciBvdmVyc2Nyb2xsQmVoYXZpb3IgPSB7XG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKSB7XG4gICAgaWYgKHByb3AgIT09ICdvdmVyc2Nyb2xsLWJlaGF2aW9yJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ21zJykge1xuICAgICAgcmV0dXJuIHByZWZpeC5jc3MgKyBcInNjcm9sbC1jaGFpbmluZ1wiO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wO1xuICB9XG59O1xuXG52YXIgcHJvcE1hcCA9IHtcbiAgJ2ZsZXgtZ3Jvdyc6ICdmbGV4LXBvc2l0aXZlJyxcbiAgJ2ZsZXgtc2hyaW5rJzogJ2ZsZXgtbmVnYXRpdmUnLFxuICAnZmxleC1iYXNpcyc6ICdmbGV4LXByZWZlcnJlZC1zaXplJyxcbiAgJ2p1c3RpZnktY29udGVudCc6ICdmbGV4LXBhY2snLFxuICBvcmRlcjogJ2ZsZXgtb3JkZXInLFxuICAnYWxpZ24taXRlbXMnOiAnZmxleC1hbGlnbicsXG4gICdhbGlnbi1jb250ZW50JzogJ2ZsZXgtbGluZS1wYWNrJyAvLyAnYWxpZ24tc2VsZicgaXMgaGFuZGxlZCBieSAnYWxpZ24tc2VsZicgcGx1Z2luLlxuXG59OyAvLyBTdXBwb3J0IG9sZCBmbGV4IHNwZWMgZnJvbSAyMDEyLlxuXG52YXIgZmxleDIwMTIgPSB7XG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBzdHlsZSkge1xuICAgIHZhciBuZXdQcm9wID0gcHJvcE1hcFtwcm9wXTtcbiAgICBpZiAoIW5ld1Byb3ApIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcHJlZml4LmpzICsgcGFzY2FsaXplKG5ld1Byb3ApIGluIHN0eWxlID8gcHJlZml4LmNzcyArIG5ld1Byb3AgOiBmYWxzZTtcbiAgfVxufTtcblxudmFyIHByb3BNYXAkMSA9IHtcbiAgZmxleDogJ2JveC1mbGV4JyxcbiAgJ2ZsZXgtZ3Jvdyc6ICdib3gtZmxleCcsXG4gICdmbGV4LWRpcmVjdGlvbic6IFsnYm94LW9yaWVudCcsICdib3gtZGlyZWN0aW9uJ10sXG4gIG9yZGVyOiAnYm94LW9yZGluYWwtZ3JvdXAnLFxuICAnYWxpZ24taXRlbXMnOiAnYm94LWFsaWduJyxcbiAgJ2ZsZXgtZmxvdyc6IFsnYm94LW9yaWVudCcsICdib3gtZGlyZWN0aW9uJ10sXG4gICdqdXN0aWZ5LWNvbnRlbnQnOiAnYm94LXBhY2snXG59O1xudmFyIHByb3BLZXlzID0gT2JqZWN0LmtleXMocHJvcE1hcCQxKTtcblxudmFyIHByZWZpeENzcyA9IGZ1bmN0aW9uIHByZWZpeENzcyhwKSB7XG4gIHJldHVybiBwcmVmaXguY3NzICsgcDtcbn07IC8vIFN1cHBvcnQgb2xkIGZsZXggc3BlYyBmcm9tIDIwMDkuXG5cblxudmFyIGZsZXgyMDA5ID0ge1xuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCwgc3R5bGUsIF9yZWYpIHtcbiAgICB2YXIgbXVsdGlwbGUgPSBfcmVmLm11bHRpcGxlO1xuXG4gICAgaWYgKHByb3BLZXlzLmluZGV4T2YocHJvcCkgPiAtMSkge1xuICAgICAgdmFyIG5ld1Byb3AgPSBwcm9wTWFwJDFbcHJvcF07XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShuZXdQcm9wKSkge1xuICAgICAgICByZXR1cm4gcHJlZml4LmpzICsgcGFzY2FsaXplKG5ld1Byb3ApIGluIHN0eWxlID8gcHJlZml4LmNzcyArIG5ld1Byb3AgOiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtdWx0aXBsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1Byb3AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCEocHJlZml4LmpzICsgcGFzY2FsaXplKG5ld1Byb3BbMF0pIGluIHN0eWxlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3UHJvcC5tYXAocHJlZml4Q3NzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIHBsdWdpbnMgPSBbXG4vLyAgIC4uLnBsdWdpbnMsXG4vLyAgICBicmVha1Byb3BzT2xkLFxuLy8gICAgaW5saW5lTG9naWNhbE9sZCxcbi8vICAgIHVucHJlZml4ZWQsXG4vLyAgICBwcmVmaXhlZCxcbi8vICAgIHNjcm9sbFNuYXAsXG4vLyAgICBmbGV4MjAxMixcbi8vICAgIGZsZXgyMDA5XG4vLyBdXG4vLyBQbHVnaW5zIHdpdGhvdXQgJ25vUHJlZmlsbCcgdmFsdWUsIGdvaW5nIGxhc3QuXG4vLyAnZmxleC0qJyBwbHVnaW5zIHNob3VsZCBiZSBhdCB0aGUgYm90dG9tLlxuLy8gJ2ZsZXgyMDA5JyBnb2luZyBhZnRlciAnZmxleDIwMTInLlxuLy8gJ3ByZWZpeGVkJyBnb2luZyBhZnRlciAndW5wcmVmaXhlZCdcblxudmFyIHBsdWdpbnMgPSBbYXBwZWFyZW5jZSwgY29sb3JBZGp1c3QsIG1hc2ssIHRleHRPcmllbnRhdGlvbiwgdHJhbnNmb3JtLCB0cmFuc2l0aW9uLCB3cml0aW5nTW9kZSwgdXNlclNlbGVjdCwgYnJlYWtQcm9wc09sZCwgaW5saW5lTG9naWNhbE9sZCwgdW5wcmVmaXhlZCwgcHJlZml4ZWQsIHNjcm9sbFNuYXAsIG92ZXJzY3JvbGxCZWhhdmlvciwgZmxleDIwMTIsIGZsZXgyMDA5XTtcbnZhciBwcm9wZXJ0eURldGVjdG9ycyA9IHBsdWdpbnMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBwLnN1cHBvcnRlZFByb3BlcnR5O1xufSkubWFwKGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBwLnN1cHBvcnRlZFByb3BlcnR5O1xufSk7XG52YXIgbm9QcmVmaWxsID0gcGx1Z2lucy5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIHAubm9QcmVmaWxsO1xufSkucmVkdWNlKGZ1bmN0aW9uIChhLCBwKSB7XG4gIGEucHVzaC5hcHBseShhLCBfdG9Db25zdW1hYmxlQXJyYXkocC5ub1ByZWZpbGwpKTtcbiAgcmV0dXJuIGE7XG59LCBbXSk7XG5cbnZhciBlbDtcbnZhciBjYWNoZSA9IHt9O1xuXG5pZiAoaXNJbkJyb3dzZXIpIHtcbiAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7IC8vIFdlIHRlc3QgZXZlcnkgcHJvcGVydHkgb24gdmVuZG9yIHByZWZpeCByZXF1aXJlbWVudC5cbiAgLy8gT25jZSB0ZXN0ZWQsIHJlc3VsdCBpcyBjYWNoZWQuIEl0IGdpdmVzIHVzIHVwIHRvIDcwJSBwZXJmIGJvb3N0LlxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9lbGVtZW50LXN0eWxlLW9iamVjdC1hY2Nlc3MtdnMtcGxhaW4tb2JqZWN0XG4gIC8vXG4gIC8vIFByZWZpbGwgY2FjaGUgd2l0aCBrbm93biBjc3MgcHJvcGVydGllcyB0byByZWR1Y2UgYW1vdW50IG9mXG4gIC8vIHByb3BlcnRpZXMgd2UgbmVlZCB0byBmZWF0dXJlIHRlc3QgYXQgcnVudGltZS5cbiAgLy8gaHR0cDovL2Rhdmlkd2Fsc2gubmFtZS92ZW5kb3ItcHJlZml4XG5cbiAgdmFyIGNvbXB1dGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyk7XG5cbiAgZm9yICh2YXIga2V5JDEgaW4gY29tcHV0ZWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgaWYgKCFpc05hTihrZXkkMSkpIGNhY2hlW2NvbXB1dGVkW2tleSQxXV0gPSBjb21wdXRlZFtrZXkkMV07XG4gIH0gLy8gUHJvcGVydGllcyB0aGF0IGNhbm5vdCBiZSBjb3JyZWN0bHkgZGV0ZWN0ZWQgdXNpbmcgdGhlXG4gIC8vIGNhY2hlIHByZWZpbGwgbWV0aG9kLlxuXG5cbiAgbm9QcmVmaWxsLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gZGVsZXRlIGNhY2hlW3hdO1xuICB9KTtcbn1cbi8qKlxuICogVGVzdCBpZiBhIHByb3BlcnR5IGlzIHN1cHBvcnRlZCwgcmV0dXJucyBzdXBwb3J0ZWQgcHJvcGVydHkgd2l0aCB2ZW5kb3JcbiAqIHByZWZpeCBpZiByZXF1aXJlZC4gUmV0dXJucyBgZmFsc2VgIGlmIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3AgZGFzaCBzZXBhcmF0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1N0cmluZ3xCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIC8vIEZvciBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gIGlmICghZWwpIHJldHVybiBwcm9wOyAvLyBSZW1vdmUgY2FjaGUgZm9yIGJlbmNobWFyayB0ZXN0cyBvciByZXR1cm4gcHJvcGVydHkgZnJvbSB0aGUgY2FjaGUuXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnYmVuY2htYXJrJyAmJiBjYWNoZVtwcm9wXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGNhY2hlW3Byb3BdO1xuICB9IC8vIENoZWNrIGlmICd0cmFuc2l0aW9uJyBvciAndHJhbnNmb3JtJyBuYXRpdmVseSBzdXBwb3J0ZWQgaW4gYnJvd3Nlci5cblxuXG4gIGlmIChwcm9wID09PSAndHJhbnNpdGlvbicgfHwgcHJvcCA9PT0gJ3RyYW5zZm9ybScpIHtcbiAgICBvcHRpb25zW3Byb3BdID0gcHJvcCBpbiBlbC5zdHlsZTtcbiAgfSAvLyBGaW5kIGEgcGx1Z2luIGZvciBjdXJyZW50IHByZWZpeCBwcm9wZXJ0eS5cblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydHlEZXRlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZVtwcm9wXSA9IHByb3BlcnR5RGV0ZWN0b3JzW2ldKHByb3AsIGVsLnN0eWxlLCBvcHRpb25zKTsgLy8gQnJlYWsgbG9vcCwgaWYgdmFsdWUgZm91bmQuXG5cbiAgICBpZiAoY2FjaGVbcHJvcF0pIGJyZWFrO1xuICB9IC8vIFJlc2V0IHN0eWxlcyBmb3IgY3VycmVudCBwcm9wZXJ0eS5cbiAgLy8gRmlyZWZveCBjYW4gZXZlbiB0aHJvdyBhbiBlcnJvciBmb3IgaW52YWxpZCBwcm9wZXJ0aWVzLCBlLmcuLCBcIjBcIi5cblxuXG4gIHRyeSB7XG4gICAgZWwuc3R5bGVbcHJvcF0gPSAnJztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlW3Byb3BdO1xufVxuXG52YXIgY2FjaGUkMSA9IHt9O1xudmFyIHRyYW5zaXRpb25Qcm9wZXJ0aWVzID0ge1xuICB0cmFuc2l0aW9uOiAxLFxuICAndHJhbnNpdGlvbi1wcm9wZXJ0eSc6IDEsXG4gICctd2Via2l0LXRyYW5zaXRpb24nOiAxLFxuICAnLXdlYmtpdC10cmFuc2l0aW9uLXByb3BlcnR5JzogMVxufTtcbnZhciB0cmFuc1Byb3BzUmVnRXhwID0gLyheXFxzKltcXHctXSspfCwgKFxccypbXFx3LV0rKSg/IVteKCldKlxcKSkvZztcbnZhciBlbCQxO1xuLyoqXG4gKiBSZXR1cm5zIHByZWZpeGVkIHZhbHVlIHRyYW5zaXRpb24vdHJhbnNmb3JtIGlmIG5lZWRlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBwMVxuICogQHBhcmFtIHtTdHJpbmd9IHAyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwcmVmaXhUcmFuc2l0aW9uQ2FsbGJhY2sobWF0Y2gsIHAxLCBwMikge1xuICBpZiAocDEgPT09ICd2YXInKSByZXR1cm4gJ3Zhcic7XG4gIGlmIChwMSA9PT0gJ2FsbCcpIHJldHVybiAnYWxsJztcbiAgaWYgKHAyID09PSAnYWxsJykgcmV0dXJuICcsIGFsbCc7XG4gIHZhciBwcmVmaXhlZFZhbHVlID0gcDEgPyBzdXBwb3J0ZWRQcm9wZXJ0eShwMSkgOiBcIiwgXCIgKyBzdXBwb3J0ZWRQcm9wZXJ0eShwMik7XG4gIGlmICghcHJlZml4ZWRWYWx1ZSkgcmV0dXJuIHAxIHx8IHAyO1xuICByZXR1cm4gcHJlZml4ZWRWYWx1ZTtcbn1cblxuaWYgKGlzSW5Ccm93c2VyKSBlbCQxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuLyoqXG4gKiBSZXR1cm5zIHByZWZpeGVkIHZhbHVlIGlmIG5lZWRlZC4gUmV0dXJucyBgZmFsc2VgIGlmIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ3xCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0ZWRWYWx1ZShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgLy8gRm9yIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgdmFyIHByZWZpeGVkVmFsdWUgPSB2YWx1ZTtcbiAgaWYgKCFlbCQxIHx8IHByb3BlcnR5ID09PSAnY29udGVudCcpIHJldHVybiB2YWx1ZTsgLy8gSXQgaXMgYSBzdHJpbmcgb3IgYSBudW1iZXIgYXMgYSBzdHJpbmcgbGlrZSAnMScuXG4gIC8vIFdlIHdhbnQgb25seSBwcmVmaXhhYmxlIHZhbHVlcyBoZXJlLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG5cbiAgaWYgKHR5cGVvZiBwcmVmaXhlZFZhbHVlICE9PSAnc3RyaW5nJyB8fCAhaXNOYU4ocGFyc2VJbnQocHJlZml4ZWRWYWx1ZSwgMTApKSkge1xuICAgIHJldHVybiBwcmVmaXhlZFZhbHVlO1xuICB9IC8vIENyZWF0ZSBjYWNoZSBrZXkgZm9yIGN1cnJlbnQgdmFsdWUuXG5cblxuICB2YXIgY2FjaGVLZXkgPSBwcm9wZXJ0eSArIHByZWZpeGVkVmFsdWU7IC8vIFJlbW92ZSBjYWNoZSBmb3IgYmVuY2htYXJrIHRlc3RzIG9yIHJldHVybiB2YWx1ZSBmcm9tIGNhY2hlLlxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2JlbmNobWFyaycgJiYgY2FjaGUkMVtjYWNoZUtleV0gIT0gbnVsbCkge1xuICAgIHJldHVybiBjYWNoZSQxW2NhY2hlS2V5XTtcbiAgfSAvLyBJRSBjYW4gZXZlbiB0aHJvdyBhbiBlcnJvciBpbiBzb21lIGNhc2VzLCBmb3IgZS5nLiBzdHlsZS5jb250ZW50ID0gJ2JhcicuXG5cblxuICB0cnkge1xuICAgIC8vIFRlc3QgdmFsdWUgYXMgaXQgaXMuXG4gICAgZWwkMS5zdHlsZVtwcm9wZXJ0eV0gPSBwcmVmaXhlZFZhbHVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBSZXR1cm4gZmFsc2UgaWYgdmFsdWUgbm90IHN1cHBvcnRlZC5cbiAgICBjYWNoZSQxW2NhY2hlS2V5XSA9IGZhbHNlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJZiAndHJhbnNpdGlvbicgb3IgJ3RyYW5zaXRpb24tcHJvcGVydHknIHByb3BlcnR5LlxuXG5cbiAgaWYgKHRyYW5zaXRpb25Qcm9wZXJ0aWVzW3Byb3BlcnR5XSkge1xuICAgIHByZWZpeGVkVmFsdWUgPSBwcmVmaXhlZFZhbHVlLnJlcGxhY2UodHJhbnNQcm9wc1JlZ0V4cCwgcHJlZml4VHJhbnNpdGlvbkNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmIChlbCQxLnN0eWxlW3Byb3BlcnR5XSA9PT0gJycpIHtcbiAgICAvLyBWYWx1ZSB3aXRoIGEgdmVuZG9yIHByZWZpeC5cbiAgICBwcmVmaXhlZFZhbHVlID0gcHJlZml4LmNzcyArIHByZWZpeGVkVmFsdWU7IC8vIEhhcmRjb2RlIHRlc3QgdG8gY29udmVydCBcImZsZXhcIiB0byBcIi1tcy1mbGV4Ym94XCIgZm9yIElFMTAuXG5cbiAgICBpZiAocHJlZml4ZWRWYWx1ZSA9PT0gJy1tcy1mbGV4JykgZWwkMS5zdHlsZVtwcm9wZXJ0eV0gPSAnLW1zLWZsZXhib3gnOyAvLyBUZXN0IHByZWZpeGVkIHZhbHVlLlxuXG4gICAgZWwkMS5zdHlsZVtwcm9wZXJ0eV0gPSBwcmVmaXhlZFZhbHVlOyAvLyBSZXR1cm4gZmFsc2UgaWYgdmFsdWUgbm90IHN1cHBvcnRlZC5cblxuICAgIGlmIChlbCQxLnN0eWxlW3Byb3BlcnR5XSA9PT0gJycpIHtcbiAgICAgIGNhY2hlJDFbY2FjaGVLZXldID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIFJlc2V0IHN0eWxlcyBmb3IgY3VycmVudCBwcm9wZXJ0eS5cblxuXG4gIGVsJDEuc3R5bGVbcHJvcGVydHldID0gJyc7IC8vIFdyaXRlIGN1cnJlbnQgdmFsdWUgdG8gY2FjaGUuXG5cbiAgY2FjaGUkMVtjYWNoZUtleV0gPSBwcmVmaXhlZFZhbHVlO1xuICByZXR1cm4gY2FjaGUkMVtjYWNoZUtleV07XG59XG5cbmV4cG9ydCB7IHByZWZpeCwgc3VwcG9ydGVkS2V5ZnJhbWVzLCBzdXBwb3J0ZWRQcm9wZXJ0eSwgc3VwcG9ydGVkVmFsdWUgfTtcbiIsImltcG9ydCB7IHN1cHBvcnRlZEtleWZyYW1lcywgc3VwcG9ydGVkVmFsdWUsIHN1cHBvcnRlZFByb3BlcnR5IH0gZnJvbSAnY3NzLXZlbmRvcic7XG5pbXBvcnQgeyB0b0Nzc1ZhbHVlIH0gZnJvbSAnanNzJztcblxuLyoqXG4gKiBBZGQgdmVuZG9yIHByZWZpeCB0byBhIHByb3BlcnR5IG5hbWUgd2hlbiBuZWVkZWQuXG4gKi9cblxuZnVuY3Rpb24ganNzVmVuZG9yUHJlZml4ZXIoKSB7XG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1J1bGUocnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgPT09ICdrZXlmcmFtZXMnKSB7XG4gICAgICB2YXIgYXRSdWxlID0gcnVsZTtcbiAgICAgIGF0UnVsZS5hdCA9IHN1cHBvcnRlZEtleWZyYW1lcyhhdFJ1bGUuYXQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWZpeFN0eWxlKHN0eWxlKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcF07XG5cbiAgICAgIGlmIChwcm9wID09PSAnZmFsbGJhY2tzJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBzdHlsZVtwcm9wXSA9IHZhbHVlLm1hcChwcmVmaXhTdHlsZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlUHJvcCA9IGZhbHNlO1xuICAgICAgdmFyIHN1cHBvcnRlZFByb3AgPSBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKTtcbiAgICAgIGlmIChzdXBwb3J0ZWRQcm9wICYmIHN1cHBvcnRlZFByb3AgIT09IHByb3ApIGNoYW5nZVByb3AgPSB0cnVlO1xuICAgICAgdmFyIGNoYW5nZVZhbHVlID0gZmFsc2U7XG4gICAgICB2YXIgc3VwcG9ydGVkVmFsdWUkMSA9IHN1cHBvcnRlZFZhbHVlKHN1cHBvcnRlZFByb3AsIHRvQ3NzVmFsdWUodmFsdWUpKTtcbiAgICAgIGlmIChzdXBwb3J0ZWRWYWx1ZSQxICYmIHN1cHBvcnRlZFZhbHVlJDEgIT09IHZhbHVlKSBjaGFuZ2VWYWx1ZSA9IHRydWU7XG5cbiAgICAgIGlmIChjaGFuZ2VQcm9wIHx8IGNoYW5nZVZhbHVlKSB7XG4gICAgICAgIGlmIChjaGFuZ2VQcm9wKSBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgICAgIHN0eWxlW3N1cHBvcnRlZFByb3AgfHwgcHJvcF0gPSBzdXBwb3J0ZWRWYWx1ZSQxIHx8IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuICAgIHJldHVybiBwcmVmaXhTdHlsZShzdHlsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKHZhbHVlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRlZFZhbHVlKHByb3AsIHRvQ3NzVmFsdWUodmFsdWUpKSB8fCB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25Qcm9jZXNzUnVsZTogb25Qcm9jZXNzUnVsZSxcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUsXG4gICAgb25DaGFuZ2VWYWx1ZTogb25DaGFuZ2VWYWx1ZVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBqc3NWZW5kb3JQcmVmaXhlcjtcbiIsIi8qKlxuICogU29ydCBwcm9wcyBieSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGpzc1Byb3BzU29ydCgpIHtcbiAgdmFyIHNvcnQgPSBmdW5jdGlvbiBzb3J0KHByb3AwLCBwcm9wMSkge1xuICAgIGlmIChwcm9wMC5sZW5ndGggPT09IHByb3AxLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHByb3AwID4gcHJvcDEgPyAxIDogLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3AwLmxlbmd0aCAtIHByb3AxLmxlbmd0aDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG9uUHJvY2Vzc1N0eWxlOiBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuICAgICAgdmFyIG5ld1N0eWxlID0ge307XG4gICAgICB2YXIgcHJvcHMgPSBPYmplY3Qua2V5cyhzdHlsZSkuc29ydChzb3J0KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdTdHlsZVtwcm9wc1tpXV0gPSBzdHlsZVtwcm9wc1tpXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdTdHlsZTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGpzc1Byb3BzU29ydDtcbiIsImltcG9ydCBmdW5jdGlvbnMgZnJvbSAnanNzLXBsdWdpbi1ydWxlLXZhbHVlLWZ1bmN0aW9uJztcbmltcG9ydCBnbG9iYWwgZnJvbSAnanNzLXBsdWdpbi1nbG9iYWwnO1xuaW1wb3J0IG5lc3RlZCBmcm9tICdqc3MtcGx1Z2luLW5lc3RlZCc7XG5pbXBvcnQgY2FtZWxDYXNlIGZyb20gJ2pzcy1wbHVnaW4tY2FtZWwtY2FzZSc7XG5pbXBvcnQgZGVmYXVsdFVuaXQgZnJvbSAnanNzLXBsdWdpbi1kZWZhdWx0LXVuaXQnO1xuaW1wb3J0IHZlbmRvclByZWZpeGVyIGZyb20gJ2pzcy1wbHVnaW4tdmVuZG9yLXByZWZpeGVyJztcbmltcG9ydCBwcm9wc1NvcnQgZnJvbSAnanNzLXBsdWdpbi1wcm9wcy1zb3J0JzsgLy8gU3Vic2V0IG9mIGpzcy1wcmVzZXQtZGVmYXVsdCB3aXRoIG9ubHkgdGhlIHBsdWdpbnMgdGhlIE1hdGVyaWFsLVVJIGNvbXBvbmVudHMgYXJlIHVzaW5nLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBqc3NQcmVzZXQoKSB7XG4gIHJldHVybiB7XG4gICAgcGx1Z2luczogW2Z1bmN0aW9ucygpLCBnbG9iYWwoKSwgbmVzdGVkKCksIGNhbWVsQ2FzZSgpLCBkZWZhdWx0VW5pdCgpLCAvLyBEaXNhYmxlIHRoZSB2ZW5kb3IgcHJlZml4ZXIgc2VydmVyLXNpZGUsIGl0IGRvZXMgbm90aGluZy5cbiAgICAvLyBUaGlzIHdheSwgd2UgY2FuIGdldCBhIHBlcmZvcm1hbmNlIGJvb3N0LlxuICAgIC8vIEluIHRoZSBkb2N1bWVudGF0aW9uLCB3ZSBhcmUgdXNpbmcgYGF1dG9wcmVmaXhlcmAgdG8gc29sdmUgdGhpcyBwcm9ibGVtLlxuICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHZlbmRvclByZWZpeGVyKCksIHByb3BzU29ydCgpXVxuICB9O1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IHsgZ2V0RGlzcGxheU5hbWUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VDbGFzc2VzKCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBiYXNlQ2xhc3NlcyA9IG9wdGlvbnMuYmFzZUNsYXNzZXMsXG4gICAgICBuZXdDbGFzc2VzID0gb3B0aW9ucy5uZXdDbGFzc2VzLFxuICAgICAgQ29tcG9uZW50ID0gb3B0aW9ucy5Db21wb25lbnQ7XG5cbiAgaWYgKCFuZXdDbGFzc2VzKSB7XG4gICAgcmV0dXJuIGJhc2VDbGFzc2VzO1xuICB9XG5cbiAgdmFyIG5leHRDbGFzc2VzID0gX2V4dGVuZHMoe30sIGJhc2VDbGFzc2VzKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh0eXBlb2YgbmV3Q2xhc3NlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoW1wiTWF0ZXJpYWwtVUk6IFRoZSB2YWx1ZSBgXCIuY29uY2F0KG5ld0NsYXNzZXMsIFwiYCBcIikgKyBcInByb3ZpZGVkIHRvIHRoZSBjbGFzc2VzIHByb3Agb2YgXCIuY29uY2F0KGdldERpc3BsYXlOYW1lKENvbXBvbmVudCksIFwiIGlzIGluY29ycmVjdC5cIiksICdZb3UgbWlnaHQgd2FudCB0byB1c2UgdGhlIGNsYXNzTmFtZSBwcm9wIGluc3RlYWQuJ10uam9pbignXFxuJykpO1xuICAgICAgcmV0dXJuIGJhc2VDbGFzc2VzO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKG5ld0NsYXNzZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWJhc2VDbGFzc2VzW2tleV0gJiYgbmV3Q2xhc3Nlc1trZXldKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoW1wiTWF0ZXJpYWwtVUk6IFRoZSBrZXkgYFwiLmNvbmNhdChrZXksIFwiYCBcIikgKyBcInByb3ZpZGVkIHRvIHRoZSBjbGFzc2VzIHByb3AgaXMgbm90IGltcGxlbWVudGVkIGluIFwiLmNvbmNhdChnZXREaXNwbGF5TmFtZShDb21wb25lbnQpLCBcIi5cIiksIFwiWW91IGNhbiBvbmx5IG92ZXJyaWRlIG9uZSBvZiB0aGUgZm9sbG93aW5nOiBcIi5jb25jYXQoT2JqZWN0LmtleXMoYmFzZUNsYXNzZXMpLmpvaW4oJywnKSwgXCIuXCIpXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdDbGFzc2VzW2tleV0gJiYgdHlwZW9mIG5ld0NsYXNzZXNba2V5XSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihbXCJNYXRlcmlhbC1VSTogVGhlIGtleSBgXCIuY29uY2F0KGtleSwgXCJgIFwiKSArIFwicHJvdmlkZWQgdG8gdGhlIGNsYXNzZXMgcHJvcCBpcyBub3QgdmFsaWQgZm9yIFwiLmNvbmNhdChnZXREaXNwbGF5TmFtZShDb21wb25lbnQpLCBcIi5cIiksIFwiWW91IG5lZWQgdG8gcHJvdmlkZSBhIG5vbiBlbXB0eSBzdHJpbmcgaW5zdGVhZCBvZjogXCIuY29uY2F0KG5ld0NsYXNzZXNba2V5XSwgXCIuXCIpXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5ld0NsYXNzZXNba2V5XSkge1xuICAgICAgbmV4dENsYXNzZXNba2V5XSA9IFwiXCIuY29uY2F0KGJhc2VDbGFzc2VzW2tleV0sIFwiIFwiKS5jb25jYXQobmV3Q2xhc3Nlc1trZXldKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV4dENsYXNzZXM7XG59IiwiLy8gVXNlZCBodHRwczovL2dpdGh1Yi5jb20vdGhpbmtsb29wL211bHRpLWtleS1jYWNoZSBhcyBpbnNwaXJhdGlvblxudmFyIG11bHRpS2V5U3RvcmUgPSB7XG4gIHNldDogZnVuY3Rpb24gc2V0KGNhY2hlLCBrZXkxLCBrZXkyLCB2YWx1ZSkge1xuICAgIHZhciBzdWJDYWNoZSA9IGNhY2hlLmdldChrZXkxKTtcblxuICAgIGlmICghc3ViQ2FjaGUpIHtcbiAgICAgIHN1YkNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgY2FjaGUuc2V0KGtleTEsIHN1YkNhY2hlKTtcbiAgICB9XG5cbiAgICBzdWJDYWNoZS5zZXQoa2V5MiwgdmFsdWUpO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uIGdldChjYWNoZSwga2V5MSwga2V5Mikge1xuICAgIHZhciBzdWJDYWNoZSA9IGNhY2hlLmdldChrZXkxKTtcbiAgICByZXR1cm4gc3ViQ2FjaGUgPyBzdWJDYWNoZS5nZXQoa2V5MikgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIGRlbGV0ZTogZnVuY3Rpb24gX2RlbGV0ZShjYWNoZSwga2V5MSwga2V5Mikge1xuICAgIHZhciBzdWJDYWNoZSA9IGNhY2hlLmdldChrZXkxKTtcbiAgICBzdWJDYWNoZS5kZWxldGUoa2V5Mik7XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBtdWx0aUtleVN0b3JlOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG52YXIgVGhlbWVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVGhlbWVDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1RoZW1lQ29udGV4dCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRoZW1lQ29udGV4dDsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFRoZW1lQ29udGV4dCBmcm9tICcuL1RoZW1lQ29udGV4dCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VUaGVtZSgpIHtcbiAgdmFyIHRoZW1lID0gUmVhY3QudXNlQ29udGV4dChUaGVtZUNvbnRleHQpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlRGVidWdWYWx1ZSh0aGVtZSk7XG4gIH1cblxuICByZXR1cm4gdGhlbWU7XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBleGFjdFByb3AgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IGNyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lIGZyb20gJy4uL2NyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lJztcbmltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ2pzcyc7XG5pbXBvcnQganNzUHJlc2V0IGZyb20gJy4uL2pzc1ByZXNldCc7IC8vIERlZmF1bHQgSlNTIGluc3RhbmNlLlxuXG52YXIganNzID0gY3JlYXRlKGpzc1ByZXNldCgpKTsgLy8gVXNlIGEgc2luZ2xldG9uIG9yIHRoZSBwcm92aWRlZCBvbmUgYnkgdGhlIGNvbnRleHQuXG4vL1xuLy8gVGhlIGNvdW50ZXItYmFzZWQgYXBwcm9hY2ggZG9lc24ndCB0b2xlcmF0ZSBhbnkgbWlzdGFrZS5cbi8vIEl0J3MgbXVjaCBzYWZlciB0byB1c2UgdGhlIHNhbWUgY291bnRlciBldmVyeXdoZXJlLlxuXG52YXIgZ2VuZXJhdGVDbGFzc05hbWUgPSBjcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZSgpOyAvLyBFeHBvcnRlZCBmb3IgdGVzdCBwdXJwb3Nlc1xuXG5leHBvcnQgdmFyIHNoZWV0c01hbmFnZXIgPSBuZXcgTWFwKCk7XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGRpc2FibGVHZW5lcmF0aW9uOiBmYWxzZSxcbiAgZ2VuZXJhdGVDbGFzc05hbWU6IGdlbmVyYXRlQ2xhc3NOYW1lLFxuICBqc3M6IGpzcyxcbiAgc2hlZXRzQ2FjaGU6IG51bGwsXG4gIHNoZWV0c01hbmFnZXI6IHNoZWV0c01hbmFnZXIsXG4gIHNoZWV0c1JlZ2lzdHJ5OiBudWxsXG59O1xuZXhwb3J0IHZhciBTdHlsZXNDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChkZWZhdWx0T3B0aW9ucyk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFN0eWxlc0NvbnRleHQuZGlzcGxheU5hbWUgPSAnU3R5bGVzQ29udGV4dCc7XG59XG5cbnZhciBpbmplY3RGaXJzdE5vZGU7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTdHlsZXNQcm92aWRlcihwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIF9wcm9wcyRpbmplY3RGaXJzdCA9IHByb3BzLmluamVjdEZpcnN0LFxuICAgICAgaW5qZWN0Rmlyc3QgPSBfcHJvcHMkaW5qZWN0Rmlyc3QgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGluamVjdEZpcnN0LFxuICAgICAgX3Byb3BzJGRpc2FibGVHZW5lcmF0ID0gcHJvcHMuZGlzYWJsZUdlbmVyYXRpb24sXG4gICAgICBkaXNhYmxlR2VuZXJhdGlvbiA9IF9wcm9wcyRkaXNhYmxlR2VuZXJhdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZUdlbmVyYXQsXG4gICAgICBsb2NhbE9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNoaWxkcmVuXCIsIFwiaW5qZWN0Rmlyc3RcIiwgXCJkaXNhYmxlR2VuZXJhdGlvblwiXSk7XG5cbiAgdmFyIG91dGVyT3B0aW9ucyA9IFJlYWN0LnVzZUNvbnRleHQoU3R5bGVzQ29udGV4dCk7XG5cbiAgdmFyIGNvbnRleHQgPSBfZXh0ZW5kcyh7fSwgb3V0ZXJPcHRpb25zLCB7XG4gICAgZGlzYWJsZUdlbmVyYXRpb246IGRpc2FibGVHZW5lcmF0aW9uXG4gIH0sIGxvY2FsT3B0aW9ucyk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgJiYgIWNvbnRleHQuc2hlZXRzTWFuYWdlcikge1xuICAgICAgY29uc29sZS5lcnJvcignTWF0ZXJpYWwtVUk6IFlvdSBuZWVkIHRvIHVzZSB0aGUgU2VydmVyU3R5bGVTaGVldHMgQVBJIHdoZW4gcmVuZGVyaW5nIG9uIHRoZSBzZXJ2ZXIuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoY29udGV4dC5qc3Mub3B0aW9ucy5pbnNlcnRpb25Qb2ludCAmJiBpbmplY3RGaXJzdCkge1xuICAgICAgY29uc29sZS5lcnJvcignTWF0ZXJpYWwtVUk6IFlvdSBjYW5ub3QgdXNlIGEgY3VzdG9tIGluc2VydGlvblBvaW50IGFuZCA8U3R5bGVzQ29udGV4dCBpbmplY3RGaXJzdD4gYXQgdGhlIHNhbWUgdGltZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChpbmplY3RGaXJzdCAmJiBsb2NhbE9wdGlvbnMuanNzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNYXRlcmlhbC1VSTogWW91IGNhbm5vdCB1c2UgdGhlIGpzcyBhbmQgaW5qZWN0Rmlyc3QgcHJvcHMgYXQgdGhlIHNhbWUgdGltZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRleHQuanNzLm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgJiYgaW5qZWN0Rmlyc3QgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoIWluamVjdEZpcnN0Tm9kZSkge1xuICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkO1xuICAgICAgaW5qZWN0Rmlyc3ROb2RlID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnbXVpLWluamVjdC1maXJzdCcpO1xuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoaW5qZWN0Rmlyc3ROb2RlLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIGNvbnRleHQuanNzID0gY3JlYXRlKHtcbiAgICAgIHBsdWdpbnM6IGpzc1ByZXNldCgpLnBsdWdpbnMsXG4gICAgICBpbnNlcnRpb25Qb2ludDogaW5qZWN0Rmlyc3ROb2RlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU3R5bGVzQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIGNoaWxkcmVuKTtcbn1cbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFN0eWxlc1Byb3ZpZGVyLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIFlvdXIgY29tcG9uZW50IHRyZWUuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogWW91IGNhbiBkaXNhYmxlIHRoZSBnZW5lcmF0aW9uIG9mIHRoZSBzdHlsZXMgd2l0aCB0aGlzIG9wdGlvbi5cbiAgICogSXQgY2FuIGJlIHVzZWZ1bCB3aGVuIHRyYXZlcnNpbmcgdGhlIFJlYWN0IHRyZWUgb3V0c2lkZSBvZiB0aGUgSFRNTFxuICAgKiByZW5kZXJpbmcgc3RlcCBvbiB0aGUgc2VydmVyLlxuICAgKiBMZXQncyBzYXkgeW91IGFyZSB1c2luZyByZWFjdC1hcG9sbG8gdG8gZXh0cmFjdCBhbGxcbiAgICogdGhlIHF1ZXJpZXMgbWFkZSBieSB0aGUgaW50ZXJmYWNlIHNlcnZlci1zaWRlIC0geW91IGNhbiBzaWduaWZpY2FudGx5IHNwZWVkIHVwIHRoZSB0cmF2ZXJzYWwgd2l0aCB0aGlzIHByb3AuXG4gICAqL1xuICBkaXNhYmxlR2VuZXJhdGlvbjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEpTUydzIGNsYXNzIG5hbWUgZ2VuZXJhdG9yLlxuICAgKi9cbiAgZ2VuZXJhdGVDbGFzc05hbWU6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgc3R5bGVzIGFyZSBpbmplY3RlZCBsYXN0IGluIHRoZSA8aGVhZD4gZWxlbWVudCBvZiB0aGUgcGFnZS5cbiAgICogQXMgYSByZXN1bHQsIHRoZXkgZ2FpbiBtb3JlIHNwZWNpZmljaXR5IHRoYW4gYW55IG90aGVyIHN0eWxlIHNoZWV0LlxuICAgKiBJZiB5b3Ugd2FudCB0byBvdmVycmlkZSBNYXRlcmlhbC1VSSdzIHN0eWxlcywgc2V0IHRoaXMgcHJvcC5cbiAgICovXG4gIGluamVjdEZpcnN0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSlNTJ3MgaW5zdGFuY2UuXG4gICAqL1xuICBqc3M6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHNlcnZlckdlbmVyYXRlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKlxuICAgKiBCZXRhIGZlYXR1cmUuXG4gICAqXG4gICAqIENhY2hlIGZvciB0aGUgc2hlZXRzLlxuICAgKi9cbiAgc2hlZXRzQ2FjaGU6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICpcbiAgICogVGhlIHNoZWV0c01hbmFnZXIgaXMgdXNlZCB0byBkZWR1cGxpY2F0ZSBzdHlsZSBzaGVldCBpbmplY3Rpb24gaW4gdGhlIHBhZ2UuXG4gICAqIEl0J3MgZGVkdXBsaWNhdGluZyB1c2luZyB0aGUgKHRoZW1lLCBzdHlsZXMpIGNvdXBsZS5cbiAgICogT24gdGhlIHNlcnZlciwgeW91IHNob3VsZCBwcm92aWRlIGEgbmV3IGluc3RhbmNlIGZvciBlYWNoIHJlcXVlc3QuXG4gICAqL1xuICBzaGVldHNNYW5hZ2VyOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqXG4gICAqIENvbGxlY3QgdGhlIHNoZWV0cy5cbiAgICovXG4gIHNoZWV0c1JlZ2lzdHJ5OiBQcm9wVHlwZXMub2JqZWN0XG59IDogdm9pZCAwO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBTdHlsZXNQcm92aWRlci5wcm9wVHlwZXMgPSBleGFjdFByb3AoU3R5bGVzUHJvdmlkZXIucHJvcFR5cGVzKSA6IHZvaWQgMDtcbn0iLCIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvcHJlZmVyLWRlZmF1bHQtZXhwb3J0ICovXG4vLyBHbG9iYWwgaW5kZXggY291bnRlciB0byBwcmVzZXJ2ZSBzb3VyY2Ugb3JkZXIuXG4vLyBXZSBjcmVhdGUgdGhlIHN0eWxlIHNoZWV0IGR1cmluZyB0aGUgY3JlYXRpb24gb2YgdGhlIGNvbXBvbmVudCxcbi8vIGNoaWxkcmVuIGFyZSBoYW5kbGVkIGFmdGVyIHRoZSBwYXJlbnRzLCBzbyB0aGUgb3JkZXIgb2Ygc3R5bGUgZWxlbWVudHMgd291bGQgYmUgcGFyZW50LT5jaGlsZC5cbi8vIEl0IGlzIGEgcHJvYmxlbSB0aG91Z2ggd2hlbiBhIHBhcmVudCBwYXNzZXMgYSBjbGFzc05hbWVcbi8vIHdoaWNoIG5lZWRzIHRvIG92ZXJyaWRlIGFueSBjaGlsZCdzIHN0eWxlcy5cbi8vIFN0eWxlU2hlZXQgb2YgdGhlIGNoaWxkIGhhcyBhIGhpZ2hlciBzcGVjaWZpY2l0eSwgYmVjYXVzZSBvZiB0aGUgc291cmNlIG9yZGVyLlxuLy8gU28gb3VyIHNvbHV0aW9uIGlzIHRvIHJlbmRlciBzaGVldHMgdGhlbSBpbiB0aGUgcmV2ZXJzZSBvcmRlciBjaGlsZC0+c2hlZXQsIHNvXG4vLyB0aGF0IHBhcmVudCBoYXMgYSBoaWdoZXIgc3BlY2lmaWNpdHkuXG52YXIgaW5kZXhDb3VudGVyID0gLTFlOTtcbmV4cG9ydCBmdW5jdGlvbiBpbmNyZW1lbnQoKSB7XG4gIGluZGV4Q291bnRlciArPSAxO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGluZGV4Q291bnRlciA+PSAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oWydNYXRlcmlhbC1VSTogWW91IG1pZ2h0IGhhdmUgYSBtZW1vcnkgbGVhay4nLCAnVGhlIGluZGV4Q291bnRlciBpcyBub3Qgc3VwcG9zZWQgdG8gZ3JvdyB0aGF0IG11Y2guJ10uam9pbignXFxuJykpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleENvdW50ZXI7XG59IiwiLy8gV2UgdXNlIHRoZSBzYW1lIGVtcHR5IG9iamVjdCB0byByZWYgY291bnQgdGhlIHN0eWxlcyB0aGF0IGRvbid0IG5lZWQgYSB0aGVtZSBvYmplY3QuXG52YXIgbm9vcFRoZW1lID0ge307XG5leHBvcnQgZGVmYXVsdCBub29wVGhlbWU7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX3R5cGVvZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mXCI7XG5pbXBvcnQgeyBkZWVwbWVyZ2UgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IG5vb3BUaGVtZSBmcm9tICcuL25vb3BUaGVtZSc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTdHlsZXNDcmVhdG9yKHN0eWxlc09yQ3JlYXRvcikge1xuICB2YXIgdGhlbWluZ0VuYWJsZWQgPSB0eXBlb2Ygc3R5bGVzT3JDcmVhdG9yID09PSAnZnVuY3Rpb24nO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKF90eXBlb2Yoc3R5bGVzT3JDcmVhdG9yKSAhPT0gJ29iamVjdCcgJiYgIXRoZW1pbmdFbmFibGVkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnTWF0ZXJpYWwtVUk6IFRoZSBgc3R5bGVzYCBhcmd1bWVudCBwcm92aWRlZCBpcyBpbnZhbGlkLicsICdZb3UgbmVlZCB0byBwcm92aWRlIGEgZnVuY3Rpb24gZ2VuZXJhdGluZyB0aGUgc3R5bGVzIG9yIGEgc3R5bGVzIG9iamVjdC4nXS5qb2luKCdcXG4nKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSh0aGVtZSwgbmFtZSkge1xuICAgICAgdmFyIHN0eWxlcztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc3R5bGVzID0gdGhlbWluZ0VuYWJsZWQgPyBzdHlsZXNPckNyZWF0b3IodGhlbWUpIDogc3R5bGVzT3JDcmVhdG9yO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRoZW1pbmdFbmFibGVkID09PSB0cnVlICYmIHRoZW1lID09PSBub29wVGhlbWUpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHByZXBlbmQgZXJyb3IgbWVzc2FnZS9uYW1lIGluc3RlYWRcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoWydNYXRlcmlhbC1VSTogVGhlIGBzdHlsZXNgIGFyZ3VtZW50IHByb3ZpZGVkIGlzIGludmFsaWQuJywgJ1lvdSBhcmUgcHJvdmlkaW5nIGEgZnVuY3Rpb24gd2l0aG91dCBhIHRoZW1lIGluIHRoZSBjb250ZXh0LicsICdPbmUgb2YgdGhlIHBhcmVudCBlbGVtZW50cyBuZWVkcyB0byB1c2UgYSBUaGVtZVByb3ZpZGVyLiddLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG5cbiAgICAgIGlmICghbmFtZSB8fCAhdGhlbWUub3ZlcnJpZGVzIHx8ICF0aGVtZS5vdmVycmlkZXNbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgIH1cblxuICAgICAgdmFyIG92ZXJyaWRlcyA9IHRoZW1lLm92ZXJyaWRlc1tuYW1lXTtcblxuICAgICAgdmFyIHN0eWxlc1dpdGhPdmVycmlkZXMgPSBfZXh0ZW5kcyh7fSwgc3R5bGVzKTtcblxuICAgICAgT2JqZWN0LmtleXMob3ZlcnJpZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIXN0eWxlc1dpdGhPdmVycmlkZXNba2V5XSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFsnTWF0ZXJpYWwtVUk6IFlvdSBhcmUgdHJ5aW5nIHRvIG92ZXJyaWRlIGEgc3R5bGUgdGhhdCBkb2VzIG5vdCBleGlzdC4nLCBcIkZpeCB0aGUgYFwiLmNvbmNhdChrZXksIFwiYCBrZXkgb2YgYHRoZW1lLm92ZXJyaWRlcy5cIikuY29uY2F0KG5hbWUsIFwiYC5cIildLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZXNXaXRoT3ZlcnJpZGVzW2tleV0gPSBkZWVwbWVyZ2Uoc3R5bGVzV2l0aE92ZXJyaWRlc1trZXldLCBvdmVycmlkZXNba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdHlsZXNXaXRoT3ZlcnJpZGVzO1xuICAgIH0sXG4gICAgb3B0aW9uczoge31cbiAgfTtcbn0iLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZ2V0RHluYW1pY1N0eWxlcyB9IGZyb20gJ2pzcyc7XG5pbXBvcnQgbWVyZ2VDbGFzc2VzIGZyb20gJy4uL21lcmdlQ2xhc3Nlcyc7XG5pbXBvcnQgbXVsdGlLZXlTdG9yZSBmcm9tICcuL211bHRpS2V5U3RvcmUnO1xuaW1wb3J0IHVzZVRoZW1lIGZyb20gJy4uL3VzZVRoZW1lJztcbmltcG9ydCB7IFN0eWxlc0NvbnRleHQgfSBmcm9tICcuLi9TdHlsZXNQcm92aWRlcic7XG5pbXBvcnQgeyBpbmNyZW1lbnQgfSBmcm9tICcuL2luZGV4Q291bnRlcic7XG5pbXBvcnQgZ2V0U3R5bGVzQ3JlYXRvciBmcm9tICcuLi9nZXRTdHlsZXNDcmVhdG9yJztcbmltcG9ydCBub29wVGhlbWUgZnJvbSAnLi4vZ2V0U3R5bGVzQ3JlYXRvci9ub29wVGhlbWUnO1xuXG5mdW5jdGlvbiBnZXRDbGFzc2VzKF9yZWYsIGNsYXNzZXMsIENvbXBvbmVudCkge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgc3R5bGVzT3B0aW9ucyA9IF9yZWYuc3R5bGVzT3B0aW9ucztcblxuICBpZiAoc3R5bGVzT3B0aW9ucy5kaXNhYmxlR2VuZXJhdGlvbikge1xuICAgIHJldHVybiBjbGFzc2VzIHx8IHt9O1xuICB9XG5cbiAgaWYgKCFzdGF0ZS5jYWNoZUNsYXNzZXMpIHtcbiAgICBzdGF0ZS5jYWNoZUNsYXNzZXMgPSB7XG4gICAgICAvLyBDYWNoZSBmb3IgdGhlIGZpbmFsaXplZCBjbGFzc2VzIHZhbHVlLlxuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAvLyBDYWNoZSBmb3IgdGhlIGxhc3QgdXNlZCBjbGFzc2VzIHByb3AgcG9pbnRlci5cbiAgICAgIGxhc3RQcm9wOiBudWxsLFxuICAgICAgLy8gQ2FjaGUgZm9yIHRoZSBsYXN0IHVzZWQgcmVuZGVyZWQgY2xhc3NlcyBwb2ludGVyLlxuICAgICAgbGFzdEpTUzoge31cbiAgICB9O1xuICB9IC8vIFRyYWNrcyBpZiBlaXRoZXIgdGhlIHJlbmRlcmVkIGNsYXNzZXMgb3IgY2xhc3NlcyBwcm9wIGhhcyBjaGFuZ2VkLFxuICAvLyByZXF1aXJpbmcgdGhlIGdlbmVyYXRpb24gb2YgYSBuZXcgZmluYWxpemVkIGNsYXNzZXMgb2JqZWN0LlxuXG5cbiAgdmFyIGdlbmVyYXRlID0gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLmNsYXNzZXMgIT09IHN0YXRlLmNhY2hlQ2xhc3Nlcy5sYXN0SlNTKSB7XG4gICAgc3RhdGUuY2FjaGVDbGFzc2VzLmxhc3RKU1MgPSBzdGF0ZS5jbGFzc2VzO1xuICAgIGdlbmVyYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChjbGFzc2VzICE9PSBzdGF0ZS5jYWNoZUNsYXNzZXMubGFzdFByb3ApIHtcbiAgICBzdGF0ZS5jYWNoZUNsYXNzZXMubGFzdFByb3AgPSBjbGFzc2VzO1xuICAgIGdlbmVyYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChnZW5lcmF0ZSkge1xuICAgIHN0YXRlLmNhY2hlQ2xhc3Nlcy52YWx1ZSA9IG1lcmdlQ2xhc3Nlcyh7XG4gICAgICBiYXNlQ2xhc3Nlczogc3RhdGUuY2FjaGVDbGFzc2VzLmxhc3RKU1MsXG4gICAgICBuZXdDbGFzc2VzOiBjbGFzc2VzLFxuICAgICAgQ29tcG9uZW50OiBDb21wb25lbnRcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5jYWNoZUNsYXNzZXMudmFsdWU7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaChfcmVmMiwgcHJvcHMpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICB0aGVtZSA9IF9yZWYyLnRoZW1lLFxuICAgICAgc3R5bGVzT3B0aW9ucyA9IF9yZWYyLnN0eWxlc09wdGlvbnMsXG4gICAgICBzdHlsZXNDcmVhdG9yID0gX3JlZjIuc3R5bGVzQ3JlYXRvcixcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuXG4gIGlmIChzdHlsZXNPcHRpb25zLmRpc2FibGVHZW5lcmF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNoZWV0TWFuYWdlciA9IG11bHRpS2V5U3RvcmUuZ2V0KHN0eWxlc09wdGlvbnMuc2hlZXRzTWFuYWdlciwgc3R5bGVzQ3JlYXRvciwgdGhlbWUpO1xuXG4gIGlmICghc2hlZXRNYW5hZ2VyKSB7XG4gICAgc2hlZXRNYW5hZ2VyID0ge1xuICAgICAgcmVmczogMCxcbiAgICAgIHN0YXRpY1NoZWV0OiBudWxsLFxuICAgICAgZHluYW1pY1N0eWxlczogbnVsbFxuICAgIH07XG4gICAgbXVsdGlLZXlTdG9yZS5zZXQoc3R5bGVzT3B0aW9ucy5zaGVldHNNYW5hZ2VyLCBzdHlsZXNDcmVhdG9yLCB0aGVtZSwgc2hlZXRNYW5hZ2VyKTtcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gX2V4dGVuZHMoe30sIHN0eWxlc0NyZWF0b3Iub3B0aW9ucywgc3R5bGVzT3B0aW9ucywge1xuICAgIHRoZW1lOiB0aGVtZSxcbiAgICBmbGlwOiB0eXBlb2Ygc3R5bGVzT3B0aW9ucy5mbGlwID09PSAnYm9vbGVhbicgPyBzdHlsZXNPcHRpb25zLmZsaXAgOiB0aGVtZS5kaXJlY3Rpb24gPT09ICdydGwnXG4gIH0pO1xuXG4gIG9wdGlvbnMuZ2VuZXJhdGVJZCA9IG9wdGlvbnMuc2VydmVyR2VuZXJhdGVDbGFzc05hbWUgfHwgb3B0aW9ucy5nZW5lcmF0ZUNsYXNzTmFtZTtcbiAgdmFyIHNoZWV0c1JlZ2lzdHJ5ID0gc3R5bGVzT3B0aW9ucy5zaGVldHNSZWdpc3RyeTtcblxuICBpZiAoc2hlZXRNYW5hZ2VyLnJlZnMgPT09IDApIHtcbiAgICB2YXIgc3RhdGljU2hlZXQ7XG5cbiAgICBpZiAoc3R5bGVzT3B0aW9ucy5zaGVldHNDYWNoZSkge1xuICAgICAgc3RhdGljU2hlZXQgPSBtdWx0aUtleVN0b3JlLmdldChzdHlsZXNPcHRpb25zLnNoZWV0c0NhY2hlLCBzdHlsZXNDcmVhdG9yLCB0aGVtZSk7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlcyA9IHN0eWxlc0NyZWF0b3IuY3JlYXRlKHRoZW1lLCBuYW1lKTtcblxuICAgIGlmICghc3RhdGljU2hlZXQpIHtcbiAgICAgIHN0YXRpY1NoZWV0ID0gc3R5bGVzT3B0aW9ucy5qc3MuY3JlYXRlU3R5bGVTaGVldChzdHlsZXMsIF9leHRlbmRzKHtcbiAgICAgICAgbGluazogZmFsc2VcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgIHN0YXRpY1NoZWV0LmF0dGFjaCgpO1xuXG4gICAgICBpZiAoc3R5bGVzT3B0aW9ucy5zaGVldHNDYWNoZSkge1xuICAgICAgICBtdWx0aUtleVN0b3JlLnNldChzdHlsZXNPcHRpb25zLnNoZWV0c0NhY2hlLCBzdHlsZXNDcmVhdG9yLCB0aGVtZSwgc3RhdGljU2hlZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaGVldHNSZWdpc3RyeSkge1xuICAgICAgc2hlZXRzUmVnaXN0cnkuYWRkKHN0YXRpY1NoZWV0KTtcbiAgICB9XG5cbiAgICBzaGVldE1hbmFnZXIuc3RhdGljU2hlZXQgPSBzdGF0aWNTaGVldDtcbiAgICBzaGVldE1hbmFnZXIuZHluYW1pY1N0eWxlcyA9IGdldER5bmFtaWNTdHlsZXMoc3R5bGVzKTtcbiAgfVxuXG4gIGlmIChzaGVldE1hbmFnZXIuZHluYW1pY1N0eWxlcykge1xuICAgIHZhciBkeW5hbWljU2hlZXQgPSBzdHlsZXNPcHRpb25zLmpzcy5jcmVhdGVTdHlsZVNoZWV0KHNoZWV0TWFuYWdlci5keW5hbWljU3R5bGVzLCBfZXh0ZW5kcyh7XG4gICAgICBsaW5rOiB0cnVlXG4gICAgfSwgb3B0aW9ucykpO1xuICAgIGR5bmFtaWNTaGVldC51cGRhdGUocHJvcHMpO1xuICAgIGR5bmFtaWNTaGVldC5hdHRhY2goKTtcbiAgICBzdGF0ZS5keW5hbWljU2hlZXQgPSBkeW5hbWljU2hlZXQ7XG4gICAgc3RhdGUuY2xhc3NlcyA9IG1lcmdlQ2xhc3Nlcyh7XG4gICAgICBiYXNlQ2xhc3Nlczogc2hlZXRNYW5hZ2VyLnN0YXRpY1NoZWV0LmNsYXNzZXMsXG4gICAgICBuZXdDbGFzc2VzOiBkeW5hbWljU2hlZXQuY2xhc3Nlc1xuICAgIH0pO1xuXG4gICAgaWYgKHNoZWV0c1JlZ2lzdHJ5KSB7XG4gICAgICBzaGVldHNSZWdpc3RyeS5hZGQoZHluYW1pY1NoZWV0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuY2xhc3NlcyA9IHNoZWV0TWFuYWdlci5zdGF0aWNTaGVldC5jbGFzc2VzO1xuICB9XG5cbiAgc2hlZXRNYW5hZ2VyLnJlZnMgKz0gMTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlKF9yZWYzLCBwcm9wcykge1xuICB2YXIgc3RhdGUgPSBfcmVmMy5zdGF0ZTtcblxuICBpZiAoc3RhdGUuZHluYW1pY1NoZWV0KSB7XG4gICAgc3RhdGUuZHluYW1pY1NoZWV0LnVwZGF0ZShwcm9wcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoKF9yZWY0KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY0LnN0YXRlLFxuICAgICAgdGhlbWUgPSBfcmVmNC50aGVtZSxcbiAgICAgIHN0eWxlc09wdGlvbnMgPSBfcmVmNC5zdHlsZXNPcHRpb25zLFxuICAgICAgc3R5bGVzQ3JlYXRvciA9IF9yZWY0LnN0eWxlc0NyZWF0b3I7XG5cbiAgaWYgKHN0eWxlc09wdGlvbnMuZGlzYWJsZUdlbmVyYXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2hlZXRNYW5hZ2VyID0gbXVsdGlLZXlTdG9yZS5nZXQoc3R5bGVzT3B0aW9ucy5zaGVldHNNYW5hZ2VyLCBzdHlsZXNDcmVhdG9yLCB0aGVtZSk7XG4gIHNoZWV0TWFuYWdlci5yZWZzIC09IDE7XG4gIHZhciBzaGVldHNSZWdpc3RyeSA9IHN0eWxlc09wdGlvbnMuc2hlZXRzUmVnaXN0cnk7XG5cbiAgaWYgKHNoZWV0TWFuYWdlci5yZWZzID09PSAwKSB7XG4gICAgbXVsdGlLZXlTdG9yZS5kZWxldGUoc3R5bGVzT3B0aW9ucy5zaGVldHNNYW5hZ2VyLCBzdHlsZXNDcmVhdG9yLCB0aGVtZSk7XG4gICAgc3R5bGVzT3B0aW9ucy5qc3MucmVtb3ZlU3R5bGVTaGVldChzaGVldE1hbmFnZXIuc3RhdGljU2hlZXQpO1xuXG4gICAgaWYgKHNoZWV0c1JlZ2lzdHJ5KSB7XG4gICAgICBzaGVldHNSZWdpc3RyeS5yZW1vdmUoc2hlZXRNYW5hZ2VyLnN0YXRpY1NoZWV0KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUuZHluYW1pY1NoZWV0KSB7XG4gICAgc3R5bGVzT3B0aW9ucy5qc3MucmVtb3ZlU3R5bGVTaGVldChzdGF0ZS5keW5hbWljU2hlZXQpO1xuXG4gICAgaWYgKHNoZWV0c1JlZ2lzdHJ5KSB7XG4gICAgICBzaGVldHNSZWdpc3RyeS5yZW1vdmUoc3RhdGUuZHluYW1pY1NoZWV0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlU3luY2hyb25vdXNFZmZlY3QoZnVuYywgdmFsdWVzKSB7XG4gIHZhciBrZXkgPSBSZWFjdC51c2VSZWYoW10pO1xuICB2YXIgb3V0cHV0OyAvLyBTdG9yZSBcImdlbmVyYXRpb25cIiBrZXkuIEp1c3QgcmV0dXJucyBhIG5ldyBvYmplY3QgZXZlcnkgdGltZVxuXG4gIHZhciBjdXJyZW50S2V5ID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9LCB2YWx1ZXMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAvLyBcInRoZSBmaXJzdCByZW5kZXJcIiwgb3IgXCJtZW1vIGRyb3BwZWQgdGhlIHZhbHVlXCJcblxuICBpZiAoa2V5LmN1cnJlbnQgIT09IGN1cnJlbnRLZXkpIHtcbiAgICBrZXkuY3VycmVudCA9IGN1cnJlbnRLZXk7XG4gICAgb3V0cHV0ID0gZnVuYygpO1xuICB9XG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICBvdXRwdXQoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbY3VycmVudEtleV0gLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWFrZVN0eWxlcyhzdHlsZXNPckNyZWF0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lLFxuICAgICAgY2xhc3NOYW1lUHJlZml4T3B0aW9uID0gb3B0aW9ucy5jbGFzc05hbWVQcmVmaXgsXG4gICAgICBDb21wb25lbnQgPSBvcHRpb25zLkNvbXBvbmVudCxcbiAgICAgIF9vcHRpb25zJGRlZmF1bHRUaGVtZSA9IG9wdGlvbnMuZGVmYXVsdFRoZW1lLFxuICAgICAgZGVmYXVsdFRoZW1lID0gX29wdGlvbnMkZGVmYXVsdFRoZW1lID09PSB2b2lkIDAgPyBub29wVGhlbWUgOiBfb3B0aW9ucyRkZWZhdWx0VGhlbWUsXG4gICAgICBzdHlsZXNPcHRpb25zMiA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvcHRpb25zLCBbXCJuYW1lXCIsIFwiY2xhc3NOYW1lUHJlZml4XCIsIFwiQ29tcG9uZW50XCIsIFwiZGVmYXVsdFRoZW1lXCJdKTtcblxuICB2YXIgc3R5bGVzQ3JlYXRvciA9IGdldFN0eWxlc0NyZWF0b3Ioc3R5bGVzT3JDcmVhdG9yKTtcbiAgdmFyIGNsYXNzTmFtZVByZWZpeCA9IG5hbWUgfHwgY2xhc3NOYW1lUHJlZml4T3B0aW9uIHx8ICdtYWtlU3R5bGVzJztcbiAgc3R5bGVzQ3JlYXRvci5vcHRpb25zID0ge1xuICAgIGluZGV4OiBpbmNyZW1lbnQoKSxcbiAgICBuYW1lOiBuYW1lLFxuICAgIG1ldGE6IGNsYXNzTmFtZVByZWZpeCxcbiAgICBjbGFzc05hbWVQcmVmaXg6IGNsYXNzTmFtZVByZWZpeFxuICB9O1xuXG4gIHZhciB1c2VTdHlsZXMgPSBmdW5jdGlvbiB1c2VTdHlsZXMoKSB7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgdGhlbWUgPSB1c2VUaGVtZSgpIHx8IGRlZmF1bHRUaGVtZTtcblxuICAgIHZhciBzdHlsZXNPcHRpb25zID0gX2V4dGVuZHMoe30sIFJlYWN0LnVzZUNvbnRleHQoU3R5bGVzQ29udGV4dCksIHN0eWxlc09wdGlvbnMyKTtcblxuICAgIHZhciBpbnN0YW5jZSA9IFJlYWN0LnVzZVJlZigpO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBSZWFjdC51c2VSZWYoKTtcbiAgICB1c2VTeW5jaHJvbm91c0VmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgc3RhdGU6IHt9LFxuICAgICAgICBzdHlsZXNDcmVhdG9yOiBzdHlsZXNDcmVhdG9yLFxuICAgICAgICBzdHlsZXNPcHRpb25zOiBzdHlsZXNPcHRpb25zLFxuICAgICAgICB0aGVtZTogdGhlbWVcbiAgICAgIH07XG4gICAgICBhdHRhY2goY3VycmVudCwgcHJvcHMpO1xuICAgICAgc2hvdWxkVXBkYXRlLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGluc3RhbmNlLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGV0YWNoKGN1cnJlbnQpO1xuICAgICAgfTtcbiAgICB9LCBbdGhlbWUsIHN0eWxlc0NyZWF0b3JdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZS5jdXJyZW50KSB7XG4gICAgICAgIHVwZGF0ZShpbnN0YW5jZS5jdXJyZW50LCBwcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIHNob3VsZFVwZGF0ZS5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9KTtcbiAgICB2YXIgY2xhc3NlcyA9IGdldENsYXNzZXMoaW5zdGFuY2UuY3VycmVudCwgcHJvcHMuY2xhc3NlcywgQ29tcG9uZW50KTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgIFJlYWN0LnVzZURlYnVnVmFsdWUoY2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsYXNzZXM7XG4gIH07XG5cbiAgcmV0dXJuIHVzZVN0eWxlcztcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gIGNvbnRleHRUeXBlOiB0cnVlLFxuICBjb250ZXh0VHlwZXM6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gIG1peGluczogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gIG5hbWU6IHRydWUsXG4gIGxlbmd0aDogdHJ1ZSxcbiAgcHJvdG90eXBlOiB0cnVlLFxuICBjYWxsZXI6IHRydWUsXG4gIGNhbGxlZTogdHJ1ZSxcbiAgYXJndW1lbnRzOiB0cnVlLFxuICBhcml0eTogdHJ1ZVxufTtcbnZhciBGT1JXQVJEX1JFRl9TVEFUSUNTID0ge1xuICAnJCR0eXBlb2YnOiB0cnVlLFxuICByZW5kZXI6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZVxufTtcbnZhciBNRU1PX1NUQVRJQ1MgPSB7XG4gICckJHR5cGVvZic6IHRydWUsXG4gIGNvbXBhcmU6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBUWVBFX1NUQVRJQ1MgPSB7fTtcblRZUEVfU1RBVElDU1tyZWFjdElzLkZvcndhcmRSZWZdID0gRk9SV0FSRF9SRUZfU1RBVElDUztcblRZUEVfU1RBVElDU1tyZWFjdElzLk1lbW9dID0gTUVNT19TVEFUSUNTO1xuXG5mdW5jdGlvbiBnZXRTdGF0aWNzKGNvbXBvbmVudCkge1xuICAvLyBSZWFjdCB2MTYuMTEgYW5kIGJlbG93XG4gIGlmIChyZWFjdElzLmlzTWVtbyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIE1FTU9fU1RBVElDUztcbiAgfSAvLyBSZWFjdCB2MTYuMTIgYW5kIGFib3ZlXG5cblxuICByZXR1cm4gVFlQRV9TVEFUSUNTW2NvbXBvbmVudFsnJCR0eXBlb2YnXV0gfHwgUkVBQ1RfU1RBVElDUztcbn1cblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbmZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBibGFja2xpc3QpIHtcbiAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZG9uJ3QgaG9pc3Qgb3ZlciBzdHJpbmcgKGh0bWwpIGNvbXBvbmVudHNcbiAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICB2YXIgaW5oZXJpdGVkQ29tcG9uZW50ID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCwgYmxhY2tsaXN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldFN0YXRpY3MgPSBnZXRTdGF0aWNzKHRhcmdldENvbXBvbmVudCk7XG4gICAgdmFyIHNvdXJjZVN0YXRpY3MgPSBnZXRTdGF0aWNzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIUtOT1dOX1NUQVRJQ1Nba2V5XSAmJiAhKGJsYWNrbGlzdCAmJiBibGFja2xpc3Rba2V5XSkgJiYgIShzb3VyY2VTdGF0aWNzICYmIHNvdXJjZVN0YXRpY3Nba2V5XSkgJiYgISh0YXJnZXRTdGF0aWNzICYmIHRhcmdldFN0YXRpY3Nba2V5XSkpIHtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlQ29tcG9uZW50LCBrZXkpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQXZvaWQgZmFpbHVyZXMgZnJvbSByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhvaXN0Tm9uUmVhY3RTdGF0aWNzO1xuIiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgaG9pc3ROb25SZWFjdFN0YXRpY3MgZnJvbSAnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnO1xuaW1wb3J0IHsgY2hhaW5Qcm9wVHlwZXMsIGdldERpc3BsYXlOYW1lIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCBtYWtlU3R5bGVzIGZyb20gJy4uL21ha2VTdHlsZXMnO1xuaW1wb3J0IGdldFRoZW1lUHJvcHMgZnJvbSAnLi4vZ2V0VGhlbWVQcm9wcyc7XG5pbXBvcnQgdXNlVGhlbWUgZnJvbSAnLi4vdXNlVGhlbWUnOyAvLyBMaW5rIGEgc3R5bGUgc2hlZXQgd2l0aCBhIGNvbXBvbmVudC5cbi8vIEl0IGRvZXMgbm90IG1vZGlmeSB0aGUgY29tcG9uZW50IHBhc3NlZCB0byBpdDtcbi8vIGluc3RlYWQsIGl0IHJldHVybnMgYSBuZXcgY29tcG9uZW50LCB3aXRoIGEgYGNsYXNzZXNgIHByb3BlcnR5LlxuXG52YXIgd2l0aFN0eWxlcyA9IGZ1bmN0aW9uIHdpdGhTdHlsZXMoc3R5bGVzT3JDcmVhdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChDb21wb25lbnQpIHtcbiAgICB2YXIgZGVmYXVsdFRoZW1lID0gb3B0aW9ucy5kZWZhdWx0VGhlbWUsXG4gICAgICAgIF9vcHRpb25zJHdpdGhUaGVtZSA9IG9wdGlvbnMud2l0aFRoZW1lLFxuICAgICAgICB3aXRoVGhlbWUgPSBfb3B0aW9ucyR3aXRoVGhlbWUgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkd2l0aFRoZW1lLFxuICAgICAgICBuYW1lID0gb3B0aW9ucy5uYW1lLFxuICAgICAgICBzdHlsZXNPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9wdGlvbnMsIFtcImRlZmF1bHRUaGVtZVwiLCBcIndpdGhUaGVtZVwiLCBcIm5hbWVcIl0pO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChDb21wb25lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoWydZb3UgYXJlIGNhbGxpbmcgd2l0aFN0eWxlcyhzdHlsZXMpKENvbXBvbmVudCkgd2l0aCBhbiB1bmRlZmluZWQgY29tcG9uZW50LicsICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGltcG9ydCBpdC4nXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNsYXNzTmFtZVByZWZpeCA9IG5hbWU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIC8vIFByb3ZpZGUgYSBiZXR0ZXIgRFggb3V0c2lkZSBwcm9kdWN0aW9uLlxuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpO1xuXG4gICAgICAgIGlmIChkaXNwbGF5TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2xhc3NOYW1lUHJlZml4ID0gZGlzcGxheU5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdXNlU3R5bGVzID0gbWFrZVN0eWxlcyhzdHlsZXNPckNyZWF0b3IsIF9leHRlbmRzKHtcbiAgICAgIGRlZmF1bHRUaGVtZTogZGVmYXVsdFRoZW1lLFxuICAgICAgQ29tcG9uZW50OiBDb21wb25lbnQsXG4gICAgICBuYW1lOiBuYW1lIHx8IENvbXBvbmVudC5kaXNwbGF5TmFtZSxcbiAgICAgIGNsYXNzTmFtZVByZWZpeDogY2xhc3NOYW1lUHJlZml4XG4gICAgfSwgc3R5bGVzT3B0aW9ucykpO1xuICAgIHZhciBXaXRoU3R5bGVzID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gV2l0aFN0eWxlcyhwcm9wcywgcmVmKSB7XG4gICAgICB2YXIgY2xhc3Nlc1Byb3AgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgICAgIGlubmVyUmVmID0gcHJvcHMuaW5uZXJSZWYsXG4gICAgICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNsYXNzZXNcIiwgXCJpbm5lclJlZlwiXSk7IC8vIFRoZSB3cmFwcGVyIHJlY2VpdmVzIG9ubHkgdXNlciBzdXBwbGllZCBwcm9wcywgd2hpY2ggY291bGQgYmUgYSBzdWJzZXQgb2ZcbiAgICAgIC8vIHRoZSBhY3R1YWwgcHJvcHMgQ29tcG9uZW50IG1pZ2h0IHJlY2VpdmUgZHVlIHRvIG1lcmdpbmcgd2l0aCBkZWZhdWx0UHJvcHMuXG4gICAgICAvLyBTbyBjb3B5aW5nIGl0IGhlcmUgd291bGQgZ2l2ZSB1cyB0aGUgc2FtZSByZXN1bHQgaW4gdGhlIHdyYXBwZXIgYXMgd2VsbC5cblxuXG4gICAgICB2YXIgY2xhc3NlcyA9IHVzZVN0eWxlcyhfZXh0ZW5kcyh7fSwgQ29tcG9uZW50LmRlZmF1bHRQcm9wcywgcHJvcHMpKTtcbiAgICAgIHZhciB0aGVtZTtcbiAgICAgIHZhciBtb3JlID0gb3RoZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgfHwgd2l0aFRoZW1lKSB7XG4gICAgICAgIC8vIG5hbWUgYW5kIHdpdGhUaGVtZSBhcmUgaW52YXJpYW50IGluIHRoZSBvdXRlciBzY29wZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgdGhlbWUgPSB1c2VUaGVtZSgpIHx8IGRlZmF1bHRUaGVtZTtcblxuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgIG1vcmUgPSBnZXRUaGVtZVByb3BzKHtcbiAgICAgICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBwcm9wczogb3RoZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBQcm92aWRlIHRoZSB0aGVtZSB0byB0aGUgd3JhcHBlZCBjb21wb25lbnQuXG4gICAgICAgIC8vIFNvIHdlIGRvbid0IGhhdmUgdG8gdXNlIHRoZSBgd2l0aFRoZW1lKClgIEhpZ2hlci1vcmRlciBDb21wb25lbnQuXG5cblxuICAgICAgICBpZiAod2l0aFRoZW1lICYmICFtb3JlLnRoZW1lKSB7XG4gICAgICAgICAgbW9yZS50aGVtZSA9IHRoZW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICAgICAgcmVmOiBpbm5lclJlZiB8fCByZWYsXG4gICAgICAgIGNsYXNzZXM6IGNsYXNzZXNcbiAgICAgIH0sIG1vcmUpKTtcbiAgICB9KTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBXaXRoU3R5bGVzLnByb3BUeXBlcyA9IHtcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgICAgICovXG4gICAgICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZSB0aGF0IHByb3AgdG8gcGFzcyBhIHJlZiB0byB0aGUgZGVjb3JhdGVkIGNvbXBvbmVudC5cbiAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgKi9cbiAgICAgIGlubmVyUmVmOiBjaGFpblByb3BUeXBlcyhQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm9iamVjdF0pLCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzLmlubmVyUmVmID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsOyAvLyByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAvLyAgICdNYXRlcmlhbC1VSTogVGhlIGBpbm5lclJlZmAgcHJvcCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjUuICcgK1xuICAgICAgICAvLyAgICAgJ1JlZnMgYXJlIG5vdyBhdXRvbWF0aWNhbGx5IGZvcndhcmRlZCB0byB0aGUgaW5uZXIgY29tcG9uZW50LicsXG4gICAgICAgIC8vICk7XG4gICAgICB9KVxuICAgIH0gOiB2b2lkIDA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgV2l0aFN0eWxlcy5kaXNwbGF5TmFtZSA9IFwiV2l0aFN0eWxlcyhcIi5jb25jYXQoZ2V0RGlzcGxheU5hbWUoQ29tcG9uZW50KSwgXCIpXCIpO1xuICAgIH1cblxuICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKFdpdGhTdHlsZXMsIENvbXBvbmVudCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gRXhwb3NlZCBmb3IgdGVzdCBwdXJwb3Nlcy5cbiAgICAgIFdpdGhTdHlsZXMuTmFrZWQgPSBDb21wb25lbnQ7XG4gICAgICBXaXRoU3R5bGVzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgV2l0aFN0eWxlcy51c2VTdHlsZXMgPSB1c2VTdHlsZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFdpdGhTdHlsZXM7XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzOyIsImltcG9ydCBjcmVhdGVUaGVtZSBmcm9tICcuL2NyZWF0ZVRoZW1lJztcbnZhciBkZWZhdWx0VGhlbWUgPSBjcmVhdGVUaGVtZSgpO1xuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdFRoZW1lOyIsImltcG9ydCB7IHVzZVRoZW1lIGFzIHVzZVRoZW1lV2l0aG91dERlZmF1bHQgfSBmcm9tICdAbWF0ZXJpYWwtdWkvc3R5bGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZGVmYXVsdFRoZW1lIGZyb20gJy4vZGVmYXVsdFRoZW1lJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZVRoZW1lKCkge1xuICB2YXIgdGhlbWUgPSB1c2VUaGVtZVdpdGhvdXREZWZhdWx0KCkgfHwgZGVmYXVsdFRoZW1lO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlRGVidWdWYWx1ZSh0aGVtZSk7XG4gIH1cblxuICByZXR1cm4gdGhlbWU7XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgeyB3aXRoU3R5bGVzIGFzIHdpdGhTdHlsZXNXaXRob3V0RGVmYXVsdCB9IGZyb20gJ0BtYXRlcmlhbC11aS9zdHlsZXMnO1xuaW1wb3J0IGRlZmF1bHRUaGVtZSBmcm9tICcuL2RlZmF1bHRUaGVtZSc7XG5cbmZ1bmN0aW9uIHdpdGhTdHlsZXMoc3R5bGVzT3JDcmVhdG9yLCBvcHRpb25zKSB7XG4gIHJldHVybiB3aXRoU3R5bGVzV2l0aG91dERlZmF1bHQoc3R5bGVzT3JDcmVhdG9yLCBfZXh0ZW5kcyh7XG4gICAgZGVmYXVsdFRoZW1lOiBkZWZhdWx0VGhlbWVcbiAgfSwgb3B0aW9ucykpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzOyIsIi8qKiFcbiAqIEBmaWxlT3ZlcnZpZXcgS2lja2FzcyBsaWJyYXJ5IHRvIGNyZWF0ZSBhbmQgcGxhY2UgcG9wcGVycyBuZWFyIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50cy5cbiAqIEB2ZXJzaW9uIDEuMTYuMS1sdHNcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmVkZXJpY28gWml2b2xvIGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJztcblxudmFyIHRpbWVvdXREdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxvbmdlclRpbWVvdXRCcm93c2VycyA9IFsnRWRnZScsICdUcmlkZW50JywgJ0ZpcmVmb3gnXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb25nZXJUaW1lb3V0QnJvd3NlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoaXNCcm93c2VyICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihsb25nZXJUaW1lb3V0QnJvd3NlcnNbaV0pID49IDApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn0oKTtcblxuZnVuY3Rpb24gbWljcm90YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB3aW5kb3cuUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGZuKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRhc2tEZWJvdW5jZShmbikge1xuICB2YXIgc2NoZWR1bGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIGZuKCk7XG4gICAgICB9LCB0aW1lb3V0RHVyYXRpb24pO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHN1cHBvcnRzTWljcm9UYXNrcyA9IGlzQnJvd3NlciAmJiB3aW5kb3cuUHJvbWlzZTtcblxuLyoqXG4qIENyZWF0ZSBhIGRlYm91bmNlZCB2ZXJzaW9uIG9mIGEgbWV0aG9kLCB0aGF0J3MgYXN5bmNocm9ub3VzbHkgZGVmZXJyZWRcbiogYnV0IGNhbGxlZCBpbiB0aGUgbWluaW11bSB0aW1lIHBvc3NpYmxlLlxuKlxuKiBAbWV0aG9kXG4qIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiogQGFyZ3VtZW50IHtGdW5jdGlvbn0gZm5cbiogQHJldHVybnMge0Z1bmN0aW9ufVxuKi9cbnZhciBkZWJvdW5jZSA9IHN1cHBvcnRzTWljcm9UYXNrcyA/IG1pY3JvdGFza0RlYm91bmNlIDogdGFza0RlYm91bmNlO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FueX0gZnVuY3Rpb25Ub0NoZWNrIC0gdmFyaWFibGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG86IGlzIGEgZnVuY3Rpb24/XG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG4gIHZhciBnZXRUeXBlID0ge307XG4gIHJldHVybiBmdW5jdGlvblRvQ2hlY2sgJiYgZ2V0VHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogR2V0IENTUyBjb21wdXRlZCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIHdpbmRvdyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgdmFyIGNzcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICByZXR1cm4gcHJvcGVydHkgPyBjc3NbcHJvcGVydHldIDogY3NzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcmVudE5vZGUgb3IgdGhlIGhvc3Qgb2YgdGhlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjcm9sbGluZyBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHNjcm9sbCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gUmV0dXJuIGJvZHksIGBnZXRTY3JvbGxgIHdpbGwgdGFrZSBjYXJlIHRvIGdldCB0aGUgY29ycmVjdCBgc2Nyb2xsVG9wYCBmcm9tIGl0XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgc3dpdGNoIChlbGVtZW50Lm5vZGVOYW1lKSB7XG4gICAgY2FzZSAnSFRNTCc6XG4gICAgY2FzZSAnQk9EWSc6XG4gICAgICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgIHJldHVybiBlbGVtZW50LmJvZHk7XG4gIH1cblxuICAvLyBGaXJlZm94IHdhbnQgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcblxuICB2YXIgX2dldFN0eWxlQ29tcHV0ZWRQcm9wID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WTtcblxuICBpZiAoLyhhdXRvfHNjcm9sbHxvdmVybGF5KS8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVmZXJlbmNlIG5vZGUgb2YgdGhlIHJlZmVyZW5jZSBvYmplY3QsIG9yIHRoZSByZWZlcmVuY2Ugb2JqZWN0IGl0c2VsZi5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSB7XG4gIHJldHVybiByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLnJlZmVyZW5jZU5vZGUgPyByZWZlcmVuY2UucmVmZXJlbmNlTm9kZSA6IHJlZmVyZW5jZTtcbn1cblxudmFyIGlzSUUxMSA9IGlzQnJvd3NlciAmJiAhISh3aW5kb3cuTVNJbnB1dE1ldGhvZENvbnRleHQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcbnZhciBpc0lFMTAgPSBpc0Jyb3dzZXIgJiYgL01TSUUgMTAvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3JlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZlcnNpb24gdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpc0lFXG4gKi9cbmZ1bmN0aW9uIGlzSUUodmVyc2lvbikge1xuICBpZiAodmVyc2lvbiA9PT0gMTEpIHtcbiAgICByZXR1cm4gaXNJRTExO1xuICB9XG4gIGlmICh2ZXJzaW9uID09PSAxMCkge1xuICAgIHJldHVybiBpc0lFMTA7XG4gIH1cbiAgcmV0dXJuIGlzSUUxMSB8fCBpc0lFMTA7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb2Zmc2V0IHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgdmFyIG5vT2Zmc2V0UGFyZW50ID0gaXNJRSgxMCkgPyBkb2N1bWVudC5ib2R5IDogbnVsbDtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgbnVsbDtcbiAgLy8gU2tpcCBoaWRkZW4gZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhbiBvZmZzZXRQYXJlbnRcbiAgd2hpbGUgKG9mZnNldFBhcmVudCA9PT0gbm9PZmZzZXRQYXJlbnQgJiYgZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSAoZWxlbWVudCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5vZmZzZXRQYXJlbnQ7XG4gIH1cblxuICB2YXIgbm9kZU5hbWUgPSBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50Lm5vZGVOYW1lO1xuXG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBUSCwgVEQgb3IgVEFCTEUgaW4gY2FzZVxuICAvLyBubyBvZmZzZXRQYXJlbnQgaXMgcHJlc2VudCwgSSBoYXRlIHRoaXMgam9iLi4uXG4gIGlmIChbJ1RIJywgJ1REJywgJ1RBQkxFJ10uaW5kZXhPZihvZmZzZXRQYXJlbnQubm9kZU5hbWUpICE9PSAtMSAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50O1xufVxuXG5mdW5jdGlvbiBpc09mZnNldENvbnRhaW5lcihlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnSFRNTCcgfHwgZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBlbGVtZW50O1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSByb290IG5vZGUgKGRvY3VtZW50LCBzaGFkb3dET00gcm9vdCkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0VsZW1lbnR9IHJvb3Qgbm9kZVxuICovXG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRSb290KG5vZGUucGFyZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgb2Zmc2V0IHBhcmVudCBjb21tb24gdG8gdGhlIHR3byBwcm92aWRlZCBub2Rlc1xuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MVxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MlxuICogQHJldHVybnMge0VsZW1lbnR9IGNvbW1vbiBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGVsZW1lbnQyKSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQxIHx8ICFlbGVtZW50MS5ub2RlVHlwZSB8fCAhZWxlbWVudDIgfHwgIWVsZW1lbnQyLm5vZGVUeXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIEhlcmUgd2UgbWFrZSBzdXJlIHRvIGdpdmUgYXMgXCJzdGFydFwiIHRoZSBlbGVtZW50IHRoYXQgY29tZXMgZmlyc3QgaW4gdGhlIERPTVxuICB2YXIgb3JkZXIgPSBlbGVtZW50MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50MikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgdmFyIHN0YXJ0ID0gb3JkZXIgPyBlbGVtZW50MSA6IGVsZW1lbnQyO1xuICB2YXIgZW5kID0gb3JkZXIgPyBlbGVtZW50MiA6IGVsZW1lbnQxO1xuXG4gIC8vIEdldCBjb21tb24gYW5jZXN0b3IgY29udGFpbmVyXG4gIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIHJhbmdlLnNldFN0YXJ0KHN0YXJ0LCAwKTtcbiAgcmFuZ2Uuc2V0RW5kKGVuZCwgMCk7XG4gIHZhciBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gIC8vIEJvdGggbm9kZXMgYXJlIGluc2lkZSAjZG9jdW1lbnRcblxuICBpZiAoZWxlbWVudDEgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyICYmIGVsZW1lbnQyICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciB8fCBzdGFydC5jb250YWlucyhlbmQpKSB7XG4gICAgaWYgKGlzT2Zmc2V0Q29udGFpbmVyKGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICB9XG5cbiAgLy8gb25lIG9mIHRoZSBub2RlcyBpcyBpbnNpZGUgc2hhZG93RE9NLCBmaW5kIHdoaWNoIG9uZVxuICB2YXIgZWxlbWVudDFyb290ID0gZ2V0Um9vdChlbGVtZW50MSk7XG4gIGlmIChlbGVtZW50MXJvb3QuaG9zdCkge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxcm9vdC5ob3N0LCBlbGVtZW50Mik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGdldFJvb3QoZWxlbWVudDIpLmhvc3QpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50IGluIHRoZSBnaXZlbiBzaWRlICh0b3AgYW5kIGxlZnQpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzaWRlIGB0b3BgIG9yIGBsZWZ0YFxuICogQHJldHVybnMge251bWJlcn0gYW1vdW50IG9mIHNjcm9sbGVkIHBpeGVsc1xuICovXG5mdW5jdGlvbiBnZXRTY3JvbGwoZWxlbWVudCkge1xuICB2YXIgc2lkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3RvcCc7XG5cbiAgdmFyIHVwcGVyU2lkZSA9IHNpZGUgPT09ICd0b3AnID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGh0bWw7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnRbdXBwZXJTaWRlXTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50W3VwcGVyU2lkZV07XG59XG5cbi8qXG4gKiBTdW0gb3Igc3VidHJhY3QgdGhlIGVsZW1lbnQgc2Nyb2xsIHZhbHVlcyAobGVmdCBhbmQgdG9wKSBmcm9tIGEgZ2l2ZW4gcmVjdCBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IC0gUmVjdCBvYmplY3QgeW91IHdhbnQgdG8gY2hhbmdlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgZnJvbSB0aGUgZnVuY3Rpb24gcmVhZHMgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VidHJhY3QgLSBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBzdWJ0cmFjdCB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHJldHVybiB7T2JqZWN0fSByZWN0IC0gVGhlIG1vZGlmaWVyIHJlY3Qgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVTY3JvbGwocmVjdCwgZWxlbWVudCkge1xuICB2YXIgc3VidHJhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICB2YXIgbW9kaWZpZXIgPSBzdWJ0cmFjdCA/IC0xIDogMTtcbiAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbi8qXG4gKiBIZWxwZXIgdG8gZGV0ZWN0IGJvcmRlcnMgb2YgYSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xuICogUmVzdWx0IG9mIGBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHlgIG9uIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYXhpcyAtIGB4YCBvciBgeWBcbiAqIEByZXR1cm4ge251bWJlcn0gYm9yZGVycyAtIFRoZSBib3JkZXJzIHNpemUgb2YgdGhlIGdpdmVuIGF4aXNcbiAqL1xuXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsIGF4aXMpIHtcbiAgdmFyIHNpZGVBID0gYXhpcyA9PT0gJ3gnID8gJ0xlZnQnIDogJ1RvcCc7XG4gIHZhciBzaWRlQiA9IHNpZGVBID09PSAnTGVmdCcgPyAnUmlnaHQnIDogJ0JvdHRvbSc7XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUEgKyAnV2lkdGgnXSkgKyBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVCICsgJ1dpZHRoJ10pO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplKGF4aXMsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGJvZHlbJ29mZnNldCcgKyBheGlzXSwgYm9keVsnc2Nyb2xsJyArIGF4aXNdLCBodG1sWydjbGllbnQnICsgYXhpc10sIGh0bWxbJ29mZnNldCcgKyBheGlzXSwgaHRtbFsnc2Nyb2xsJyArIGF4aXNdLCBpc0lFKDEwKSA/IHBhcnNlSW50KGh0bWxbJ29mZnNldCcgKyBheGlzXSkgKyBwYXJzZUludChjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ1RvcCcgOiAnTGVmdCcpXSkgKyBwYXJzZUludChjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ0JvdHRvbScgOiAnUmlnaHQnKV0pIDogMCk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1NpemVzKGRvY3VtZW50KSB7XG4gIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgdmFyIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gaXNJRSgxMCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShodG1sKTtcblxuICByZXR1cm4ge1xuICAgIGhlaWdodDogZ2V0U2l6ZSgnSGVpZ2h0JywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSksXG4gICAgd2lkdGg6IGdldFNpemUoJ1dpZHRoJywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSlcbiAgfTtcbn1cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdpdmVuIGVsZW1lbnQgb2Zmc2V0cywgZ2VuZXJhdGUgYW4gb3V0cHV0IHNpbWlsYXIgdG8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gb2Zmc2V0c1xuICogQHJldHVybnMge09iamVjdH0gQ2xpZW50UmVjdCBsaWtlIG91dHB1dFxuICovXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0KG9mZnNldHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBvZmZzZXRzLCB7XG4gICAgcmlnaHQ6IG9mZnNldHMubGVmdCArIG9mZnNldHMud2lkdGgsXG4gICAgYm90dG9tOiBvZmZzZXRzLnRvcCArIG9mZnNldHMuaGVpZ2h0XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBib3VuZGluZyBjbGllbnQgcmVjdCBvZiBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9IGNsaWVudCByZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0ge307XG5cbiAgLy8gSUUxMCAxMCBGSVg6IFBsZWFzZSwgZG9uJ3QgYXNrLCB0aGUgZWxlbWVudCBpc24ndFxuICAvLyBjb25zaWRlcmVkIGluIERPTSBpbiBzb21lIGNpcmN1bXN0YW5jZXMuLi5cbiAgLy8gVGhpcyBpc24ndCByZXByb2R1Y2libGUgaW4gSUUxMCBjb21wYXRpYmlsaXR5IG1vZGUgb2YgSUUxMVxuICB0cnkge1xuICAgIGlmIChpc0lFKDEwKSkge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gICAgICByZWN0LnRvcCArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdDtcbiAgICAgIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gIH07XG5cbiAgLy8gc3VidHJhY3Qgc2Nyb2xsYmFyIHNpemUgZnJvbSBzaXplc1xuICB2YXIgc2l6ZXMgPSBlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcgPyBnZXRXaW5kb3dTaXplcyhlbGVtZW50Lm93bmVyRG9jdW1lbnQpIDoge307XG4gIHZhciB3aWR0aCA9IHNpemVzLndpZHRoIHx8IGVsZW1lbnQuY2xpZW50V2lkdGggfHwgcmVzdWx0LndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gc2l6ZXMuaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IHJlc3VsdC5oZWlnaHQ7XG5cbiAgdmFyIGhvcml6U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIHdpZHRoO1xuICB2YXIgdmVydFNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gaGVpZ2h0O1xuXG4gIC8vIGlmIGFuIGh5cG90aGV0aWNhbCBzY3JvbGxiYXIgaXMgZGV0ZWN0ZWQsIHdlIG11c3QgYmUgc3VyZSBpdCdzIG5vdCBhIGBib3JkZXJgXG4gIC8vIHdlIG1ha2UgdGhpcyBjaGVjayBjb25kaXRpb25hbCBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICBpZiAoaG9yaXpTY3JvbGxiYXIgfHwgdmVydFNjcm9sbGJhcikge1xuICAgIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCk7XG4gICAgaG9yaXpTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneCcpO1xuICAgIHZlcnRTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneScpO1xuXG4gICAgcmVzdWx0LndpZHRoIC09IGhvcml6U2Nyb2xsYmFyO1xuICAgIHJlc3VsdC5oZWlnaHQgLT0gdmVydFNjcm9sbGJhcjtcbiAgfVxuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShjaGlsZHJlbiwgcGFyZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICB2YXIgaXNJRTEwID0gaXNJRSgxMCk7XG4gIHZhciBpc0hUTUwgPSBwYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJztcbiAgdmFyIGNoaWxkcmVuUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChjaGlsZHJlbik7XG4gIHZhciBwYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHBhcmVudCk7XG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoY2hpbGRyZW4pO1xuXG4gIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkocGFyZW50KTtcbiAgdmFyIGJvcmRlclRvcFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyVG9wV2lkdGgpO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKTtcblxuICAvLyBJbiBjYXNlcyB3aGVyZSB0aGUgcGFyZW50IGlzIGZpeGVkLCB3ZSBtdXN0IGlnbm9yZSBuZWdhdGl2ZSBzY3JvbGwgaW4gb2Zmc2V0IGNhbGNcbiAgaWYgKGZpeGVkUG9zaXRpb24gJiYgaXNIVE1MKSB7XG4gICAgcGFyZW50UmVjdC50b3AgPSBNYXRoLm1heChwYXJlbnRSZWN0LnRvcCwgMCk7XG4gICAgcGFyZW50UmVjdC5sZWZ0ID0gTWF0aC5tYXgocGFyZW50UmVjdC5sZWZ0LCAwKTtcbiAgfVxuICB2YXIgb2Zmc2V0cyA9IGdldENsaWVudFJlY3Qoe1xuICAgIHRvcDogY2hpbGRyZW5SZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wIC0gYm9yZGVyVG9wV2lkdGgsXG4gICAgbGVmdDogY2hpbGRyZW5SZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQgLSBib3JkZXJMZWZ0V2lkdGgsXG4gICAgd2lkdGg6IGNoaWxkcmVuUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IGNoaWxkcmVuUmVjdC5oZWlnaHRcbiAgfSk7XG4gIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gMDtcblxuICAvLyBTdWJ0cmFjdCBtYXJnaW5zIG9mIGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGl0J3MgYmVpbmcgdXNlZCBhcyBwYXJlbnRcbiAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gIC8vIHRoZSBib3ggb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgaW4gdGhlIG90aGVyIGNhc2VzIG5vdC5cbiAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCk7XG4gICAgdmFyIG1hcmdpbkxlZnQgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0KTtcblxuICAgIG9mZnNldHMudG9wIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMuYm90dG9tIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubGVmdCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuICAgIG9mZnNldHMucmlnaHQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcblxuICAgIC8vIEF0dGFjaCBtYXJnaW5Ub3AgYW5kIG1hcmdpbkxlZnQgYmVjYXVzZSBpbiBzb21lIGNpcmN1bXN0YW5jZXMgd2UgbWF5IG5lZWQgdGhlbVxuICAgIG9mZnNldHMubWFyZ2luVG9wID0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubWFyZ2luTGVmdCA9IG1hcmdpbkxlZnQ7XG4gIH1cblxuICBpZiAoaXNJRTEwICYmICFmaXhlZFBvc2l0aW9uID8gcGFyZW50LmNvbnRhaW5zKHNjcm9sbFBhcmVudCkgOiBwYXJlbnQgPT09IHNjcm9sbFBhcmVudCAmJiBzY3JvbGxQYXJlbnQubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgIG9mZnNldHMgPSBpbmNsdWRlU2Nyb2xsKG9mZnNldHMsIHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKGVsZW1lbnQpIHtcbiAgdmFyIGV4Y2x1ZGVTY3JvbGwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGVsZW1lbnQsIGh0bWwpO1xuICB2YXIgd2lkdGggPSBNYXRoLm1heChodG1sLmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGh0bWwuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG5cbiAgdmFyIHNjcm9sbFRvcCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwpIDogMDtcbiAgdmFyIHNjcm9sbExlZnQgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sLCAnbGVmdCcpIDogMDtcblxuICB2YXIgb2Zmc2V0ID0ge1xuICAgIHRvcDogc2Nyb2xsVG9wIC0gcmVsYXRpdmVPZmZzZXQudG9wICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luVG9wLFxuICAgIGxlZnQ6IHNjcm9sbExlZnQgLSByZWxhdGl2ZU9mZnNldC5sZWZ0ICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luTGVmdCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChvZmZzZXQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGZpeGVkIG9yIGlzIGluc2lkZSBhIGZpeGVkIHBhcmVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGN1c3RvbUNvbnRhaW5lclxuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0byBcImlzRml4ZWQ/XCJcbiAqL1xuZnVuY3Rpb24gaXNGaXhlZChlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkKHBhcmVudE5vZGUpO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBwYXJlbnQgb2YgYW4gZWxlbWVudCB0aGF0IGhhcyBhIHRyYW5zZm9ybWVkIHByb3BlcnR5IGRlZmluZWRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IGZpcnN0IHRyYW5zZm9ybWVkIHBhcmVudCBvciBkb2N1bWVudEVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnRFbGVtZW50IHx8IGlzSUUoKSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cbiAgdmFyIGVsID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICB3aGlsZSAoZWwgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsLCAndHJhbnNmb3JtJykgPT09ICdub25lJykge1xuICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWwgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xufVxuXG4vKipcbiAqIENvbXB1dGVkIHRoZSBib3VuZGFyaWVzIGxpbWl0cyBhbmQgcmV0dXJuIHRoZW1cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQgLSBFbGVtZW50IHVzZWQgdG8gZGVmaW5lIHRoZSBib3VuZGFyaWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZpeGVkUG9zaXRpb24gLSBJcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgYm91bmRhcmllc1xuICovXG5mdW5jdGlvbiBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcblxuICB2YXIgYm91bmRhcmllcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSk7XG5cbiAgLy8gSGFuZGxlIHZpZXdwb3J0IGNhc2VcbiAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgYm91bmRhcmllcyA9IGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIEhhbmRsZSBvdGhlciBjYXNlcyBiYXNlZCBvbiBET00gZWxlbWVudCB1c2VkIGFzIGJvdW5kYXJpZXNcbiAgICB2YXIgYm91bmRhcmllc05vZGUgPSB2b2lkIDA7XG4gICAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShyZWZlcmVuY2UpKTtcbiAgICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd3aW5kb3cnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBib3VuZGFyaWVzRWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0cyA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShib3VuZGFyaWVzTm9kZSwgb2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcblxuICAgIC8vIEluIGNhc2Ugb2YgSFRNTCwgd2UgbmVlZCBhIGRpZmZlcmVudCBjb21wdXRhdGlvblxuICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnICYmICFpc0ZpeGVkKG9mZnNldFBhcmVudCkpIHtcbiAgICAgIHZhciBfZ2V0V2luZG93U2l6ZXMgPSBnZXRXaW5kb3dTaXplcyhwb3BwZXIub3duZXJEb2N1bWVudCksXG4gICAgICAgICAgaGVpZ2h0ID0gX2dldFdpbmRvd1NpemVzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcblxuICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gaGVpZ2h0ICsgb2Zmc2V0cy50b3A7XG4gICAgICBib3VuZGFyaWVzLmxlZnQgKz0gb2Zmc2V0cy5sZWZ0IC0gb2Zmc2V0cy5tYXJnaW5MZWZ0O1xuICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgYWxsIHRoZSBvdGhlciBET00gZWxlbWVudHMsIHRoaXMgb25lIGlzIGdvb2RcbiAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nc1xuICBwYWRkaW5nID0gcGFkZGluZyB8fCAwO1xuICB2YXIgaXNQYWRkaW5nTnVtYmVyID0gdHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInO1xuICBib3VuZGFyaWVzLmxlZnQgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcubGVmdCB8fCAwO1xuICBib3VuZGFyaWVzLnRvcCArPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy50b3AgfHwgMDtcbiAgYm91bmRhcmllcy5yaWdodCAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5yaWdodCB8fCAwO1xuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5ib3R0b20gfHwgMDtcblxuICByZXR1cm4gYm91bmRhcmllcztcbn1cblxuZnVuY3Rpb24gZ2V0QXJlYShfcmVmKSB7XG4gIHZhciB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodDtcblxuICByZXR1cm4gd2lkdGggKiBoZWlnaHQ7XG59XG5cbi8qKlxuICogVXRpbGl0eSB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgYGF1dG9gIHBsYWNlbWVudCB0byB0aGUgcGxhY2VtZW50IHdpdGggbW9yZVxuICogYXZhaWxhYmxlIHNwYWNlLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQocGxhY2VtZW50LCByZWZSZWN0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG5cbiAgaWYgKHBsYWNlbWVudC5pbmRleE9mKCdhdXRvJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpO1xuXG4gIHZhciByZWN0cyA9IHtcbiAgICB0b3A6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWZSZWN0LnRvcCAtIGJvdW5kYXJpZXMudG9wXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMucmlnaHQgLSByZWZSZWN0LnJpZ2h0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5ib3R0b20gLSByZWZSZWN0LmJvdHRvbVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgd2lkdGg6IHJlZlJlY3QubGVmdCAtIGJvdW5kYXJpZXMubGVmdCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNvcnRlZEFyZWFzID0gT2JqZWN0LmtleXMocmVjdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleToga2V5XG4gICAgfSwgcmVjdHNba2V5XSwge1xuICAgICAgYXJlYTogZ2V0QXJlYShyZWN0c1trZXldKVxuICAgIH0pO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuYXJlYSAtIGEuYXJlYTtcbiAgfSk7XG5cbiAgdmFyIGZpbHRlcmVkQXJlYXMgPSBzb3J0ZWRBcmVhcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodDtcbiAgICByZXR1cm4gd2lkdGggPj0gcG9wcGVyLmNsaWVudFdpZHRoICYmIGhlaWdodCA+PSBwb3BwZXIuY2xpZW50SGVpZ2h0O1xuICB9KTtcblxuICB2YXIgY29tcHV0ZWRQbGFjZW1lbnQgPSBmaWx0ZXJlZEFyZWFzLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZEFyZWFzWzBdLmtleSA6IHNvcnRlZEFyZWFzWzBdLmtleTtcblxuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgcmV0dXJuIGNvbXB1dGVkUGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7RWxlbWVudH0gZml4ZWRQb3NpdGlvbiAtIGlzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlKSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHZhciBjb21tb25PZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSk7XG4gIHJldHVybiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUocmVmZXJlbmNlLCBjb21tb25PZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3V0ZXIgc2l6ZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQgKG9mZnNldCBzaXplICsgbWFyZ2lucylcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVyU2l6ZXMoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wIHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luQm90dG9tIHx8IDApO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCB8fCAwKTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksXG4gICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCArIHhcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudFxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgdmFyIGhhc2ggPSB7IGxlZnQ6ICdyaWdodCcsIHJpZ2h0OiAnbGVmdCcsIGJvdHRvbTogJ3RvcCcsIHRvcDogJ2JvdHRvbScgfTtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0gQ1NTIHBvc2l0aW9uIHRoZSBQb3BwZXIgd2lsbCBnZXQgYXBwbGllZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0cyAtIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhY2VtZW50IC0gb25lIG9mIHRoZSB2YWxpZCBwbGFjZW1lbnQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gcG9wcGVyT2Zmc2V0cyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFBvcHBlck9mZnNldHMocG9wcGVyLCByZWZlcmVuY2VPZmZzZXRzLCBwbGFjZW1lbnQpIHtcbiAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgLy8gR2V0IHBvcHBlciBub2RlIHNpemVzXG4gIHZhciBwb3BwZXJSZWN0ID0gZ2V0T3V0ZXJTaXplcyhwb3BwZXIpO1xuXG4gIC8vIEFkZCBwb3NpdGlvbiwgd2lkdGggYW5kIGhlaWdodCB0byBvdXIgb2Zmc2V0cyBvYmplY3RcbiAgdmFyIHBvcHBlck9mZnNldHMgPSB7XG4gICAgd2lkdGg6IHBvcHBlclJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBwb3BwZXJSZWN0LmhlaWdodFxuICB9O1xuXG4gIC8vIGRlcGVuZGluZyBieSB0aGUgcG9wcGVyIHBsYWNlbWVudCB3ZSBoYXZlIHRvIGNvbXB1dGUgaXRzIG9mZnNldHMgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgdmFyIGlzSG9yaXogPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgbWFpblNpZGUgPSBpc0hvcml6ID8gJ3RvcCcgOiAnbGVmdCc7XG4gIHZhciBzZWNvbmRhcnlTaWRlID0gaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2Vjb25kYXJ5TWVhc3VyZW1lbnQgPSAhaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBwb3BwZXJPZmZzZXRzW21haW5TaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbbWFpblNpZGVdICsgcmVmZXJlbmNlT2Zmc2V0c1ttZWFzdXJlbWVudF0gLyAyIC0gcG9wcGVyUmVjdFttZWFzdXJlbWVudF0gLyAyO1xuICBpZiAocGxhY2VtZW50ID09PSBzZWNvbmRhcnlTaWRlKSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gLSBwb3BwZXJSZWN0W3NlY29uZGFyeU1lYXN1cmVtZW50XTtcbiAgfSBlbHNlIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tnZXRPcHBvc2l0ZVBsYWNlbWVudChzZWNvbmRhcnlTaWRlKV07XG4gIH1cblxuICByZXR1cm4gcG9wcGVyT2Zmc2V0cztcbn1cblxuLyoqXG4gKiBNaW1pY3MgdGhlIGBmaW5kYCBtZXRob2Qgb2YgQXJyYXlcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZChhcnIsIGNoZWNrKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgcmV0dXJuIGFyci5maW5kKGNoZWNrKTtcbiAgfVxuXG4gIC8vIHVzZSBgZmlsdGVyYCB0byBvYnRhaW4gdGhlIHNhbWUgYmVoYXZpb3Igb2YgYGZpbmRgXG4gIHJldHVybiBhcnIuZmlsdGVyKGNoZWNrKVswXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBtYXRjaGluZyBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFyciwgcHJvcCwgdmFsdWUpIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kSW5kZXggaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoZnVuY3Rpb24gKGN1cikge1xuICAgICAgcmV0dXJuIGN1cltwcm9wXSA9PT0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvLyB1c2UgYGZpbmRgICsgYGluZGV4T2ZgIGlmIGBmaW5kSW5kZXhgIGlzbid0IHN1cHBvcnRlZFxuICB2YXIgbWF0Y2ggPSBmaW5kKGFyciwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmpbcHJvcF0gPT09IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGFyci5pbmRleE9mKG1hdGNoKTtcbn1cblxuLyoqXG4gKiBMb29wIHRyb3VnaCB0aGUgbGlzdCBvZiBtb2RpZmllcnMgYW5kIHJ1biB0aGVtIGluIG9yZGVyLFxuICogZWFjaCBvZiB0aGVtIHdpbGwgdGhlbiBlZGl0IHRoZSBkYXRhIG9iamVjdC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5kcyAtIE9wdGlvbmFsIG1vZGlmaWVyIG5hbWUgdXNlZCBhcyBzdG9wcGVyXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH1cbiAqL1xuZnVuY3Rpb24gcnVuTW9kaWZpZXJzKG1vZGlmaWVycywgZGF0YSwgZW5kcykge1xuICB2YXIgbW9kaWZpZXJzVG9SdW4gPSBlbmRzID09PSB1bmRlZmluZWQgPyBtb2RpZmllcnMgOiBtb2RpZmllcnMuc2xpY2UoMCwgZmluZEluZGV4KG1vZGlmaWVycywgJ25hbWUnLCBlbmRzKSk7XG5cbiAgbW9kaWZpZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAobW9kaWZpZXJbJ2Z1bmN0aW9uJ10pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICBjb25zb2xlLndhcm4oJ2Btb2RpZmllci5mdW5jdGlvbmAgaXMgZGVwcmVjYXRlZCwgdXNlIGBtb2RpZmllci5mbmAhJyk7XG4gICAgfVxuICAgIHZhciBmbiA9IG1vZGlmaWVyWydmdW5jdGlvbiddIHx8IG1vZGlmaWVyLmZuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIGlmIChtb2RpZmllci5lbmFibGVkICYmIGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICAvLyBBZGQgcHJvcGVydGllcyB0byBvZmZzZXRzIHRvIG1ha2UgdGhlbSBhIGNvbXBsZXRlIGNsaWVudFJlY3Qgb2JqZWN0XG4gICAgICAvLyB3ZSBkbyB0aGlzIGJlZm9yZSBlYWNoIG1vZGlmaWVyIHRvIG1ha2Ugc3VyZSB0aGUgcHJldmlvdXMgb25lIGRvZXNuJ3RcbiAgICAgIC8vIG1lc3Mgd2l0aCB0aGVzZSB2YWx1ZXNcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuICAgICAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSk7XG5cbiAgICAgIGRhdGEgPSBmbihkYXRhLCBtb2RpZmllcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLCBjb21wdXRpbmcgdGhlIG5ldyBvZmZzZXRzIGFuZCBhcHBseWluZ1xuICogdGhlIG5ldyBzdHlsZS48YnIgLz5cbiAqIFByZWZlciBgc2NoZWR1bGVVcGRhdGVgIG92ZXIgYHVwZGF0ZWAgYmVjYXVzZSBvZiBwZXJmb3JtYW5jZSByZWFzb25zLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiB1cGRhdGUoKSB7XG4gIC8vIGlmIHBvcHBlciBpcyBkZXN0cm95ZWQsIGRvbid0IHBlcmZvcm0gYW55IGZ1cnRoZXIgdXBkYXRlXG4gIGlmICh0aGlzLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRhdGEgPSB7XG4gICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgc3R5bGVzOiB7fSxcbiAgICBhcnJvd1N0eWxlczoge30sXG4gICAgYXR0cmlidXRlczoge30sXG4gICAgZmxpcHBlZDogZmFsc2UsXG4gICAgb2Zmc2V0czoge31cbiAgfTtcblxuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZU9mZnNldHModGhpcy5zdGF0ZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIGRhdGEucGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQodGhpcy5vcHRpb25zLnBsYWNlbWVudCwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICAvLyBzdG9yZSB0aGUgY29tcHV0ZWQgcGxhY2VtZW50IGluc2lkZSBgb3JpZ2luYWxQbGFjZW1lbnRgXG4gIGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcblxuICBkYXRhLnBvc2l0aW9uRml4ZWQgPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZDtcblxuICAvLyBjb21wdXRlIHRoZSBwb3BwZXIgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0UG9wcGVyT2Zmc2V0cyh0aGlzLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIucG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnO1xuXG4gIC8vIHJ1biB0aGUgbW9kaWZpZXJzXG4gIGRhdGEgPSBydW5Nb2RpZmllcnModGhpcy5tb2RpZmllcnMsIGRhdGEpO1xuXG4gIC8vIHRoZSBmaXJzdCBgdXBkYXRlYCB3aWxsIGNhbGwgYG9uQ3JlYXRlYCBjYWxsYmFja1xuICAvLyB0aGUgb3RoZXIgb25lcyB3aWxsIGNhbGwgYG9uVXBkYXRlYCBjYWxsYmFja1xuICBpZiAoIXRoaXMuc3RhdGUuaXNDcmVhdGVkKSB7XG4gICAgdGhpcy5zdGF0ZS5pc0NyZWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy5vbkNyZWF0ZShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUoZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBpcyBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJFbmFibGVkKG1vZGlmaWVycywgbW9kaWZpZXJOYW1lKSB7XG4gIHJldHVybiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICBlbmFibGVkID0gX3JlZi5lbmFibGVkO1xuICAgIHJldHVybiBlbmFibGVkICYmIG5hbWUgPT09IG1vZGlmaWVyTmFtZTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmVmaXhlZCBzdXBwb3J0ZWQgcHJvcGVydHkgbmFtZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5IChjYW1lbENhc2UpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBwcmVmaXhlZCBwcm9wZXJ0eSAoY2FtZWxDYXNlIG9yIFBhc2NhbENhc2UsIGRlcGVuZGluZyBvbiB0aGUgdmVuZG9yIHByZWZpeClcbiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXhlcyA9IFtmYWxzZSwgJ21zJywgJ1dlYmtpdCcsICdNb3onLCAnTyddO1xuICB2YXIgdXBwZXJQcm9wID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgIHZhciB0b0NoZWNrID0gcHJlZml4ID8gJycgKyBwcmVmaXggKyB1cHBlclByb3AgOiBwcm9wZXJ0eTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGVbdG9DaGVja10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdG9DaGVjaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIHBvcHBlci5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXRseSBhc2tlZCBmb3IgdGhlIGRlbGV0aW9uIG9uIGRlc3Ryb3lcbiAgLy8gZG8gbm90IHVzZSBgcmVtb3ZlYCBiZWNhdXNlIElFMTEgZG9lc24ndCBzdXBwb3J0IGl0XG4gIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlT25EZXN0cm95KSB7XG4gICAgdGhpcy5wb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHBlcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogR2V0IHRoZSB3aW5kb3cgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyhlbGVtZW50KSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxQYXJlbnQsIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cykge1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50Lm5vZGVOYW1lID09PSAnQk9EWSc7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBzY3JvbGxQYXJlbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHNjcm9sbFBhcmVudDtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgaWYgKCFpc0JvZHkpIHtcbiAgICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoZ2V0U2Nyb2xsUGFyZW50KHRhcmdldC5wYXJlbnROb2RlKSwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKTtcbiAgfVxuICBzY3JvbGxQYXJlbnRzLnB1c2godGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBTZXR1cCBuZWVkZWQgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBvcHRpb25zLCBzdGF0ZSwgdXBkYXRlQm91bmQpIHtcbiAgLy8gUmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBzdGF0ZS51cGRhdGVCb3VuZCA9IHVwZGF0ZUJvdW5kO1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIC8vIFNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICB2YXIgc2Nyb2xsRWxlbWVudCA9IGdldFNjcm9sbFBhcmVudChyZWZlcmVuY2UpO1xuICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsRWxlbWVudCwgJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kLCBzdGF0ZS5zY3JvbGxQYXJlbnRzKTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IHNjcm9sbEVsZW1lbnQ7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSB0cnVlO1xuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIGFkZCByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgc3RhcnQgcmVjYWxjdWxhdGluZ1xuICogcG9zaXRpb24gb2YgdGhlIHBvcHBlciBlbGVtZW50IHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKCF0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICB0aGlzLnN0YXRlID0gc2V0dXBFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLCB0aGlzLnN0YXRlLCB0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBzdGF0ZSkge1xuICAvLyBSZW1vdmUgcmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG5cbiAgLy8gUmVtb3ZlIHNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG4gIH0pO1xuXG4gIC8vIFJlc2V0IHN0YXRlXG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gbnVsbDtcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IFtdO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGZhbHNlO1xuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCByZW1vdmUgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHdvbid0IHJlY2FsY3VsYXRlIHBvcHBlciBwb3NpdGlvblxuICogd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuIEl0IGFsc28gd29uJ3QgdHJpZ2dlciBgb25VcGRhdGVgIGNhbGxiYWNrIGFueW1vcmUsXG4gKiB1bmxlc3MgeW91IGNhbGwgYHVwZGF0ZWAgbWV0aG9kIG1hbnVhbGx5LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgICB0aGlzLnN0YXRlID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMuc3RhdGUpO1xuICB9XG59XG5cbi8qKlxuICogVGVsbHMgaWYgYSBnaXZlbiBpbnB1dCBpcyBhIG51bWJlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHsqfSBpbnB1dCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuIG4gIT09ICcnICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHN0eWxlIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB1bml0ID0gJyc7XG4gICAgLy8gYWRkIHVuaXQgaWYgdGhlIHZhbHVlIGlzIG51bWVyaWMgYW5kIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAgaWYgKFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLmluZGV4T2YocHJvcCkgIT09IC0xICYmIGlzTnVtZXJpYyhzdHlsZXNbcHJvcF0pKSB7XG4gICAgICB1bml0ID0gJ3B4JztcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXSArIHVuaXQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGVzIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5zdHlsZXMgLSBMaXN0IG9mIHN0eWxlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLmF0dHJpYnV0ZXMgLSBMaXN0IG9mIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2FtZSBkYXRhIG9iamVjdFxuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlKGRhdGEpIHtcbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuc3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gaW4gdGhpcyB3YXkgd2UgY2FuIG1ha2UgdGhlIDNyZCBwYXJ0eSBtb2RpZmllcnMgYWRkIGN1c3RvbSBzdHlsZXMgdG8gaXRcbiAgLy8gQmUgYXdhcmUsIG1vZGlmaWVycyBjb3VsZCBvdmVycmlkZSB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoZSBwcmV2aW91c1xuICAvLyBsaW5lcyBvZiB0aGlzIG1vZGlmaWVyIVxuICBzZXRTdHlsZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuc3R5bGVzKTtcblxuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5hdHRyaWJ1dGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gdGhleSB3aWxsIGJlIHNldCBhcyBIVE1MIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgc2V0QXR0cmlidXRlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgZGVmaW5lZCBhbmQgYXJyb3dTdHlsZXMgaGFzIHNvbWUgcHJvcGVydGllc1xuICBpZiAoZGF0YS5hcnJvd0VsZW1lbnQgJiYgT2JqZWN0LmtleXMoZGF0YS5hcnJvd1N0eWxlcykubGVuZ3RoKSB7XG4gICAgc2V0U3R5bGVzKGRhdGEuYXJyb3dFbGVtZW50LCBkYXRhLmFycm93U3R5bGVzKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gKiB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyIG1hcmdpbnMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBnZXQgdGhlXG4gKiBjb3JyZWN0IHBvcHBlciBvZmZzZXRzLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUG9wcGVyLmpzIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZU9uTG9hZChyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBzdGF0ZSkge1xuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgdmFyIHJlZmVyZW5jZU9mZnNldHMgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgdmFyIHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KG9wdGlvbnMucGxhY2VtZW50LCByZWZlcmVuY2VPZmZzZXRzLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHBsYWNlbWVudCk7XG5cbiAgLy8gQXBwbHkgYHBvc2l0aW9uYCB0byBwb3BwZXIgYmVmb3JlIGFueXRoaW5nIGVsc2UgYmVjYXVzZVxuICAvLyB3aXRob3V0IHRoZSBwb3NpdGlvbiBhcHBsaWVkIHdlIGNhbid0IGd1YXJhbnRlZSBjb3JyZWN0IGNvbXB1dGF0aW9uc1xuICBzZXRTdHlsZXMocG9wcGVyLCB7IHBvc2l0aW9uOiBvcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJyB9KTtcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gc2hvdWxkUm91bmQgLSBJZiB0aGUgb2Zmc2V0cyBzaG91bGQgYmUgcm91bmRlZCBhdCBhbGxcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwb3BwZXIncyBwb3NpdGlvbiBvZmZzZXRzIHJvdW5kZWRcbiAqXG4gKiBUaGUgdGFsZSBvZiBwaXhlbC1wZXJmZWN0IHBvc2l0aW9uaW5nLiBJdCdzIHN0aWxsIG5vdCAxMDAlIHBlcmZlY3QsIGJ1dCBhc1xuICogZ29vZCBhcyBpdCBjYW4gYmUgd2l0aGluIHJlYXNvbi5cbiAqIERpc2N1c3Npb24gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvcHVsbC83MTVcbiAqXG4gKiBMb3cgRFBJIHNjcmVlbnMgY2F1c2UgYSBwb3BwZXIgdG8gYmUgYmx1cnJ5IGlmIG5vdCB1c2luZyBmdWxsIHBpeGVscyAoU2FmYXJpXG4gKiBhcyB3ZWxsIG9uIEhpZ2ggRFBJIHNjcmVlbnMpLlxuICpcbiAqIEZpcmVmb3ggcHJlZmVycyBubyByb3VuZGluZyBmb3IgcG9zaXRpb25pbmcgYW5kIGRvZXMgbm90IGhhdmUgYmx1cnJpbmVzcyBvblxuICogaGlnaCBEUEkgc2NyZWVucy5cbiAqXG4gKiBPbmx5IGhvcml6b250YWwgcGxhY2VtZW50IGFuZCBsZWZ0L3JpZ2h0IHZhbHVlcyBuZWVkIHRvIGJlIGNvbnNpZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFJvdW5kZWRPZmZzZXRzKGRhdGEsIHNob3VsZFJvdW5kKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICAgIGZsb29yID0gTWF0aC5mbG9vcjtcblxuICB2YXIgbm9Sb3VuZCA9IGZ1bmN0aW9uIG5vUm91bmQodikge1xuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIHZhciByZWZlcmVuY2VXaWR0aCA9IHJvdW5kKHJlZmVyZW5jZS53aWR0aCk7XG4gIHZhciBwb3BwZXJXaWR0aCA9IHJvdW5kKHBvcHBlci53aWR0aCk7XG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGRhdGEucGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBpc1ZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LmluZGV4T2YoJy0nKSAhPT0gLTE7XG4gIHZhciBzYW1lV2lkdGhQYXJpdHkgPSByZWZlcmVuY2VXaWR0aCAlIDIgPT09IHBvcHBlcldpZHRoICUgMjtcbiAgdmFyIGJvdGhPZGRXaWR0aCA9IHJlZmVyZW5jZVdpZHRoICUgMiA9PT0gMSAmJiBwb3BwZXJXaWR0aCAlIDIgPT09IDE7XG5cbiAgdmFyIGhvcml6b250YWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogaXNWZXJ0aWNhbCB8fCBpc1ZhcmlhdGlvbiB8fCBzYW1lV2lkdGhQYXJpdHkgPyByb3VuZCA6IGZsb29yO1xuICB2YXIgdmVydGljYWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogcm91bmQ7XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBob3Jpem9udGFsVG9JbnRlZ2VyKGJvdGhPZGRXaWR0aCAmJiAhaXNWYXJpYXRpb24gJiYgc2hvdWxkUm91bmQgPyBwb3BwZXIubGVmdCAtIDEgOiBwb3BwZXIubGVmdCksXG4gICAgdG9wOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIudG9wKSxcbiAgICBib3R0b206IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci5ib3R0b20pLFxuICAgIHJpZ2h0OiBob3Jpem9udGFsVG9JbnRlZ2VyKHBvcHBlci5yaWdodClcbiAgfTtcbn1cblxudmFyIGlzRmlyZWZveCA9IGlzQnJvd3NlciAmJiAvRmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciB4ID0gb3B0aW9ucy54LFxuICAgICAgeSA9IG9wdGlvbnMueTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVnYWN5IHN1cHBvcnQgaW4gUG9wcGVyLmpzIHYyXG5cbiAgdmFyIGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAnYXBwbHlTdHlsZSc7XG4gIH0pLmdwdUFjY2VsZXJhdGlvbjtcbiAgaWYgKGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgZ3B1QWNjZWxlcmF0aW9uYCBvcHRpb24gbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXIgYW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgUG9wcGVyLmpzIScpO1xuICB9XG4gIHZhciBncHVBY2NlbGVyYXRpb24gPSBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCA/IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA6IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uO1xuXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuXG4gIC8vIFN0eWxlc1xuICB2YXIgc3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBwb3BwZXIucG9zaXRpb25cbiAgfTtcblxuICB2YXIgb2Zmc2V0cyA9IGdldFJvdW5kZWRPZmZzZXRzKGRhdGEsIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDwgMiB8fCAhaXNGaXJlZm94KTtcblxuICB2YXIgc2lkZUEgPSB4ID09PSAnYm90dG9tJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gIHZhciBzaWRlQiA9IHkgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gIC8vIGlmIGdwdUFjY2VsZXJhdGlvbiBpcyBzZXQgdG8gYHRydWVgIGFuZCB0cmFuc2Zvcm0gaXMgc3VwcG9ydGVkLFxuICAvLyAgd2UgdXNlIGB0cmFuc2xhdGUzZGAgdG8gYXBwbHkgdGhlIHBvc2l0aW9uIHRvIHRoZSBwb3BwZXIgd2VcbiAgLy8gYXV0b21hdGljYWxseSB1c2UgdGhlIHN1cHBvcnRlZCBwcmVmaXhlZCB2ZXJzaW9uIGlmIG5lZWRlZFxuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG5cbiAgLy8gbm93LCBsZXQncyBtYWtlIGEgc3RlcCBiYWNrIGFuZCBsb29rIGF0IHRoaXMgY29kZSBjbG9zZWx5ICh3dGY/KVxuICAvLyBJZiB0aGUgY29udGVudCBvZiB0aGUgcG9wcGVyIGdyb3dzIG9uY2UgaXQncyBiZWVuIHBvc2l0aW9uZWQsIGl0XG4gIC8vIG1heSBoYXBwZW4gdGhhdCB0aGUgcG9wcGVyIGdldHMgbWlzcGxhY2VkIGJlY2F1c2Ugb2YgdGhlIG5ldyBjb250ZW50XG4gIC8vIG92ZXJmbG93aW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUbyBhdm9pZCB0aGlzIHByb2JsZW0sIHdlIHByb3ZpZGUgdHdvIG9wdGlvbnMgKHggYW5kIHkpLCB3aGljaCBhbGxvd1xuICAvLyB0aGUgY29uc3VtZXIgdG8gZGVmaW5lIHRoZSBvZmZzZXQgb3JpZ2luLlxuICAvLyBJZiB3ZSBwb3NpdGlvbiBhIHBvcHBlciBvbiB0b3Agb2YgYSByZWZlcmVuY2UgZWxlbWVudCwgd2UgY2FuIHNldFxuICAvLyBgeGAgdG8gYHRvcGAgdG8gbWFrZSB0aGUgcG9wcGVyIGdyb3cgdG93YXJkcyBpdHMgdG9wIGluc3RlYWQgb2ZcbiAgLy8gaXRzIGJvdHRvbS5cbiAgdmFyIGxlZnQgPSB2b2lkIDAsXG4gICAgICB0b3AgPSB2b2lkIDA7XG4gIGlmIChzaWRlQSA9PT0gJ2JvdHRvbScpIHtcbiAgICAvLyB3aGVuIG9mZnNldFBhcmVudCBpcyA8aHRtbD4gdGhlIHBvc2l0aW9uaW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiAoZXhjbHVkaW5nIHRoZSBzY3JvbGxiYXIpXG4gICAgLy8gYW5kIG5vdCB0aGUgYm90dG9tIG9mIHRoZSBodG1sIGVsZW1lbnRcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnRSZWN0LmhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBvZmZzZXRzLnRvcDtcbiAgfVxuICBpZiAoc2lkZUIgPT09ICdyaWdodCcpIHtcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnRSZWN0LndpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVmdCA9IG9mZnNldHMubGVmdDtcbiAgfVxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uICYmIHByZWZpeGVkUHJvcGVydHkpIHtcbiAgICBzdHlsZXNbcHJlZml4ZWRQcm9wZXJ0eV0gPSAndHJhbnNsYXRlM2QoJyArIGxlZnQgKyAncHgsICcgKyB0b3AgKyAncHgsIDApJztcbiAgICBzdHlsZXNbc2lkZUFdID0gMDtcbiAgICBzdHlsZXNbc2lkZUJdID0gMDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aHdlcmlzZSwgd2UgdXNlIHRoZSBzdGFuZGFyZCBgdG9wYCwgYGxlZnRgLCBgYm90dG9tYCBhbmQgYHJpZ2h0YCBwcm9wZXJ0aWVzXG4gICAgdmFyIGludmVydFRvcCA9IHNpZGVBID09PSAnYm90dG9tJyA/IC0xIDogMTtcbiAgICB2YXIgaW52ZXJ0TGVmdCA9IHNpZGVCID09PSAncmlnaHQnID8gLTEgOiAxO1xuICAgIHN0eWxlc1tzaWRlQV0gPSB0b3AgKiBpbnZlcnRUb3A7XG4gICAgc3R5bGVzW3NpZGVCXSA9IGxlZnQgKiBpbnZlcnRMZWZ0O1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gc2lkZUEgKyAnLCAnICsgc2lkZUI7XG4gIH1cblxuICAvLyBBdHRyaWJ1dGVzXG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICd4LXBsYWNlbWVudCc6IGRhdGEucGxhY2VtZW50XG4gIH07XG5cbiAgLy8gVXBkYXRlIGBkYXRhYCBhdHRyaWJ1dGVzLCBzdHlsZXMgYW5kIGFycm93U3R5bGVzXG4gIGRhdGEuYXR0cmlidXRlcyA9IF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCBkYXRhLmF0dHJpYnV0ZXMpO1xuICBkYXRhLnN0eWxlcyA9IF9leHRlbmRzKHt9LCBzdHlsZXMsIGRhdGEuc3R5bGVzKTtcbiAgZGF0YS5hcnJvd1N0eWxlcyA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMuYXJyb3csIGRhdGEuYXJyb3dTdHlsZXMpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGRlcGVuZHMgZnJvbSBhbm90aGVyIG9uZS48YnIgLz5cbiAqIEl0IGNoZWNrcyBpZiB0aGUgbmVlZGVkIG1vZGlmaWVyIGlzIGxpc3RlZCBhbmQgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVycyAtIGxpc3Qgb2YgbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGluZ05hbWUgLSBuYW1lIG9mIHJlcXVlc3RpbmcgbW9kaWZpZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0ZWROYW1lIC0gbmFtZSBvZiByZXF1ZXN0ZWQgbW9kaWZpZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyUmVxdWlyZWQobW9kaWZpZXJzLCByZXF1ZXN0aW5nTmFtZSwgcmVxdWVzdGVkTmFtZSkge1xuICB2YXIgcmVxdWVzdGluZyA9IGZpbmQobW9kaWZpZXJzLCBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgIHJldHVybiBuYW1lID09PSByZXF1ZXN0aW5nTmFtZTtcbiAgfSk7XG5cbiAgdmFyIGlzUmVxdWlyZWQgPSAhIXJlcXVlc3RpbmcgJiYgbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09IHJlcXVlc3RlZE5hbWUgJiYgbW9kaWZpZXIuZW5hYmxlZCAmJiBtb2RpZmllci5vcmRlciA8IHJlcXVlc3Rpbmcub3JkZXI7XG4gIH0pO1xuXG4gIGlmICghaXNSZXF1aXJlZCkge1xuICAgIHZhciBfcmVxdWVzdGluZyA9ICdgJyArIHJlcXVlc3RpbmdOYW1lICsgJ2AnO1xuICAgIHZhciByZXF1ZXN0ZWQgPSAnYCcgKyByZXF1ZXN0ZWROYW1lICsgJ2AnO1xuICAgIGNvbnNvbGUud2FybihyZXF1ZXN0ZWQgKyAnIG1vZGlmaWVyIGlzIHJlcXVpcmVkIGJ5ICcgKyBfcmVxdWVzdGluZyArICcgbW9kaWZpZXIgaW4gb3JkZXIgdG8gd29yaywgYmUgc3VyZSB0byBpbmNsdWRlIGl0IGJlZm9yZSAnICsgX3JlcXVlc3RpbmcgKyAnIScpO1xuICB9XG4gIHJldHVybiBpc1JlcXVpcmVkO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gYXJyb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyRhcnJvdztcblxuICAvLyBhcnJvdyBkZXBlbmRzIG9uIGtlZXBUb2dldGhlciBpbiBvcmRlciB0byB3b3JrXG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnYXJyb3cnLCAna2VlcFRvZ2V0aGVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBhcnJvd0VsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGEgc3RyaW5nLCBzdXBwb3NlIGl0J3MgYSBDU1Mgc2VsZWN0b3JcbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIG5vdCBmb3VuZCwgZG9uJ3QgcnVuIHRoZSBtb2RpZmllclxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgdGhlIGFycm93RWxlbWVudCBpc24ndCBhIHF1ZXJ5IHNlbGVjdG9yIHdlIG11c3QgY2hlY2sgdGhhdCB0aGVcbiAgICAvLyBwcm92aWRlZCBET00gbm9kZSBpcyBjaGlsZCBvZiBpdHMgcG9wcGVyIG5vZGVcbiAgICBpZiAoIWRhdGEuaW5zdGFuY2UucG9wcGVyLmNvbnRhaW5zKGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGFycm93LmVsZW1lbnRgIG11c3QgYmUgY2hpbGQgb2YgaXRzIHBvcHBlciBlbGVtZW50IScpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzaWRlQ2FwaXRhbGl6ZWQgPSBpc1ZlcnRpY2FsID8gJ1RvcCcgOiAnTGVmdCc7XG4gIHZhciBzaWRlID0gc2lkZUNhcGl0YWxpemVkLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhbHRTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgdmFyIGFycm93RWxlbWVudFNpemUgPSBnZXRPdXRlclNpemVzKGFycm93RWxlbWVudClbbGVuXTtcblxuICAvL1xuICAvLyBleHRlbmRzIGtlZXBUb2dldGhlciBiZWhhdmlvciBtYWtpbmcgc3VyZSB0aGUgcG9wcGVyIGFuZCBpdHNcbiAgLy8gcmVmZXJlbmNlIGhhdmUgZW5vdWdoIHBpeGVscyBpbiBjb25qdW5jdGlvblxuICAvL1xuXG4gIC8vIHRvcC9sZWZ0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSA8IHBvcHBlcltzaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLT0gcG9wcGVyW3NpZGVdIC0gKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSk7XG4gIH1cbiAgLy8gYm90dG9tL3JpZ2h0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgPiBwb3BwZXJbb3BTaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gKz0gcmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSAtIHBvcHBlcltvcFNpZGVdO1xuICB9XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuXG4gIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgdmFyIGNlbnRlciA9IHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVtsZW5dIC8gMiAtIGFycm93RWxlbWVudFNpemUgLyAyO1xuXG4gIC8vIENvbXB1dGUgdGhlIHNpZGVWYWx1ZSB1c2luZyB0aGUgdXBkYXRlZCBwb3BwZXIgb2Zmc2V0c1xuICAvLyB0YWtlIHBvcHBlciBtYXJnaW4gaW4gYWNjb3VudCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgdGhpcyBpbmZvIGF2YWlsYWJsZVxuICB2YXIgY3NzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIHBvcHBlck1hcmdpblNpZGUgPSBwYXJzZUZsb2F0KGNzc1snbWFyZ2luJyArIHNpZGVDYXBpdGFsaXplZF0pO1xuICB2YXIgcG9wcGVyQm9yZGVyU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydib3JkZXInICsgc2lkZUNhcGl0YWxpemVkICsgJ1dpZHRoJ10pO1xuICB2YXIgc2lkZVZhbHVlID0gY2VudGVyIC0gZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtIHBvcHBlck1hcmdpblNpZGUgLSBwb3BwZXJCb3JkZXJTaWRlO1xuXG4gIC8vIHByZXZlbnQgYXJyb3dFbGVtZW50IGZyb20gYmVpbmcgcGxhY2VkIG5vdCBjb250aWd1b3VzbHkgdG8gaXRzIHBvcHBlclxuICBzaWRlVmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihwb3BwZXJbbGVuXSAtIGFycm93RWxlbWVudFNpemUsIHNpZGVWYWx1ZSksIDApO1xuXG4gIGRhdGEuYXJyb3dFbGVtZW50ID0gYXJyb3dFbGVtZW50O1xuICBkYXRhLm9mZnNldHMuYXJyb3cgPSAoX2RhdGEkb2Zmc2V0cyRhcnJvdyA9IHt9LCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBzaWRlLCBNYXRoLnJvdW5kKHNpZGVWYWx1ZSkpLCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBhbHRTaWRlLCAnJyksIF9kYXRhJG9mZnNldHMkYXJyb3cpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IHZhcmlhdGlvbiBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IHZhcmlhdGlvblxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbikge1xuICBpZiAodmFyaWF0aW9uID09PSAnZW5kJykge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9IGVsc2UgaWYgKHZhcmlhdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgIHJldHVybiAnZW5kJztcbiAgfVxuICByZXR1cm4gdmFyaWF0aW9uO1xufVxuXG4vKipcbiAqIExpc3Qgb2YgYWNjZXB0ZWQgcGxhY2VtZW50cyB0byB1c2UgYXMgdmFsdWVzIG9mIHRoZSBgcGxhY2VtZW50YCBvcHRpb24uPGJyIC8+XG4gKiBWYWxpZCBwbGFjZW1lbnRzIGFyZTpcbiAqIC0gYGF1dG9gXG4gKiAtIGB0b3BgXG4gKiAtIGByaWdodGBcbiAqIC0gYGJvdHRvbWBcbiAqIC0gYGxlZnRgXG4gKlxuICogRWFjaCBwbGFjZW1lbnQgY2FuIGhhdmUgYSB2YXJpYXRpb24gZnJvbSB0aGlzIGxpc3Q6XG4gKiAtIGAtc3RhcnRgXG4gKiAtIGAtZW5kYFxuICpcbiAqIFZhcmlhdGlvbnMgYXJlIGludGVycHJldGVkIGVhc2lseSBpZiB5b3UgdGhpbmsgb2YgdGhlbSBhcyB0aGUgbGVmdCB0byByaWdodFxuICogd3JpdHRlbiBsYW5ndWFnZXMuIEhvcml6b250YWxseSAoYHRvcGAgYW5kIGBib3R0b21gKSwgYHN0YXJ0YCBpcyBsZWZ0IGFuZCBgZW5kYFxuICogaXMgcmlnaHQuPGJyIC8+XG4gKiBWZXJ0aWNhbGx5IChgbGVmdGAgYW5kIGByaWdodGApLCBgc3RhcnRgIGlzIHRvcCBhbmQgYGVuZGAgaXMgYm90dG9tLlxuICpcbiAqIFNvbWUgdmFsaWQgZXhhbXBsZXMgYXJlOlxuICogLSBgdG9wLWVuZGAgKG9uIHRvcCBvZiByZWZlcmVuY2UsIHJpZ2h0IGFsaWduZWQpXG4gKiAtIGByaWdodC1zdGFydGAgKG9uIHJpZ2h0IG9mIHJlZmVyZW5jZSwgdG9wIGFsaWduZWQpXG4gKiAtIGBib3R0b21gIChvbiBib3R0b20sIGNlbnRlcmVkKVxuICogLSBgYXV0by1lbmRgIChvbiB0aGUgc2lkZSB3aXRoIG1vcmUgc3BhY2UgYXZhaWxhYmxlLCBhbGlnbm1lbnQgZGVwZW5kcyBieSBwbGFjZW1lbnQpXG4gKlxuICogQHN0YXRpY1xuICogQHR5cGUge0FycmF5fVxuICogQGVudW0ge1N0cmluZ31cbiAqIEByZWFkb25seVxuICogQG1ldGhvZCBwbGFjZW1lbnRzXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBwbGFjZW1lbnRzID0gWydhdXRvLXN0YXJ0JywgJ2F1dG8nLCAnYXV0by1lbmQnLCAndG9wLXN0YXJ0JywgJ3RvcCcsICd0b3AtZW5kJywgJ3JpZ2h0LXN0YXJ0JywgJ3JpZ2h0JywgJ3JpZ2h0LWVuZCcsICdib3R0b20tZW5kJywgJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnbGVmdC1lbmQnLCAnbGVmdCcsICdsZWZ0LXN0YXJ0J107XG5cbi8vIEdldCByaWQgb2YgYGF1dG9gIGBhdXRvLXN0YXJ0YCBhbmQgYGF1dG8tZW5kYFxudmFyIHZhbGlkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuc2xpY2UoMyk7XG5cbi8qKlxuICogR2l2ZW4gYW4gaW5pdGlhbCBwbGFjZW1lbnQsIHJldHVybnMgYWxsIHRoZSBzdWJzZXF1ZW50IHBsYWNlbWVudHNcbiAqIGNsb2Nrd2lzZSAob3IgY291bnRlci1jbG9ja3dpc2UpLlxuICpcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgLSBBIHZhbGlkIHBsYWNlbWVudCAoaXQgYWNjZXB0cyB2YXJpYXRpb25zKVxuICogQGFyZ3VtZW50IHtCb29sZWFufSBjb3VudGVyIC0gU2V0IHRvIHRydWUgdG8gd2FsayB0aGUgcGxhY2VtZW50cyBjb3VudGVyY2xvY2t3aXNlXG4gKiBAcmV0dXJucyB7QXJyYXl9IHBsYWNlbWVudHMgaW5jbHVkaW5nIHRoZWlyIHZhcmlhdGlvbnNcbiAqL1xuZnVuY3Rpb24gY2xvY2t3aXNlKHBsYWNlbWVudCkge1xuICB2YXIgY291bnRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGluZGV4ID0gdmFsaWRQbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KTtcbiAgdmFyIGFyciA9IHZhbGlkUGxhY2VtZW50cy5zbGljZShpbmRleCArIDEpLmNvbmNhdCh2YWxpZFBsYWNlbWVudHMuc2xpY2UoMCwgaW5kZXgpKTtcbiAgcmV0dXJuIGNvdW50ZXIgPyBhcnIucmV2ZXJzZSgpIDogYXJyO1xufVxuXG52YXIgQkVIQVZJT1JTID0ge1xuICBGTElQOiAnZmxpcCcsXG4gIENMT0NLV0lTRTogJ2Nsb2Nrd2lzZScsXG4gIENPVU5URVJDTE9DS1dJU0U6ICdjb3VudGVyY2xvY2t3aXNlJ1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGZsaXAoZGF0YSwgb3B0aW9ucykge1xuICAvLyBpZiBgaW5uZXJgIG1vZGlmaWVyIGlzIGVuYWJsZWQsIHdlIGNhbid0IHVzZSB0aGUgYGZsaXBgIG1vZGlmaWVyXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2lubmVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGlmIChkYXRhLmZsaXBwZWQgJiYgZGF0YS5wbGFjZW1lbnQgPT09IGRhdGEub3JpZ2luYWxQbGFjZW1lbnQpIHtcbiAgICAvLyBzZWVtcyBsaWtlIGZsaXAgaXMgdHJ5aW5nIHRvIGxvb3AsIHByb2JhYmx5IHRoZXJlJ3Mgbm90IGVub3VnaCBzcGFjZSBvbiBhbnkgb2YgdGhlIGZsaXBwYWJsZSBzaWRlc1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVsxXSB8fCAnJztcblxuICB2YXIgZmxpcE9yZGVyID0gW107XG5cbiAgc3dpdGNoIChvcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgY2FzZSBCRUhBVklPUlMuRkxJUDpcbiAgICAgIGZsaXBPcmRlciA9IFtwbGFjZW1lbnQsIHBsYWNlbWVudE9wcG9zaXRlXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ09VTlRFUkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZsaXBPcmRlciA9IG9wdGlvbnMuYmVoYXZpb3I7XG4gIH1cblxuICBmbGlwT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCwgaW5kZXgpIHtcbiAgICBpZiAocGxhY2VtZW50ICE9PSBzdGVwIHx8IGZsaXBPcmRlci5sZW5ndGggPT09IGluZGV4ICsgMSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG4gICAgdmFyIHJlZk9mZnNldHMgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuXG4gICAgLy8gdXNpbmcgZmxvb3IgYmVjYXVzZSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgbWF5IGNvbnRhaW4gZGVjaW1hbHMgd2UgYXJlIG5vdCBnb2luZyB0byBjb25zaWRlciBoZXJlXG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgb3ZlcmxhcHNSZWYgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKHJlZk9mZnNldHMubGVmdCkgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihyZWZPZmZzZXRzLnJpZ2h0KSB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKHJlZk9mZnNldHMudG9wKSB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKHJlZk9mZnNldHMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NMZWZ0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKGJvdW5kYXJpZXMubGVmdCk7XG4gICAgdmFyIG92ZXJmbG93c1JpZ2h0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihib3VuZGFyaWVzLnJpZ2h0KTtcbiAgICB2YXIgb3ZlcmZsb3dzVG9wID0gZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IoYm91bmRhcmllcy50b3ApO1xuICAgIHZhciBvdmVyZmxvd3NCb3R0b20gPSBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihib3VuZGFyaWVzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzQm91bmRhcmllcyA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIG92ZXJmbG93c0xlZnQgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIG92ZXJmbG93c1JpZ2h0IHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgb3ZlcmZsb3dzVG9wIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgb3ZlcmZsb3dzQm90dG9tO1xuXG4gICAgLy8gZmxpcCB0aGUgdmFyaWF0aW9uIGlmIHJlcXVpcmVkXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgLy8gZmxpcHMgdmFyaWF0aW9uIGlmIHJlZmVyZW5jZSBlbGVtZW50IG92ZXJmbG93cyBib3VuZGFyaWVzXG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb25CeVJlZiA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1RvcCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0JvdHRvbSk7XG5cbiAgICAvLyBmbGlwcyB2YXJpYXRpb24gaWYgcG9wcGVyIGNvbnRlbnQgb3ZlcmZsb3dzIGJvdW5kYXJpZXNcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbkJ5Q29udGVudCA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9uc0J5Q29udGVudCAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0xlZnQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0JvdHRvbSB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1RvcCk7XG5cbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbiA9IGZsaXBwZWRWYXJpYXRpb25CeVJlZiB8fCBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50O1xuXG4gICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMgfHwgZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgLy8gdGhpcyBib29sZWFuIHRvIGRldGVjdCBhbnkgZmxpcCBsb29wXG4gICAgICBkYXRhLmZsaXBwZWQgPSB0cnVlO1xuXG4gICAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcykge1xuICAgICAgICBwbGFjZW1lbnQgPSBmbGlwT3JkZXJbaW5kZXggKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgdmFyaWF0aW9uID0gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5wbGFjZW1lbnQgPSBwbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xuXG4gICAgICAvLyB0aGlzIG9iamVjdCBjb250YWlucyBgcG9zaXRpb25gLCB3ZSB3YW50IHRvIHByZXNlcnZlIGl0IGFsb25nIHdpdGhcbiAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHByb3BlcnR5IHdlIG1heSBhZGQgaW4gdGhlIGZ1dHVyZVxuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMucG9wcGVyLCBnZXRQb3BwZXJPZmZzZXRzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCkpO1xuXG4gICAgICBkYXRhID0gcnVuTW9kaWZpZXJzKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBkYXRhLCAnZmxpcCcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24ga2VlcFRvZ2V0aGVyKGRhdGEpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdyaWdodCcgOiAnYm90dG9tJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICBpZiAocG9wcGVyW3NpZGVdIDwgZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pIC0gcG9wcGVyW21lYXN1cmVtZW50XTtcbiAgfVxuICBpZiAocG9wcGVyW29wU2lkZV0gPiBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW3NpZGVdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdmFsdWUgKyB1bml0IGludG8gYSBweCB2YWx1ZSBudW1iZXJcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzdHIgLSBWYWx1ZSArIHVuaXQgc3RyaW5nXG4gKiBAYXJndW1lbnQge1N0cmluZ30gbWVhc3VyZW1lbnQgLSBgaGVpZ2h0YCBvciBgd2lkdGhgXG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICogVmFsdWUgaW4gcGl4ZWxzLCBvciBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdmFsdWVzIHdlcmUgZXh0cmFjdGVkXG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cykge1xuICAvLyBzZXBhcmF0ZSB2YWx1ZSBmcm9tIHVuaXRcbiAgdmFyIHNwbGl0ID0gc3RyLm1hdGNoKC8oKD86XFwtfFxcKyk/XFxkKlxcLj9cXGQqKSguKikvKTtcbiAgdmFyIHZhbHVlID0gK3NwbGl0WzFdO1xuICB2YXIgdW5pdCA9IHNwbGl0WzJdO1xuXG4gIC8vIElmIGl0J3Mgbm90IGEgbnVtYmVyIGl0J3MgYW4gb3BlcmF0b3IsIEkgZ3Vlc3NcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBpZiAodW5pdC5pbmRleE9mKCclJykgPT09IDApIHtcbiAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgIGNhc2UgJyVwJzpcbiAgICAgICAgZWxlbWVudCA9IHBvcHBlck9mZnNldHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJSc6XG4gICAgICBjYXNlICclcic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbGVtZW50ID0gcmVmZXJlbmNlT2Zmc2V0cztcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3ZoJyB8fCB1bml0ID09PSAndncnKSB7XG4gICAgLy8gaWYgaXMgYSB2aCBvciB2dywgd2UgY2FsY3VsYXRlIHRoZSBzaXplIGJhc2VkIG9uIHRoZSB2aWV3cG9ydFxuICAgIHZhciBzaXplID0gdm9pZCAwO1xuICAgIGlmICh1bml0ID09PSAndmgnKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpcyBhbiBleHBsaWNpdCBwaXhlbCB1bml0LCB3ZSBnZXQgcmlkIG9mIHRoZSB1bml0IGFuZCBrZWVwIHRoZSB2YWx1ZVxuICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBgb2Zmc2V0YCBzdHJpbmcgdG8gZXh0cmFwb2xhdGUgYHhgIGFuZCBgeWAgbnVtZXJpYyBvZmZzZXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICogQHJldHVybnMge0FycmF5fSBhIHR3byBjZWxscyBhcnJheSB3aXRoIHggYW5kIHkgb2Zmc2V0cyBpbiBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cywgYmFzZVBsYWNlbWVudCkge1xuICB2YXIgb2Zmc2V0cyA9IFswLCAwXTtcblxuICAvLyBVc2UgaGVpZ2h0IGlmIHBsYWNlbWVudCBpcyBsZWZ0IG9yIHJpZ2h0IGFuZCBpbmRleCBpcyAwIG90aGVyd2lzZSB1c2Ugd2lkdGhcbiAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAvLyB3aWxsIHVzZSB0aGUgb3RoZXIgb25lXG4gIHZhciB1c2VIZWlnaHQgPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAvLyBTcGxpdCB0aGUgb2Zmc2V0IHN0cmluZyB0byBvYnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHNcbiAgLy8gVGhlIHJlZ2V4IGFkZHJlc3NlcyB2YWx1ZXMgd2l0aCB0aGUgcGx1cyBvciBtaW51cyBzaWduIGluIGZyb250ICgrMTAsIC0yMCwgZXRjKVxuICB2YXIgZnJhZ21lbnRzID0gb2Zmc2V0LnNwbGl0KC8oXFwrfFxcLSkvKS5tYXAoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy50cmltKCk7XG4gIH0pO1xuXG4gIC8vIERldGVjdCBpZiB0aGUgb2Zmc2V0IHN0cmluZyBjb250YWlucyBhIHBhaXIgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIG9uZVxuICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICB2YXIgZGl2aWRlciA9IGZyYWdtZW50cy5pbmRleE9mKGZpbmQoZnJhZ21lbnRzLCBmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnNlYXJjaCgvLHxcXHMvKSAhPT0gLTE7XG4gIH0pKTtcblxuICBpZiAoZnJhZ21lbnRzW2RpdmlkZXJdICYmIGZyYWdtZW50c1tkaXZpZGVyXS5pbmRleE9mKCcsJykgPT09IC0xKSB7XG4gICAgY29uc29sZS53YXJuKCdPZmZzZXRzIHNlcGFyYXRlZCBieSB3aGl0ZSBzcGFjZShzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIGEgY29tbWEgKCwpIGluc3RlYWQuJyk7XG4gIH1cblxuICAvLyBJZiBkaXZpZGVyIGlzIGZvdW5kLCB3ZSBkaXZpZGUgdGhlIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kcyB0byBkaXZpZGVcbiAgLy8gdGhlbSBieSBvZnNldCBYIGFuZCBZLlxuICB2YXIgc3BsaXRSZWdleCA9IC9cXHMqLFxccyp8XFxzKy87XG4gIHZhciBvcHMgPSBkaXZpZGVyICE9PSAtMSA/IFtmcmFnbWVudHMuc2xpY2UoMCwgZGl2aWRlcikuY29uY2F0KFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMF1dKSwgW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVsxXV0uY29uY2F0KGZyYWdtZW50cy5zbGljZShkaXZpZGVyICsgMSkpXSA6IFtmcmFnbWVudHNdO1xuXG4gIC8vIENvbnZlcnQgdGhlIHZhbHVlcyB3aXRoIHVuaXRzIHRvIGFic29sdXRlIHBpeGVscyB0byBhbGxvdyBvdXIgY29tcHV0YXRpb25zXG4gIG9wcyA9IG9wcy5tYXAoZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIC8vIE1vc3Qgb2YgdGhlIHVuaXRzIHJlbHkgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwb3BwZXJcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSAoaW5kZXggPT09IDEgPyAhdXNlSGVpZ2h0IDogdXNlSGVpZ2h0KSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICByZXR1cm4gb3BcbiAgICAvLyBUaGlzIGFnZ3JlZ2F0ZXMgYW55IGArYCBvciBgLWAgc2lnbiB0aGF0IGFyZW4ndCBjb25zaWRlcmVkIG9wZXJhdG9yc1xuICAgIC8vIGUuZy46IDEwICsgKzUgPT4gWzEwLCArLCArNV1cbiAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYVthLmxlbmd0aCAtIDFdID09PSAnJyAmJiBbJysnLCAnLSddLmluZGV4T2YoYikgIT09IC0xKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2UgaWYgKG1lcmdlV2l0aFByZXZpb3VzKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSArPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgIH1cbiAgICB9LCBbXSlcbiAgICAvLyBIZXJlIHdlIGNvbnZlcnQgdGhlIHN0cmluZyB2YWx1ZXMgaW50byBudW1iZXIgdmFsdWVzIChpbiBweClcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBMb29wIHRyb3VnaCB0aGUgb2Zmc2V0cyBhcnJheXMgYW5kIGV4ZWN1dGUgdGhlIG9wZXJhdGlvbnNcbiAgb3BzLmZvckVhY2goZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIG9wLmZvckVhY2goZnVuY3Rpb24gKGZyYWcsIGluZGV4Mikge1xuICAgICAgaWYgKGlzTnVtZXJpYyhmcmFnKSkge1xuICAgICAgICBvZmZzZXRzW2luZGV4XSArPSBmcmFnICogKG9wW2luZGV4MiAtIDFdID09PSAnLScgPyAtMSA6IDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQGFyZ3VtZW50IHtOdW1iZXJ8U3RyaW5nfSBvcHRpb25zLm9mZnNldD0wXG4gKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gb2Zmc2V0KGRhdGEsIF9yZWYpIHtcbiAgdmFyIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQsXG4gICAgICBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIHZhciBvZmZzZXRzID0gdm9pZCAwO1xuICBpZiAoaXNOdW1lcmljKCtvZmZzZXQpKSB7XG4gICAgb2Zmc2V0cyA9IFsrb2Zmc2V0LCAwXTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRzID0gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYmFzZVBsYWNlbWVudCk7XG4gIH1cblxuICBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0IC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wIC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1sxXTtcbiAgfVxuXG4gIGRhdGEucG9wcGVyID0gcG9wcGVyO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kYXJpZXNFbGVtZW50ID0gb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCB8fCBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuXG4gIC8vIElmIG9mZnNldFBhcmVudCBpcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIHJlYWxseSB3YW50IHRvXG4gIC8vIGdvIG9uZSBzdGVwIHVwIGFuZCB1c2UgdGhlIG5leHQgb2Zmc2V0UGFyZW50IGFzIHJlZmVyZW5jZSB0b1xuICAvLyBhdm9pZCB0byBtYWtlIHRoaXMgbW9kaWZpZXIgY29tcGxldGVseSB1c2VsZXNzIGFuZCBsb29rIGxpa2UgYnJva2VuXG4gIGlmIChkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICBib3VuZGFyaWVzRWxlbWVudCA9IGdldE9mZnNldFBhcmVudChib3VuZGFyaWVzRWxlbWVudCk7XG4gIH1cblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzZXRzIHRoZSBwb3BwZXIncyBwb3NpdGlvbiBzbyB0aGF0IHRoZSBkb2N1bWVudCBzaXplIGNhbiBiZSBjYWxjdWxhdGVkIGV4Y2x1ZGluZ1xuICAvLyB0aGUgc2l6ZSBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgaXRzZWxmXG4gIHZhciB0cmFuc2Zvcm1Qcm9wID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcbiAgdmFyIHBvcHBlclN0eWxlcyA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnN0eWxlOyAvLyBhc3NpZ25tZW50IHRvIGhlbHAgbWluaWZpY2F0aW9uXG4gIHZhciB0b3AgPSBwb3BwZXJTdHlsZXMudG9wLFxuICAgICAgbGVmdCA9IHBvcHBlclN0eWxlcy5sZWZ0LFxuICAgICAgdHJhbnNmb3JtID0gcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdO1xuXG4gIHBvcHBlclN0eWxlcy50b3AgPSAnJztcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSAnJztcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gJyc7XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIG9mZnNldHMgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gIHBvcHBlclN0eWxlcy50b3AgPSB0b3A7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gbGVmdDtcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuXG4gIG9wdGlvbnMuYm91bmRhcmllcyA9IGJvdW5kYXJpZXM7XG5cbiAgdmFyIG9yZGVyID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgdmFyIGNoZWNrID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uIHByaW1hcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgocG9wcGVyW3BsYWNlbWVudF0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIHBsYWNlbWVudCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5OiBmdW5jdGlvbiBzZWNvbmRhcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPiBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKHBvcHBlclttYWluU2lkZV0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSAtIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIG1haW5TaWRlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHZhciBzaWRlID0gWydsZWZ0JywgJ3RvcCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5JztcbiAgICBwb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBjaGVja1tzaWRlXShwbGFjZW1lbnQpKTtcbiAgfSk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gc2hpZnQoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBzaGlmdHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIC8vIGlmIHNoaWZ0IHNoaWZ0dmFyaWF0aW9uIGlzIHNwZWNpZmllZCwgcnVuIHRoZSBtb2RpZmllclxuICBpZiAoc2hpZnR2YXJpYXRpb24pIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyO1xuXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgdmFyIHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgIHN0YXJ0OiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdKSxcbiAgICAgIGVuZDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVttZWFzdXJlbWVudF0gLSBwb3BwZXJbbWVhc3VyZW1lbnRdKVxuICAgIH07XG5cbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgc2hpZnRPZmZzZXRzW3NoaWZ0dmFyaWF0aW9uXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciByZWZSZWN0ID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIGJvdW5kID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdwcmV2ZW50T3ZlcmZsb3cnO1xuICB9KS5ib3VuZGFyaWVzO1xuXG4gIGlmIChyZWZSZWN0LmJvdHRvbSA8IGJvdW5kLnRvcCB8fCByZWZSZWN0LmxlZnQgPiBib3VuZC5yaWdodCB8fCByZWZSZWN0LnRvcCA+IGJvdW5kLmJvdHRvbSB8fCByZWZSZWN0LnJpZ2h0IDwgYm91bmQubGVmdCkge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IHRydWU7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gZmFsc2U7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBpbm5lcihkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc0hvcml6ID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIHN1YnRyYWN0TGVuZ3RoID0gWyd0b3AnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPT09IC0xO1xuXG4gIHBvcHBlcltpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCddID0gcmVmZXJlbmNlW2Jhc2VQbGFjZW1lbnRdIC0gKHN1YnRyYWN0TGVuZ3RoID8gcG9wcGVyW2lzSG9yaXogPyAnd2lkdGgnIDogJ2hlaWdodCddIDogMCk7XG5cbiAgZGF0YS5wbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChwb3BwZXIpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyIGZ1bmN0aW9uLCBlYWNoIG1vZGlmaWVyIGNhbiBoYXZlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIGFzc2lnbmVkXG4gKiB0byBpdHMgYGZuYCBwcm9wZXJ0eS48YnIgLz5cbiAqIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZSwgdGhpcyBtZWFucyB0aGF0IHlvdSBtdXN0XG4gKiBtYWtlIHN1cmUgdGhleSBhcmUgcGVyZm9ybWFudCBlbm91Z2ggdG8gYXZvaWQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuXG4gKlxuICogQGZ1bmN0aW9uIE1vZGlmaWVyRm5cbiAqIEBhcmd1bWVudCB7ZGF0YU9iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5cbi8qKlxuICogTW9kaWZpZXJzIGFyZSBwbHVnaW5zIHVzZWQgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHlvdXIgcG9wcGVycy48YnIgLz5cbiAqIFBvcHBlci5qcyB1c2VzIGEgc2V0IG9mIDkgbW9kaWZpZXJzIHRvIHByb3ZpZGUgYWxsIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXNcbiAqIG5lZWRlZCBieSB0aGUgbGlicmFyeS5cbiAqXG4gKiBVc3VhbGx5IHlvdSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIHRoZSBgb3JkZXJgLCBgZm5gIGFuZCBgb25Mb2FkYCBwcm9wcy5cbiAqIEFsbCB0aGUgb3RoZXIgcHJvcGVydGllcyBhcmUgY29uZmlndXJhdGlvbnMgdGhhdCBjb3VsZCBiZSB0d2Vha2VkLlxuICogQG5hbWVzcGFjZSBtb2RpZmllcnNcbiAqL1xudmFyIG1vZGlmaWVycyA9IHtcbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gc2hpZnQgdGhlIHBvcHBlciBvbiB0aGUgc3RhcnQgb3IgZW5kIG9mIGl0cyByZWZlcmVuY2VcbiAgICogZWxlbWVudC48YnIgLz5cbiAgICogSXQgd2lsbCByZWFkIHRoZSB2YXJpYXRpb24gb2YgdGhlIGBwbGFjZW1lbnRgIHByb3BlcnR5LjxiciAvPlxuICAgKiBJdCBjYW4gYmUgb25lIGVpdGhlciBgLWVuZGAgb3IgYC1zdGFydGAuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBzaGlmdDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0xMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHNoaWZ0XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBgb2Zmc2V0YCBtb2RpZmllciBjYW4gc2hpZnQgeW91ciBwb3BwZXIgb24gYm90aCBpdHMgYXhpcy5cbiAgICpcbiAgICogSXQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHVuaXRzOlxuICAgKiAtIGBweGAgb3IgdW5pdC1sZXNzLCBpbnRlcnByZXRlZCBhcyBwaXhlbHNcbiAgICogLSBgJWAgb3IgYCVyYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICAgKiAtIGAlcGAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogLSBgdndgLCBDU1Mgdmlld3BvcnQgd2lkdGggdW5pdFxuICAgKiAtIGB2aGAsIENTUyB2aWV3cG9ydCBoZWlnaHQgdW5pdFxuICAgKlxuICAgKiBGb3IgbGVuZ3RoIGlzIGludGVuZGVkIHRoZSBtYWluIGF4aXMgcmVsYXRpdmUgdG8gdGhlIHBsYWNlbWVudCBvZiB0aGUgcG9wcGVyLjxiciAvPlxuICAgKiBUaGlzIG1lYW5zIHRoYXQgaWYgdGhlIHBsYWNlbWVudCBpcyBgdG9wYCBvciBgYm90dG9tYCwgdGhlIGxlbmd0aCB3aWxsIGJlIHRoZVxuICAgKiBgd2lkdGhgLiBJbiBjYXNlIG9mIGBsZWZ0YCBvciBgcmlnaHRgLCBpdCB3aWxsIGJlIHRoZSBgaGVpZ2h0YC5cbiAgICpcbiAgICogWW91IGNhbiBwcm92aWRlIGEgc2luZ2xlIHZhbHVlIChhcyBgTnVtYmVyYCBvciBgU3RyaW5nYCksIG9yIGEgcGFpciBvZiB2YWx1ZXNcbiAgICogYXMgYFN0cmluZ2AgZGl2aWRlZCBieSBhIGNvbW1hIG9yIG9uZSAob3IgbW9yZSkgd2hpdGUgc3BhY2VzLjxiciAvPlxuICAgKiBUaGUgbGF0dGVyIGlzIGEgZGVwcmVjYXRlZCBtZXRob2QgYmVjYXVzZSBpdCBsZWFkcyB0byBjb25mdXNpb24gYW5kIHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpbiB2Mi48YnIgLz5cbiAgICogQWRkaXRpb25hbGx5LCBpdCBhY2NlcHRzIGFkZGl0aW9ucyBhbmQgc3VidHJhY3Rpb25zIGJldHdlZW4gZGlmZmVyZW50IHVuaXRzLlxuICAgKiBOb3RlIHRoYXQgbXVsdGlwbGljYXRpb25zIGFuZCBkaXZpc2lvbnMgYXJlbid0IHN1cHBvcnRlZC5cbiAgICpcbiAgICogVmFsaWQgZXhhbXBsZXMgYXJlOlxuICAgKiBgYGBcbiAgICogMTBcbiAgICogJzEwJSdcbiAgICogJzEwLCAxMCdcbiAgICogJzEwJSwgMTAnXG4gICAqICcxMCArIDEwJSdcbiAgICogJzEwIC0gNXZoICsgMyUnXG4gICAqICctMTBweCArIDV2aCwgNXB4IC0gNiUnXG4gICAqIGBgYFxuICAgKiA+ICoqTkIqKjogSWYgeW91IGRlc2lyZSB0byBhcHBseSBvZmZzZXRzIHRvIHlvdXIgcG9wcGVycyBpbiBhIHdheSB0aGF0IG1heSBtYWtlIHRoZW0gb3ZlcmxhcFxuICAgKiA+IHdpdGggdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnQsIHVuZm9ydHVuYXRlbHksIHlvdSB3aWxsIGhhdmUgdG8gZGlzYWJsZSB0aGUgYGZsaXBgIG1vZGlmaWVyLlxuICAgKiA+IFlvdSBjYW4gcmVhZCBtb3JlIG9uIHRoaXMgYXQgdGhpcyBbaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL2lzc3Vlcy8zNzMpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgb2Zmc2V0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTIwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogb2Zmc2V0LFxuICAgIC8qKiBAcHJvcCB7TnVtYmVyfFN0cmluZ30gb2Zmc2V0PTBcbiAgICAgKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBvZmZzZXQ6IDBcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBwcmV2ZW50IHRoZSBwb3BwZXIgZnJvbSBiZWluZyBwb3NpdGlvbmVkIG91dHNpZGUgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBBIHNjZW5hcmlvIGV4aXN0cyB3aGVyZSB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBub3Qgd2l0aGluIHRoZSBib3VuZGFyaWVzLjxiciAvPlxuICAgKiBXZSBjYW4gc2F5IGl0IGhhcyBcImVzY2FwZWQgdGhlIGJvdW5kYXJpZXNcIiDigJQgb3IganVzdCBcImVzY2FwZWRcIi48YnIgLz5cbiAgICogSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHBvcHBlciBzaG91bGQgZWl0aGVyOlxuICAgKlxuICAgKiAtIGRldGFjaCBmcm9tIHRoZSByZWZlcmVuY2UgYW5kIHJlbWFpbiBcInRyYXBwZWRcIiBpbiB0aGUgYm91bmRhcmllcywgb3JcbiAgICogLSBpZiBpdCBzaG91bGQgaWdub3JlIHRoZSBib3VuZGFyeSBhbmQgXCJlc2NhcGUgd2l0aCBpdHMgcmVmZXJlbmNlXCJcbiAgICpcbiAgICogV2hlbiBgZXNjYXBlV2l0aFJlZmVyZW5jZWAgaXMgc2V0IHRvYHRydWVgIGFuZCByZWZlcmVuY2UgaXMgY29tcGxldGVseVxuICAgKiBvdXRzaWRlIGl0cyBib3VuZGFyaWVzLCB0aGUgcG9wcGVyIHdpbGwgb3ZlcmZsb3cgKG9yIGNvbXBsZXRlbHkgbGVhdmUpXG4gICAqIHRoZSBib3VuZGFyaWVzIGluIG9yZGVyIHRvIHJlbWFpbiBhdHRhY2hlZCB0byB0aGUgZWRnZSBvZiB0aGUgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTMwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtBcnJheX0gW3ByaW9yaXR5PVsnbGVmdCcsJ3JpZ2h0JywndG9wJywnYm90dG9tJ11dXG4gICAgICogUG9wcGVyIHdpbGwgdHJ5IHRvIHByZXZlbnQgb3ZlcmZsb3cgZm9sbG93aW5nIHRoZXNlIHByaW9yaXRpZXMgYnkgZGVmYXVsdCxcbiAgICAgKiB0aGVuLCBpdCBjb3VsZCBvdmVyZmxvdyBvbiB0aGUgbGVmdCBhbmQgb24gdG9wIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcHJpb3JpdHk6IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogQW1vdW50IG9mIHBpeGVsIHVzZWQgdG8gZGVmaW5lIGEgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib3VuZGFyaWVzXG4gICAgICogYW5kIHRoZSBwb3BwZXIuIFRoaXMgbWFrZXMgc3VyZSB0aGUgcG9wcGVyIGFsd2F5cyBoYXMgYSBsaXR0bGUgcGFkZGluZ1xuICAgICAqIGJldHdlZW4gdGhlIGVkZ2VzIG9mIGl0cyBjb250YWluZXJcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSdzY3JvbGxQYXJlbnQnXG4gICAgICogQm91bmRhcmllcyB1c2VkIGJ5IHRoZSBtb2RpZmllci4gQ2FuIGJlIGBzY3JvbGxQYXJlbnRgLCBgd2luZG93YCxcbiAgICAgKiBgdmlld3BvcnRgIG9yIGFueSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3Njcm9sbFBhcmVudCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHJlZmVyZW5jZSBhbmQgaXRzIHBvcHBlciBzdGF5IG5lYXIgZWFjaCBvdGhlclxuICAgKiB3aXRob3V0IGxlYXZpbmcgYW55IGdhcCBiZXR3ZWVuIHRoZSB0d28uIEVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gdGhlIGFycm93IGlzXG4gICAqIGVuYWJsZWQgYW5kIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0IGl0IHBvaW50cyB0byBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEl0IGNhcmVzIG9ubHkgYWJvdXQgdGhlIGZpcnN0IGF4aXMuIFlvdSBjYW4gc3RpbGwgaGF2ZSBwb3BwZXJzIHdpdGggbWFyZ2luXG4gICAqIGJldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAga2VlcFRvZ2V0aGVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTQwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNDAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjoga2VlcFRvZ2V0aGVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kaWZpZXIgaXMgdXNlZCB0byBtb3ZlIHRoZSBgYXJyb3dFbGVtZW50YCBvZiB0aGUgcG9wcGVyIHRvIG1ha2VcbiAgICogc3VyZSBpdCBpcyBwb3NpdGlvbmVkIGJldHdlZW4gdGhlIHJlZmVyZW5jZSBlbGVtZW50IGFuZCBpdHMgcG9wcGVyIGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgb3V0ZXIgc2l6ZSBvZiB0aGUgYGFycm93RWxlbWVudGAgbm9kZSB0byBkZXRlY3QgaG93IG1hbnlcbiAgICogcGl4ZWxzIG9mIGNvbmp1bmN0aW9uIGFyZSBuZWVkZWQuXG4gICAqXG4gICAqIEl0IGhhcyBubyBlZmZlY3QgaWYgbm8gYGFycm93RWxlbWVudGAgaXMgcHJvdmlkZWQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcnJvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj01MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDUwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFycm93LFxuICAgIC8qKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBlbGVtZW50PSdbeC1hcnJvd10nIC0gU2VsZWN0b3Igb3Igbm9kZSB1c2VkIGFzIGFycm93ICovXG4gICAgZWxlbWVudDogJ1t4LWFycm93XSdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBmbGlwIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQgd2hlbiBpdCBzdGFydHMgdG8gb3ZlcmxhcCBpdHNcbiAgICogcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICpcbiAgICogKipOT1RFOioqIHRoaXMgbW9kaWZpZXIgd2lsbCBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlIGFuZCB3aWxsXG4gICAqIHJlc3RhcnQgaXQgaWYgaXQgZGV0ZWN0cyB0aGUgbmVlZCB0byBmbGlwIHRoZSBwbGFjZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBmbGlwOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTYwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogZmxpcCxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEFycmF5fSBiZWhhdmlvcj0nZmxpcCdcbiAgICAgKiBUaGUgYmVoYXZpb3IgdXNlZCB0byBjaGFuZ2UgdGhlIHBvcHBlcidzIHBsYWNlbWVudC4gSXQgY2FuIGJlIG9uZSBvZlxuICAgICAqIGBmbGlwYCwgYGNsb2Nrd2lzZWAsIGBjb3VudGVyY2xvY2t3aXNlYCBvciBhbiBhcnJheSB3aXRoIGEgbGlzdCBvZiB2YWxpZFxuICAgICAqIHBsYWNlbWVudHMgKHdpdGggb3B0aW9uYWwgdmFyaWF0aW9ucylcbiAgICAgKi9cbiAgICBiZWhhdmlvcjogJ2ZsaXAnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBmbGlwIGlmIGl0IGhpdHMgdGhlIGVkZ2VzIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0ndmlld3BvcnQnXG4gICAgICogVGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBvcHBlciBwb3NpdGlvbi5cbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgbmV2ZXIgYmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllc1xuICAgICAqIChleGNlcHQgaWYgYGtlZXBUb2dldGhlcmAgaXMgZW5hYmxlZClcbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3ZpZXdwb3J0JyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnM9ZmFsc2VcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgc3dpdGNoIHBsYWNlbWVudCB2YXJpYXRpb24gYmV0d2VlbiBgLXN0YXJ0YCBhbmQgYC1lbmRgIHdoZW5cbiAgICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIGJvdW5kYXJpZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3JpZ2luYWwgcGxhY2VtZW50IHNob3VsZCBoYXZlIGEgc2V0IHZhcmlhdGlvbi5cbiAgICAgKi9cbiAgICBmbGlwVmFyaWF0aW9uczogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGZsaXBWYXJpYXRpb25zQnlDb250ZW50PWZhbHNlXG4gICAgICogVGhlIHBvcHBlciB3aWxsIHN3aXRjaCBwbGFjZW1lbnQgdmFyaWF0aW9uIGJldHdlZW4gYC1zdGFydGAgYW5kIGAtZW5kYCB3aGVuXG4gICAgICogdGhlIHBvcHBlciBlbGVtZW50IG92ZXJsYXBzIGl0cyByZWZlcmVuY2UgYm91bmRhcmllcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAqL1xuICAgIGZsaXBWYXJpYXRpb25zQnlDb250ZW50OiBmYWxzZVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2UgdGhlIHBvcHBlciBmbG93IHRvd2FyZCB0aGUgaW5uZXIgb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBCeSBkZWZhdWx0LCB3aGVuIHRoaXMgbW9kaWZpZXIgaXMgZGlzYWJsZWQsIHRoZSBwb3BwZXIgd2lsbCBiZSBwbGFjZWQgb3V0c2lkZVxuICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBpbm5lcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj03MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDcwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9ZmFsc2UgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaW5uZXJcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBoaWRlIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0c2lkZSBvZiB0aGVcbiAgICogcG9wcGVyIGJvdW5kYXJpZXMuIEl0IHdpbGwgc2V0IGEgYHgtb3V0LW9mLWJvdW5kYXJpZXNgIGF0dHJpYnV0ZSB3aGljaCBjYW5cbiAgICogYmUgdXNlZCB0byBoaWRlIHdpdGggYSBDU1Mgc2VsZWN0b3IgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgaXNcbiAgICogb3V0IG9mIGJvdW5kYXJpZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGhpZGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBoaWRlXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdHlsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGVsZW1lbnQgdG8gZ2V0c1xuICAgKiBwcm9wZXJseSBwb3NpdGlvbmVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtb2RpZmllciB3aWxsIG5vdCB0b3VjaCB0aGUgRE9NLCBpdCBqdXN0IHByZXBhcmVzIHRoZSBzdHlsZXNcbiAgICogc28gdGhhdCBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgY2FuIGFwcGx5IGl0LiBUaGlzIHNlcGFyYXRpb24gaXMgdXNlZnVsXG4gICAqIGluIGNhc2UgeW91IG5lZWQgdG8gcmVwbGFjZSBgYXBwbHlTdHlsZWAgd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtb2RpZmllciBoYXMgYDg1MGAgYXMgYG9yZGVyYCB2YWx1ZSB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgUG9wcGVyLmpzLiBFeHBlY3QgdGhlIG1vZGlmaWVycyBvcmRlcmluZyBtZXRob2RcbiAgICogdG8gY2hhbmdlIGluIGZ1dHVyZSBtYWpvciB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGNvbXB1dGVTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04NTAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDg1MCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGNvbXB1dGVTdHlsZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHRydWUsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2JvdHRvbSddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBYIGF4aXMgKGBib3R0b21gIG9yIGB0b3BgKS4gQUtBIFggb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgYm90dG9tYFxuICAgICAqL1xuICAgIHg6ICdib3R0b20nLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdsZWZ0J11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFkgYXhpcyAoYGxlZnRgIG9yIGByaWdodGApLiBBS0EgWSBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGByaWdodGBcbiAgICAgKi9cbiAgICB5OiAncmlnaHQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGNvbXB1dGVkIHN0eWxlcyB0byB0aGUgcG9wcGVyIGVsZW1lbnQuXG4gICAqXG4gICAqIEFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgYXJlIGxpbWl0ZWQgdG8gdGhpcyBtb2RpZmllci4gVGhpcyBpcyB1c2VmdWwgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBpbnRlZ3JhdGUgUG9wcGVyLmpzIGluc2lkZSBhIGZyYW1ld29yayBvciB2aWV3IGxpYnJhcnkgYW5kIHlvdVxuICAgKiB3YW50IHRvIGRlbGVnYXRlIGFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgdG8gaXQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiB5b3UgZGlzYWJsZSB0aGlzIG1vZGlmaWVyLCB5b3UgbXVzdCBtYWtlIHN1cmUgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIGhhcyBpdHMgcG9zaXRpb24gc2V0IHRvIGBhYnNvbHV0ZWAgYmVmb3JlIFBvcHBlci5qcyBjYW4gZG8gaXRzIHdvcmshXG4gICAqXG4gICAqIEp1c3QgZGlzYWJsZSB0aGlzIG1vZGlmaWVyIGFuZCBkZWZpbmUgeW91ciBvd24gdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCBlZmZlY3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcHBseVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTkwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogOTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXBwbHlTdHlsZSxcbiAgICAvKiogQHByb3Age0Z1bmN0aW9ufSAqL1xuICAgIG9uTG9hZDogYXBwbHlTdHlsZU9uTG9hZCxcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMTAuMCwgdGhlIHByb3BlcnR5IG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNEIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB1bmRlZmluZWRcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgYGRhdGFPYmplY3RgIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgaW5mb3JtYXRpb24gdXNlZCBieSBQb3BwZXIuanMuXG4gKiBUaGlzIG9iamVjdCBpcyBwYXNzZWQgdG8gbW9kaWZpZXJzIGFuZCB0byB0aGUgYG9uQ3JlYXRlYCBhbmQgYG9uVXBkYXRlYCBjYWxsYmFja3MuXG4gKiBAbmFtZSBkYXRhT2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5pbnN0YW5jZSBUaGUgUG9wcGVyLmpzIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5wbGFjZW1lbnQgUGxhY2VtZW50IGFwcGxpZWQgdG8gcG9wcGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5mbGlwcGVkIFRydWUgaWYgcG9wcGVyIGhhcyBiZWVuIGZsaXBwZWQgYnkgZmxpcCBtb2RpZmllclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmhpZGUgVHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0IG9mIGJvdW5kYXJpZXMsIHVzZWZ1bCB0byBrbm93IHdoZW4gdG8gaGlkZSB0aGUgcG9wcGVyXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBkYXRhLmFycm93RWxlbWVudCBOb2RlIHVzZWQgYXMgYXJyb3cgYnkgYXJyb3cgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLnN0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmFycm93U3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGFycm93LiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYm91bmRhcmllcyBPZmZzZXRzIG9mIHRoZSBwb3BwZXIgYm91bmRhcmllc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cyBUaGUgbWVhc3VyZW1lbnRzIG9mIHBvcHBlciwgcmVmZXJlbmNlIGFuZCBhcnJvdyBlbGVtZW50c1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5wb3BwZXIgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMuYXJyb3ddIGB0b3BgIGFuZCBgbGVmdGAgb2Zmc2V0cywgb25seSBvbmUgb2YgdGhlbSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIDBcbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBwcm92aWRlZCB0byBQb3BwZXIuanMgY29uc3RydWN0b3IuPGJyIC8+XG4gKiBUaGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiB1c2luZyB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IG9mIFBvcHBlci5qcy48YnIgLz5cbiAqIFRvIG92ZXJyaWRlIGFuIG9wdGlvbiwgc2ltcGx5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWVcbiAqIHN0cnVjdHVyZSBvZiB0aGUgYG9wdGlvbnNgIG9iamVjdCwgYXMgdGhlIDNyZCBhcmd1bWVudC4gRm9yIGV4YW1wbGU6XG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmLCBwb3AsIHtcbiAqICAgbW9kaWZpZXJzOiB7XG4gKiAgICAgcHJldmVudE92ZXJmbG93OiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIERlZmF1bHRzID0ge1xuICAvKipcbiAgICogUG9wcGVyJ3MgcGxhY2VtZW50LlxuICAgKiBAcHJvcCB7UG9wcGVyLnBsYWNlbWVudHN9IHBsYWNlbWVudD0nYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAvKipcbiAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCBwb3BwZXIgdG8gcG9zaXRpb24gaXQgc2VsZiBpbiAnZml4ZWQnIG1vZGVcbiAgICogQHByb3Age0Jvb2xlYW59IHBvc2l0aW9uRml4ZWQ9ZmFsc2VcbiAgICovXG4gIHBvc2l0aW9uRml4ZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGV2ZW50cyAocmVzaXplLCBzY3JvbGwpIGFyZSBpbml0aWFsbHkgZW5hYmxlZC5cbiAgICogQHByb3Age0Jvb2xlYW59IGV2ZW50c0VuYWJsZWQ9dHJ1ZVxuICAgKi9cbiAgZXZlbnRzRW5hYmxlZDogdHJ1ZSxcblxuICAvKipcbiAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZW1vdmUgdGhlIHBvcHBlciB3aGVuXG4gICAqIHlvdSBjYWxsIHRoZSBgZGVzdHJveWAgbWV0aG9kLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcmVtb3ZlT25EZXN0cm95PWZhbHNlXG4gICAqL1xuICByZW1vdmVPbkRlc3Ryb3k6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIGNyZWF0ZWQuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uQ3JlYXRlfVxuICAgKi9cbiAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgdXBkYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBub3QgY2FsbGVkXG4gICAqIG9uIHRoZSBpbml0aWFsaXphdGlvbi9jcmVhdGlvbiBvZiB0aGUgcG9wcGVyLCBidXQgb25seSBvbiBzdWJzZXF1ZW50XG4gICAqIHVwZGF0ZXMuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uVXBkYXRlfVxuICAgKi9cbiAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgbW9kaWZpZXJzIHVzZWQgdG8gbW9kaWZ5IHRoZSBvZmZzZXRzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuXG4gICAqIFRoZXkgcHJvdmlkZSBtb3N0IG9mIHRoZSBmdW5jdGlvbmFsaXRpZXMgb2YgUG9wcGVyLmpzLlxuICAgKiBAcHJvcCB7bW9kaWZpZXJzfVxuICAgKi9cbiAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIG9uQ3JlYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBvblVwZGF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLy8gVXRpbHNcbi8vIE1ldGhvZHNcbnZhciBQb3BwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFBvcHBlci5qcyBpbnN0YW5jZS5cbiAgICogQGNsYXNzIFBvcHBlclxuICAgKiBAcGFyYW0ge0VsZW1lbnR8cmVmZXJlbmNlT2JqZWN0fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgLyBYTUwgZWxlbWVudCB1c2VkIGFzIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBZb3VyIGN1c3RvbSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBvbmVzIGRlZmluZWQgaW4gW0RlZmF1bHRzXSgjZGVmYXVsdHMpXG4gICAqIEByZXR1cm4ge09iamVjdH0gaW5zdGFuY2UgLSBUaGUgZ2VuZXJhdGVkIFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQb3BwZXIpO1xuXG4gICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMudXBkYXRlKTtcbiAgICB9O1xuXG4gICAgLy8gbWFrZSB1cGRhdGUoKSBkZWJvdW5jZWQsIHNvIHRoYXQgaXQgb25seSBydW5zIGF0IG1vc3Qgb25jZS1wZXItdGlja1xuICAgIHRoaXMudXBkYXRlID0gZGVib3VuY2UodGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG5cbiAgICAvLyB3aXRoIHt9IHdlIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3B0aW9ucyBpbnNpZGUgaXRcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgIC8vIGluaXQgc3RhdGVcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgICAgaXNDcmVhdGVkOiBmYWxzZSxcbiAgICAgIHNjcm9sbFBhcmVudHM6IFtdXG4gICAgfTtcblxuICAgIC8vIGdldCByZWZlcmVuY2UgYW5kIHBvcHBlciBlbGVtZW50cyAoYWxsb3cgalF1ZXJ5IHdyYXBwZXJzKVxuICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5qcXVlcnkgPyByZWZlcmVuY2VbMF0gOiByZWZlcmVuY2U7XG4gICAgdGhpcy5wb3BwZXIgPSBwb3BwZXIgJiYgcG9wcGVyLmpxdWVyeSA/IHBvcHBlclswXSA6IHBvcHBlcjtcblxuICAgIC8vIERlZXAgbWVyZ2UgbW9kaWZpZXJzIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMubW9kaWZpZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnMsIG9wdGlvbnMubW9kaWZpZXJzKSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVyc1tuYW1lXSB8fCB7fSwgb3B0aW9ucy5tb2RpZmllcnMgPyBvcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA6IHt9KTtcbiAgICB9KTtcblxuICAgIC8vIFJlZmFjdG9yaW5nIG1vZGlmaWVycycgbGlzdCAoT2JqZWN0ID0+IEFycmF5KVxuICAgIHRoaXMubW9kaWZpZXJzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLm1vZGlmaWVycykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9LCBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSk7XG4gICAgfSlcbiAgICAvLyBzb3J0IHRoZSBtb2RpZmllcnMgYnkgb3JkZXJcbiAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgIH0pO1xuXG4gICAgLy8gbW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSB3aGVuIFBvcHBlci5qcyBnZXQgaW5pdGVkXG4gICAgLy8gc3VjaCBjb2RlIGlzIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIG9mIGl0cyBtb2RpZmllclxuICAgIC8vIHRoZXkgY291bGQgYWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZWlyIG9wdGlvbnMgY29uZmlndXJhdGlvblxuICAgIC8vIEJFIEFXQVJFOiBkb24ndCBhZGQgb3B0aW9ucyB0byBgb3B0aW9ucy5tb2RpZmllcnMubmFtZWAgYnV0IHRvIGBtb2RpZmllck9wdGlvbnNgIVxuICAgIHRoaXMubW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyT3B0aW9ucykge1xuICAgICAgaWYgKG1vZGlmaWVyT3B0aW9ucy5lbmFibGVkICYmIGlzRnVuY3Rpb24obW9kaWZpZXJPcHRpb25zLm9uTG9hZCkpIHtcbiAgICAgICAgbW9kaWZpZXJPcHRpb25zLm9uTG9hZChfdGhpcy5yZWZlcmVuY2UsIF90aGlzLnBvcHBlciwgX3RoaXMub3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBfdGhpcy5zdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBmaXJlIHRoZSBmaXJzdCB1cGRhdGUgdG8gcG9zaXRpb24gdGhlIHBvcHBlciBpbiB0aGUgcmlnaHQgcGxhY2VcbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgdmFyIGV2ZW50c0VuYWJsZWQgPSB0aGlzLm9wdGlvbnMuZXZlbnRzRW5hYmxlZDtcbiAgICBpZiAoZXZlbnRzRW5hYmxlZCkge1xuICAgICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzLCB0aGV5IHdpbGwgdGFrZSBjYXJlIG9mIHVwZGF0ZSB0aGUgcG9zaXRpb24gaW4gc3BlY2lmaWMgc2l0dWF0aW9uc1xuICAgICAgdGhpcy5lbmFibGVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGV2ZW50c0VuYWJsZWQ7XG4gIH1cblxuICAvLyBXZSBjYW4ndCB1c2UgY2xhc3MgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgZG9uJ3QgZ2V0IGxpc3RlZCBpbiB0aGVcbiAgLy8gY2xhc3MgcHJvdG90eXBlIGFuZCBicmVhayBzdHVmZiBsaWtlIFNpbm9uIHN0dWJzXG5cblxuICBjcmVhdGVDbGFzcyhQb3BwZXIsIFt7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlJCQxKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95JCQxKCkge1xuICAgICAgcmV0dXJuIGRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGVuYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGRpc2FibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhbiB1cGRhdGUuIEl0IHdpbGwgcnVuIG9uIHRoZSBuZXh0IFVJIHVwZGF0ZSBhdmFpbGFibGUuXG4gICAgICogQG1ldGhvZCBzY2hlZHVsZVVwZGF0ZVxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdGlvbiBvZiB1dGlsaXRpZXMgdXNlZnVsIHdoZW4gd3JpdGluZyBjdXN0b20gbW9kaWZpZXJzLlxuICAgICAqIFN0YXJ0aW5nIGZyb20gdmVyc2lvbiAxLjcsIHRoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBvbmx5IGlmIHlvdVxuICAgICAqIGluY2x1ZGUgYHBvcHBlci11dGlscy5qc2AgYmVmb3JlIGBwb3BwZXIuanNgLlxuICAgICAqXG4gICAgICogKipERVBSRUNBVElPTioqOiBUaGlzIHdheSB0byBhY2Nlc3MgUG9wcGVyVXRpbHMgaXMgZGVwcmVjYXRlZFxuICAgICAqIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjIhIFVzZSB0aGUgUG9wcGVyVXRpbHMgbW9kdWxlIGRpcmVjdGx5IGluc3RlYWQuXG4gICAgICogRHVlIHRvIHRoZSBoaWdoIGluc3RhYmlsaXR5IG9mIHRoZSBtZXRob2RzIGNvbnRhaW5lZCBpbiBVdGlscywgd2UgY2FuJ3RcbiAgICAgKiBndWFyYW50ZWUgdGhlbSB0byBmb2xsb3cgc2VtdmVyLiBVc2UgdGhlbSBhdCB5b3VyIG93biByaXNrIVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjhcbiAgICAgKiBAbWVtYmVyIFV0aWxzXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG4gIH1dKTtcbiAgcmV0dXJuIFBvcHBlcjtcbn0oKTtcblxuLyoqXG4gKiBUaGUgYHJlZmVyZW5jZU9iamVjdGAgaXMgYW4gb2JqZWN0IHRoYXQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGNvbXBhdGlibGUgd2l0aCBQb3BwZXIuanNcbiAqIGFuZCBsZXRzIHlvdSB1c2UgaXQgYXMgcmVwbGFjZW1lbnQgb2YgYSByZWFsIERPTSBub2RlLjxiciAvPlxuICogWW91IGNhbiB1c2UgdGhpcyBtZXRob2QgdG8gcG9zaXRpb24gYSBwb3BwZXIgcmVsYXRpdmVseSB0byBhIHNldCBvZiBjb29yZGluYXRlc1xuICogaW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhIERPTSBub2RlIHRvIHVzZSBhcyByZWZlcmVuY2UuXG4gKlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZmVyZW5jZU9iamVjdCwgcG9wcGVyTm9kZSk7XG4gKiBgYGBcbiAqXG4gKiBOQjogVGhpcyBmZWF0dXJlIGlzbid0IHN1cHBvcnRlZCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMC5cbiAqIEBuYW1lIHJlZmVyZW5jZU9iamVjdFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZGF0YS5nZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2V0IG9mIGNvb3JkaW5hdGVzIGNvbXBhdGlibGUgd2l0aCB0aGUgbmF0aXZlIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudFdpZHRoXG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50SGVpZ2h0XG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqL1xuXG5cblBvcHBlci5VdGlscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCkuUG9wcGVyVXRpbHM7XG5Qb3BwZXIucGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5Qb3BwZXIuRGVmYXVsdHMgPSBEZWZhdWx0cztcblxuZXhwb3J0IGRlZmF1bHQgUG9wcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9wcGVyLmpzLm1hcFxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVwcmVjYXRlZFByb3BUeXBlKHZhbGlkYXRvciwgcmVhc29uKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBjb21wb25lbnROYW1lU2FmZSA9IGNvbXBvbmVudE5hbWUgfHwgJzw8YW5vbnltb3VzPj4nO1xuICAgIHZhciBwcm9wRnVsbE5hbWVTYWZlID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9wc1twcm9wTmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFwiVGhlIFwiLmNvbmNhdChsb2NhdGlvbiwgXCIgYFwiKS5jb25jYXQocHJvcEZ1bGxOYW1lU2FmZSwgXCJgIG9mIFwiKSArIFwiYFwiLmNvbmNhdChjb21wb25lbnROYW1lU2FmZSwgXCJgIGlzIGRlcHJlY2F0ZWQuIFwiKS5jb25jYXQocmVhc29uKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59IiwiLy8gVE9ETyB2NTogY29uc2lkZXIgdG8gbWFrZSBpdCBwcml2YXRlXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXRSZWYocmVmLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAocmVmKSB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfVxufSIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBzZXRSZWYgZnJvbSAnLi9zZXRSZWYnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlRm9ya1JlZihyZWZBLCByZWZCKSB7XG4gIC8qKlxuICAgKiBUaGlzIHdpbGwgY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIGlmIHRoZSByZWYgcHJvcHMgY2hhbmdlIGFuZCBhcmUgZGVmaW5lZC5cbiAgICogVGhpcyBtZWFucyByZWFjdCB3aWxsIGNhbGwgdGhlIG9sZCBmb3JrUmVmIHdpdGggYG51bGxgIGFuZCB0aGUgbmV3IGZvcmtSZWZcbiAgICogd2l0aCB0aGUgcmVmLiBDbGVhbnVwIG5hdHVyYWxseSBlbWVyZ2VzIGZyb20gdGhpcyBiZWhhdmlvclxuICAgKi9cbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZWZBID09IG51bGwgJiYgcmVmQiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlZlZhbHVlKSB7XG4gICAgICBzZXRSZWYocmVmQSwgcmVmVmFsdWUpO1xuICAgICAgc2V0UmVmKHJlZkIsIHJlZlZhbHVlKTtcbiAgICB9O1xuICB9LCBbcmVmQSwgcmVmQl0pO1xufSIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZXhhY3RQcm9wLCBIVE1MRWxlbWVudFR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IGRlcHJlY2F0ZWRQcm9wVHlwZSBmcm9tICcuLi91dGlscy9kZXByZWNhdGVkUHJvcFR5cGUnO1xuaW1wb3J0IHNldFJlZiBmcm9tICcuLi91dGlscy9zZXRSZWYnO1xuaW1wb3J0IHVzZUZvcmtSZWYgZnJvbSAnLi4vdXRpbHMvdXNlRm9ya1JlZic7XG5cbmZ1bmN0aW9uIGdldENvbnRhaW5lcihjb250YWluZXIpIHtcbiAgY29udGFpbmVyID0gdHlwZW9mIGNvbnRhaW5lciA9PT0gJ2Z1bmN0aW9uJyA/IGNvbnRhaW5lcigpIDogY29udGFpbmVyOyAvLyAjU3RyaWN0TW9kZSByZWFkeVxuXG4gIHJldHVybiBSZWFjdERPTS5maW5kRE9NTm9kZShjb250YWluZXIpO1xufVxuXG52YXIgdXNlRW5oYW5jZWRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbi8qKlxuICogUG9ydGFscyBwcm92aWRlIGEgZmlyc3QtY2xhc3Mgd2F5IHRvIHJlbmRlciBjaGlsZHJlbiBpbnRvIGEgRE9NIG5vZGVcbiAqIHRoYXQgZXhpc3RzIG91dHNpZGUgdGhlIERPTSBoaWVyYXJjaHkgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKi9cblxudmFyIFBvcnRhbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFBvcnRhbChwcm9wcywgcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY29udGFpbmVyID0gcHJvcHMuY29udGFpbmVyLFxuICAgICAgX3Byb3BzJGRpc2FibGVQb3J0YWwgPSBwcm9wcy5kaXNhYmxlUG9ydGFsLFxuICAgICAgZGlzYWJsZVBvcnRhbCA9IF9wcm9wcyRkaXNhYmxlUG9ydGFsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlUG9ydGFsLFxuICAgICAgb25SZW5kZXJlZCA9IHByb3BzLm9uUmVuZGVyZWQ7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpLFxuICAgICAgbW91bnROb2RlID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgc2V0TW91bnROb2RlID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciBoYW5kbGVSZWYgPSB1c2VGb3JrUmVmKCAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gY2hpbGRyZW4ucmVmIDogbnVsbCwgcmVmKTtcbiAgdXNlRW5oYW5jZWRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghZGlzYWJsZVBvcnRhbCkge1xuICAgICAgc2V0TW91bnROb2RlKGdldENvbnRhaW5lcihjb250YWluZXIpIHx8IGRvY3VtZW50LmJvZHkpO1xuICAgIH1cbiAgfSwgW2NvbnRhaW5lciwgZGlzYWJsZVBvcnRhbF0pO1xuICB1c2VFbmhhbmNlZEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG1vdW50Tm9kZSAmJiAhZGlzYWJsZVBvcnRhbCkge1xuICAgICAgc2V0UmVmKHJlZiwgbW91bnROb2RlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFJlZihyZWYsIG51bGwpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LCBbcmVmLCBtb3VudE5vZGUsIGRpc2FibGVQb3J0YWxdKTtcbiAgdXNlRW5oYW5jZWRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChvblJlbmRlcmVkICYmIChtb3VudE5vZGUgfHwgZGlzYWJsZVBvcnRhbCkpIHtcbiAgICAgIG9uUmVuZGVyZWQoKTtcbiAgICB9XG4gIH0sIFtvblJlbmRlcmVkLCBtb3VudE5vZGUsIGRpc2FibGVQb3J0YWxdKTtcblxuICBpZiAoZGlzYWJsZVBvcnRhbCkge1xuICAgIGlmICggLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGRyZW4sIHtcbiAgICAgICAgcmVmOiBoYW5kbGVSZWZcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHJldHVybiBtb3VudE5vZGUgPyAvKiNfX1BVUkVfXyovUmVhY3RET00uY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBtb3VudE5vZGUpIDogbW91bnROb2RlO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBQb3J0YWwucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogVGhlIGNoaWxkcmVuIHRvIHJlbmRlciBpbnRvIHRoZSBgY29udGFpbmVyYC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogQSBIVE1MIGVsZW1lbnQsIGNvbXBvbmVudCBpbnN0YW5jZSwgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGVpdGhlci5cbiAgICogVGhlIGBjb250YWluZXJgIHdpbGwgaGF2ZSB0aGUgcG9ydGFsIGNoaWxkcmVuIGFwcGVuZGVkIHRvIGl0LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBpdCB1c2VzIHRoZSBib2R5IG9mIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQgb2JqZWN0LFxuICAgKiBzbyBpdCdzIHNpbXBseSBgZG9jdW1lbnQuYm9keWAgbW9zdCBvZiB0aGUgdGltZS5cbiAgICovXG4gIGNvbnRhaW5lcjogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLm9uZU9mVHlwZShbSFRNTEVsZW1lbnRUeXBlLCBQcm9wVHlwZXMuaW5zdGFuY2VPZihSZWFjdC5Db21wb25lbnQpLCBQcm9wVHlwZXMuZnVuY10pLFxuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSBwb3J0YWwgYmVoYXZpb3IuXG4gICAqIFRoZSBjaGlsZHJlbiBzdGF5IHdpdGhpbiBpdCdzIHBhcmVudCBET00gaGllcmFyY2h5LlxuICAgKi9cbiAgZGlzYWJsZVBvcnRhbDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIG9uY2UgdGhlIGNoaWxkcmVuIGhhcyBiZWVuIG1vdW50ZWQgaW50byB0aGUgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIFRoaXMgcHJvcCB3aWxsIGJlIHJlbW92ZWQgaW4gdjUsIHRoZSByZWYgY2FuIGJlIHVzZWQgaW5zdGVhZC5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSByZWYgaW5zdGVhZC5cbiAgICovXG4gIG9uUmVuZGVyZWQ6IGRlcHJlY2F0ZWRQcm9wVHlwZShQcm9wVHlwZXMuZnVuYywgJ1VzZSB0aGUgcmVmIGluc3RlYWQuJylcbn0gOiB2b2lkIDA7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBQb3J0YWxbJ3Byb3BUeXBlcycgKyAnJ10gPSBleGFjdFByb3AoUG9ydGFsLnByb3BUeXBlcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvcnRhbDsiLCIvKipcbiAqIFNhZmUgY2hhaW5lZCBmdW5jdGlvblxuICpcbiAqIFdpbGwgb25seSBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gaWYgbmVlZGVkLFxuICogb3RoZXJ3aXNlIHdpbGwgcGFzcyBiYWNrIGV4aXN0aW5nIGZ1bmN0aW9ucyBvciBudWxsLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmN0aW9ucyB0byBjaGFpblxuICogQHJldHVybnMge2Z1bmN0aW9ufG51bGx9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmNzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBmdW5jKSB7XG4gICAgaWYgKGZ1bmMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ01hdGVyaWFsLVVJOiBJbnZhbGlkIEFyZ3VtZW50IFR5cGUsIG11c3Qgb25seSBwcm92aWRlIGZ1bmN0aW9ucywgdW5kZWZpbmVkLCBvciBudWxsLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBhY2MuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH0sIGZ1bmN0aW9uICgpIHt9KTtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFBvcHBlckpzIGZyb20gJ3BvcHBlci5qcyc7XG5pbXBvcnQgeyBjaGFpblByb3BUeXBlcywgcmVmVHlwZSwgSFRNTEVsZW1lbnRUeXBlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCB7IHVzZVRoZW1lIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3N0eWxlcyc7XG5pbXBvcnQgUG9ydGFsIGZyb20gJy4uL1BvcnRhbCc7XG5pbXBvcnQgY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uIGZyb20gJy4uL3V0aWxzL2NyZWF0ZUNoYWluZWRGdW5jdGlvbic7XG5pbXBvcnQgc2V0UmVmIGZyb20gJy4uL3V0aWxzL3NldFJlZic7XG5pbXBvcnQgdXNlRm9ya1JlZiBmcm9tICcuLi91dGlscy91c2VGb3JrUmVmJztcblxuZnVuY3Rpb24gZmxpcFBsYWNlbWVudChwbGFjZW1lbnQsIHRoZW1lKSB7XG4gIHZhciBkaXJlY3Rpb24gPSB0aGVtZSAmJiB0aGVtZS5kaXJlY3Rpb24gfHwgJ2x0cic7XG5cbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ2x0cicpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgc3dpdGNoIChwbGFjZW1lbnQpIHtcbiAgICBjYXNlICdib3R0b20tZW5kJzpcbiAgICAgIHJldHVybiAnYm90dG9tLXN0YXJ0JztcblxuICAgIGNhc2UgJ2JvdHRvbS1zdGFydCc6XG4gICAgICByZXR1cm4gJ2JvdHRvbS1lbmQnO1xuXG4gICAgY2FzZSAndG9wLWVuZCc6XG4gICAgICByZXR1cm4gJ3RvcC1zdGFydCc7XG5cbiAgICBjYXNlICd0b3Atc3RhcnQnOlxuICAgICAgcmV0dXJuICd0b3AtZW5kJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFuY2hvckVsKGFuY2hvckVsKSB7XG4gIHJldHVybiB0eXBlb2YgYW5jaG9yRWwgPT09ICdmdW5jdGlvbicgPyBhbmNob3JFbCgpIDogYW5jaG9yRWw7XG59XG5cbnZhciB1c2VFbmhhbmNlZEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xudmFyIGRlZmF1bHRQb3BwZXJPcHRpb25zID0ge307XG4vKipcbiAqIFBvcHBlcnMgcmVseSBvbiB0aGUgM3JkIHBhcnR5IGxpYnJhcnkgW1BvcHBlci5qc10oaHR0cHM6Ly9wb3BwZXIuanMub3JnL2RvY3MvdjEvKSBmb3IgcG9zaXRpb25pbmcuXG4gKi9cblxudmFyIFBvcHBlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFBvcHBlcihwcm9wcywgcmVmKSB7XG4gIHZhciBhbmNob3JFbCA9IHByb3BzLmFuY2hvckVsLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNvbnRhaW5lciA9IHByb3BzLmNvbnRhaW5lcixcbiAgICAgIF9wcm9wcyRkaXNhYmxlUG9ydGFsID0gcHJvcHMuZGlzYWJsZVBvcnRhbCxcbiAgICAgIGRpc2FibGVQb3J0YWwgPSBfcHJvcHMkZGlzYWJsZVBvcnRhbCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZVBvcnRhbCxcbiAgICAgIF9wcm9wcyRrZWVwTW91bnRlZCA9IHByb3BzLmtlZXBNb3VudGVkLFxuICAgICAga2VlcE1vdW50ZWQgPSBfcHJvcHMka2VlcE1vdW50ZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGtlZXBNb3VudGVkLFxuICAgICAgbW9kaWZpZXJzID0gcHJvcHMubW9kaWZpZXJzLFxuICAgICAgb3BlbiA9IHByb3BzLm9wZW4sXG4gICAgICBfcHJvcHMkcGxhY2VtZW50ID0gcHJvcHMucGxhY2VtZW50LFxuICAgICAgaW5pdGlhbFBsYWNlbWVudCA9IF9wcm9wcyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/ICdib3R0b20nIDogX3Byb3BzJHBsYWNlbWVudCxcbiAgICAgIF9wcm9wcyRwb3BwZXJPcHRpb25zID0gcHJvcHMucG9wcGVyT3B0aW9ucyxcbiAgICAgIHBvcHBlck9wdGlvbnMgPSBfcHJvcHMkcG9wcGVyT3B0aW9ucyA9PT0gdm9pZCAwID8gZGVmYXVsdFBvcHBlck9wdGlvbnMgOiBfcHJvcHMkcG9wcGVyT3B0aW9ucyxcbiAgICAgIHBvcHBlclJlZlByb3AgPSBwcm9wcy5wb3BwZXJSZWYsXG4gICAgICBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgX3Byb3BzJHRyYW5zaXRpb24gPSBwcm9wcy50cmFuc2l0aW9uLFxuICAgICAgdHJhbnNpdGlvbiA9IF9wcm9wcyR0cmFuc2l0aW9uID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyR0cmFuc2l0aW9uLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImFuY2hvckVsXCIsIFwiY2hpbGRyZW5cIiwgXCJjb250YWluZXJcIiwgXCJkaXNhYmxlUG9ydGFsXCIsIFwia2VlcE1vdW50ZWRcIiwgXCJtb2RpZmllcnNcIiwgXCJvcGVuXCIsIFwicGxhY2VtZW50XCIsIFwicG9wcGVyT3B0aW9uc1wiLCBcInBvcHBlclJlZlwiLCBcInN0eWxlXCIsIFwidHJhbnNpdGlvblwiXSk7XG5cbiAgdmFyIHRvb2x0aXBSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBvd25SZWYgPSB1c2VGb3JrUmVmKHRvb2x0aXBSZWYsIHJlZik7XG4gIHZhciBwb3BwZXJSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBoYW5kbGVQb3BwZXJSZWYgPSB1c2VGb3JrUmVmKHBvcHBlclJlZiwgcG9wcGVyUmVmUHJvcCk7XG4gIHZhciBoYW5kbGVQb3BwZXJSZWZSZWYgPSBSZWFjdC51c2VSZWYoaGFuZGxlUG9wcGVyUmVmKTtcbiAgdXNlRW5oYW5jZWRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGhhbmRsZVBvcHBlclJlZlJlZi5jdXJyZW50ID0gaGFuZGxlUG9wcGVyUmVmO1xuICB9LCBbaGFuZGxlUG9wcGVyUmVmXSk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUocG9wcGVyUmVmUHJvcCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwb3BwZXJSZWYuY3VycmVudDtcbiAgfSwgW10pO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZSh0cnVlKSxcbiAgICAgIGV4aXRlZCA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldEV4aXRlZCA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICB2YXIgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICB2YXIgcnRsUGxhY2VtZW50ID0gZmxpcFBsYWNlbWVudChpbml0aWFsUGxhY2VtZW50LCB0aGVtZSk7XG4gIC8qKlxuICAgKiBwbGFjZW1lbnQgaW5pdGlhbGl6ZWQgZnJvbSBwcm9wIGJ1dCBjYW4gY2hhbmdlIGR1cmluZyBsaWZldGltZSBpZiBtb2RpZmllcnMuZmxpcC5cbiAgICogbW9kaWZpZXJzLmZsaXAgaXMgZXNzZW50aWFsbHkgYSBmbGlwIGZvciBjb250cm9sbGVkL3VuY29udHJvbGxlZCBiZWhhdmlvclxuICAgKi9cblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlMiA9IFJlYWN0LnVzZVN0YXRlKHJ0bFBsYWNlbWVudCksXG4gICAgICBwbGFjZW1lbnQgPSBfUmVhY3QkdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0UGxhY2VtZW50ID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChwb3BwZXJSZWYuY3VycmVudCkge1xuICAgICAgcG9wcGVyUmVmLmN1cnJlbnQudXBkYXRlKCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIGhhbmRsZU9wZW4gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0b29sdGlwUmVmLmN1cnJlbnQgfHwgIWFuY2hvckVsIHx8ICFvcGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBvcHBlclJlZi5jdXJyZW50KSB7XG4gICAgICBwb3BwZXJSZWYuY3VycmVudC5kZXN0cm95KCk7XG4gICAgICBoYW5kbGVQb3BwZXJSZWZSZWYuY3VycmVudChudWxsKTtcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlUG9wcGVyVXBkYXRlID0gZnVuY3Rpb24gaGFuZGxlUG9wcGVyVXBkYXRlKGRhdGEpIHtcbiAgICAgIHNldFBsYWNlbWVudChkYXRhLnBsYWNlbWVudCk7XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlZEFuY2hvckVsID0gZ2V0QW5jaG9yRWwoYW5jaG9yRWwpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChyZXNvbHZlZEFuY2hvckVsICYmIHJlc29sdmVkQW5jaG9yRWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgdmFyIGJveCA9IHJlc29sdmVkQW5jaG9yRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiYgYm94LnRvcCA9PT0gMCAmJiBib3gubGVmdCA9PT0gMCAmJiBib3gucmlnaHQgPT09IDAgJiYgYm94LmJvdHRvbSA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihbJ01hdGVyaWFsLVVJOiBUaGUgYGFuY2hvckVsYCBwcm9wIHByb3ZpZGVkIHRvIHRoZSBjb21wb25lbnQgaXMgaW52YWxpZC4nLCAnVGhlIGFuY2hvciBlbGVtZW50IHNob3VsZCBiZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBsYXlvdXQuJywgXCJNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgcHJlc2VudCBpbiB0aGUgZG9jdW1lbnQgb3IgdGhhdCBpdCdzIG5vdCBkaXNwbGF5IG5vbmUuXCJdLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwb3BwZXIgPSBuZXcgUG9wcGVySnMoZ2V0QW5jaG9yRWwoYW5jaG9yRWwpLCB0b29sdGlwUmVmLmN1cnJlbnQsIF9leHRlbmRzKHtcbiAgICAgIHBsYWNlbWVudDogcnRsUGxhY2VtZW50XG4gICAgfSwgcG9wcGVyT3B0aW9ucywge1xuICAgICAgbW9kaWZpZXJzOiBfZXh0ZW5kcyh7fSwgZGlzYWJsZVBvcnRhbCA/IHt9IDoge1xuICAgICAgICAvLyBJdCdzIHVzaW5nIHNjcm9sbFBhcmVudCBieSBkZWZhdWx0LCB3ZSBjYW4gdXNlIHRoZSB2aWV3cG9ydCB3aGVuIHVzaW5nIGEgcG9ydGFsLlxuICAgICAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAgICAgICBib3VuZGFyaWVzRWxlbWVudDogJ3dpbmRvdydcbiAgICAgICAgfVxuICAgICAgfSwgbW9kaWZpZXJzLCBwb3BwZXJPcHRpb25zLm1vZGlmaWVycyksXG4gICAgICAvLyBXZSBjb3VsZCBoYXZlIGJlZW4gdXNpbmcgYSBjdXN0b20gbW9kaWZpZXIgbGlrZSByZWFjdC1wb3BwZXIgaXMgZG9pbmcuXG4gICAgICAvLyBCdXQgaXQgc2VlbXMgdGhpcyBpcyB0aGUgYmVzdCBwdWJsaWMgQVBJIGZvciB0aGlzIHVzZSBjYXNlLlxuICAgICAgb25DcmVhdGU6IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihoYW5kbGVQb3BwZXJVcGRhdGUsIHBvcHBlck9wdGlvbnMub25DcmVhdGUpLFxuICAgICAgb25VcGRhdGU6IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihoYW5kbGVQb3BwZXJVcGRhdGUsIHBvcHBlck9wdGlvbnMub25VcGRhdGUpXG4gICAgfSkpO1xuICAgIGhhbmRsZVBvcHBlclJlZlJlZi5jdXJyZW50KHBvcHBlcik7XG4gIH0sIFthbmNob3JFbCwgZGlzYWJsZVBvcnRhbCwgbW9kaWZpZXJzLCBvcGVuLCBydGxQbGFjZW1lbnQsIHBvcHBlck9wdGlvbnNdKTtcbiAgdmFyIGhhbmRsZVJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgc2V0UmVmKG93blJlZiwgbm9kZSk7XG4gICAgaGFuZGxlT3BlbigpO1xuICB9LCBbb3duUmVmLCBoYW5kbGVPcGVuXSk7XG5cbiAgdmFyIGhhbmRsZUVudGVyID0gZnVuY3Rpb24gaGFuZGxlRW50ZXIoKSB7XG4gICAgc2V0RXhpdGVkKGZhbHNlKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlQ2xvc2UgPSBmdW5jdGlvbiBoYW5kbGVDbG9zZSgpIHtcbiAgICBpZiAoIXBvcHBlclJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcG9wcGVyUmVmLmN1cnJlbnQuZGVzdHJveSgpO1xuICAgIGhhbmRsZVBvcHBlclJlZlJlZi5jdXJyZW50KG51bGwpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVFeGl0ZWQgPSBmdW5jdGlvbiBoYW5kbGVFeGl0ZWQoKSB7XG4gICAgc2V0RXhpdGVkKHRydWUpO1xuICAgIGhhbmRsZUNsb3NlKCk7XG4gIH07XG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaGFuZGxlQ2xvc2UoKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFvcGVuICYmICF0cmFuc2l0aW9uKSB7XG4gICAgICAvLyBPdGhlcndpc2UgaGFuZGxlRXhpdGVkIHdpbGwgY2FsbCB0aGlzLlxuICAgICAgaGFuZGxlQ2xvc2UoKTtcbiAgICB9XG4gIH0sIFtvcGVuLCB0cmFuc2l0aW9uXSk7XG5cbiAgaWYgKCFrZWVwTW91bnRlZCAmJiAhb3BlbiAmJiAoIXRyYW5zaXRpb24gfHwgZXhpdGVkKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNoaWxkUHJvcHMgPSB7XG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfTtcblxuICBpZiAodHJhbnNpdGlvbikge1xuICAgIGNoaWxkUHJvcHMuVHJhbnNpdGlvblByb3BzID0ge1xuICAgICAgaW46IG9wZW4sXG4gICAgICBvbkVudGVyOiBoYW5kbGVFbnRlcixcbiAgICAgIG9uRXhpdGVkOiBoYW5kbGVFeGl0ZWRcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvcnRhbCwge1xuICAgIGRpc2FibGVQb3J0YWw6IGRpc2FibGVQb3J0YWwsXG4gICAgY29udGFpbmVyOiBjb250YWluZXJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogaGFuZGxlUmVmLFxuICAgIHJvbGU6IFwidG9vbHRpcFwiXG4gIH0sIG90aGVyLCB7XG4gICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgIC8vIFByZXZlbnRzIHNjcm9sbCBpc3N1ZSwgd2FpdGluZyBmb3IgUG9wcGVyLmpzIHRvIGFkZCB0aGlzIHN0eWxlIG9uY2UgaW5pdGlhdGVkLlxuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAvLyBGaXggUG9wcGVyLmpzIGRpc3BsYXkgaXNzdWVcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBkaXNwbGF5OiAhb3BlbiAmJiBrZWVwTW91bnRlZCAmJiAhdHJhbnNpdGlvbiA/ICdub25lJyA6IG51bGxcbiAgICB9LCBzdHlsZSlcbiAgfSksIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkcmVuKGNoaWxkUHJvcHMpIDogY2hpbGRyZW4pKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUG9wcGVyLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIEEgSFRNTCBlbGVtZW50LCBbcmVmZXJlbmNlT2JqZWN0XShodHRwczovL3BvcHBlci5qcy5vcmcvZG9jcy92MS8jcmVmZXJlbmNlT2JqZWN0KSxcbiAgICogb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgZWl0aGVyLlxuICAgKiBJdCdzIHVzZWQgdG8gc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLlxuICAgKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgcGFzc2VkIGFzIHRoZSByZWZlcmVuY2Ugb2JqZWN0IG9mIHRoZSBQb3BwZXIgaW5zdGFuY2UuXG4gICAqL1xuICBhbmNob3JFbDogY2hhaW5Qcm9wVHlwZXMoUHJvcFR5cGVzLm9uZU9mVHlwZShbSFRNTEVsZW1lbnRUeXBlLCBQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuZnVuY10pLCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBpZiAocHJvcHMub3Blbikge1xuICAgICAgdmFyIHJlc29sdmVkQW5jaG9yRWwgPSBnZXRBbmNob3JFbChwcm9wcy5hbmNob3JFbCk7XG5cbiAgICAgIGlmIChyZXNvbHZlZEFuY2hvckVsICYmIHJlc29sdmVkQW5jaG9yRWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgdmFyIGJveCA9IHJlc29sdmVkQW5jaG9yRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiYgYm94LnRvcCA9PT0gMCAmJiBib3gubGVmdCA9PT0gMCAmJiBib3gucmlnaHQgPT09IDAgJiYgYm94LmJvdHRvbSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoWydNYXRlcmlhbC1VSTogVGhlIGBhbmNob3JFbGAgcHJvcCBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50IGlzIGludmFsaWQuJywgJ1RoZSBhbmNob3IgZWxlbWVudCBzaG91bGQgYmUgcGFydCBvZiB0aGUgZG9jdW1lbnQgbGF5b3V0LicsIFwiTWFrZSBzdXJlIHRoZSBlbGVtZW50IGlzIHByZXNlbnQgaW4gdGhlIGRvY3VtZW50IG9yIHRoYXQgaXQncyBub3QgZGlzcGxheSBub25lLlwiXS5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXJlc29sdmVkQW5jaG9yRWwgfHwgdHlwZW9mIHJlc29sdmVkQW5jaG9yRWwuY2xpZW50V2lkdGggIT09ICdudW1iZXInIHx8IHR5cGVvZiByZXNvbHZlZEFuY2hvckVsLmNsaWVudEhlaWdodCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHJlc29sdmVkQW5jaG9yRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoWydNYXRlcmlhbC1VSTogVGhlIGBhbmNob3JFbGAgcHJvcCBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50IGlzIGludmFsaWQuJywgJ0l0IHNob3VsZCBiZSBhbiBIVE1MIGVsZW1lbnQgaW5zdGFuY2Ugb3IgYSByZWZlcmVuY2VPYmplY3QgJywgJyhodHRwczovL3BvcHBlci5qcy5vcmcvZG9jcy92MS8jcmVmZXJlbmNlT2JqZWN0KS4nXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0pLFxuXG4gIC8qKlxuICAgKiBQb3BwZXIgcmVuZGVyIGZ1bmN0aW9uIG9yIG5vZGUuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLm9uZU9mVHlwZShbUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5mdW5jXSkuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogQSBIVE1MIGVsZW1lbnQsIGNvbXBvbmVudCBpbnN0YW5jZSwgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGVpdGhlci5cbiAgICogVGhlIGBjb250YWluZXJgIHdpbGwgaGF2ZSB0aGUgcG9ydGFsIGNoaWxkcmVuIGFwcGVuZGVkIHRvIGl0LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBpdCB1c2VzIHRoZSBib2R5IG9mIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQgb2JqZWN0LFxuICAgKiBzbyBpdCdzIHNpbXBseSBgZG9jdW1lbnQuYm9keWAgbW9zdCBvZiB0aGUgdGltZS5cbiAgICovXG4gIGNvbnRhaW5lcjogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLm9uZU9mVHlwZShbSFRNTEVsZW1lbnRUeXBlLCBQcm9wVHlwZXMuaW5zdGFuY2VPZihSZWFjdC5Db21wb25lbnQpLCBQcm9wVHlwZXMuZnVuY10pLFxuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSBwb3J0YWwgYmVoYXZpb3IuXG4gICAqIFRoZSBjaGlsZHJlbiBzdGF5IHdpdGhpbiBpdCdzIHBhcmVudCBET00gaGllcmFyY2h5LlxuICAgKi9cbiAgZGlzYWJsZVBvcnRhbDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEFsd2F5cyBrZWVwIHRoZSBjaGlsZHJlbiBpbiB0aGUgRE9NLlxuICAgKiBUaGlzIHByb3AgY2FuIGJlIHVzZWZ1bCBpbiBTRU8gc2l0dWF0aW9uIG9yXG4gICAqIHdoZW4geW91IHdhbnQgdG8gbWF4aW1pemUgdGhlIHJlc3BvbnNpdmVuZXNzIG9mIHRoZSBQb3BwZXIuXG4gICAqL1xuICBrZWVwTW91bnRlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFBvcHBlci5qcyBpcyBiYXNlZCBvbiBhIFwicGx1Z2luLWxpa2VcIiBhcmNoaXRlY3R1cmUsXG4gICAqIG1vc3Qgb2YgaXRzIGZlYXR1cmVzIGFyZSBmdWxseSBlbmNhcHN1bGF0ZWQgXCJtb2RpZmllcnNcIi5cbiAgICpcbiAgICogQSBtb2RpZmllciBpcyBhIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGVhY2ggdGltZSBQb3BwZXIuanMgbmVlZHMgdG9cbiAgICogY29tcHV0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcHBlci5cbiAgICogRm9yIHRoaXMgcmVhc29uLCBtb2RpZmllcnMgc2hvdWxkIGJlIHZlcnkgcGVyZm9ybWFudCB0byBhdm9pZCBib3R0bGVuZWNrcy5cbiAgICogVG8gbGVhcm4gaG93IHRvIGNyZWF0ZSBhIG1vZGlmaWVyLCBbcmVhZCB0aGUgbW9kaWZpZXJzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vcG9wcGVyLmpzLm9yZy9kb2NzL3YxLyNtb2RpZmllcnMpLlxuICAgKi9cbiAgbW9kaWZpZXJzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBwb3BwZXIgaXMgdmlzaWJsZS5cbiAgICovXG4gIG9wZW46IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIFBvcHBlciBwbGFjZW1lbnQuXG4gICAqL1xuICBwbGFjZW1lbnQ6IFByb3BUeXBlcy5vbmVPZihbJ2JvdHRvbS1lbmQnLCAnYm90dG9tLXN0YXJ0JywgJ2JvdHRvbScsICdsZWZ0LWVuZCcsICdsZWZ0LXN0YXJ0JywgJ2xlZnQnLCAncmlnaHQtZW5kJywgJ3JpZ2h0LXN0YXJ0JywgJ3JpZ2h0JywgJ3RvcC1lbmQnLCAndG9wLXN0YXJ0JywgJ3RvcCddKSxcblxuICAvKipcbiAgICogT3B0aW9ucyBwcm92aWRlZCB0byB0aGUgW2Bwb3BwZXIuanNgXShodHRwczovL3BvcHBlci5qcy5vcmcvZG9jcy92MS8pIGluc3RhbmNlLlxuICAgKi9cbiAgcG9wcGVyT3B0aW9uczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQSByZWYgdGhhdCBwb2ludHMgdG8gdGhlIHVzZWQgcG9wcGVyIGluc3RhbmNlLlxuICAgKi9cbiAgcG9wcGVyUmVmOiByZWZUeXBlLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogSGVscCBzdXBwb3J0aW5nIGEgcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9UcmFuc2l0aW9uIGNvbXBvbmVudC5cbiAgICovXG4gIHRyYW5zaXRpb246IFByb3BUeXBlcy5ib29sXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgUG9wcGVyOyIsImltcG9ydCB7IGZvcm1hdE11aUVycm9yTWVzc2FnZSBhcyBfZm9ybWF0TXVpRXJyb3JNZXNzYWdlIH0gZnJvbSBcIkBtYXRlcmlhbC11aS91dGlsc1wiO1xuLy8gSXQgc2hvdWxkIHRvIGJlIG5vdGVkIHRoYXQgdGhpcyBmdW5jdGlvbiBpc24ndCBlcXVpdmFsZW50IHRvIGB0ZXh0LXRyYW5zZm9ybTogY2FwaXRhbGl6ZWAuXG4vL1xuLy8gQSBzdHJpY3QgY2FwaXRhbGl6YXRpb24gc2hvdWxkIHVwcGVyY2FzZSB0aGUgZmlyc3QgbGV0dGVyIG9mIGVhY2ggd29yZCBhIHRoZSBzZW50ZW5jZS5cbi8vIFdlIG9ubHkgaGFuZGxlIHRoZSBmaXJzdCB3b3JkLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiTWF0ZXJpYWwtVUk6IGNhcGl0YWxpemUoc3RyaW5nKSBleHBlY3RzIGEgc3RyaW5nIGFyZ3VtZW50LlwiIDogX2Zvcm1hdE11aUVycm9yTWVzc2FnZSg3KSk7XG4gIH1cblxuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCBjYXBpdGFsaXplIGZyb20gJy4uL3V0aWxzL2NhcGl0YWxpemUnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IHtcbiAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgbGluZUhlaWdodDogJzQ4cHgnLFxuICAgICAgbGlzdFN0eWxlOiAnbm9uZScsXG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS50ZXh0LnNlY29uZGFyeSxcbiAgICAgIGZvbnRGYW1pbHk6IHRoZW1lLnR5cG9ncmFwaHkuZm9udEZhbWlseSxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoZW1lLnR5cG9ncmFwaHkuZm9udFdlaWdodE1lZGl1bSxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LnB4VG9SZW0oMTQpXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbG9yPVwicHJpbWFyeVwiYC4gKi9cbiAgICBjb2xvclByaW1hcnk6IHtcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnByaW1hcnkubWFpblxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBjb2xvcj1cImluaGVyaXRcImAuICovXG4gICAgY29sb3JJbmhlcml0OiB7XG4gICAgICBjb2xvcjogJ2luaGVyaXQnXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBpbm5lciBgY29tcG9uZW50YCBlbGVtZW50IGlmIGBkaXNhYmxlR3V0dGVycz17ZmFsc2V9YC4gKi9cbiAgICBndXR0ZXJzOiB7XG4gICAgICBwYWRkaW5nTGVmdDogMTYsXG4gICAgICBwYWRkaW5nUmlnaHQ6IDE2XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGluc2V0PXt0cnVlfWAuICovXG4gICAgaW5zZXQ6IHtcbiAgICAgIHBhZGRpbmdMZWZ0OiA3MlxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBkaXNhYmxlU3RpY2t5PXtmYWxzZX1gLiAqL1xuICAgIHN0aWNreToge1xuICAgICAgcG9zaXRpb246ICdzdGlja3knLFxuICAgICAgdG9wOiAwLFxuICAgICAgekluZGV4OiAxLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnaW5oZXJpdCdcbiAgICB9XG4gIH07XG59O1xudmFyIExpc3RTdWJoZWFkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBMaXN0U3ViaGVhZGVyKHByb3BzLCByZWYpIHtcbiAgdmFyIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgX3Byb3BzJGNvbG9yID0gcHJvcHMuY29sb3IsXG4gICAgICBjb2xvciA9IF9wcm9wcyRjb2xvciA9PT0gdm9pZCAwID8gJ2RlZmF1bHQnIDogX3Byb3BzJGNvbG9yLFxuICAgICAgX3Byb3BzJGNvbXBvbmVudCA9IHByb3BzLmNvbXBvbmVudCxcbiAgICAgIENvbXBvbmVudCA9IF9wcm9wcyRjb21wb25lbnQgPT09IHZvaWQgMCA/ICdsaScgOiBfcHJvcHMkY29tcG9uZW50LFxuICAgICAgX3Byb3BzJGRpc2FibGVHdXR0ZXJzID0gcHJvcHMuZGlzYWJsZUd1dHRlcnMsXG4gICAgICBkaXNhYmxlR3V0dGVycyA9IF9wcm9wcyRkaXNhYmxlR3V0dGVycyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZUd1dHRlcnMsXG4gICAgICBfcHJvcHMkZGlzYWJsZVN0aWNreSA9IHByb3BzLmRpc2FibGVTdGlja3ksXG4gICAgICBkaXNhYmxlU3RpY2t5ID0gX3Byb3BzJGRpc2FibGVTdGlja3kgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVTdGlja3ksXG4gICAgICBfcHJvcHMkaW5zZXQgPSBwcm9wcy5pbnNldCxcbiAgICAgIGluc2V0ID0gX3Byb3BzJGluc2V0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRpbnNldCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29sb3JcIiwgXCJjb21wb25lbnRcIiwgXCJkaXNhYmxlR3V0dGVyc1wiLCBcImRpc2FibGVTdGlja3lcIiwgXCJpbnNldFwiXSk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSwgY29sb3IgIT09ICdkZWZhdWx0JyAmJiBjbGFzc2VzW1wiY29sb3JcIi5jb25jYXQoY2FwaXRhbGl6ZShjb2xvcikpXSwgaW5zZXQgJiYgY2xhc3Nlcy5pbnNldCwgIWRpc2FibGVTdGlja3kgJiYgY2xhc3Nlcy5zdGlja3ksICFkaXNhYmxlR3V0dGVycyAmJiBjbGFzc2VzLmd1dHRlcnMpLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IExpc3RTdWJoZWFkZXIucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIHRob3NlIHRoZW1lIGNvbG9ycyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ2RlZmF1bHQnLCAncHJpbWFyeScsICdpbmhlcml0J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgTGlzdCBTdWJoZWFkZXIgd2lsbCBub3QgaGF2ZSBndXR0ZXJzLlxuICAgKi9cbiAgZGlzYWJsZUd1dHRlcnM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBMaXN0IFN1YmhlYWRlciB3aWxsIG5vdCBzdGljayB0byB0aGUgdG9wIGR1cmluZyBzY3JvbGwuXG4gICAqL1xuICBkaXNhYmxlU3RpY2t5OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgTGlzdCBTdWJoZWFkZXIgd2lsbCBiZSBpbmRlbnRlZC5cbiAgICovXG4gIGluc2V0OiBQcm9wVHlwZXMuYm9vbFxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlMaXN0U3ViaGVhZGVyJ1xufSkoTGlzdFN1YmhlYWRlcik7IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHsgY2hhaW5Qcm9wVHlwZXMgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgdmFyIGVsZXZhdGlvbnMgPSB7fTtcbiAgdGhlbWUuc2hhZG93cy5mb3JFYWNoKGZ1bmN0aW9uIChzaGFkb3csIGluZGV4KSB7XG4gICAgZWxldmF0aW9uc1tcImVsZXZhdGlvblwiLmNvbmNhdChpbmRleCldID0ge1xuICAgICAgYm94U2hhZG93OiBzaGFkb3dcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5iYWNrZ3JvdW5kLnBhcGVyLFxuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudGV4dC5wcmltYXJ5LFxuICAgICAgdHJhbnNpdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKCdib3gtc2hhZG93JylcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgc3F1YXJlPXtmYWxzZX1gLiAqL1xuICAgIHJvdW5kZWQ6IHtcbiAgICAgIGJvcmRlclJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHZhcmlhbnQ9XCJvdXRsaW5lZFwiYC4gKi9cbiAgICBvdXRsaW5lZDoge1xuICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCBcIi5jb25jYXQodGhlbWUucGFsZXR0ZS5kaXZpZGVyKVxuICAgIH1cbiAgfSwgZWxldmF0aW9ucyk7XG59O1xudmFyIFBhcGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gUGFwZXIocHJvcHMsIHJlZikge1xuICB2YXIgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkY29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50LFxuICAgICAgQ29tcG9uZW50ID0gX3Byb3BzJGNvbXBvbmVudCA9PT0gdm9pZCAwID8gJ2RpdicgOiBfcHJvcHMkY29tcG9uZW50LFxuICAgICAgX3Byb3BzJHNxdWFyZSA9IHByb3BzLnNxdWFyZSxcbiAgICAgIHNxdWFyZSA9IF9wcm9wcyRzcXVhcmUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJHNxdWFyZSxcbiAgICAgIF9wcm9wcyRlbGV2YXRpb24gPSBwcm9wcy5lbGV2YXRpb24sXG4gICAgICBlbGV2YXRpb24gPSBfcHJvcHMkZWxldmF0aW9uID09PSB2b2lkIDAgPyAxIDogX3Byb3BzJGVsZXZhdGlvbixcbiAgICAgIF9wcm9wcyR2YXJpYW50ID0gcHJvcHMudmFyaWFudCxcbiAgICAgIHZhcmlhbnQgPSBfcHJvcHMkdmFyaWFudCA9PT0gdm9pZCAwID8gJ2VsZXZhdGlvbicgOiBfcHJvcHMkdmFyaWFudCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29tcG9uZW50XCIsIFwic3F1YXJlXCIsIFwiZWxldmF0aW9uXCIsIFwidmFyaWFudFwiXSk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSwgdmFyaWFudCA9PT0gJ291dGxpbmVkJyA/IGNsYXNzZXMub3V0bGluZWQgOiBjbGFzc2VzW1wiZWxldmF0aW9uXCIuY29uY2F0KGVsZXZhdGlvbildLCAhc3F1YXJlICYmIGNsYXNzZXMucm91bmRlZCksXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUGFwZXIucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBTaGFkb3cgZGVwdGgsIGNvcnJlc3BvbmRzIHRvIGBkcGAgaW4gdGhlIHNwZWMuXG4gICAqIEl0IGFjY2VwdHMgdmFsdWVzIGJldHdlZW4gMCBhbmQgMjQgaW5jbHVzaXZlLlxuICAgKi9cbiAgZWxldmF0aW9uOiBjaGFpblByb3BUeXBlcyhQcm9wVHlwZXMubnVtYmVyLCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICAgIGVsZXZhdGlvbiA9IHByb3BzLmVsZXZhdGlvbjsgLy8gaW4gY2FzZSBgd2l0aFN0eWxlc2AgZmFpbHMgdG8gaW5qZWN0IHdlIGRvbid0IG5lZWQgdGhpcyB3YXJuaW5nXG5cbiAgICBpZiAoY2xhc3NlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZWxldmF0aW9uICE9IG51bGwgJiYgY2xhc3Nlc1tcImVsZXZhdGlvblwiLmNvbmNhdChlbGV2YXRpb24pXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFwiTWF0ZXJpYWwtVUk6IFRoaXMgZWxldmF0aW9uIGBcIi5jb25jYXQoZWxldmF0aW9uLCBcImAgaXMgbm90IGltcGxlbWVudGVkLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0pLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHJvdW5kZWQgY29ybmVycyBhcmUgZGlzYWJsZWQuXG4gICAqL1xuICBzcXVhcmU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgdmFyaWFudCB0byB1c2UuXG4gICAqL1xuICB2YXJpYW50OiBQcm9wVHlwZXMub25lT2YoWydlbGV2YXRpb24nLCAnb3V0bGluZWQnXSlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpUGFwZXInXG59KShQYXBlcik7IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xudmFyIHVzZUVuaGFuY2VkRWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQwOTkjaXNzdWVjb21tZW50LTQ0MDAxMzg5MlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlRXZlbnRDYWxsYmFjayhmbikge1xuICB2YXIgcmVmID0gUmVhY3QudXNlUmVmKGZuKTtcbiAgdXNlRW5oYW5jZWRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZi5jdXJyZW50ID0gZm47XG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoMCwgcmVmLmN1cnJlbnQpLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSwgW10pO1xufSIsIi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL2ZvY3VzLXZpc2libGUvYmxvYi92NC4xLjUvc3JjL2ZvY3VzLXZpc2libGUuanNcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG52YXIgaGFkS2V5Ym9hcmRFdmVudCA9IHRydWU7XG52YXIgaGFkRm9jdXNWaXNpYmxlUmVjZW50bHkgPSBmYWxzZTtcbnZhciBoYWRGb2N1c1Zpc2libGVSZWNlbnRseVRpbWVvdXQgPSBudWxsO1xudmFyIGlucHV0VHlwZXNXaGl0ZWxpc3QgPSB7XG4gIHRleHQ6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdXJsOiB0cnVlLFxuICB0ZWw6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBkYXRlOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgd2VlazogdHJ1ZSxcbiAgdGltZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWVcbn07XG4vKipcbiAqIENvbXB1dGVzIHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgdHJpZ2dlciB0aGVcbiAqIGBmb2N1cy12aXNpYmxlYCBjbGFzcyBiZWluZyBhZGRlZCwgaS5lLiB3aGV0aGVyIGl0IHNob3VsZCBhbHdheXMgbWF0Y2hcbiAqIGA6Zm9jdXMtdmlzaWJsZWAgd2hlbiBmb2N1c2VkLlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGZvY3VzVHJpZ2dlcnNLZXlib2FyZE1vZGFsaXR5KG5vZGUpIHtcbiAgdmFyIHR5cGUgPSBub2RlLnR5cGUsXG4gICAgICB0YWdOYW1lID0gbm9kZS50YWdOYW1lO1xuXG4gIGlmICh0YWdOYW1lID09PSAnSU5QVVQnICYmIGlucHV0VHlwZXNXaGl0ZWxpc3RbdHlwZV0gJiYgIW5vZGUucmVhZE9ubHkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0YWdOYW1lID09PSAnVEVYVEFSRUEnICYmICFub2RlLnJlYWRPbmx5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAobm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBLZWVwIHRyYWNrIG9mIG91ciBrZXlib2FyZCBtb2RhbGl0eSBzdGF0ZSB3aXRoIGBoYWRLZXlib2FyZEV2ZW50YC5cbiAqIElmIHRoZSBtb3N0IHJlY2VudCB1c2VyIGludGVyYWN0aW9uIHdhcyB2aWEgdGhlIGtleWJvYXJkO1xuICogYW5kIHRoZSBrZXkgcHJlc3MgZGlkIG5vdCBpbmNsdWRlIGEgbWV0YSwgYWx0L29wdGlvbiwgb3IgY29udHJvbCBrZXk7XG4gKiB0aGVuIHRoZSBtb2RhbGl0eSBpcyBrZXlib2FyZC4gT3RoZXJ3aXNlLCB0aGUgbW9kYWxpdHkgaXMgbm90IGtleWJvYXJkLlxuICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxuICovXG5cblxuZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICBpZiAoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGhhZEtleWJvYXJkRXZlbnQgPSB0cnVlO1xufVxuLyoqXG4gKiBJZiBhdCBhbnkgcG9pbnQgYSB1c2VyIGNsaWNrcyB3aXRoIGEgcG9pbnRpbmcgZGV2aWNlLCBlbnN1cmUgdGhhdCB3ZSBjaGFuZ2VcbiAqIHRoZSBtb2RhbGl0eSBhd2F5IGZyb20ga2V5Ym9hcmQuXG4gKiBUaGlzIGF2b2lkcyB0aGUgc2l0dWF0aW9uIHdoZXJlIGEgdXNlciBwcmVzc2VzIGEga2V5IG9uIGFuIGFscmVhZHkgZm9jdXNlZFxuICogZWxlbWVudCwgYW5kIHRoZW4gY2xpY2tzIG9uIGEgZGlmZmVyZW50IGVsZW1lbnQsIGZvY3VzaW5nIGl0IHdpdGggYVxuICogcG9pbnRpbmcgZGV2aWNlLCB3aGlsZSB3ZSBzdGlsbCB0aGluayB3ZSdyZSBpbiBrZXlib2FyZCBtb2RhbGl0eS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJEb3duKCkge1xuICBoYWRLZXlib2FyZEV2ZW50ID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gIGlmICh0aGlzLnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAvLyBJZiB0aGUgdGFiIGJlY29tZXMgYWN0aXZlIGFnYWluLCB0aGUgYnJvd3NlciB3aWxsIGhhbmRsZSBjYWxsaW5nIGZvY3VzXG4gICAgLy8gb24gdGhlIGVsZW1lbnQgKFNhZmFyaSBhY3R1YWxseSBjYWxscyBpdCB0d2ljZSkuXG4gICAgLy8gSWYgdGhpcyB0YWIgY2hhbmdlIGNhdXNlZCBhIGJsdXIgb24gYW4gZWxlbWVudCB3aXRoIGZvY3VzLXZpc2libGUsXG4gICAgLy8gcmUtYXBwbHkgdGhlIGNsYXNzIHdoZW4gdGhlIHVzZXIgc3dpdGNoZXMgYmFjayB0byB0aGUgdGFiLlxuICAgIGlmIChoYWRGb2N1c1Zpc2libGVSZWNlbnRseSkge1xuICAgICAgaGFkS2V5Ym9hcmRFdmVudCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmUoZG9jKSB7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93biwgdHJ1ZSk7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVQb2ludGVyRG93biwgdHJ1ZSk7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZVBvaW50ZXJEb3duLCB0cnVlKTtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBoYW5kbGVQb2ludGVyRG93biwgdHJ1ZSk7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZWFyZG93bihkb2MpIHtcbiAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duLCB0cnVlKTtcbiAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZVBvaW50ZXJEb3duLCB0cnVlKTtcbiAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24sIHRydWUpO1xuICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZVBvaW50ZXJEb3duLCB0cnVlKTtcbiAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gaXNGb2N1c1Zpc2libGUoZXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuICB0cnkge1xuICAgIHJldHVybiB0YXJnZXQubWF0Y2hlcygnOmZvY3VzLXZpc2libGUnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHt9IC8vIGJyb3dzZXJzIG5vdCBpbXBsZW1lbnRpbmcgOmZvY3VzLXZpc2libGUgd2lsbCB0aHJvdyBhIFN5bnRheEVycm9yXG4gIC8vIHdlIHVzZSBvdXIgb3duIGhldXJpc3RpYyBmb3IgdGhvc2UgYnJvd3NlcnNcbiAgLy8gcmV0aHJvdyBtaWdodCBiZSBiZXR0ZXIgaWYgaXQncyBub3QgdGhlIGV4cGVjdGVkIGVycm9yIGJ1dCBkbyB3ZSByZWFsbHlcbiAgLy8gd2FudCB0byBjcmFzaCBpZiBmb2N1cy12aXNpYmxlIG1hbGZ1bmN0aW9uZWQ/XG4gIC8vIG5vIG5lZWQgZm9yIHZhbGlkRm9jdXNUYXJnZXQgY2hlY2suIHRoZSB1c2VyIGRvZXMgdGhhdCBieSBhdHRhY2hpbmcgaXQgdG9cbiAgLy8gZm9jdXNhYmxlIGV2ZW50cyBvbmx5XG5cblxuICByZXR1cm4gaGFkS2V5Ym9hcmRFdmVudCB8fCBmb2N1c1RyaWdnZXJzS2V5Ym9hcmRNb2RhbGl0eSh0YXJnZXQpO1xufVxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIGlmIGEgYmx1ciBldmVudCBpcyBmaXJlZCBvbiBhIGZvY3VzLXZpc2libGUgZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gaGFuZGxlQmx1clZpc2libGUoKSB7XG4gIC8vIFRvIGRldGVjdCBhIHRhYi93aW5kb3cgc3dpdGNoLCB3ZSBsb29rIGZvciBhIGJsdXIgZXZlbnQgZm9sbG93ZWRcbiAgLy8gcmFwaWRseSBieSBhIHZpc2liaWxpdHkgY2hhbmdlLlxuICAvLyBJZiB3ZSBkb24ndCBzZWUgYSB2aXNpYmlsaXR5IGNoYW5nZSB3aXRoaW4gMTAwbXMsIGl0J3MgcHJvYmFibHkgYVxuICAvLyByZWd1bGFyIGZvY3VzIGNoYW5nZS5cbiAgaGFkRm9jdXNWaXNpYmxlUmVjZW50bHkgPSB0cnVlO1xuICB3aW5kb3cuY2xlYXJUaW1lb3V0KGhhZEZvY3VzVmlzaWJsZVJlY2VudGx5VGltZW91dCk7XG4gIGhhZEZvY3VzVmlzaWJsZVJlY2VudGx5VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBoYWRGb2N1c1Zpc2libGVSZWNlbnRseSA9IGZhbHNlO1xuICB9LCAxMDApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VJc0ZvY3VzVmlzaWJsZSgpIHtcbiAgdmFyIHJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHZhciBub2RlID0gUmVhY3RET00uZmluZERPTU5vZGUoaW5zdGFuY2UpO1xuXG4gICAgaWYgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgcHJlcGFyZShub2RlLm93bmVyRG9jdW1lbnQpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlRGVidWdWYWx1ZShpc0ZvY3VzVmlzaWJsZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlzRm9jdXNWaXNpYmxlOiBpc0ZvY3VzVmlzaWJsZSxcbiAgICBvbkJsdXJWaXNpYmxlOiBoYW5kbGVCbHVyVmlzaWJsZSxcbiAgICByZWY6IHJlZlxuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IHtcbiAgZGlzYWJsZWQ6IGZhbHNlXG59OyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5leHBvcnQgdmFyIHRpbWVvdXRzU2hhcGUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnNoYXBlKHtcbiAgZW50ZXI6IFByb3BUeXBlcy5udW1iZXIsXG4gIGV4aXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGFwcGVhcjogUHJvcFR5cGVzLm51bWJlclxufSkuaXNSZXF1aXJlZF0pIDogbnVsbDtcbmV4cG9ydCB2YXIgY2xhc3NOYW1lc1NoYXBlID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5zaGFwZSh7XG4gIGVudGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBleGl0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICBhY3RpdmU6IFByb3BUeXBlcy5zdHJpbmdcbn0pLCBQcm9wVHlwZXMuc2hhcGUoe1xuICBlbnRlcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgZW50ZXJEb25lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBlbnRlckFjdGl2ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZXhpdDogUHJvcFR5cGVzLnN0cmluZyxcbiAgZXhpdERvbmU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGV4aXRBY3RpdmU6IFByb3BUeXBlcy5zdHJpbmdcbn0pXSkgOiBudWxsOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgZGVmYXVsdCBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpOyIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlXCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IGNvbmZpZyBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyB0aW1lb3V0c1NoYXBlIH0gZnJvbSAnLi91dGlscy9Qcm9wVHlwZXMnO1xuaW1wb3J0IFRyYW5zaXRpb25Hcm91cENvbnRleHQgZnJvbSAnLi9UcmFuc2l0aW9uR3JvdXBDb250ZXh0JztcbmV4cG9ydCB2YXIgVU5NT1VOVEVEID0gJ3VubW91bnRlZCc7XG5leHBvcnQgdmFyIEVYSVRFRCA9ICdleGl0ZWQnO1xuZXhwb3J0IHZhciBFTlRFUklORyA9ICdlbnRlcmluZyc7XG5leHBvcnQgdmFyIEVOVEVSRUQgPSAnZW50ZXJlZCc7XG5leHBvcnQgdmFyIEVYSVRJTkcgPSAnZXhpdGluZyc7XG4vKipcbiAqIFRoZSBUcmFuc2l0aW9uIGNvbXBvbmVudCBsZXRzIHlvdSBkZXNjcmliZSBhIHRyYW5zaXRpb24gZnJvbSBvbmUgY29tcG9uZW50XG4gKiBzdGF0ZSB0byBhbm90aGVyIF9vdmVyIHRpbWVfIHdpdGggYSBzaW1wbGUgZGVjbGFyYXRpdmUgQVBJLiBNb3N0IGNvbW1vbmx5XG4gKiBpdCdzIHVzZWQgdG8gYW5pbWF0ZSB0aGUgbW91bnRpbmcgYW5kIHVubW91bnRpbmcgb2YgYSBjb21wb25lbnQsIGJ1dCBjYW4gYWxzb1xuICogYmUgdXNlZCB0byBkZXNjcmliZSBpbi1wbGFjZSB0cmFuc2l0aW9uIHN0YXRlcyBhcyB3ZWxsLlxuICpcbiAqIC0tLVxuICpcbiAqICoqTm90ZSoqOiBgVHJhbnNpdGlvbmAgaXMgYSBwbGF0Zm9ybS1hZ25vc3RpYyBiYXNlIGNvbXBvbmVudC4gSWYgeW91J3JlIHVzaW5nXG4gKiB0cmFuc2l0aW9ucyBpbiBDU1MsIHlvdSdsbCBwcm9iYWJseSB3YW50IHRvIHVzZVxuICogW2BDU1NUcmFuc2l0aW9uYF0oaHR0cHM6Ly9yZWFjdGNvbW11bml0eS5vcmcvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9jc3MtdHJhbnNpdGlvbilcbiAqIGluc3RlYWQuIEl0IGluaGVyaXRzIGFsbCB0aGUgZmVhdHVyZXMgb2YgYFRyYW5zaXRpb25gLCBidXQgY29udGFpbnNcbiAqIGFkZGl0aW9uYWwgZmVhdHVyZXMgbmVjZXNzYXJ5IHRvIHBsYXkgbmljZSB3aXRoIENTUyB0cmFuc2l0aW9ucyAoaGVuY2UgdGhlXG4gKiBuYW1lIG9mIHRoZSBjb21wb25lbnQpLlxuICpcbiAqIC0tLVxuICpcbiAqIEJ5IGRlZmF1bHQgdGhlIGBUcmFuc2l0aW9uYCBjb21wb25lbnQgZG9lcyBub3QgYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHRoZVxuICogY29tcG9uZW50IGl0IHJlbmRlcnMsIGl0IG9ubHkgdHJhY2tzIFwiZW50ZXJcIiBhbmQgXCJleGl0XCIgc3RhdGVzIGZvciB0aGVcbiAqIGNvbXBvbmVudHMuIEl0J3MgdXAgdG8geW91IHRvIGdpdmUgbWVhbmluZyBhbmQgZWZmZWN0IHRvIHRob3NlIHN0YXRlcy4gRm9yXG4gKiBleGFtcGxlIHdlIGNhbiBhZGQgc3R5bGVzIHRvIGEgY29tcG9uZW50IHdoZW4gaXQgZW50ZXJzIG9yIGV4aXRzOlxuICpcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAnO1xuICpcbiAqIGNvbnN0IGR1cmF0aW9uID0gMzAwO1xuICpcbiAqIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHtcbiAqICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHtkdXJhdGlvbn1tcyBlYXNlLWluLW91dGAsXG4gKiAgIG9wYWNpdHk6IDAsXG4gKiB9XG4gKlxuICogY29uc3QgdHJhbnNpdGlvblN0eWxlcyA9IHtcbiAqICAgZW50ZXJpbmc6IHsgb3BhY2l0eTogMSB9LFxuICogICBlbnRlcmVkOiAgeyBvcGFjaXR5OiAxIH0sXG4gKiAgIGV4aXRpbmc6ICB7IG9wYWNpdHk6IDAgfSxcbiAqICAgZXhpdGVkOiAgeyBvcGFjaXR5OiAwIH0sXG4gKiB9O1xuICpcbiAqIGNvbnN0IEZhZGUgPSAoeyBpbjogaW5Qcm9wIH0pID0+IChcbiAqICAgPFRyYW5zaXRpb24gaW49e2luUHJvcH0gdGltZW91dD17ZHVyYXRpb259PlxuICogICAgIHtzdGF0ZSA9PiAoXG4gKiAgICAgICA8ZGl2IHN0eWxlPXt7XG4gKiAgICAgICAgIC4uLmRlZmF1bHRTdHlsZSxcbiAqICAgICAgICAgLi4udHJhbnNpdGlvblN0eWxlc1tzdGF0ZV1cbiAqICAgICAgIH19PlxuICogICAgICAgICBJJ20gYSBmYWRlIFRyYW5zaXRpb24hXG4gKiAgICAgICA8L2Rpdj5cbiAqICAgICApfVxuICogICA8L1RyYW5zaXRpb24+XG4gKiApO1xuICogYGBgXG4gKlxuICogVGhlcmUgYXJlIDQgbWFpbiBzdGF0ZXMgYSBUcmFuc2l0aW9uIGNhbiBiZSBpbjpcbiAqICAtIGAnZW50ZXJpbmcnYFxuICogIC0gYCdlbnRlcmVkJ2BcbiAqICAtIGAnZXhpdGluZydgXG4gKiAgLSBgJ2V4aXRlZCdgXG4gKlxuICogVHJhbnNpdGlvbiBzdGF0ZSBpcyB0b2dnbGVkIHZpYSB0aGUgYGluYCBwcm9wLiBXaGVuIGB0cnVlYCB0aGUgY29tcG9uZW50XG4gKiBiZWdpbnMgdGhlIFwiRW50ZXJcIiBzdGFnZS4gRHVyaW5nIHRoaXMgc3RhZ2UsIHRoZSBjb21wb25lbnQgd2lsbCBzaGlmdCBmcm9tXG4gKiBpdHMgY3VycmVudCB0cmFuc2l0aW9uIHN0YXRlLCB0byBgJ2VudGVyaW5nJ2AgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGVcbiAqIHRyYW5zaXRpb24gYW5kIHRoZW4gdG8gdGhlIGAnZW50ZXJlZCdgIHN0YWdlIG9uY2UgaXQncyBjb21wbGV0ZS4gTGV0J3MgdGFrZVxuICogdGhlIGZvbGxvd2luZyBleGFtcGxlICh3ZSdsbCB1c2UgdGhlXG4gKiBbdXNlU3RhdGVdKGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9ob29rcy1yZWZlcmVuY2UuaHRtbCN1c2VzdGF0ZSkgaG9vayk6XG4gKlxuICogYGBganN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IFtpblByb3AsIHNldEluUHJvcF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGRpdj5cbiAqICAgICAgIDxUcmFuc2l0aW9uIGluPXtpblByb3B9IHRpbWVvdXQ9ezUwMH0+XG4gKiAgICAgICAgIHtzdGF0ZSA9PiAoXG4gKiAgICAgICAgICAgLy8gLi4uXG4gKiAgICAgICAgICl9XG4gKiAgICAgICA8L1RyYW5zaXRpb24+XG4gKiAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldEluUHJvcCh0cnVlKX0+XG4gKiAgICAgICAgIENsaWNrIHRvIEVudGVyXG4gKiAgICAgICA8L2J1dHRvbj5cbiAqICAgICA8L2Rpdj5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkIHRoZSBjb21wb25lbnQgd2lsbCBzaGlmdCB0byB0aGUgYCdlbnRlcmluZydgIHN0YXRlXG4gKiBhbmQgc3RheSB0aGVyZSBmb3IgNTAwbXMgKHRoZSB2YWx1ZSBvZiBgdGltZW91dGApIGJlZm9yZSBpdCBmaW5hbGx5IHN3aXRjaGVzXG4gKiB0byBgJ2VudGVyZWQnYC5cbiAqXG4gKiBXaGVuIGBpbmAgaXMgYGZhbHNlYCB0aGUgc2FtZSB0aGluZyBoYXBwZW5zIGV4Y2VwdCB0aGUgc3RhdGUgbW92ZXMgZnJvbVxuICogYCdleGl0aW5nJ2AgdG8gYCdleGl0ZWQnYC5cbiAqL1xuXG52YXIgVHJhbnNpdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShUcmFuc2l0aW9uLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUcmFuc2l0aW9uKHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgdmFyIHBhcmVudEdyb3VwID0gY29udGV4dDsgLy8gSW4gdGhlIGNvbnRleHQgb2YgYSBUcmFuc2l0aW9uR3JvdXAgYWxsIGVudGVycyBhcmUgcmVhbGx5IGFwcGVhcnNcblxuICAgIHZhciBhcHBlYXIgPSBwYXJlbnRHcm91cCAmJiAhcGFyZW50R3JvdXAuaXNNb3VudGluZyA/IHByb3BzLmVudGVyIDogcHJvcHMuYXBwZWFyO1xuICAgIHZhciBpbml0aWFsU3RhdHVzO1xuICAgIF90aGlzLmFwcGVhclN0YXR1cyA9IG51bGw7XG5cbiAgICBpZiAocHJvcHMuaW4pIHtcbiAgICAgIGlmIChhcHBlYXIpIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IEVYSVRFRDtcbiAgICAgICAgX3RoaXMuYXBwZWFyU3RhdHVzID0gRU5URVJJTkc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsU3RhdHVzID0gRU5URVJFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BzLnVubW91bnRPbkV4aXQgfHwgcHJvcHMubW91bnRPbkVudGVyKSB7XG4gICAgICAgIGluaXRpYWxTdGF0dXMgPSBVTk1PVU5URUQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsU3RhdHVzID0gRVhJVEVEO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgc3RhdHVzOiBpbml0aWFsU3RhdHVzXG4gICAgfTtcbiAgICBfdGhpcy5uZXh0Q2FsbGJhY2sgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFRyYW5zaXRpb24uZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKF9yZWYsIHByZXZTdGF0ZSkge1xuICAgIHZhciBuZXh0SW4gPSBfcmVmLmluO1xuXG4gICAgaWYgKG5leHRJbiAmJiBwcmV2U3RhdGUuc3RhdHVzID09PSBVTk1PVU5URUQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogRVhJVEVEXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9IC8vIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHByZXZQcm9wcykge1xuICAvLyAgIGxldCBuZXh0U3RhdHVzID0gbnVsbFxuICAvLyAgIGlmIChwcmV2UHJvcHMgIT09IHRoaXMucHJvcHMpIHtcbiAgLy8gICAgIGNvbnN0IHsgc3RhdHVzIH0gPSB0aGlzLnN0YXRlXG4gIC8vICAgICBpZiAodGhpcy5wcm9wcy5pbikge1xuICAvLyAgICAgICBpZiAoc3RhdHVzICE9PSBFTlRFUklORyAmJiBzdGF0dXMgIT09IEVOVEVSRUQpIHtcbiAgLy8gICAgICAgICBuZXh0U3RhdHVzID0gRU5URVJJTkdcbiAgLy8gICAgICAgfVxuICAvLyAgICAgfSBlbHNlIHtcbiAgLy8gICAgICAgaWYgKHN0YXR1cyA9PT0gRU5URVJJTkcgfHwgc3RhdHVzID09PSBFTlRFUkVEKSB7XG4gIC8vICAgICAgICAgbmV4dFN0YXR1cyA9IEVYSVRJTkdcbiAgLy8gICAgICAgfVxuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy8gICByZXR1cm4geyBuZXh0U3RhdHVzIH1cbiAgLy8gfVxuICA7XG5cbiAgdmFyIF9wcm90byA9IFRyYW5zaXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMudXBkYXRlU3RhdHVzKHRydWUsIHRoaXMuYXBwZWFyU3RhdHVzKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIHZhciBuZXh0U3RhdHVzID0gbnVsbDtcblxuICAgIGlmIChwcmV2UHJvcHMgIT09IHRoaXMucHJvcHMpIHtcbiAgICAgIHZhciBzdGF0dXMgPSB0aGlzLnN0YXRlLnN0YXR1cztcblxuICAgICAgaWYgKHRoaXMucHJvcHMuaW4pIHtcbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gRU5URVJJTkcgJiYgc3RhdHVzICE9PSBFTlRFUkVEKSB7XG4gICAgICAgICAgbmV4dFN0YXR1cyA9IEVOVEVSSU5HO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RhdHVzID09PSBFTlRFUklORyB8fCBzdGF0dXMgPT09IEVOVEVSRUQpIHtcbiAgICAgICAgICBuZXh0U3RhdHVzID0gRVhJVElORztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU3RhdHVzKGZhbHNlLCBuZXh0U3RhdHVzKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmNhbmNlbE5leHRDYWxsYmFjaygpO1xuICB9O1xuXG4gIF9wcm90by5nZXRUaW1lb3V0cyA9IGZ1bmN0aW9uIGdldFRpbWVvdXRzKCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5wcm9wcy50aW1lb3V0O1xuICAgIHZhciBleGl0LCBlbnRlciwgYXBwZWFyO1xuICAgIGV4aXQgPSBlbnRlciA9IGFwcGVhciA9IHRpbWVvdXQ7XG5cbiAgICBpZiAodGltZW91dCAhPSBudWxsICYmIHR5cGVvZiB0aW1lb3V0ICE9PSAnbnVtYmVyJykge1xuICAgICAgZXhpdCA9IHRpbWVvdXQuZXhpdDtcbiAgICAgIGVudGVyID0gdGltZW91dC5lbnRlcjsgLy8gVE9ETzogcmVtb3ZlIGZhbGxiYWNrIGZvciBuZXh0IG1ham9yXG5cbiAgICAgIGFwcGVhciA9IHRpbWVvdXQuYXBwZWFyICE9PSB1bmRlZmluZWQgPyB0aW1lb3V0LmFwcGVhciA6IGVudGVyO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBleGl0OiBleGl0LFxuICAgICAgZW50ZXI6IGVudGVyLFxuICAgICAgYXBwZWFyOiBhcHBlYXJcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by51cGRhdGVTdGF0dXMgPSBmdW5jdGlvbiB1cGRhdGVTdGF0dXMobW91bnRpbmcsIG5leHRTdGF0dXMpIHtcbiAgICBpZiAobW91bnRpbmcgPT09IHZvaWQgMCkge1xuICAgICAgbW91bnRpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobmV4dFN0YXR1cyAhPT0gbnVsbCkge1xuICAgICAgLy8gbmV4dFN0YXR1cyB3aWxsIGFsd2F5cyBiZSBFTlRFUklORyBvciBFWElUSU5HLlxuICAgICAgdGhpcy5jYW5jZWxOZXh0Q2FsbGJhY2soKTtcblxuICAgICAgaWYgKG5leHRTdGF0dXMgPT09IEVOVEVSSU5HKSB7XG4gICAgICAgIHRoaXMucGVyZm9ybUVudGVyKG1vdW50aW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGVyZm9ybUV4aXQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucHJvcHMudW5tb3VudE9uRXhpdCAmJiB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gRVhJVEVEKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc3RhdHVzOiBVTk1PVU5URURcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucGVyZm9ybUVudGVyID0gZnVuY3Rpb24gcGVyZm9ybUVudGVyKG1vdW50aW5nKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgZW50ZXIgPSB0aGlzLnByb3BzLmVudGVyO1xuICAgIHZhciBhcHBlYXJpbmcgPSB0aGlzLmNvbnRleHQgPyB0aGlzLmNvbnRleHQuaXNNb3VudGluZyA6IG1vdW50aW5nO1xuXG4gICAgdmFyIF9yZWYyID0gdGhpcy5wcm9wcy5ub2RlUmVmID8gW2FwcGVhcmluZ10gOiBbUmVhY3RET00uZmluZERPTU5vZGUodGhpcyksIGFwcGVhcmluZ10sXG4gICAgICAgIG1heWJlTm9kZSA9IF9yZWYyWzBdLFxuICAgICAgICBtYXliZUFwcGVhcmluZyA9IF9yZWYyWzFdO1xuXG4gICAgdmFyIHRpbWVvdXRzID0gdGhpcy5nZXRUaW1lb3V0cygpO1xuICAgIHZhciBlbnRlclRpbWVvdXQgPSBhcHBlYXJpbmcgPyB0aW1lb3V0cy5hcHBlYXIgOiB0aW1lb3V0cy5lbnRlcjsgLy8gbm8gZW50ZXIgYW5pbWF0aW9uIHNraXAgcmlnaHQgdG8gRU5URVJFRFxuICAgIC8vIGlmIHdlIGFyZSBtb3VudGluZyBhbmQgcnVubmluZyB0aGlzIGl0IG1lYW5zIGFwcGVhciBfbXVzdF8gYmUgc2V0XG5cbiAgICBpZiAoIW1vdW50aW5nICYmICFlbnRlciB8fCBjb25maWcuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgc3RhdHVzOiBFTlRFUkVEXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5wcm9wcy5vbkVudGVyZWQobWF5YmVOb2RlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHJvcHMub25FbnRlcihtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKTtcbiAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICBzdGF0dXM6IEVOVEVSSU5HXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyLnByb3BzLm9uRW50ZXJpbmcobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyk7XG5cbiAgICAgIF90aGlzMi5vblRyYW5zaXRpb25FbmQoZW50ZXJUaW1lb3V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zYWZlU2V0U3RhdGUoe1xuICAgICAgICAgIHN0YXR1czogRU5URVJFRFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnByb3BzLm9uRW50ZXJlZChtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucGVyZm9ybUV4aXQgPSBmdW5jdGlvbiBwZXJmb3JtRXhpdCgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBleGl0ID0gdGhpcy5wcm9wcy5leGl0O1xuICAgIHZhciB0aW1lb3V0cyA9IHRoaXMuZ2V0VGltZW91dHMoKTtcbiAgICB2YXIgbWF5YmVOb2RlID0gdGhpcy5wcm9wcy5ub2RlUmVmID8gdW5kZWZpbmVkIDogUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7IC8vIG5vIGV4aXQgYW5pbWF0aW9uIHNraXAgcmlnaHQgdG8gRVhJVEVEXG5cbiAgICBpZiAoIWV4aXQgfHwgY29uZmlnLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgIHN0YXR1czogRVhJVEVEXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5wcm9wcy5vbkV4aXRlZChtYXliZU5vZGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcm9wcy5vbkV4aXQobWF5YmVOb2RlKTtcbiAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICBzdGF0dXM6IEVYSVRJTkdcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczMucHJvcHMub25FeGl0aW5nKG1heWJlTm9kZSk7XG5cbiAgICAgIF90aGlzMy5vblRyYW5zaXRpb25FbmQodGltZW91dHMuZXhpdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgICBzdGF0dXM6IEVYSVRFRFxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMzLnByb3BzLm9uRXhpdGVkKG1heWJlTm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNhbmNlbE5leHRDYWxsYmFjayA9IGZ1bmN0aW9uIGNhbmNlbE5leHRDYWxsYmFjaygpIHtcbiAgICBpZiAodGhpcy5uZXh0Q2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHRoaXMubmV4dENhbGxiYWNrLmNhbmNlbCgpO1xuICAgICAgdGhpcy5uZXh0Q2FsbGJhY2sgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc2FmZVNldFN0YXRlID0gZnVuY3Rpb24gc2FmZVNldFN0YXRlKG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAvLyBUaGlzIHNob3VsZG4ndCBiZSBuZWNlc3NhcnksIGJ1dCB0aGVyZSBhcmUgd2VpcmQgcmFjZSBjb25kaXRpb25zIHdpdGhcbiAgICAvLyBzZXRTdGF0ZSBjYWxsYmFja3MgYW5kIHVubW91bnRpbmcgaW4gdGVzdGluZywgc28gYWx3YXlzIG1ha2Ugc3VyZSB0aGF0XG4gICAgLy8gd2UgY2FuIGNhbmNlbCBhbnkgcGVuZGluZyBzZXRTdGF0ZSBjYWxsYmFja3MgYWZ0ZXIgd2UgdW5tb3VudC5cbiAgICBjYWxsYmFjayA9IHRoaXMuc2V0TmV4dENhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICB0aGlzLnNldFN0YXRlKG5leHRTdGF0ZSwgY2FsbGJhY2spO1xuICB9O1xuXG4gIF9wcm90by5zZXROZXh0Q2FsbGJhY2sgPSBmdW5jdGlvbiBzZXROZXh0Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHZhciBhY3RpdmUgPSB0cnVlO1xuXG4gICAgdGhpcy5uZXh0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIF90aGlzNC5uZXh0Q2FsbGJhY2sgPSBudWxsO1xuICAgICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMubmV4dENhbGxiYWNrLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5uZXh0Q2FsbGJhY2s7XG4gIH07XG5cbiAgX3Byb3RvLm9uVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZCh0aW1lb3V0LCBoYW5kbGVyKSB7XG4gICAgdGhpcy5zZXROZXh0Q2FsbGJhY2soaGFuZGxlcik7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnByb3BzLm5vZGVSZWYgPyB0aGlzLnByb3BzLm5vZGVSZWYuY3VycmVudCA6IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpO1xuICAgIHZhciBkb2VzTm90SGF2ZVRpbWVvdXRPckxpc3RlbmVyID0gdGltZW91dCA9PSBudWxsICYmICF0aGlzLnByb3BzLmFkZEVuZExpc3RlbmVyO1xuXG4gICAgaWYgKCFub2RlIHx8IGRvZXNOb3RIYXZlVGltZW91dE9yTGlzdGVuZXIpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy5uZXh0Q2FsbGJhY2ssIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLmFkZEVuZExpc3RlbmVyKSB7XG4gICAgICB2YXIgX3JlZjMgPSB0aGlzLnByb3BzLm5vZGVSZWYgPyBbdGhpcy5uZXh0Q2FsbGJhY2tdIDogW25vZGUsIHRoaXMubmV4dENhbGxiYWNrXSxcbiAgICAgICAgICBtYXliZU5vZGUgPSBfcmVmM1swXSxcbiAgICAgICAgICBtYXliZU5leHRDYWxsYmFjayA9IF9yZWYzWzFdO1xuXG4gICAgICB0aGlzLnByb3BzLmFkZEVuZExpc3RlbmVyKG1heWJlTm9kZSwgbWF5YmVOZXh0Q2FsbGJhY2spO1xuICAgIH1cblxuICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy5uZXh0Q2FsbGJhY2ssIHRpbWVvdXQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBzdGF0dXMgPSB0aGlzLnN0YXRlLnN0YXR1cztcblxuICAgIGlmIChzdGF0dXMgPT09IFVOTU9VTlRFRCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgX2luID0gX3RoaXMkcHJvcHMuaW4sXG4gICAgICAgIF9tb3VudE9uRW50ZXIgPSBfdGhpcyRwcm9wcy5tb3VudE9uRW50ZXIsXG4gICAgICAgIF91bm1vdW50T25FeGl0ID0gX3RoaXMkcHJvcHMudW5tb3VudE9uRXhpdCxcbiAgICAgICAgX2FwcGVhciA9IF90aGlzJHByb3BzLmFwcGVhcixcbiAgICAgICAgX2VudGVyID0gX3RoaXMkcHJvcHMuZW50ZXIsXG4gICAgICAgIF9leGl0ID0gX3RoaXMkcHJvcHMuZXhpdCxcbiAgICAgICAgX3RpbWVvdXQgPSBfdGhpcyRwcm9wcy50aW1lb3V0LFxuICAgICAgICBfYWRkRW5kTGlzdGVuZXIgPSBfdGhpcyRwcm9wcy5hZGRFbmRMaXN0ZW5lcixcbiAgICAgICAgX29uRW50ZXIgPSBfdGhpcyRwcm9wcy5vbkVudGVyLFxuICAgICAgICBfb25FbnRlcmluZyA9IF90aGlzJHByb3BzLm9uRW50ZXJpbmcsXG4gICAgICAgIF9vbkVudGVyZWQgPSBfdGhpcyRwcm9wcy5vbkVudGVyZWQsXG4gICAgICAgIF9vbkV4aXQgPSBfdGhpcyRwcm9wcy5vbkV4aXQsXG4gICAgICAgIF9vbkV4aXRpbmcgPSBfdGhpcyRwcm9wcy5vbkV4aXRpbmcsXG4gICAgICAgIF9vbkV4aXRlZCA9IF90aGlzJHByb3BzLm9uRXhpdGVkLFxuICAgICAgICBfbm9kZVJlZiA9IF90aGlzJHByb3BzLm5vZGVSZWYsXG4gICAgICAgIGNoaWxkUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJpblwiLCBcIm1vdW50T25FbnRlclwiLCBcInVubW91bnRPbkV4aXRcIiwgXCJhcHBlYXJcIiwgXCJlbnRlclwiLCBcImV4aXRcIiwgXCJ0aW1lb3V0XCIsIFwiYWRkRW5kTGlzdGVuZXJcIiwgXCJvbkVudGVyXCIsIFwib25FbnRlcmluZ1wiLCBcIm9uRW50ZXJlZFwiLCBcIm9uRXhpdFwiLCBcIm9uRXhpdGluZ1wiLCBcIm9uRXhpdGVkXCIsIFwibm9kZVJlZlwiXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgLy8gYWxsb3dzIGZvciBuZXN0ZWQgVHJhbnNpdGlvbnNcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbkdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSwgdHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nID8gY2hpbGRyZW4oc3RhdHVzLCBjaGlsZFByb3BzKSA6IFJlYWN0LmNsb25lRWxlbWVudChSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSwgY2hpbGRQcm9wcykpXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gVHJhbnNpdGlvbjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuVHJhbnNpdGlvbi5jb250ZXh0VHlwZSA9IFRyYW5zaXRpb25Hcm91cENvbnRleHQ7XG5UcmFuc2l0aW9uLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgLyoqXG4gICAqIEEgUmVhY3QgcmVmZXJlbmNlIHRvIERPTSBlbGVtZW50IHRoYXQgbmVlZCB0byB0cmFuc2l0aW9uOlxuICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTExMjcxMzAvNDY3MTkzMlxuICAgKlxuICAgKiAgIC0gV2hlbiBgbm9kZVJlZmAgcHJvcCBpcyB1c2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZCB0byBjYWxsYmFjayBmdW5jdGlvbnNcbiAgICogICAgICAoZS5nLiBgb25FbnRlcmApIGJlY2F1c2UgdXNlciBhbHJlYWR5IGhhcyBkaXJlY3QgYWNjZXNzIHRvIHRoZSBub2RlLlxuICAgKiAgIC0gV2hlbiBjaGFuZ2luZyBga2V5YCBwcm9wIG9mIGBUcmFuc2l0aW9uYCBpbiBhIGBUcmFuc2l0aW9uR3JvdXBgIGEgbmV3XG4gICAqICAgICBgbm9kZVJlZmAgbmVlZCB0byBiZSBwcm92aWRlZCB0byBgVHJhbnNpdGlvbmAgd2l0aCBjaGFuZ2VkIGBrZXlgIHByb3BcbiAgICogICAgIChzZWVcbiAgICogICAgIFt0ZXN0L0NTU1RyYW5zaXRpb24tdGVzdC5qc10oaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9ibG9iLzEzNDM1Zjg5N2IzYWI3MWY2ZTE5ZDcyNGYxNDU1OTZmNTkxMDU4MWMvdGVzdC9DU1NUcmFuc2l0aW9uLXRlc3QuanMjTDM2Mi1MNDM3KSkuXG4gICAqL1xuICBub2RlUmVmOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGN1cnJlbnQ6IHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyA/IFByb3BUeXBlcy5hbnkgOiBmdW5jdGlvbiAocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHZhbHVlID0gcHJvcFZhbHVlW2tleV07XG4gICAgICByZXR1cm4gUHJvcFR5cGVzLmluc3RhbmNlT2YodmFsdWUgJiYgJ293bmVyRG9jdW1lbnQnIGluIHZhbHVlID8gdmFsdWUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5FbGVtZW50IDogRWxlbWVudCkocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCk7XG4gICAgfVxuICB9KSxcblxuICAvKipcbiAgICogQSBgZnVuY3Rpb25gIGNoaWxkIGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgYSBSZWFjdCBlbGVtZW50LiBUaGlzIGZ1bmN0aW9uIGlzXG4gICAqIGNhbGxlZCB3aXRoIHRoZSBjdXJyZW50IHRyYW5zaXRpb24gc3RhdHVzIChgJ2VudGVyaW5nJ2AsIGAnZW50ZXJlZCdgLFxuICAgKiBgJ2V4aXRpbmcnYCwgYCdleGl0ZWQnYCksIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGFwcGx5IGNvbnRleHRcbiAgICogc3BlY2lmaWMgcHJvcHMgdG8gYSBjb21wb25lbnQuXG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiA8VHJhbnNpdGlvbiBpbj17dGhpcy5zdGF0ZS5pbn0gdGltZW91dD17MTUwfT5cbiAgICogICB7c3RhdGUgPT4gKFxuICAgKiAgICAgPE15Q29tcG9uZW50IGNsYXNzTmFtZT17YGZhZGUgZmFkZS0ke3N0YXRlfWB9IC8+XG4gICAqICAgKX1cbiAgICogPC9UcmFuc2l0aW9uPlxuICAgKiBgYGBcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLCBQcm9wVHlwZXMuZWxlbWVudC5pc1JlcXVpcmVkXSkuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogU2hvdyB0aGUgY29tcG9uZW50OyB0cmlnZ2VycyB0aGUgZW50ZXIgb3IgZXhpdCBzdGF0ZXNcbiAgICovXG4gIGluOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQnkgZGVmYXVsdCB0aGUgY2hpbGQgY29tcG9uZW50IGlzIG1vdW50ZWQgaW1tZWRpYXRlbHkgYWxvbmcgd2l0aFxuICAgKiB0aGUgcGFyZW50IGBUcmFuc2l0aW9uYCBjb21wb25lbnQuIElmIHlvdSB3YW50IHRvIFwibGF6eSBtb3VudFwiIHRoZSBjb21wb25lbnQgb24gdGhlXG4gICAqIGZpcnN0IGBpbj17dHJ1ZX1gIHlvdSBjYW4gc2V0IGBtb3VudE9uRW50ZXJgLiBBZnRlciB0aGUgZmlyc3QgZW50ZXIgdHJhbnNpdGlvbiB0aGUgY29tcG9uZW50IHdpbGwgc3RheVxuICAgKiBtb3VudGVkLCBldmVuIG9uIFwiZXhpdGVkXCIsIHVubGVzcyB5b3UgYWxzbyBzcGVjaWZ5IGB1bm1vdW50T25FeGl0YC5cbiAgICovXG4gIG1vdW50T25FbnRlcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQgdGhlIGNoaWxkIGNvbXBvbmVudCBzdGF5cyBtb3VudGVkIGFmdGVyIGl0IHJlYWNoZXMgdGhlIGAnZXhpdGVkJ2Agc3RhdGUuXG4gICAqIFNldCBgdW5tb3VudE9uRXhpdGAgaWYgeW91J2QgcHJlZmVyIHRvIHVubW91bnQgdGhlIGNvbXBvbmVudCBhZnRlciBpdCBmaW5pc2hlcyBleGl0aW5nLlxuICAgKi9cbiAgdW5tb3VudE9uRXhpdDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQgdGhlIGNoaWxkIGNvbXBvbmVudCBkb2VzIG5vdCBwZXJmb3JtIHRoZSBlbnRlciB0cmFuc2l0aW9uIHdoZW5cbiAgICogaXQgZmlyc3QgbW91bnRzLCByZWdhcmRsZXNzIG9mIHRoZSB2YWx1ZSBvZiBgaW5gLiBJZiB5b3Ugd2FudCB0aGlzXG4gICAqIGJlaGF2aW9yLCBzZXQgYm90aCBgYXBwZWFyYCBhbmQgYGluYCB0byBgdHJ1ZWAuXG4gICAqXG4gICAqID4gKipOb3RlKio6IHRoZXJlIGFyZSBubyBzcGVjaWFsIGFwcGVhciBzdGF0ZXMgbGlrZSBgYXBwZWFyaW5nYC9gYXBwZWFyZWRgLCB0aGlzIHByb3BcbiAgICogPiBvbmx5IGFkZHMgYW4gYWRkaXRpb25hbCBlbnRlciB0cmFuc2l0aW9uLiBIb3dldmVyLCBpbiB0aGVcbiAgICogPiBgPENTU1RyYW5zaXRpb24+YCBjb21wb25lbnQgdGhhdCBmaXJzdCBlbnRlciB0cmFuc2l0aW9uIGRvZXMgcmVzdWx0IGluXG4gICAqID4gYWRkaXRpb25hbCBgLmFwcGVhci0qYCBjbGFzc2VzLCB0aGF0IHdheSB5b3UgY2FuIGNob29zZSB0byBzdHlsZSBpdFxuICAgKiA+IGRpZmZlcmVudGx5LlxuICAgKi9cbiAgYXBwZWFyOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgZW50ZXIgdHJhbnNpdGlvbnMuXG4gICAqL1xuICBlbnRlcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGV4aXQgdHJhbnNpdGlvbnMuXG4gICAqL1xuICBleGl0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGR1cmF0aW9uIG9mIHRoZSB0cmFuc2l0aW9uLCBpbiBtaWxsaXNlY29uZHMuXG4gICAqIFJlcXVpcmVkIHVubGVzcyBgYWRkRW5kTGlzdGVuZXJgIGlzIHByb3ZpZGVkLlxuICAgKlxuICAgKiBZb3UgbWF5IHNwZWNpZnkgYSBzaW5nbGUgdGltZW91dCBmb3IgYWxsIHRyYW5zaXRpb25zOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogdGltZW91dD17NTAwfVxuICAgKiBgYGBcbiAgICpcbiAgICogb3IgaW5kaXZpZHVhbGx5OlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogdGltZW91dD17e1xuICAgKiAgYXBwZWFyOiA1MDAsXG4gICAqICBlbnRlcjogMzAwLFxuICAgKiAgZXhpdDogNTAwLFxuICAgKiB9fVxuICAgKiBgYGBcbiAgICpcbiAgICogLSBgYXBwZWFyYCBkZWZhdWx0cyB0byB0aGUgdmFsdWUgb2YgYGVudGVyYFxuICAgKiAtIGBlbnRlcmAgZGVmYXVsdHMgdG8gYDBgXG4gICAqIC0gYGV4aXRgIGRlZmF1bHRzIHRvIGAwYFxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyIHwgeyBlbnRlcj86IG51bWJlciwgZXhpdD86IG51bWJlciwgYXBwZWFyPzogbnVtYmVyIH19XG4gICAqL1xuICB0aW1lb3V0OiBmdW5jdGlvbiB0aW1lb3V0KHByb3BzKSB7XG4gICAgdmFyIHB0ID0gdGltZW91dHNTaGFwZTtcbiAgICBpZiAoIXByb3BzLmFkZEVuZExpc3RlbmVyKSBwdCA9IHB0LmlzUmVxdWlyZWQ7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHQuYXBwbHkodm9pZCAwLCBbcHJvcHNdLmNvbmNhdChhcmdzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBhIGN1c3RvbSB0cmFuc2l0aW9uIGVuZCB0cmlnZ2VyLiBDYWxsZWQgd2l0aCB0aGUgdHJhbnNpdGlvbmluZ1xuICAgKiBET00gbm9kZSBhbmQgYSBgZG9uZWAgY2FsbGJhY2suIEFsbG93cyBmb3IgbW9yZSBmaW5lIGdyYWluZWQgdHJhbnNpdGlvbiBlbmRcbiAgICogbG9naWMuIFRpbWVvdXRzIGFyZSBzdGlsbCB1c2VkIGFzIGEgZmFsbGJhY2sgaWYgcHJvdmlkZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiBhZGRFbmRMaXN0ZW5lcj17KG5vZGUsIGRvbmUpID0+IHtcbiAgICogICAvLyB1c2UgdGhlIGNzcyB0cmFuc2l0aW9uZW5kIGV2ZW50IHRvIG1hcmsgdGhlIGZpbmlzaCBvZiBhIHRyYW5zaXRpb25cbiAgICogICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBkb25lLCBmYWxzZSk7XG4gICAqIH19XG4gICAqIGBgYFxuICAgKi9cbiAgYWRkRW5kTGlzdGVuZXI6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBiZWZvcmUgdGhlIFwiZW50ZXJpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC4gQW4gZXh0cmEgcGFyYW1ldGVyXG4gICAqIGBpc0FwcGVhcmluZ2AgaXMgc3VwcGxpZWQgdG8gaW5kaWNhdGUgaWYgdGhlIGVudGVyIHN0YWdlIGlzIG9jY3VycmluZyBvbiB0aGUgaW5pdGlhbCBtb3VudFxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpIC0+IHZvaWRcbiAgICovXG4gIG9uRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJlbnRlcmluZ1wiIHN0YXR1cyBpcyBhcHBsaWVkLiBBbiBleHRyYSBwYXJhbWV0ZXJcbiAgICogYGlzQXBwZWFyaW5nYCBpcyBzdXBwbGllZCB0byBpbmRpY2F0ZSBpZiB0aGUgZW50ZXIgc3RhZ2UgaXMgb2NjdXJyaW5nIG9uIHRoZSBpbml0aWFsIG1vdW50XG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbClcbiAgICovXG4gIG9uRW50ZXJpbmc6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJlbnRlcmVkXCIgc3RhdHVzIGlzIGFwcGxpZWQuIEFuIGV4dHJhIHBhcmFtZXRlclxuICAgKiBgaXNBcHBlYXJpbmdgIGlzIHN1cHBsaWVkIHRvIGluZGljYXRlIGlmIHRoZSBlbnRlciBzdGFnZSBpcyBvY2N1cnJpbmcgb24gdGhlIGluaXRpYWwgbW91bnRcbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKSAtPiB2b2lkXG4gICAqL1xuICBvbkVudGVyZWQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBiZWZvcmUgdGhlIFwiZXhpdGluZ1wiIHN0YXR1cyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCkgLT4gdm9pZFxuICAgKi9cbiAgb25FeGl0OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZXhpdGluZ1wiIHN0YXR1cyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCkgLT4gdm9pZFxuICAgKi9cbiAgb25FeGl0aW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZXhpdGVkXCIgc3RhdHVzIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWRcbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpIC0+IHZvaWRcbiAgICovXG4gIG9uRXhpdGVkOiBQcm9wVHlwZXMuZnVuY1xufSA6IHt9OyAvLyBOYW1lIHRoZSBmdW5jdGlvbiBzbyBpdCBpcyBjbGVhcmVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5UcmFuc2l0aW9uLmRlZmF1bHRQcm9wcyA9IHtcbiAgaW46IGZhbHNlLFxuICBtb3VudE9uRW50ZXI6IGZhbHNlLFxuICB1bm1vdW50T25FeGl0OiBmYWxzZSxcbiAgYXBwZWFyOiBmYWxzZSxcbiAgZW50ZXI6IHRydWUsXG4gIGV4aXQ6IHRydWUsXG4gIG9uRW50ZXI6IG5vb3AsXG4gIG9uRW50ZXJpbmc6IG5vb3AsXG4gIG9uRW50ZXJlZDogbm9vcCxcbiAgb25FeGl0OiBub29wLFxuICBvbkV4aXRpbmc6IG5vb3AsXG4gIG9uRXhpdGVkOiBub29wXG59O1xuVHJhbnNpdGlvbi5VTk1PVU5URUQgPSBVTk1PVU5URUQ7XG5UcmFuc2l0aW9uLkVYSVRFRCA9IEVYSVRFRDtcblRyYW5zaXRpb24uRU5URVJJTkcgPSBFTlRFUklORztcblRyYW5zaXRpb24uRU5URVJFRCA9IEVOVEVSRUQ7XG5UcmFuc2l0aW9uLkVYSVRJTkcgPSBFWElUSU5HO1xuZXhwb3J0IGRlZmF1bHQgVHJhbnNpdGlvbjsiLCJpbXBvcnQgeyBDaGlsZHJlbiwgY2xvbmVFbGVtZW50LCBpc1ZhbGlkRWxlbWVudCB9IGZyb20gJ3JlYWN0Jztcbi8qKlxuICogR2l2ZW4gYHRoaXMucHJvcHMuY2hpbGRyZW5gLCByZXR1cm4gYW4gb2JqZWN0IG1hcHBpbmcga2V5IHRvIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Kn0gY2hpbGRyZW4gYHRoaXMucHJvcHMuY2hpbGRyZW5gXG4gKiBAcmV0dXJuIHtvYmplY3R9IE1hcHBpbmcgb2Yga2V5IHRvIGNoaWxkXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENoaWxkTWFwcGluZyhjaGlsZHJlbiwgbWFwRm4pIHtcbiAgdmFyIG1hcHBlciA9IGZ1bmN0aW9uIG1hcHBlcihjaGlsZCkge1xuICAgIHJldHVybiBtYXBGbiAmJiBpc1ZhbGlkRWxlbWVudChjaGlsZCkgPyBtYXBGbihjaGlsZCkgOiBjaGlsZDtcbiAgfTtcblxuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGNoaWxkcmVuKSBDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIGM7XG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgLy8gcnVuIHRoZSBtYXAgZnVuY3Rpb24gaGVyZSBpbnN0ZWFkIHNvIHRoYXQgdGhlIGtleSBpcyB0aGUgY29tcHV0ZWQgb25lXG4gICAgcmVzdWx0W2NoaWxkLmtleV0gPSBtYXBwZXIoY2hpbGQpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogV2hlbiB5b3UncmUgYWRkaW5nIG9yIHJlbW92aW5nIGNoaWxkcmVuIHNvbWUgbWF5IGJlIGFkZGVkIG9yIHJlbW92ZWQgaW4gdGhlXG4gKiBzYW1lIHJlbmRlciBwYXNzLiBXZSB3YW50IHRvIHNob3cgKmJvdGgqIHNpbmNlIHdlIHdhbnQgdG8gc2ltdWx0YW5lb3VzbHlcbiAqIGFuaW1hdGUgZWxlbWVudHMgaW4gYW5kIG91dC4gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIHByZXZpb3VzIHNldCBvZiBrZXlzXG4gKiBhbmQgYSBuZXcgc2V0IG9mIGtleXMgYW5kIG1lcmdlcyB0aGVtIHdpdGggaXRzIGJlc3QgZ3Vlc3Mgb2YgdGhlIGNvcnJlY3RcbiAqIG9yZGVyaW5nLiBJbiB0aGUgZnV0dXJlIHdlIG1heSBleHBvc2Ugc29tZSBvZiB0aGUgdXRpbGl0aWVzIGluXG4gKiBSZWFjdE11bHRpQ2hpbGQgdG8gbWFrZSB0aGlzIGVhc3ksIGJ1dCBmb3Igbm93IFJlYWN0IGl0c2VsZiBkb2VzIG5vdFxuICogZGlyZWN0bHkgaGF2ZSB0aGlzIGNvbmNlcHQgb2YgdGhlIHVuaW9uIG9mIHByZXZDaGlsZHJlbiBhbmQgbmV4dENoaWxkcmVuXG4gKiBzbyB3ZSBpbXBsZW1lbnQgaXQgaGVyZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcHJldiBwcmV2IGNoaWxkcmVuIGFzIHJldHVybmVkIGZyb21cbiAqIGBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKClgLlxuICogQHBhcmFtIHtvYmplY3R9IG5leHQgbmV4dCBjaGlsZHJlbiBhcyByZXR1cm5lZCBmcm9tXG4gKiBgUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZygpYC5cbiAqIEByZXR1cm4ge29iamVjdH0gYSBrZXkgc2V0IHRoYXQgY29udGFpbnMgYWxsIGtleXMgaW4gYHByZXZgIGFuZCBhbGwga2V5c1xuICogaW4gYG5leHRgIGluIGEgcmVhc29uYWJsZSBvcmRlci5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VDaGlsZE1hcHBpbmdzKHByZXYsIG5leHQpIHtcbiAgcHJldiA9IHByZXYgfHwge307XG4gIG5leHQgPSBuZXh0IHx8IHt9O1xuXG4gIGZ1bmN0aW9uIGdldFZhbHVlRm9yS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkgaW4gbmV4dCA/IG5leHRba2V5XSA6IHByZXZba2V5XTtcbiAgfSAvLyBGb3IgZWFjaCBrZXkgb2YgYG5leHRgLCB0aGUgbGlzdCBvZiBrZXlzIHRvIGluc2VydCBiZWZvcmUgdGhhdCBrZXkgaW5cbiAgLy8gdGhlIGNvbWJpbmVkIGxpc3RcblxuXG4gIHZhciBuZXh0S2V5c1BlbmRpbmcgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgcGVuZGluZ0tleXMgPSBbXTtcblxuICBmb3IgKHZhciBwcmV2S2V5IGluIHByZXYpIHtcbiAgICBpZiAocHJldktleSBpbiBuZXh0KSB7XG4gICAgICBpZiAocGVuZGluZ0tleXMubGVuZ3RoKSB7XG4gICAgICAgIG5leHRLZXlzUGVuZGluZ1twcmV2S2V5XSA9IHBlbmRpbmdLZXlzO1xuICAgICAgICBwZW5kaW5nS2V5cyA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nS2V5cy5wdXNoKHByZXZLZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpO1xuICB2YXIgY2hpbGRNYXBwaW5nID0ge307XG5cbiAgZm9yICh2YXIgbmV4dEtleSBpbiBuZXh0KSB7XG4gICAgaWYgKG5leHRLZXlzUGVuZGluZ1tuZXh0S2V5XSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IG5leHRLZXlzUGVuZGluZ1tuZXh0S2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGVuZGluZ05leHRLZXkgPSBuZXh0S2V5c1BlbmRpbmdbbmV4dEtleV1baV07XG4gICAgICAgIGNoaWxkTWFwcGluZ1tuZXh0S2V5c1BlbmRpbmdbbmV4dEtleV1baV1dID0gZ2V0VmFsdWVGb3JLZXkocGVuZGluZ05leHRLZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkTWFwcGluZ1tuZXh0S2V5XSA9IGdldFZhbHVlRm9yS2V5KG5leHRLZXkpO1xuICB9IC8vIEZpbmFsbHksIGFkZCB0aGUga2V5cyB3aGljaCBkaWRuJ3QgYXBwZWFyIGJlZm9yZSBhbnkga2V5IGluIGBuZXh0YFxuXG5cbiAgZm9yIChpID0gMDsgaSA8IHBlbmRpbmdLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hpbGRNYXBwaW5nW3BlbmRpbmdLZXlzW2ldXSA9IGdldFZhbHVlRm9yS2V5KHBlbmRpbmdLZXlzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZE1hcHBpbmc7XG59XG5cbmZ1bmN0aW9uIGdldFByb3AoY2hpbGQsIHByb3AsIHByb3BzKSB7XG4gIHJldHVybiBwcm9wc1twcm9wXSAhPSBudWxsID8gcHJvcHNbcHJvcF0gOiBjaGlsZC5wcm9wc1twcm9wXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEluaXRpYWxDaGlsZE1hcHBpbmcocHJvcHMsIG9uRXhpdGVkKSB7XG4gIHJldHVybiBnZXRDaGlsZE1hcHBpbmcocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgIG9uRXhpdGVkOiBvbkV4aXRlZC5iaW5kKG51bGwsIGNoaWxkKSxcbiAgICAgIGluOiB0cnVlLFxuICAgICAgYXBwZWFyOiBnZXRQcm9wKGNoaWxkLCAnYXBwZWFyJywgcHJvcHMpLFxuICAgICAgZW50ZXI6IGdldFByb3AoY2hpbGQsICdlbnRlcicsIHByb3BzKSxcbiAgICAgIGV4aXQ6IGdldFByb3AoY2hpbGQsICdleGl0JywgcHJvcHMpXG4gICAgfSk7XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE5leHRDaGlsZE1hcHBpbmcobmV4dFByb3BzLCBwcmV2Q2hpbGRNYXBwaW5nLCBvbkV4aXRlZCkge1xuICB2YXIgbmV4dENoaWxkTWFwcGluZyA9IGdldENoaWxkTWFwcGluZyhuZXh0UHJvcHMuY2hpbGRyZW4pO1xuICB2YXIgY2hpbGRyZW4gPSBtZXJnZUNoaWxkTWFwcGluZ3MocHJldkNoaWxkTWFwcGluZywgbmV4dENoaWxkTWFwcGluZyk7XG4gIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltrZXldO1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSByZXR1cm47XG4gICAgdmFyIGhhc1ByZXYgPSAoa2V5IGluIHByZXZDaGlsZE1hcHBpbmcpO1xuICAgIHZhciBoYXNOZXh0ID0gKGtleSBpbiBuZXh0Q2hpbGRNYXBwaW5nKTtcbiAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkTWFwcGluZ1trZXldO1xuICAgIHZhciBpc0xlYXZpbmcgPSBpc1ZhbGlkRWxlbWVudChwcmV2Q2hpbGQpICYmICFwcmV2Q2hpbGQucHJvcHMuaW47IC8vIGl0ZW0gaXMgbmV3IChlbnRlcmluZylcblxuICAgIGlmIChoYXNOZXh0ICYmICghaGFzUHJldiB8fCBpc0xlYXZpbmcpKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnZW50ZXJpbmcnLCBrZXkpXG4gICAgICBjaGlsZHJlbltrZXldID0gY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgIG9uRXhpdGVkOiBvbkV4aXRlZC5iaW5kKG51bGwsIGNoaWxkKSxcbiAgICAgICAgaW46IHRydWUsXG4gICAgICAgIGV4aXQ6IGdldFByb3AoY2hpbGQsICdleGl0JywgbmV4dFByb3BzKSxcbiAgICAgICAgZW50ZXI6IGdldFByb3AoY2hpbGQsICdlbnRlcicsIG5leHRQcm9wcylcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIWhhc05leHQgJiYgaGFzUHJldiAmJiAhaXNMZWF2aW5nKSB7XG4gICAgICAvLyBpdGVtIGlzIG9sZCAoZXhpdGluZylcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdsZWF2aW5nJywga2V5KVxuICAgICAgY2hpbGRyZW5ba2V5XSA9IGNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICBpbjogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaGFzTmV4dCAmJiBoYXNQcmV2ICYmIGlzVmFsaWRFbGVtZW50KHByZXZDaGlsZCkpIHtcbiAgICAgIC8vIGl0ZW0gaGFzbid0IGNoYW5nZWQgdHJhbnNpdGlvbiBzdGF0ZXNcbiAgICAgIC8vIGNvcHkgb3ZlciB0aGUgbGFzdCB0cmFuc2l0aW9uIHByb3BzO1xuICAgICAgLy8gY29uc29sZS5sb2coJ3VuY2hhbmdlZCcsIGtleSlcbiAgICAgIGNoaWxkcmVuW2tleV0gPSBjbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgb25FeGl0ZWQ6IG9uRXhpdGVkLmJpbmQobnVsbCwgY2hpbGQpLFxuICAgICAgICBpbjogcHJldkNoaWxkLnByb3BzLmluLFxuICAgICAgICBleGl0OiBnZXRQcm9wKGNoaWxkLCAnZXhpdCcsIG5leHRQcm9wcyksXG4gICAgICAgIGVudGVyOiBnZXRQcm9wKGNoaWxkLCAnZW50ZXInLCBuZXh0UHJvcHMpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2hpbGRyZW47XG59IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIjtcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZVwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgVHJhbnNpdGlvbkdyb3VwQ29udGV4dCBmcm9tICcuL1RyYW5zaXRpb25Hcm91cENvbnRleHQnO1xuaW1wb3J0IHsgZ2V0Q2hpbGRNYXBwaW5nLCBnZXRJbml0aWFsQ2hpbGRNYXBwaW5nLCBnZXROZXh0Q2hpbGRNYXBwaW5nIH0gZnJvbSAnLi91dGlscy9DaGlsZE1hcHBpbmcnO1xuXG52YXIgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBvYmpba107XG4gIH0pO1xufTtcblxudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgY29tcG9uZW50OiAnZGl2JyxcbiAgY2hpbGRGYWN0b3J5OiBmdW5jdGlvbiBjaGlsZEZhY3RvcnkoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cbn07XG4vKipcbiAqIFRoZSBgPFRyYW5zaXRpb25Hcm91cD5gIGNvbXBvbmVudCBtYW5hZ2VzIGEgc2V0IG9mIHRyYW5zaXRpb24gY29tcG9uZW50c1xuICogKGA8VHJhbnNpdGlvbj5gIGFuZCBgPENTU1RyYW5zaXRpb24+YCkgaW4gYSBsaXN0LiBMaWtlIHdpdGggdGhlIHRyYW5zaXRpb25cbiAqIGNvbXBvbmVudHMsIGA8VHJhbnNpdGlvbkdyb3VwPmAgaXMgYSBzdGF0ZSBtYWNoaW5lIGZvciBtYW5hZ2luZyB0aGUgbW91bnRpbmdcbiAqIGFuZCB1bm1vdW50aW5nIG9mIGNvbXBvbmVudHMgb3ZlciB0aW1lLlxuICpcbiAqIENvbnNpZGVyIHRoZSBleGFtcGxlIGJlbG93LiBBcyBpdGVtcyBhcmUgcmVtb3ZlZCBvciBhZGRlZCB0byB0aGUgVG9kb0xpc3QgdGhlXG4gKiBgaW5gIHByb3AgaXMgdG9nZ2xlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBgPFRyYW5zaXRpb25Hcm91cD5gLlxuICpcbiAqIE5vdGUgdGhhdCBgPFRyYW5zaXRpb25Hcm91cD5gICBkb2VzIG5vdCBkZWZpbmUgYW55IGFuaW1hdGlvbiBiZWhhdmlvciFcbiAqIEV4YWN0bHkgX2hvd18gYSBsaXN0IGl0ZW0gYW5pbWF0ZXMgaXMgdXAgdG8gdGhlIGluZGl2aWR1YWwgdHJhbnNpdGlvblxuICogY29tcG9uZW50LiBUaGlzIG1lYW5zIHlvdSBjYW4gbWl4IGFuZCBtYXRjaCBhbmltYXRpb25zIGFjcm9zcyBkaWZmZXJlbnQgbGlzdFxuICogaXRlbXMuXG4gKi9cblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShUcmFuc2l0aW9uR3JvdXAsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRyYW5zaXRpb25Hcm91cChwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSB8fCB0aGlzO1xuXG4gICAgdmFyIGhhbmRsZUV4aXRlZCA9IF90aGlzLmhhbmRsZUV4aXRlZC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTsgLy8gSW5pdGlhbCBjaGlsZHJlbiBzaG91bGQgYWxsIGJlIGVudGVyaW5nLCBkZXBlbmRlbnQgb24gYXBwZWFyXG5cblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgY29udGV4dFZhbHVlOiB7XG4gICAgICAgIGlzTW91bnRpbmc6IHRydWVcbiAgICAgIH0sXG4gICAgICBoYW5kbGVFeGl0ZWQ6IGhhbmRsZUV4aXRlZCxcbiAgICAgIGZpcnN0UmVuZGVyOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVHJhbnNpdGlvbkdyb3VwLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY29udGV4dFZhbHVlOiB7XG4gICAgICAgIGlzTW91bnRpbmc6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gIH07XG5cbiAgVHJhbnNpdGlvbkdyb3VwLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgcHJldkNoaWxkTWFwcGluZyA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICAgIGhhbmRsZUV4aXRlZCA9IF9yZWYuaGFuZGxlRXhpdGVkLFxuICAgICAgICBmaXJzdFJlbmRlciA9IF9yZWYuZmlyc3RSZW5kZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoaWxkcmVuOiBmaXJzdFJlbmRlciA/IGdldEluaXRpYWxDaGlsZE1hcHBpbmcobmV4dFByb3BzLCBoYW5kbGVFeGl0ZWQpIDogZ2V0TmV4dENoaWxkTWFwcGluZyhuZXh0UHJvcHMsIHByZXZDaGlsZE1hcHBpbmcsIGhhbmRsZUV4aXRlZCksXG4gICAgICBmaXJzdFJlbmRlcjogZmFsc2VcbiAgICB9O1xuICB9IC8vIG5vZGUgaXMgYHVuZGVmaW5lZGAgd2hlbiB1c2VyIHByb3ZpZGVkIGBub2RlUmVmYCBwcm9wXG4gIDtcblxuICBfcHJvdG8uaGFuZGxlRXhpdGVkID0gZnVuY3Rpb24gaGFuZGxlRXhpdGVkKGNoaWxkLCBub2RlKSB7XG4gICAgdmFyIGN1cnJlbnRDaGlsZE1hcHBpbmcgPSBnZXRDaGlsZE1hcHBpbmcodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgaWYgKGNoaWxkLmtleSBpbiBjdXJyZW50Q2hpbGRNYXBwaW5nKSByZXR1cm47XG5cbiAgICBpZiAoY2hpbGQucHJvcHMub25FeGl0ZWQpIHtcbiAgICAgIGNoaWxkLnByb3BzLm9uRXhpdGVkKG5vZGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1vdW50ZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IF9leHRlbmRzKHt9LCBzdGF0ZS5jaGlsZHJlbik7XG5cbiAgICAgICAgZGVsZXRlIGNoaWxkcmVuW2NoaWxkLmtleV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBDb21wb25lbnQgPSBfdGhpcyRwcm9wcy5jb21wb25lbnQsXG4gICAgICAgIGNoaWxkRmFjdG9yeSA9IF90aGlzJHByb3BzLmNoaWxkRmFjdG9yeSxcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiY29tcG9uZW50XCIsIFwiY2hpbGRGYWN0b3J5XCJdKTtcblxuICAgIHZhciBjb250ZXh0VmFsdWUgPSB0aGlzLnN0YXRlLmNvbnRleHRWYWx1ZTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2YWx1ZXModGhpcy5zdGF0ZS5jaGlsZHJlbikubWFwKGNoaWxkRmFjdG9yeSk7XG4gICAgZGVsZXRlIHByb3BzLmFwcGVhcjtcbiAgICBkZWxldGUgcHJvcHMuZW50ZXI7XG4gICAgZGVsZXRlIHByb3BzLmV4aXQ7XG5cbiAgICBpZiAoQ29tcG9uZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbkdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogY29udGV4dFZhbHVlXG4gICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRyYW5zaXRpb25Hcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBjb250ZXh0VmFsdWVcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHByb3BzLCBjaGlsZHJlbikpO1xuICB9O1xuXG4gIHJldHVybiBUcmFuc2l0aW9uR3JvdXA7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblRyYW5zaXRpb25Hcm91cC5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIC8qKlxuICAgKiBgPFRyYW5zaXRpb25Hcm91cD5gIHJlbmRlcnMgYSBgPGRpdj5gIGJ5IGRlZmF1bHQuIFlvdSBjYW4gY2hhbmdlIHRoaXNcbiAgICogYmVoYXZpb3IgYnkgcHJvdmlkaW5nIGEgYGNvbXBvbmVudGAgcHJvcC5cbiAgICogSWYgeW91IHVzZSBSZWFjdCB2MTYrIGFuZCB3b3VsZCBsaWtlIHRvIGF2b2lkIGEgd3JhcHBpbmcgYDxkaXY+YCBlbGVtZW50XG4gICAqIHlvdSBjYW4gcGFzcyBpbiBgY29tcG9uZW50PXtudWxsfWAuIFRoaXMgaXMgdXNlZnVsIGlmIHRoZSB3cmFwcGluZyBkaXZcbiAgICogYm9ya3MgeW91ciBjc3Mgc3R5bGVzLlxuICAgKi9cbiAgY29tcG9uZW50OiBQcm9wVHlwZXMuYW55LFxuXG4gIC8qKlxuICAgKiBBIHNldCBvZiBgPFRyYW5zaXRpb24+YCBjb21wb25lbnRzLCB0aGF0IGFyZSB0b2dnbGVkIGBpbmAgYW5kIG91dCBhcyB0aGV5XG4gICAqIGxlYXZlLiB0aGUgYDxUcmFuc2l0aW9uR3JvdXA+YCB3aWxsIGluamVjdCBzcGVjaWZpYyB0cmFuc2l0aW9uIHByb3BzLCBzb1xuICAgKiByZW1lbWJlciB0byBzcHJlYWQgdGhlbSB0aHJvdWdoIGlmIHlvdSBhcmUgd3JhcHBpbmcgdGhlIGA8VHJhbnNpdGlvbj5gIGFzXG4gICAqIHdpdGggb3VyIGA8RmFkZT5gIGV4YW1wbGUuXG4gICAqXG4gICAqIFdoaWxlIHRoaXMgY29tcG9uZW50IGlzIG1lYW50IGZvciBtdWx0aXBsZSBgVHJhbnNpdGlvbmAgb3IgYENTU1RyYW5zaXRpb25gXG4gICAqIGNoaWxkcmVuLCBzb21ldGltZXMgeW91IG1heSB3YW50IHRvIGhhdmUgYSBzaW5nbGUgdHJhbnNpdGlvbiBjaGlsZCB3aXRoXG4gICAqIGNvbnRlbnQgdGhhdCB5b3Ugd2FudCB0byBiZSB0cmFuc2l0aW9uZWQgb3V0IGFuZCBpbiB3aGVuIHlvdSBjaGFuZ2UgaXRcbiAgICogKGUuZy4gcm91dGVzLCBpbWFnZXMgZXRjLikgSW4gdGhhdCBjYXNlIHlvdSBjYW4gY2hhbmdlIHRoZSBga2V5YCBwcm9wIG9mXG4gICAqIHRoZSB0cmFuc2l0aW9uIGNoaWxkIGFzIHlvdSBjaGFuZ2UgaXRzIGNvbnRlbnQsIHRoaXMgd2lsbCBjYXVzZVxuICAgKiBgVHJhbnNpdGlvbkdyb3VwYCB0byB0cmFuc2l0aW9uIHRoZSBjaGlsZCBvdXQgYW5kIGJhY2sgaW4uXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgcHJvcCB0aGF0IGVuYWJsZXMgb3IgZGlzYWJsZXMgYXBwZWFyIGFuaW1hdGlvbnNcbiAgICogZm9yIGFsbCBjaGlsZHJlbi4gTm90ZSB0aGF0IHNwZWNpZnlpbmcgdGhpcyB3aWxsIG92ZXJyaWRlIGFueSBkZWZhdWx0cyBzZXRcbiAgICogb24gaW5kaXZpZHVhbCBjaGlsZHJlbiBUcmFuc2l0aW9ucy5cbiAgICovXG4gIGFwcGVhcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgcHJvcCB0aGF0IGVuYWJsZXMgb3IgZGlzYWJsZXMgZW50ZXIgYW5pbWF0aW9uc1xuICAgKiBmb3IgYWxsIGNoaWxkcmVuLiBOb3RlIHRoYXQgc3BlY2lmeWluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IGRlZmF1bHRzIHNldFxuICAgKiBvbiBpbmRpdmlkdWFsIGNoaWxkcmVuIFRyYW5zaXRpb25zLlxuICAgKi9cbiAgZW50ZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbmNlIHByb3AgdGhhdCBlbmFibGVzIG9yIGRpc2FibGVzIGV4aXQgYW5pbWF0aW9uc1xuICAgKiBmb3IgYWxsIGNoaWxkcmVuLiBOb3RlIHRoYXQgc3BlY2lmeWluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IGRlZmF1bHRzIHNldFxuICAgKiBvbiBpbmRpdmlkdWFsIGNoaWxkcmVuIFRyYW5zaXRpb25zLlxuICAgKi9cbiAgZXhpdDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFlvdSBtYXkgbmVlZCB0byBhcHBseSByZWFjdGl2ZSB1cGRhdGVzIHRvIGEgY2hpbGQgYXMgaXQgaXMgZXhpdGluZy5cbiAgICogVGhpcyBpcyBnZW5lcmFsbHkgZG9uZSBieSB1c2luZyBgY2xvbmVFbGVtZW50YCBob3dldmVyIGluIHRoZSBjYXNlIG9mIGFuIGV4aXRpbmdcbiAgICogY2hpbGQgdGhlIGVsZW1lbnQgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIGFuZCBub3QgYWNjZXNzaWJsZSB0byB0aGUgY29uc3VtZXIuXG4gICAqXG4gICAqIElmIHlvdSBkbyBuZWVkIHRvIHVwZGF0ZSBhIGNoaWxkIGFzIGl0IGxlYXZlcyB5b3UgY2FuIHByb3ZpZGUgYSBgY2hpbGRGYWN0b3J5YFxuICAgKiB0byB3cmFwIGV2ZXJ5IGNoaWxkLCBldmVuIHRoZSBvbmVzIHRoYXQgYXJlIGxlYXZpbmcuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKGNoaWxkOiBSZWFjdEVsZW1lbnQpIC0+IFJlYWN0RWxlbWVudFxuICAgKi9cbiAgY2hpbGRGYWN0b3J5OiBQcm9wVHlwZXMuZnVuY1xufSA6IHt9O1xuVHJhbnNpdGlvbkdyb3VwLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IFRyYW5zaXRpb25Hcm91cDsiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgdXNlRXZlbnRDYWxsYmFjayBmcm9tICcuLi91dGlscy91c2VFdmVudENhbGxiYWNrJztcbnZhciB1c2VFbmhhbmNlZEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gUmVhY3QudXNlRWZmZWN0IDogUmVhY3QudXNlTGF5b3V0RWZmZWN0O1xuLyoqXG4gKiBAaWdub3JlIC0gaW50ZXJuYWwgY29tcG9uZW50LlxuICovXG5cbmZ1bmN0aW9uIFJpcHBsZShwcm9wcykge1xuICB2YXIgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBfcHJvcHMkcHVsc2F0ZSA9IHByb3BzLnB1bHNhdGUsXG4gICAgICBwdWxzYXRlID0gX3Byb3BzJHB1bHNhdGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJHB1bHNhdGUsXG4gICAgICByaXBwbGVYID0gcHJvcHMucmlwcGxlWCxcbiAgICAgIHJpcHBsZVkgPSBwcm9wcy5yaXBwbGVZLFxuICAgICAgcmlwcGxlU2l6ZSA9IHByb3BzLnJpcHBsZVNpemUsXG4gICAgICBpblByb3AgPSBwcm9wcy5pbixcbiAgICAgIF9wcm9wcyRvbkV4aXRlZCA9IHByb3BzLm9uRXhpdGVkLFxuICAgICAgb25FeGl0ZWQgPSBfcHJvcHMkb25FeGl0ZWQgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHt9IDogX3Byb3BzJG9uRXhpdGVkLFxuICAgICAgdGltZW91dCA9IHByb3BzLnRpbWVvdXQ7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIGxlYXZpbmcgPSBfUmVhY3QkdXNlU3RhdGVbMF0sXG4gICAgICBzZXRMZWF2aW5nID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciByaXBwbGVDbGFzc05hbWUgPSBjbHN4KGNsYXNzZXMucmlwcGxlLCBjbGFzc2VzLnJpcHBsZVZpc2libGUsIHB1bHNhdGUgJiYgY2xhc3Nlcy5yaXBwbGVQdWxzYXRlKTtcbiAgdmFyIHJpcHBsZVN0eWxlcyA9IHtcbiAgICB3aWR0aDogcmlwcGxlU2l6ZSxcbiAgICBoZWlnaHQ6IHJpcHBsZVNpemUsXG4gICAgdG9wOiAtKHJpcHBsZVNpemUgLyAyKSArIHJpcHBsZVksXG4gICAgbGVmdDogLShyaXBwbGVTaXplIC8gMikgKyByaXBwbGVYXG4gIH07XG4gIHZhciBjaGlsZENsYXNzTmFtZSA9IGNsc3goY2xhc3Nlcy5jaGlsZCwgbGVhdmluZyAmJiBjbGFzc2VzLmNoaWxkTGVhdmluZywgcHVsc2F0ZSAmJiBjbGFzc2VzLmNoaWxkUHVsc2F0ZSk7XG4gIHZhciBoYW5kbGVFeGl0ZWQgPSB1c2VFdmVudENhbGxiYWNrKG9uRXhpdGVkKTsgLy8gUmlwcGxlIGlzIHVzZWQgZm9yIHVzZXIgZmVlZGJhY2sgKGUuZy4gY2xpY2sgb3IgcHJlc3MpIHNvIHdlIHdhbnQgdG8gYXBwbHkgc3R5bGVzIHdpdGggdGhlIGhpZ2hlc3QgcHJpb3JpdHlcblxuICB1c2VFbmhhbmNlZEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpblByb3ApIHtcbiAgICAgIC8vIHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAjb25FeGl0XG4gICAgICBzZXRMZWF2aW5nKHRydWUpOyAvLyByZWFjdC10cmFuc2l0aW9uLWdyb3VwI29uRXhpdGVkXG5cbiAgICAgIHZhciB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGhhbmRsZUV4aXRlZCwgdGltZW91dCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSwgW2hhbmRsZUV4aXRlZCwgaW5Qcm9wLCB0aW1lb3V0XSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogcmlwcGxlQ2xhc3NOYW1lLFxuICAgIHN0eWxlOiByaXBwbGVTdHlsZXNcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IGNoaWxkQ2xhc3NOYW1lXG4gIH0pKTtcbn1cblxucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmlwcGxlLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlIC0gaW5qZWN0ZWQgZnJvbSBUcmFuc2l0aW9uR3JvdXBcbiAgICovXG4gIGluOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQGlnbm9yZSAtIGluamVjdGVkIGZyb20gVHJhbnNpdGlvbkdyb3VwXG4gICAqL1xuICBvbkV4aXRlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHJpcHBsZSBwdWxzYXRlcywgdHlwaWNhbGx5IGluZGljYXRpbmcgdGhlIGtleWJvYXJkIGZvY3VzIHN0YXRlIG9mIGFuIGVsZW1lbnQuXG4gICAqL1xuICBwdWxzYXRlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogRGlhbWV0ZXIgb2YgdGhlIHJpcHBsZS5cbiAgICovXG4gIHJpcHBsZVNpemU6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIHJpcHBsZSBjZW50ZXIuXG4gICAqL1xuICByaXBwbGVYOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgcmlwcGxlIGNlbnRlci5cbiAgICovXG4gIHJpcHBsZVk6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIGV4aXQgZGVsYXlcbiAgICovXG4gIHRpbWVvdXQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IFJpcHBsZTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5XCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IFRyYW5zaXRpb25Hcm91cCB9IGZyb20gJ3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5pbXBvcnQgUmlwcGxlIGZyb20gJy4vUmlwcGxlJztcbnZhciBEVVJBVElPTiA9IDU1MDtcbmV4cG9ydCB2YXIgREVMQVlfUklQUExFID0gODA7XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gICAgcm9vdDoge1xuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB6SW5kZXg6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBib3JkZXJSYWRpdXM6ICdpbmhlcml0J1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaW50ZXJuYWwgYFJpcHBsZWAgY29tcG9uZW50cyBgcmlwcGxlYCBjbGFzcy4gKi9cbiAgICByaXBwbGU6IHtcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaW50ZXJuYWwgYFJpcHBsZWAgY29tcG9uZW50cyBgcmlwcGxlVmlzaWJsZWAgY2xhc3MuICovXG4gICAgcmlwcGxlVmlzaWJsZToge1xuICAgICAgb3BhY2l0eTogMC4zLFxuICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknLFxuICAgICAgYW5pbWF0aW9uOiBcIiRlbnRlciBcIi5jb25jYXQoRFVSQVRJT04sIFwibXMgXCIpLmNvbmNhdCh0aGVtZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZUluT3V0KVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaW50ZXJuYWwgYFJpcHBsZWAgY29tcG9uZW50cyBgcmlwcGxlUHVsc2F0ZWAgY2xhc3MuICovXG4gICAgcmlwcGxlUHVsc2F0ZToge1xuICAgICAgYW5pbWF0aW9uRHVyYXRpb246IFwiXCIuY29uY2F0KHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXIsIFwibXNcIilcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGludGVybmFsIGBSaXBwbGVgIGNvbXBvbmVudHMgYGNoaWxkYCBjbGFzcy4gKi9cbiAgICBjaGlsZDoge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJ1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaW50ZXJuYWwgYFJpcHBsZWAgY29tcG9uZW50cyBgY2hpbGRMZWF2aW5nYCBjbGFzcy4gKi9cbiAgICBjaGlsZExlYXZpbmc6IHtcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBhbmltYXRpb246IFwiJGV4aXQgXCIuY29uY2F0KERVUkFUSU9OLCBcIm1zIFwiKS5jb25jYXQodGhlbWUudHJhbnNpdGlvbnMuZWFzaW5nLmVhc2VJbk91dClcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGludGVybmFsIGBSaXBwbGVgIGNvbXBvbmVudHMgYGNoaWxkUHVsc2F0ZWAgY2xhc3MuICovXG4gICAgY2hpbGRQdWxzYXRlOiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBhbmltYXRpb246IFwiJHB1bHNhdGUgMjUwMG1zIFwiLmNvbmNhdCh0aGVtZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZUluT3V0LCBcIiAyMDBtcyBpbmZpbml0ZVwiKVxuICAgIH0sXG4gICAgJ0BrZXlmcmFtZXMgZW50ZXInOiB7XG4gICAgICAnMCUnOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDApJyxcbiAgICAgICAgb3BhY2l0eTogMC4xXG4gICAgICB9LFxuICAgICAgJzEwMCUnOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJyxcbiAgICAgICAgb3BhY2l0eTogMC4zXG4gICAgICB9XG4gICAgfSxcbiAgICAnQGtleWZyYW1lcyBleGl0Jzoge1xuICAgICAgJzAlJzoge1xuICAgICAgICBvcGFjaXR5OiAxXG4gICAgICB9LFxuICAgICAgJzEwMCUnOiB7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH1cbiAgICB9LFxuICAgICdAa2V5ZnJhbWVzIHB1bHNhdGUnOiB7XG4gICAgICAnMCUnOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJ1xuICAgICAgfSxcbiAgICAgICc1MCUnOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDAuOTIpJ1xuICAgICAgfSxcbiAgICAgICcxMDAlJzoge1xuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSgxKSdcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuLyoqXG4gKiBAaWdub3JlIC0gaW50ZXJuYWwgY29tcG9uZW50LlxuICpcbiAqIFRPRE8gdjU6IE1ha2UgcHJpdmF0ZVxuICovXG5cbnZhciBUb3VjaFJpcHBsZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFRvdWNoUmlwcGxlKHByb3BzLCByZWYpIHtcbiAgdmFyIF9wcm9wcyRjZW50ZXIgPSBwcm9wcy5jZW50ZXIsXG4gICAgICBjZW50ZXJQcm9wID0gX3Byb3BzJGNlbnRlciA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkY2VudGVyLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2VudGVyXCIsIFwiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiXSk7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKFtdKSxcbiAgICAgIHJpcHBsZXMgPSBfUmVhY3QkdXNlU3RhdGVbMF0sXG4gICAgICBzZXRSaXBwbGVzID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciBuZXh0S2V5ID0gUmVhY3QudXNlUmVmKDApO1xuICB2YXIgcmlwcGxlQ2FsbGJhY2sgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJpcHBsZUNhbGxiYWNrLmN1cnJlbnQpIHtcbiAgICAgIHJpcHBsZUNhbGxiYWNrLmN1cnJlbnQoKTtcbiAgICAgIHJpcHBsZUNhbGxiYWNrLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW3JpcHBsZXNdKTsgLy8gVXNlZCB0byBmaWx0ZXIgb3V0IG1vdXNlIGVtdWxhdGVkIGV2ZW50cyBvbiBtb2JpbGUuXG5cbiAgdmFyIGlnbm9yaW5nTW91c2VEb3duID0gUmVhY3QudXNlUmVmKGZhbHNlKTsgLy8gV2UgdXNlIGEgdGltZXIgaW4gb3JkZXIgdG8gb25seSBzaG93IHRoZSByaXBwbGVzIGZvciB0b3VjaCBcImNsaWNrXCIgbGlrZSBldmVudHMuXG4gIC8vIFdlIGRvbid0IHdhbnQgdG8gZGlzcGxheSB0aGUgcmlwcGxlIGZvciB0b3VjaCBzY3JvbGwgZXZlbnRzLlxuXG4gIHZhciBzdGFydFRpbWVyID0gUmVhY3QudXNlUmVmKG51bGwpOyAvLyBUaGlzIGlzIHRoZSBob29rIGNhbGxlZCBvbmNlIHRoZSBwcmV2aW91cyB0aW1lb3V0IGlzIHJlYWR5LlxuXG4gIHZhciBzdGFydFRpbWVyQ29tbWl0ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgY29udGFpbmVyID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQoc3RhcnRUaW1lci5jdXJyZW50KTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHZhciBzdGFydENvbW1pdCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB2YXIgcHVsc2F0ZSA9IHBhcmFtcy5wdWxzYXRlLFxuICAgICAgICByaXBwbGVYID0gcGFyYW1zLnJpcHBsZVgsXG4gICAgICAgIHJpcHBsZVkgPSBwYXJhbXMucmlwcGxlWSxcbiAgICAgICAgcmlwcGxlU2l6ZSA9IHBhcmFtcy5yaXBwbGVTaXplLFxuICAgICAgICBjYiA9IHBhcmFtcy5jYjtcbiAgICBzZXRSaXBwbGVzKGZ1bmN0aW9uIChvbGRSaXBwbGVzKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShvbGRSaXBwbGVzKSwgWy8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJpcHBsZSwge1xuICAgICAgICBrZXk6IG5leHRLZXkuY3VycmVudCxcbiAgICAgICAgY2xhc3NlczogY2xhc3NlcyxcbiAgICAgICAgdGltZW91dDogRFVSQVRJT04sXG4gICAgICAgIHB1bHNhdGU6IHB1bHNhdGUsXG4gICAgICAgIHJpcHBsZVg6IHJpcHBsZVgsXG4gICAgICAgIHJpcHBsZVk6IHJpcHBsZVksXG4gICAgICAgIHJpcHBsZVNpemU6IHJpcHBsZVNpemVcbiAgICAgIH0pXSk7XG4gICAgfSk7XG4gICAgbmV4dEtleS5jdXJyZW50ICs9IDE7XG4gICAgcmlwcGxlQ2FsbGJhY2suY3VycmVudCA9IGNiO1xuICB9LCBbY2xhc3Nlc10pO1xuICB2YXIgc3RhcnQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIGNiID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIF9vcHRpb25zJHB1bHNhdGUgPSBvcHRpb25zLnB1bHNhdGUsXG4gICAgICAgIHB1bHNhdGUgPSBfb3B0aW9ucyRwdWxzYXRlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHB1bHNhdGUsXG4gICAgICAgIF9vcHRpb25zJGNlbnRlciA9IG9wdGlvbnMuY2VudGVyLFxuICAgICAgICBjZW50ZXIgPSBfb3B0aW9ucyRjZW50ZXIgPT09IHZvaWQgMCA/IGNlbnRlclByb3AgfHwgb3B0aW9ucy5wdWxzYXRlIDogX29wdGlvbnMkY2VudGVyLFxuICAgICAgICBfb3B0aW9ucyRmYWtlRWxlbWVudCA9IG9wdGlvbnMuZmFrZUVsZW1lbnQsXG4gICAgICAgIGZha2VFbGVtZW50ID0gX29wdGlvbnMkZmFrZUVsZW1lbnQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkZmFrZUVsZW1lbnQ7XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgJiYgaWdub3JpbmdNb3VzZURvd24uY3VycmVudCkge1xuICAgICAgaWdub3JpbmdNb3VzZURvd24uY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgIGlnbm9yaW5nTW91c2VEb3duLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0gZmFrZUVsZW1lbnQgPyBudWxsIDogY29udGFpbmVyLmN1cnJlbnQ7XG4gICAgdmFyIHJlY3QgPSBlbGVtZW50ID8gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH07IC8vIEdldCB0aGUgc2l6ZSBvZiB0aGUgcmlwcGxlXG5cbiAgICB2YXIgcmlwcGxlWDtcbiAgICB2YXIgcmlwcGxlWTtcbiAgICB2YXIgcmlwcGxlU2l6ZTtcblxuICAgIGlmIChjZW50ZXIgfHwgZXZlbnQuY2xpZW50WCA9PT0gMCAmJiBldmVudC5jbGllbnRZID09PSAwIHx8ICFldmVudC5jbGllbnRYICYmICFldmVudC50b3VjaGVzKSB7XG4gICAgICByaXBwbGVYID0gTWF0aC5yb3VuZChyZWN0LndpZHRoIC8gMik7XG4gICAgICByaXBwbGVZID0gTWF0aC5yb3VuZChyZWN0LmhlaWdodCAvIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3JlZiA9IGV2ZW50LnRvdWNoZXMgPyBldmVudC50b3VjaGVzWzBdIDogZXZlbnQsXG4gICAgICAgICAgY2xpZW50WCA9IF9yZWYuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZID0gX3JlZi5jbGllbnRZO1xuXG4gICAgICByaXBwbGVYID0gTWF0aC5yb3VuZChjbGllbnRYIC0gcmVjdC5sZWZ0KTtcbiAgICAgIHJpcHBsZVkgPSBNYXRoLnJvdW5kKGNsaWVudFkgLSByZWN0LnRvcCk7XG4gICAgfVxuXG4gICAgaWYgKGNlbnRlcikge1xuICAgICAgcmlwcGxlU2l6ZSA9IE1hdGguc3FydCgoMiAqIE1hdGgucG93KHJlY3Qud2lkdGgsIDIpICsgTWF0aC5wb3cocmVjdC5oZWlnaHQsIDIpKSAvIDMpOyAvLyBGb3Igc29tZSByZWFzb24gdGhlIGFuaW1hdGlvbiBpcyBicm9rZW4gb24gTW9iaWxlIENocm9tZSBpZiB0aGUgc2l6ZSBpZiBldmVuLlxuXG4gICAgICBpZiAocmlwcGxlU2l6ZSAlIDIgPT09IDApIHtcbiAgICAgICAgcmlwcGxlU2l6ZSArPSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2l6ZVggPSBNYXRoLm1heChNYXRoLmFicygoZWxlbWVudCA/IGVsZW1lbnQuY2xpZW50V2lkdGggOiAwKSAtIHJpcHBsZVgpLCByaXBwbGVYKSAqIDIgKyAyO1xuICAgICAgdmFyIHNpemVZID0gTWF0aC5tYXgoTWF0aC5hYnMoKGVsZW1lbnQgPyBlbGVtZW50LmNsaWVudEhlaWdodCA6IDApIC0gcmlwcGxlWSksIHJpcHBsZVkpICogMiArIDI7XG4gICAgICByaXBwbGVTaXplID0gTWF0aC5zcXJ0KE1hdGgucG93KHNpemVYLCAyKSArIE1hdGgucG93KHNpemVZLCAyKSk7XG4gICAgfSAvLyBUb3VjaGUgZGV2aWNlc1xuXG5cbiAgICBpZiAoZXZlbnQudG91Y2hlcykge1xuICAgICAgLy8gY2hlY2sgdGhhdCB0aGlzIGlzbid0IGFub3RoZXIgdG91Y2hzdGFydCBkdWUgdG8gbXVsdGl0b3VjaFxuICAgICAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgb25seSBjbGVhciBhIHNpbmdsZSB0aW1lciB3aGVuIHVubW91bnRpbmcgd2hpbGUgdHdvXG4gICAgICAvLyBhcmUgcnVubmluZ1xuICAgICAgaWYgKHN0YXJ0VGltZXJDb21taXQuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBQcmVwYXJlIHRoZSByaXBwbGUgZWZmZWN0LlxuICAgICAgICBzdGFydFRpbWVyQ29tbWl0LmN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhcnRDb21taXQoe1xuICAgICAgICAgICAgcHVsc2F0ZTogcHVsc2F0ZSxcbiAgICAgICAgICAgIHJpcHBsZVg6IHJpcHBsZVgsXG4gICAgICAgICAgICByaXBwbGVZOiByaXBwbGVZLFxuICAgICAgICAgICAgcmlwcGxlU2l6ZTogcmlwcGxlU2l6ZSxcbiAgICAgICAgICAgIGNiOiBjYlxuICAgICAgICAgIH0pO1xuICAgICAgICB9OyAvLyBEZWxheSB0aGUgZXhlY3V0aW9uIG9mIHRoZSByaXBwbGUgZWZmZWN0LlxuXG5cbiAgICAgICAgc3RhcnRUaW1lci5jdXJyZW50ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0VGltZXJDb21taXQuY3VycmVudCkge1xuICAgICAgICAgICAgc3RhcnRUaW1lckNvbW1pdC5jdXJyZW50KCk7XG4gICAgICAgICAgICBzdGFydFRpbWVyQ29tbWl0LmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgREVMQVlfUklQUExFKTsgLy8gV2UgaGF2ZSB0byBtYWtlIGEgdHJhZGVvZmYgd2l0aCB0aGlzIHZhbHVlLlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydENvbW1pdCh7XG4gICAgICAgIHB1bHNhdGU6IHB1bHNhdGUsXG4gICAgICAgIHJpcHBsZVg6IHJpcHBsZVgsXG4gICAgICAgIHJpcHBsZVk6IHJpcHBsZVksXG4gICAgICAgIHJpcHBsZVNpemU6IHJpcHBsZVNpemUsXG4gICAgICAgIGNiOiBjYlxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbY2VudGVyUHJvcCwgc3RhcnRDb21taXRdKTtcbiAgdmFyIHB1bHNhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgc3RhcnQoe30sIHtcbiAgICAgIHB1bHNhdGU6IHRydWVcbiAgICB9KTtcbiAgfSwgW3N0YXJ0XSk7XG4gIHZhciBzdG9wID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50LCBjYikge1xuICAgIGNsZWFyVGltZW91dChzdGFydFRpbWVyLmN1cnJlbnQpOyAvLyBUaGUgdG91Y2ggaW50ZXJhY3Rpb24gb2NjdXJzIHRvbyBxdWlja2x5LlxuICAgIC8vIFdlIHN0aWxsIHdhbnQgdG8gc2hvdyByaXBwbGUgZWZmZWN0LlxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICd0b3VjaGVuZCcgJiYgc3RhcnRUaW1lckNvbW1pdC5jdXJyZW50KSB7XG4gICAgICBldmVudC5wZXJzaXN0KCk7XG4gICAgICBzdGFydFRpbWVyQ29tbWl0LmN1cnJlbnQoKTtcbiAgICAgIHN0YXJ0VGltZXJDb21taXQuY3VycmVudCA9IG51bGw7XG4gICAgICBzdGFydFRpbWVyLmN1cnJlbnQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RvcChldmVudCwgY2IpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhcnRUaW1lckNvbW1pdC5jdXJyZW50ID0gbnVsbDtcbiAgICBzZXRSaXBwbGVzKGZ1bmN0aW9uIChvbGRSaXBwbGVzKSB7XG4gICAgICBpZiAob2xkUmlwcGxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBvbGRSaXBwbGVzLnNsaWNlKDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2xkUmlwcGxlcztcbiAgICB9KTtcbiAgICByaXBwbGVDYWxsYmFjay5jdXJyZW50ID0gY2I7XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHVsc2F0ZTogcHVsc2F0ZSxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIHN0b3A6IHN0b3BcbiAgICB9O1xuICB9LCBbcHVsc2F0ZSwgc3RhcnQsIHN0b3BdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lKSxcbiAgICByZWY6IGNvbnRhaW5lclxuICB9LCBvdGhlciksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRyYW5zaXRpb25Hcm91cCwge1xuICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICBleGl0OiB0cnVlXG4gIH0sIHJpcHBsZXMpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVG91Y2hSaXBwbGUucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgcmlwcGxlIHN0YXJ0cyBhdCB0aGUgY2VudGVyIG9mIHRoZSBjb21wb25lbnRcbiAgICogcmF0aGVyIHRoYW4gYXQgdGhlIHBvaW50IG9mIGludGVyYWN0aW9uLlxuICAgKi9cbiAgY2VudGVyOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZ1xufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIGZsaXA6IGZhbHNlLFxuICBuYW1lOiAnTXVpVG91Y2hSaXBwbGUnXG59KSggLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oVG91Y2hSaXBwbGUpKTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHsgZWxlbWVudFR5cGVBY2NlcHRpbmdSZWYsIHJlZlR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IHVzZUZvcmtSZWYgZnJvbSAnLi4vdXRpbHMvdXNlRm9ya1JlZic7XG5pbXBvcnQgdXNlRXZlbnRDYWxsYmFjayBmcm9tICcuLi91dGlscy91c2VFdmVudENhbGxiYWNrJztcbmltcG9ydCBkZXByZWNhdGVkUHJvcFR5cGUgZnJvbSAnLi4vdXRpbHMvZGVwcmVjYXRlZFByb3BUeXBlJztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCB1c2VJc0ZvY3VzVmlzaWJsZSBmcm9tICcuLi91dGlscy91c2VJc0ZvY3VzVmlzaWJsZSc7XG5pbXBvcnQgVG91Y2hSaXBwbGUgZnJvbSAnLi9Ub3VjaFJpcHBsZSc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IHtcbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgcm9vdDoge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtZmxleCcsXG4gICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIFdlYmtpdFRhcEhpZ2hsaWdodENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAvLyBSZXNldCBkZWZhdWx0IHZhbHVlXG4gICAgLy8gV2UgZGlzYWJsZSB0aGUgZm9jdXMgcmluZyBmb3IgbW91c2UsIHRvdWNoIGFuZCBrZXlib2FyZCB1c2Vycy5cbiAgICBvdXRsaW5lOiAwLFxuICAgIGJvcmRlcjogMCxcbiAgICBtYXJnaW46IDAsXG4gICAgLy8gUmVtb3ZlIHRoZSBtYXJnaW4gaW4gU2FmYXJpXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgLy8gUmVtb3ZlIHRoZSBwYWRkaW5nIGluIEZpcmVmb3hcbiAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgJy1tb3otYXBwZWFyYW5jZSc6ICdub25lJyxcbiAgICAvLyBSZXNldFxuICAgICctd2Via2l0LWFwcGVhcmFuY2UnOiAnbm9uZScsXG4gICAgLy8gUmVzZXRcbiAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnLFxuICAgIC8vIFNvIHdlIHRha2UgcHJlY2VkZW50IG92ZXIgdGhlIHN0eWxlIG9mIGEgbmF0aXZlIDxhIC8+IGVsZW1lbnQuXG4gICAgY29sb3I6ICdpbmhlcml0JyxcbiAgICAnJjo6LW1vei1mb2N1cy1pbm5lcic6IHtcbiAgICAgIGJvcmRlclN0eWxlOiAnbm9uZScgLy8gUmVtb3ZlIEZpcmVmb3ggZG90dGVkIG91dGxpbmUuXG5cbiAgICB9LFxuICAgICcmJGRpc2FibGVkJzoge1xuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgLy8gRGlzYWJsZSBsaW5rIGludGVyYWN0aW9uc1xuICAgICAgY3Vyc29yOiAnZGVmYXVsdCdcbiAgICB9LFxuICAgICdAbWVkaWEgcHJpbnQnOiB7XG4gICAgICBjb2xvckFkanVzdDogJ2V4YWN0J1xuICAgIH1cbiAgfSxcblxuICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBkaXNhYmxlZD17dHJ1ZX1gLiAqL1xuICBkaXNhYmxlZDoge30sXG5cbiAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBrZXlib2FyZCBmb2N1c2VkLiAqL1xuICBmb2N1c1Zpc2libGU6IHt9XG59O1xuLyoqXG4gKiBgQnV0dG9uQmFzZWAgY29udGFpbnMgYXMgZmV3IHN0eWxlcyBhcyBwb3NzaWJsZS5cbiAqIEl0IGFpbXMgdG8gYmUgYSBzaW1wbGUgYnVpbGRpbmcgYmxvY2sgZm9yIGNyZWF0aW5nIGEgYnV0dG9uLlxuICogSXQgY29udGFpbnMgYSBsb2FkIG9mIHN0eWxlIHJlc2V0IGFuZCBzb21lIGZvY3VzL3JpcHBsZSBsb2dpYy5cbiAqL1xuXG52YXIgQnV0dG9uQmFzZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEJ1dHRvbkJhc2UocHJvcHMsIHJlZikge1xuICB2YXIgYWN0aW9uID0gcHJvcHMuYWN0aW9uLFxuICAgICAgYnV0dG9uUmVmUHJvcCA9IHByb3BzLmJ1dHRvblJlZixcbiAgICAgIF9wcm9wcyRjZW50ZXJSaXBwbGUgPSBwcm9wcy5jZW50ZXJSaXBwbGUsXG4gICAgICBjZW50ZXJSaXBwbGUgPSBfcHJvcHMkY2VudGVyUmlwcGxlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRjZW50ZXJSaXBwbGUsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkY29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50LFxuICAgICAgY29tcG9uZW50ID0gX3Byb3BzJGNvbXBvbmVudCA9PT0gdm9pZCAwID8gJ2J1dHRvbicgOiBfcHJvcHMkY29tcG9uZW50LFxuICAgICAgX3Byb3BzJGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQsXG4gICAgICBkaXNhYmxlZCA9IF9wcm9wcyRkaXNhYmxlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZWQsXG4gICAgICBfcHJvcHMkZGlzYWJsZVJpcHBsZSA9IHByb3BzLmRpc2FibGVSaXBwbGUsXG4gICAgICBkaXNhYmxlUmlwcGxlID0gX3Byb3BzJGRpc2FibGVSaXBwbGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVSaXBwbGUsXG4gICAgICBfcHJvcHMkZGlzYWJsZVRvdWNoUmkgPSBwcm9wcy5kaXNhYmxlVG91Y2hSaXBwbGUsXG4gICAgICBkaXNhYmxlVG91Y2hSaXBwbGUgPSBfcHJvcHMkZGlzYWJsZVRvdWNoUmkgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVUb3VjaFJpLFxuICAgICAgX3Byb3BzJGZvY3VzUmlwcGxlID0gcHJvcHMuZm9jdXNSaXBwbGUsXG4gICAgICBmb2N1c1JpcHBsZSA9IF9wcm9wcyRmb2N1c1JpcHBsZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZm9jdXNSaXBwbGUsXG4gICAgICBmb2N1c1Zpc2libGVDbGFzc05hbWUgPSBwcm9wcy5mb2N1c1Zpc2libGVDbGFzc05hbWUsXG4gICAgICBvbkJsdXIgPSBwcm9wcy5vbkJsdXIsXG4gICAgICBvbkNsaWNrID0gcHJvcHMub25DbGljayxcbiAgICAgIG9uRm9jdXMgPSBwcm9wcy5vbkZvY3VzLFxuICAgICAgb25Gb2N1c1Zpc2libGUgPSBwcm9wcy5vbkZvY3VzVmlzaWJsZSxcbiAgICAgIG9uS2V5RG93biA9IHByb3BzLm9uS2V5RG93bixcbiAgICAgIG9uS2V5VXAgPSBwcm9wcy5vbktleVVwLFxuICAgICAgb25Nb3VzZURvd24gPSBwcm9wcy5vbk1vdXNlRG93bixcbiAgICAgIG9uTW91c2VMZWF2ZSA9IHByb3BzLm9uTW91c2VMZWF2ZSxcbiAgICAgIG9uTW91c2VVcCA9IHByb3BzLm9uTW91c2VVcCxcbiAgICAgIG9uVG91Y2hFbmQgPSBwcm9wcy5vblRvdWNoRW5kLFxuICAgICAgb25Ub3VjaE1vdmUgPSBwcm9wcy5vblRvdWNoTW92ZSxcbiAgICAgIG9uVG91Y2hTdGFydCA9IHByb3BzLm9uVG91Y2hTdGFydCxcbiAgICAgIG9uRHJhZ0xlYXZlID0gcHJvcHMub25EcmFnTGVhdmUsXG4gICAgICBfcHJvcHMkdGFiSW5kZXggPSBwcm9wcy50YWJJbmRleCxcbiAgICAgIHRhYkluZGV4ID0gX3Byb3BzJHRhYkluZGV4ID09PSB2b2lkIDAgPyAwIDogX3Byb3BzJHRhYkluZGV4LFxuICAgICAgVG91Y2hSaXBwbGVQcm9wcyA9IHByb3BzLlRvdWNoUmlwcGxlUHJvcHMsXG4gICAgICBfcHJvcHMkdHlwZSA9IHByb3BzLnR5cGUsXG4gICAgICB0eXBlID0gX3Byb3BzJHR5cGUgPT09IHZvaWQgMCA/ICdidXR0b24nIDogX3Byb3BzJHR5cGUsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYWN0aW9uXCIsIFwiYnV0dG9uUmVmXCIsIFwiY2VudGVyUmlwcGxlXCIsIFwiY2hpbGRyZW5cIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29tcG9uZW50XCIsIFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlUmlwcGxlXCIsIFwiZGlzYWJsZVRvdWNoUmlwcGxlXCIsIFwiZm9jdXNSaXBwbGVcIiwgXCJmb2N1c1Zpc2libGVDbGFzc05hbWVcIiwgXCJvbkJsdXJcIiwgXCJvbkNsaWNrXCIsIFwib25Gb2N1c1wiLCBcIm9uRm9jdXNWaXNpYmxlXCIsIFwib25LZXlEb3duXCIsIFwib25LZXlVcFwiLCBcIm9uTW91c2VEb3duXCIsIFwib25Nb3VzZUxlYXZlXCIsIFwib25Nb3VzZVVwXCIsIFwib25Ub3VjaEVuZFwiLCBcIm9uVG91Y2hNb3ZlXCIsIFwib25Ub3VjaFN0YXJ0XCIsIFwib25EcmFnTGVhdmVcIiwgXCJ0YWJJbmRleFwiLCBcIlRvdWNoUmlwcGxlUHJvcHNcIiwgXCJ0eXBlXCJdKTtcblxuICB2YXIgYnV0dG9uUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuXG4gIGZ1bmN0aW9uIGdldEJ1dHRvbk5vZGUoKSB7XG4gICAgLy8gI1N0cmljdE1vZGUgcmVhZHlcbiAgICByZXR1cm4gUmVhY3RET00uZmluZERPTU5vZGUoYnV0dG9uUmVmLmN1cnJlbnQpO1xuICB9XG5cbiAgdmFyIHJpcHBsZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgZm9jdXNWaXNpYmxlID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgc2V0Rm9jdXNWaXNpYmxlID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIGlmIChkaXNhYmxlZCAmJiBmb2N1c1Zpc2libGUpIHtcbiAgICBzZXRGb2N1c1Zpc2libGUoZmFsc2UpO1xuICB9XG5cbiAgdmFyIF91c2VJc0ZvY3VzVmlzaWJsZSA9IHVzZUlzRm9jdXNWaXNpYmxlKCksXG4gICAgICBpc0ZvY3VzVmlzaWJsZSA9IF91c2VJc0ZvY3VzVmlzaWJsZS5pc0ZvY3VzVmlzaWJsZSxcbiAgICAgIG9uQmx1clZpc2libGUgPSBfdXNlSXNGb2N1c1Zpc2libGUub25CbHVyVmlzaWJsZSxcbiAgICAgIGZvY3VzVmlzaWJsZVJlZiA9IF91c2VJc0ZvY3VzVmlzaWJsZS5yZWY7XG5cbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShhY3Rpb24sIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9jdXNWaXNpYmxlOiBmdW5jdGlvbiBmb2N1c1Zpc2libGUoKSB7XG4gICAgICAgIHNldEZvY3VzVmlzaWJsZSh0cnVlKTtcbiAgICAgICAgYnV0dG9uUmVmLmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGZvY3VzVmlzaWJsZSAmJiBmb2N1c1JpcHBsZSAmJiAhZGlzYWJsZVJpcHBsZSkge1xuICAgICAgcmlwcGxlUmVmLmN1cnJlbnQucHVsc2F0ZSgpO1xuICAgIH1cbiAgfSwgW2Rpc2FibGVSaXBwbGUsIGZvY3VzUmlwcGxlLCBmb2N1c1Zpc2libGVdKTtcblxuICBmdW5jdGlvbiB1c2VSaXBwbGVIYW5kbGVyKHJpcHBsZUFjdGlvbiwgZXZlbnRDYWxsYmFjaykge1xuICAgIHZhciBza2lwUmlwcGxlQWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBkaXNhYmxlVG91Y2hSaXBwbGU7XG4gICAgcmV0dXJuIHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnRDYWxsYmFjaykge1xuICAgICAgICBldmVudENhbGxiYWNrKGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlnbm9yZSA9IHNraXBSaXBwbGVBY3Rpb247XG5cbiAgICAgIGlmICghaWdub3JlICYmIHJpcHBsZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJpcHBsZVJlZi5jdXJyZW50W3JpcHBsZUFjdGlvbl0oZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYW5kbGVNb3VzZURvd24gPSB1c2VSaXBwbGVIYW5kbGVyKCdzdGFydCcsIG9uTW91c2VEb3duKTtcbiAgdmFyIGhhbmRsZURyYWdMZWF2ZSA9IHVzZVJpcHBsZUhhbmRsZXIoJ3N0b3AnLCBvbkRyYWdMZWF2ZSk7XG4gIHZhciBoYW5kbGVNb3VzZVVwID0gdXNlUmlwcGxlSGFuZGxlcignc3RvcCcsIG9uTW91c2VVcCk7XG4gIHZhciBoYW5kbGVNb3VzZUxlYXZlID0gdXNlUmlwcGxlSGFuZGxlcignc3RvcCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChmb2N1c1Zpc2libGUpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgaWYgKG9uTW91c2VMZWF2ZSkge1xuICAgICAgb25Nb3VzZUxlYXZlKGV2ZW50KTtcbiAgICB9XG4gIH0pO1xuICB2YXIgaGFuZGxlVG91Y2hTdGFydCA9IHVzZVJpcHBsZUhhbmRsZXIoJ3N0YXJ0Jywgb25Ub3VjaFN0YXJ0KTtcbiAgdmFyIGhhbmRsZVRvdWNoRW5kID0gdXNlUmlwcGxlSGFuZGxlcignc3RvcCcsIG9uVG91Y2hFbmQpO1xuICB2YXIgaGFuZGxlVG91Y2hNb3ZlID0gdXNlUmlwcGxlSGFuZGxlcignc3RvcCcsIG9uVG91Y2hNb3ZlKTtcbiAgdmFyIGhhbmRsZUJsdXIgPSB1c2VSaXBwbGVIYW5kbGVyKCdzdG9wJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGZvY3VzVmlzaWJsZSkge1xuICAgICAgb25CbHVyVmlzaWJsZShldmVudCk7XG4gICAgICBzZXRGb2N1c1Zpc2libGUoZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChvbkJsdXIpIHtcbiAgICAgIG9uQmx1cihldmVudCk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG4gIHZhciBoYW5kbGVGb2N1cyA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gRml4IGZvciBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzc3NjlcbiAgICBpZiAoIWJ1dHRvblJlZi5jdXJyZW50KSB7XG4gICAgICBidXR0b25SZWYuY3VycmVudCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKGlzRm9jdXNWaXNpYmxlKGV2ZW50KSkge1xuICAgICAgc2V0Rm9jdXNWaXNpYmxlKHRydWUpO1xuXG4gICAgICBpZiAob25Gb2N1c1Zpc2libGUpIHtcbiAgICAgICAgb25Gb2N1c1Zpc2libGUoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvbkZvY3VzKSB7XG4gICAgICBvbkZvY3VzKGV2ZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBpc05vbk5hdGl2ZUJ1dHRvbiA9IGZ1bmN0aW9uIGlzTm9uTmF0aXZlQnV0dG9uKCkge1xuICAgIHZhciBidXR0b24gPSBnZXRCdXR0b25Ob2RlKCk7XG4gICAgcmV0dXJuIGNvbXBvbmVudCAmJiBjb21wb25lbnQgIT09ICdidXR0b24nICYmICEoYnV0dG9uLnRhZ05hbWUgPT09ICdBJyAmJiBidXR0b24uaHJlZik7XG4gIH07XG4gIC8qKlxuICAgKiBJRSAxMSBzaGltIGZvciBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9yZXBlYXRcbiAgICovXG5cblxuICB2YXIga2V5ZG93blJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIHZhciBoYW5kbGVLZXlEb3duID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBDaGVjayBpZiBrZXkgaXMgYWxyZWFkeSBkb3duIHRvIGF2b2lkIHJlcGVhdHMgYmVpbmcgY291bnRlZCBhcyBtdWx0aXBsZSBhY3RpdmF0aW9uc1xuICAgIGlmIChmb2N1c1JpcHBsZSAmJiAha2V5ZG93blJlZi5jdXJyZW50ICYmIGZvY3VzVmlzaWJsZSAmJiByaXBwbGVSZWYuY3VycmVudCAmJiBldmVudC5rZXkgPT09ICcgJykge1xuICAgICAga2V5ZG93blJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGV2ZW50LnBlcnNpc3QoKTtcbiAgICAgIHJpcHBsZVJlZi5jdXJyZW50LnN0b3AoZXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmlwcGxlUmVmLmN1cnJlbnQuc3RhcnQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gZXZlbnQuY3VycmVudFRhcmdldCAmJiBpc05vbk5hdGl2ZUJ1dHRvbigpICYmIGV2ZW50LmtleSA9PT0gJyAnKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGlmIChvbktleURvd24pIHtcbiAgICAgIG9uS2V5RG93bihldmVudCk7XG4gICAgfSAvLyBLZXlib2FyZCBhY2Nlc3NpYmlsaXR5IGZvciBub24gaW50ZXJhY3RpdmUgZWxlbWVudHNcblxuXG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gZXZlbnQuY3VycmVudFRhcmdldCAmJiBpc05vbk5hdGl2ZUJ1dHRvbigpICYmIGV2ZW50LmtleSA9PT0gJ0VudGVyJyAmJiAhZGlzYWJsZWQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBoYW5kbGVLZXlVcCA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gY2FsbGluZyBwcmV2ZW50RGVmYXVsdCBpbiBrZXlVcCBvbiBhIDxidXR0b24+IHdpbGwgbm90IGRpc3BhdGNoIGEgY2xpY2sgZXZlbnQgaWYgU3BhY2UgaXMgcHJlc3NlZFxuICAgIC8vIGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9idXR0b24ta2V5dXAtcHJldmVudGRlZmF1bHQtZG43ZjBcbiAgICBpZiAoZm9jdXNSaXBwbGUgJiYgZXZlbnQua2V5ID09PSAnICcgJiYgcmlwcGxlUmVmLmN1cnJlbnQgJiYgZm9jdXNWaXNpYmxlICYmICFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICBrZXlkb3duUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGV2ZW50LnBlcnNpc3QoKTtcbiAgICAgIHJpcHBsZVJlZi5jdXJyZW50LnN0b3AoZXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmlwcGxlUmVmLmN1cnJlbnQucHVsc2F0ZShldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob25LZXlVcCkge1xuICAgICAgb25LZXlVcChldmVudCk7XG4gICAgfSAvLyBLZXlib2FyZCBhY2Nlc3NpYmlsaXR5IGZvciBub24gaW50ZXJhY3RpdmUgZWxlbWVudHNcblxuXG4gICAgaWYgKG9uQ2xpY2sgJiYgZXZlbnQudGFyZ2V0ID09PSBldmVudC5jdXJyZW50VGFyZ2V0ICYmIGlzTm9uTmF0aXZlQnV0dG9uKCkgJiYgZXZlbnQua2V5ID09PSAnICcgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIG9uQ2xpY2soZXZlbnQpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBDb21wb25lbnRQcm9wID0gY29tcG9uZW50O1xuXG4gIGlmIChDb21wb25lbnRQcm9wID09PSAnYnV0dG9uJyAmJiBvdGhlci5ocmVmKSB7XG4gICAgQ29tcG9uZW50UHJvcCA9ICdhJztcbiAgfVxuXG4gIHZhciBidXR0b25Qcm9wcyA9IHt9O1xuXG4gIGlmIChDb21wb25lbnRQcm9wID09PSAnYnV0dG9uJykge1xuICAgIGJ1dHRvblByb3BzLnR5cGUgPSB0eXBlO1xuICAgIGJ1dHRvblByb3BzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKENvbXBvbmVudFByb3AgIT09ICdhJyB8fCAhb3RoZXIuaHJlZikge1xuICAgICAgYnV0dG9uUHJvcHMucm9sZSA9ICdidXR0b24nO1xuICAgIH1cblxuICAgIGJ1dHRvblByb3BzWydhcmlhLWRpc2FibGVkJ10gPSBkaXNhYmxlZDtcbiAgfVxuXG4gIHZhciBoYW5kbGVVc2VyUmVmID0gdXNlRm9ya1JlZihidXR0b25SZWZQcm9wLCByZWYpO1xuICB2YXIgaGFuZGxlT3duUmVmID0gdXNlRm9ya1JlZihmb2N1c1Zpc2libGVSZWYsIGJ1dHRvblJlZik7XG4gIHZhciBoYW5kbGVSZWYgPSB1c2VGb3JrUmVmKGhhbmRsZVVzZXJSZWYsIGhhbmRsZU93blJlZik7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTIgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgICBtb3VudGVkU3RhdGUgPSBfUmVhY3QkdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0TW91bnRlZFN0YXRlID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHNldE1vdW50ZWRTdGF0ZSh0cnVlKTtcbiAgfSwgW10pO1xuICB2YXIgZW5hYmxlVG91Y2hSaXBwbGUgPSBtb3VudGVkU3RhdGUgJiYgIWRpc2FibGVSaXBwbGUgJiYgIWRpc2FibGVkO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChlbmFibGVUb3VjaFJpcHBsZSAmJiAhcmlwcGxlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihbJ01hdGVyaWFsLVVJOiBUaGUgYGNvbXBvbmVudGAgcHJvcCBwcm92aWRlZCB0byBCdXR0b25CYXNlIGlzIGludmFsaWQuJywgJ1BsZWFzZSBtYWtlIHN1cmUgdGhlIGNoaWxkcmVuIHByb3AgaXMgcmVuZGVyZWQgaW4gdGhpcyBjdXN0b20gY29tcG9uZW50LiddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9LCBbZW5hYmxlVG91Y2hSaXBwbGVdKTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnRQcm9wLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lLCBmb2N1c1Zpc2libGUgJiYgW2NsYXNzZXMuZm9jdXNWaXNpYmxlLCBmb2N1c1Zpc2libGVDbGFzc05hbWVdLCBkaXNhYmxlZCAmJiBjbGFzc2VzLmRpc2FibGVkKSxcbiAgICBvbkJsdXI6IGhhbmRsZUJsdXIsXG4gICAgb25DbGljazogb25DbGljayxcbiAgICBvbkZvY3VzOiBoYW5kbGVGb2N1cyxcbiAgICBvbktleURvd246IGhhbmRsZUtleURvd24sXG4gICAgb25LZXlVcDogaGFuZGxlS2V5VXAsXG4gICAgb25Nb3VzZURvd246IGhhbmRsZU1vdXNlRG93bixcbiAgICBvbk1vdXNlTGVhdmU6IGhhbmRsZU1vdXNlTGVhdmUsXG4gICAgb25Nb3VzZVVwOiBoYW5kbGVNb3VzZVVwLFxuICAgIG9uRHJhZ0xlYXZlOiBoYW5kbGVEcmFnTGVhdmUsXG4gICAgb25Ub3VjaEVuZDogaGFuZGxlVG91Y2hFbmQsXG4gICAgb25Ub3VjaE1vdmU6IGhhbmRsZVRvdWNoTW92ZSxcbiAgICBvblRvdWNoU3RhcnQ6IGhhbmRsZVRvdWNoU3RhcnQsXG4gICAgcmVmOiBoYW5kbGVSZWYsXG4gICAgdGFiSW5kZXg6IGRpc2FibGVkID8gLTEgOiB0YWJJbmRleFxuICB9LCBidXR0b25Qcm9wcywgb3RoZXIpLCBjaGlsZHJlbiwgZW5hYmxlVG91Y2hSaXBwbGUgP1xuICAvKiNfX1BVUkVfXyovXG5cbiAgLyogVG91Y2hSaXBwbGUgaXMgb25seSBuZWVkZWQgY2xpZW50LXNpZGUsIHgyIGJvb3N0IG9uIHRoZSBzZXJ2ZXIuICovXG4gIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG91Y2hSaXBwbGUsIF9leHRlbmRzKHtcbiAgICByZWY6IHJpcHBsZVJlZixcbiAgICBjZW50ZXI6IGNlbnRlclJpcHBsZVxuICB9LCBUb3VjaFJpcHBsZVByb3BzKSkgOiBudWxsKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gQnV0dG9uQmFzZS5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBBIHJlZiBmb3IgaW1wZXJhdGl2ZSBhY3Rpb25zLlxuICAgKiBJdCBjdXJyZW50bHkgb25seSBzdXBwb3J0cyBgZm9jdXNWaXNpYmxlKClgIGFjdGlvbi5cbiAgICovXG4gIGFjdGlvbjogcmVmVHlwZSxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKlxuICAgKiBVc2UgdGhhdCBwcm9wIHRvIHBhc3MgYSByZWYgdG8gdGhlIG5hdGl2ZSBidXR0b24gY29tcG9uZW50LlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYHJlZmAgaW5zdGVhZC5cbiAgICovXG4gIGJ1dHRvblJlZjogZGVwcmVjYXRlZFByb3BUeXBlKHJlZlR5cGUsICdVc2UgYHJlZmAgaW5zdGVhZC4nKSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgcmlwcGxlcyB3aWxsIGJlIGNlbnRlcmVkLlxuICAgKiBUaGV5IHdvbid0IHN0YXJ0IGF0IHRoZSBjdXJzb3IgaW50ZXJhY3Rpb24gcG9zaXRpb24uXG4gICAqL1xuICBjZW50ZXJSaXBwbGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgcm9vdCBub2RlLlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgY29tcG9uZW50OiBlbGVtZW50VHlwZUFjY2VwdGluZ1JlZixcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYmFzZSBidXR0b24gd2lsbCBiZSBkaXNhYmxlZC5cbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgcmlwcGxlIGVmZmVjdCB3aWxsIGJlIGRpc2FibGVkLlxuICAgKlxuICAgKiDimqDvuI8gV2l0aG91dCBhIHJpcHBsZSB0aGVyZSBpcyBubyBzdHlsaW5nIGZvciA6Zm9jdXMtdmlzaWJsZSBieSBkZWZhdWx0LiBCZSBzdXJlXG4gICAqIHRvIGhpZ2hsaWdodCB0aGUgZWxlbWVudCBieSBhcHBseWluZyBzZXBhcmF0ZSBzdHlsZXMgd2l0aCB0aGUgYGZvY3VzVmlzaWJsZUNsYXNzTmFtZWAuXG4gICAqL1xuICBkaXNhYmxlUmlwcGxlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgdG91Y2ggcmlwcGxlIGVmZmVjdCB3aWxsIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgZGlzYWJsZVRvdWNoUmlwcGxlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYmFzZSBidXR0b24gd2lsbCBoYXZlIGEga2V5Ym9hcmQgZm9jdXMgcmlwcGxlLlxuICAgKi9cbiAgZm9jdXNSaXBwbGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGlzIHByb3AgY2FuIGhlbHAgaWRlbnRpZnkgd2hpY2ggZWxlbWVudCBoYXMga2V5Ym9hcmQgZm9jdXMuXG4gICAqIFRoZSBjbGFzcyBuYW1lIHdpbGwgYmUgYXBwbGllZCB3aGVuIHRoZSBlbGVtZW50IGdhaW5zIHRoZSBmb2N1cyB0aHJvdWdoIGtleWJvYXJkIGludGVyYWN0aW9uLlxuICAgKiBJdCdzIGEgcG9seWZpbGwgZm9yIHRoZSBbQ1NTIDpmb2N1cy12aXNpYmxlIHNlbGVjdG9yXShodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvc2VsZWN0b3JzLTQvI3RoZS1mb2N1cy12aXNpYmxlLXBzZXVkbykuXG4gICAqIFRoZSByYXRpb25hbGUgZm9yIHVzaW5nIHRoaXMgZmVhdHVyZSBbaXMgZXhwbGFpbmVkIGhlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL2ZvY3VzLXZpc2libGUvYmxvYi9tYXN0ZXIvZXhwbGFpbmVyLm1kKS5cbiAgICogQSBbcG9seWZpbGwgY2FuIGJlIHVzZWRdKGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL2ZvY3VzLXZpc2libGUpIHRvIGFwcGx5IGEgYGZvY3VzLXZpc2libGVgIGNsYXNzIHRvIG90aGVyIGNvbXBvbmVudHNcbiAgICogaWYgbmVlZGVkLlxuICAgKi9cbiAgZm9jdXNWaXNpYmxlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBocmVmOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25EcmFnTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkZvY3VzOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGZvY3VzZWQgd2l0aCBhIGtleWJvYXJkLlxuICAgKiBXZSB0cmlnZ2VyIGEgYG9uRm9jdXNgIGNhbGxiYWNrIHRvby5cbiAgICovXG4gIG9uRm9jdXNWaXNpYmxlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25LZXlEb3duOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25LZXlVcDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uTW91c2VEb3duOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Nb3VzZVVwOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Ub3VjaEVuZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uVG91Y2hNb3ZlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Ub3VjaFN0YXJ0OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgdGFiSW5kZXg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogUHJvcHMgYXBwbGllZCB0byB0aGUgYFRvdWNoUmlwcGxlYCBlbGVtZW50LlxuICAgKi9cbiAgVG91Y2hSaXBwbGVQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgdHlwZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9uZU9mKFsnYnV0dG9uJywgJ3Jlc2V0JywgJ3N1Ym1pdCddKSwgUHJvcFR5cGVzLnN0cmluZ10pXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUJ1dHRvbkJhc2UnXG59KShCdXR0b25CYXNlKTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyBjaGFpblByb3BUeXBlcyB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5pbXBvcnQgeyBhbHBoYSB9IGZyb20gJy4uL3N0eWxlcy9jb2xvck1hbmlwdWxhdG9yJztcbmltcG9ydCBCdXR0b25CYXNlIGZyb20gJy4uL0J1dHRvbkJhc2UnO1xuaW1wb3J0IGNhcGl0YWxpemUgZnJvbSAnLi4vdXRpbHMvY2FwaXRhbGl6ZSc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gICAgcm9vdDoge1xuICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgIGZsZXg6ICcwIDAgYXV0bycsXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5weFRvUmVtKDI0KSxcbiAgICAgIHBhZGRpbmc6IDEyLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcbiAgICAgIG92ZXJmbG93OiAndmlzaWJsZScsXG4gICAgICAvLyBFeHBsaWNpdGx5IHNldCB0aGUgZGVmYXVsdCB2YWx1ZSB0byBzb2x2ZSBhIGJ1ZyBvbiBJRSAxMS5cbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmFjdGlvbi5hY3RpdmUsXG4gICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ2JhY2tncm91bmQtY29sb3InLCB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVzdFxuICAgICAgfSksXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBhbHBoYSh0aGVtZS5wYWxldHRlLmFjdGlvbi5hY3RpdmUsIHRoZW1lLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSksXG4gICAgICAgIC8vIFJlc2V0IG9uIHRvdWNoIGRldmljZXMsIGl0IGRvZXNuJ3QgYWRkIHNwZWNpZmljaXR5XG4gICAgICAgICdAbWVkaWEgKGhvdmVyOiBub25lKSc6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICcmJGRpc2FibGVkJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmFjdGlvbi5kaXNhYmxlZFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBlZGdlPVwic3RhcnRcImAuICovXG4gICAgZWRnZVN0YXJ0OiB7XG4gICAgICBtYXJnaW5MZWZ0OiAtMTIsXG4gICAgICAnJHNpemVTbWFsbCYnOiB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IC0zXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGVkZ2U9XCJlbmRcImAuICovXG4gICAgZWRnZUVuZDoge1xuICAgICAgbWFyZ2luUmlnaHQ6IC0xMixcbiAgICAgICckc2l6ZVNtYWxsJic6IHtcbiAgICAgICAgbWFyZ2luUmlnaHQ6IC0zXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbG9yPVwiaW5oZXJpdFwiYC4gKi9cbiAgICBjb2xvckluaGVyaXQ6IHtcbiAgICAgIGNvbG9yOiAnaW5oZXJpdCdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgY29sb3I9XCJwcmltYXJ5XCJgLiAqL1xuICAgIGNvbG9yUHJpbWFyeToge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluLFxuICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYWxwaGEodGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW4sIHRoZW1lLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSksXG4gICAgICAgIC8vIFJlc2V0IG9uIHRvdWNoIGRldmljZXMsIGl0IGRvZXNuJ3QgYWRkIHNwZWNpZmljaXR5XG4gICAgICAgICdAbWVkaWEgKGhvdmVyOiBub25lKSc6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBjb2xvcj1cInNlY29uZGFyeVwiYC4gKi9cbiAgICBjb2xvclNlY29uZGFyeToge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW4sXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBhbHBoYSh0aGVtZS5wYWxldHRlLnNlY29uZGFyeS5tYWluLCB0aGVtZS5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHkpLFxuICAgICAgICAvLyBSZXNldCBvbiB0b3VjaCBkZXZpY2VzLCBpdCBkb2Vzbid0IGFkZCBzcGVjaWZpY2l0eVxuICAgICAgICAnQG1lZGlhIChob3Zlcjogbm9uZSknOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZGlzYWJsZWQ9e3RydWV9YC4gKi9cbiAgICBkaXNhYmxlZDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBzaXplPVwic21hbGxcImAuICovXG4gICAgc2l6ZVNtYWxsOiB7XG4gICAgICBwYWRkaW5nOiAzLFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkucHhUb1JlbSgxOClcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNoaWxkcmVuIGNvbnRhaW5lciBlbGVtZW50LiAqL1xuICAgIGxhYmVsOiB7XG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgYWxpZ25JdGVtczogJ2luaGVyaXQnLFxuICAgICAganVzdGlmeUNvbnRlbnQ6ICdpbmhlcml0J1xuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIFJlZmVyIHRvIHRoZSBbSWNvbnNdKC9jb21wb25lbnRzL2ljb25zLykgc2VjdGlvbiBvZiB0aGUgZG9jdW1lbnRhdGlvblxuICogcmVnYXJkaW5nIHRoZSBhdmFpbGFibGUgaWNvbiBvcHRpb25zLlxuICovXG5cbnZhciBJY29uQnV0dG9uID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gSWNvbkJ1dHRvbihwcm9wcywgcmVmKSB7XG4gIHZhciBfcHJvcHMkZWRnZSA9IHByb3BzLmVkZ2UsXG4gICAgICBlZGdlID0gX3Byb3BzJGVkZ2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGVkZ2UsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkY29sb3IgPSBwcm9wcy5jb2xvcixcbiAgICAgIGNvbG9yID0gX3Byb3BzJGNvbG9yID09PSB2b2lkIDAgPyAnZGVmYXVsdCcgOiBfcHJvcHMkY29sb3IsXG4gICAgICBfcHJvcHMkZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGRpc2FibGVkID0gX3Byb3BzJGRpc2FibGVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlZCxcbiAgICAgIF9wcm9wcyRkaXNhYmxlRm9jdXNSaSA9IHByb3BzLmRpc2FibGVGb2N1c1JpcHBsZSxcbiAgICAgIGRpc2FibGVGb2N1c1JpcHBsZSA9IF9wcm9wcyRkaXNhYmxlRm9jdXNSaSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZUZvY3VzUmksXG4gICAgICBfcHJvcHMkc2l6ZSA9IHByb3BzLnNpemUsXG4gICAgICBzaXplID0gX3Byb3BzJHNpemUgPT09IHZvaWQgMCA/ICdtZWRpdW0nIDogX3Byb3BzJHNpemUsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiZWRnZVwiLCBcImNoaWxkcmVuXCIsIFwiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcImNvbG9yXCIsIFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlRm9jdXNSaXBwbGVcIiwgXCJzaXplXCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uQmFzZSwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSwgY29sb3IgIT09ICdkZWZhdWx0JyAmJiBjbGFzc2VzW1wiY29sb3JcIi5jb25jYXQoY2FwaXRhbGl6ZShjb2xvcikpXSwgZGlzYWJsZWQgJiYgY2xhc3Nlcy5kaXNhYmxlZCwgc2l6ZSA9PT0gXCJzbWFsbFwiICYmIGNsYXNzZXNbXCJzaXplXCIuY29uY2F0KGNhcGl0YWxpemUoc2l6ZSkpXSwge1xuICAgICAgJ3N0YXJ0JzogY2xhc3Nlcy5lZGdlU3RhcnQsXG4gICAgICAnZW5kJzogY2xhc3Nlcy5lZGdlRW5kXG4gICAgfVtlZGdlXSksXG4gICAgY2VudGVyUmlwcGxlOiB0cnVlLFxuICAgIGZvY3VzUmlwcGxlOiAhZGlzYWJsZUZvY3VzUmlwcGxlLFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlciksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzLmxhYmVsXG4gIH0sIGNoaWxkcmVuKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IEljb25CdXR0b24ucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogVGhlIGljb24gZWxlbWVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBjaGFpblByb3BUeXBlcyhQcm9wVHlwZXMubm9kZSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIGZvdW5kID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShwcm9wcy5jaGlsZHJlbikuc29tZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpICYmIGNoaWxkLnByb3BzLm9uQ2xpY2s7XG4gICAgfSk7XG5cbiAgICBpZiAoZm91bmQpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoWydNYXRlcmlhbC1VSTogWW91IGFyZSBwcm92aWRpbmcgYW4gb25DbGljayBldmVudCBsaXN0ZW5lciAnICsgJ3RvIGEgY2hpbGQgb2YgYSBidXR0b24gZWxlbWVudC4nLCAnRmlyZWZveCB3aWxsIG5ldmVyIHRyaWdnZXIgdGhlIGV2ZW50LicsICdZb3Ugc2hvdWxkIG1vdmUgdGhlIG9uQ2xpY2sgbGlzdGVuZXIgdG8gdGhlIHBhcmVudCBidXR0b24gZWxlbWVudC4nLCAnaHR0cHM6Ly9naXRodWIuY29tL211aS1vcmcvbWF0ZXJpYWwtdWkvaXNzdWVzLzEzOTU3J10uam9pbignXFxuJykpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9KSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIHRob3NlIHRoZW1lIGNvbG9ycyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ2RlZmF1bHQnLCAnaW5oZXJpdCcsICdwcmltYXJ5JywgJ3NlY29uZGFyeSddKSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYnV0dG9uIHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlICBrZXlib2FyZCBmb2N1cyByaXBwbGUgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICovXG4gIGRpc2FibGVGb2N1c1JpcHBsZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHJpcHBsZSBlZmZlY3Qgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICovXG4gIGRpc2FibGVSaXBwbGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBnaXZlbiwgdXNlcyBhIG5lZ2F0aXZlIG1hcmdpbiB0byBjb3VudGVyYWN0IHRoZSBwYWRkaW5nIG9uIG9uZVxuICAgKiBzaWRlICh0aGlzIGlzIG9mdGVuIGhlbHBmdWwgZm9yIGFsaWduaW5nIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gICAqIHNpZGUgb2YgdGhlIGljb24gd2l0aCBjb250ZW50IGFib3ZlIG9yIGJlbG93LCB3aXRob3V0IHJ1aW5pbmcgdGhlIGJvcmRlclxuICAgKiBzaXplIGFuZCBzaGFwZSkuXG4gICAqL1xuICBlZGdlOiBQcm9wVHlwZXMub25lT2YoWydzdGFydCcsICdlbmQnLCBmYWxzZV0pLFxuXG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgYnV0dG9uLlxuICAgKiBgc21hbGxgIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGRlbnNlIGJ1dHRvbiBzdHlsaW5nLlxuICAgKi9cbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnc21hbGwnLCAnbWVkaXVtJ10pXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUljb25CdXR0b24nXG59KShJY29uQnV0dG9uKTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyBjaGFpblByb3BUeXBlcyB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5pbXBvcnQgY2FwaXRhbGl6ZSBmcm9tICcuLi91dGlscy9jYXBpdGFsaXplJztcbmV4cG9ydCB2YXIgc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKHRoZW1lKSB7XG4gIHJldHVybiB7XG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgICByb290OiB7XG4gICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICB3aWR0aDogJzFlbScsXG4gICAgICBoZWlnaHQ6ICcxZW0nLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICBmaWxsOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5weFRvUmVtKDI0KSxcbiAgICAgIHRyYW5zaXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgnZmlsbCcsIHtcbiAgICAgICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXJcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbG9yPVwicHJpbWFyeVwiYC4gKi9cbiAgICBjb2xvclByaW1hcnk6IHtcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnByaW1hcnkubWFpblxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBjb2xvcj1cInNlY29uZGFyeVwiYC4gKi9cbiAgICBjb2xvclNlY29uZGFyeToge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW5cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgY29sb3I9XCJhY3Rpb25cImAuICovXG4gICAgY29sb3JBY3Rpb246IHtcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmFjdGlvbi5hY3RpdmVcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgY29sb3I9XCJlcnJvclwiYC4gKi9cbiAgICBjb2xvckVycm9yOiB7XG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5lcnJvci5tYWluXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbG9yPVwiZGlzYWJsZWRcImAuICovXG4gICAgY29sb3JEaXNhYmxlZDoge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGZvbnRTaXplPVwiaW5oZXJpdFwiYC4gKi9cbiAgICBmb250U2l6ZUluaGVyaXQ6IHtcbiAgICAgIGZvbnRTaXplOiAnaW5oZXJpdCdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZm9udFNpemU9XCJzbWFsbFwiYC4gKi9cbiAgICBmb250U2l6ZVNtYWxsOiB7XG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5weFRvUmVtKDIwKVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBmb250U2l6ZT1cImxhcmdlXCJgLiAqL1xuICAgIGZvbnRTaXplTGFyZ2U6IHtcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LnB4VG9SZW0oMzUpXG4gICAgfVxuICB9O1xufTtcbnZhciBTdmdJY29uID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gU3ZnSWNvbihwcm9wcywgcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkY29sb3IgPSBwcm9wcy5jb2xvcixcbiAgICAgIGNvbG9yID0gX3Byb3BzJGNvbG9yID09PSB2b2lkIDAgPyAnaW5oZXJpdCcgOiBfcHJvcHMkY29sb3IsXG4gICAgICBfcHJvcHMkY29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50LFxuICAgICAgQ29tcG9uZW50ID0gX3Byb3BzJGNvbXBvbmVudCA9PT0gdm9pZCAwID8gJ3N2ZycgOiBfcHJvcHMkY29tcG9uZW50LFxuICAgICAgX3Byb3BzJGZvbnRTaXplID0gcHJvcHMuZm9udFNpemUsXG4gICAgICBmb250U2l6ZSA9IF9wcm9wcyRmb250U2l6ZSA9PT0gdm9pZCAwID8gJ21lZGl1bScgOiBfcHJvcHMkZm9udFNpemUsXG4gICAgICBodG1sQ29sb3IgPSBwcm9wcy5odG1sQ29sb3IsXG4gICAgICB0aXRsZUFjY2VzcyA9IHByb3BzLnRpdGxlQWNjZXNzLFxuICAgICAgX3Byb3BzJHZpZXdCb3ggPSBwcm9wcy52aWV3Qm94LFxuICAgICAgdmlld0JveCA9IF9wcm9wcyR2aWV3Qm94ID09PSB2b2lkIDAgPyAnMCAwIDI0IDI0JyA6IF9wcm9wcyR2aWV3Qm94LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcImNvbG9yXCIsIFwiY29tcG9uZW50XCIsIFwiZm9udFNpemVcIiwgXCJodG1sQ29sb3JcIiwgXCJ0aXRsZUFjY2Vzc1wiLCBcInZpZXdCb3hcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUsIGNvbG9yICE9PSAnaW5oZXJpdCcgJiYgY2xhc3Nlc1tcImNvbG9yXCIuY29uY2F0KGNhcGl0YWxpemUoY29sb3IpKV0sIGZvbnRTaXplICE9PSAnZGVmYXVsdCcgJiYgZm9udFNpemUgIT09ICdtZWRpdW0nICYmIGNsYXNzZXNbXCJmb250U2l6ZVwiLmNvbmNhdChjYXBpdGFsaXplKGZvbnRTaXplKSldKSxcbiAgICBmb2N1c2FibGU6IFwiZmFsc2VcIixcbiAgICB2aWV3Qm94OiB2aWV3Qm94LFxuICAgIGNvbG9yOiBodG1sQ29sb3IsXG4gICAgXCJhcmlhLWhpZGRlblwiOiB0aXRsZUFjY2VzcyA/IHVuZGVmaW5lZCA6IHRydWUsXG4gICAgcm9sZTogdGl0bGVBY2Nlc3MgPyAnaW1nJyA6IHVuZGVmaW5lZCxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlciksIGNoaWxkcmVuLCB0aXRsZUFjY2VzcyA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwgbnVsbCwgdGl0bGVBY2Nlc3MpIDogbnVsbCk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFN2Z0ljb24ucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogTm9kZSBwYXNzZWQgaW50byB0aGUgU1ZHIGVsZW1lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2YgdGhlIGNvbXBvbmVudC4gSXQgc3VwcG9ydHMgdGhvc2UgdGhlbWUgY29sb3JzIHRoYXQgbWFrZSBzZW5zZSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqIFlvdSBjYW4gdXNlIHRoZSBgaHRtbENvbG9yYCBwcm9wIHRvIGFwcGx5IGEgY29sb3IgYXR0cmlidXRlIHRvIHRoZSBTVkcgZWxlbWVudC5cbiAgICovXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoWydhY3Rpb24nLCAnZGlzYWJsZWQnLCAnZXJyb3InLCAnaW5oZXJpdCcsICdwcmltYXJ5JywgJ3NlY29uZGFyeSddKSxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgcm9vdCBub2RlLlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgY29tcG9uZW50OiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAuZWxlbWVudFR5cGUsXG5cbiAgLyoqXG4gICAqIFRoZSBmb250U2l6ZSBhcHBsaWVkIHRvIHRoZSBpY29uLiBEZWZhdWx0cyB0byAyNHB4LCBidXQgY2FuIGJlIGNvbmZpZ3VyZSB0byBpbmhlcml0IGZvbnQgc2l6ZS5cbiAgICovXG4gIGZvbnRTaXplOiBjaGFpblByb3BUeXBlcyhQcm9wVHlwZXMub25lT2YoWydkZWZhdWx0JywgJ2luaGVyaXQnLCAnbGFyZ2UnLCAnbWVkaXVtJywgJ3NtYWxsJ10pLCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgZm9udFNpemUgPSBwcm9wcy5mb250U2l6ZTtcblxuICAgIGlmIChmb250U2l6ZSA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdGVyaWFsLVVJOiBgZm9udFNpemU9XCJkZWZhdWx0XCJgIGlzIGRlcHJlY2F0ZWQuIFVzZSBgZm9udFNpemU9XCJtZWRpdW1cImAgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSksXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBjb2xvciBhdHRyaWJ1dGUgdG8gdGhlIFNWRyBlbGVtZW50LlxuICAgKi9cbiAgaHRtbENvbG9yOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgc2hhcGUtcmVuZGVyaW5nIGF0dHJpYnV0ZS4gVGhlIGJlaGF2aW9yIG9mIHRoZSBkaWZmZXJlbnQgb3B0aW9ucyBpcyBkZXNjcmliZWQgb24gdGhlXG4gICAqIFtNRE4gV2ViIERvY3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc2hhcGUtcmVuZGVyaW5nKS5cbiAgICogSWYgeW91IGFyZSBoYXZpbmcgaXNzdWVzIHdpdGggYmx1cnJ5IGljb25zIHlvdSBzaG91bGQgaW52ZXN0aWdhdGUgdGhpcyBwcm9wZXJ0eS5cbiAgICovXG4gIHNoYXBlUmVuZGVyaW5nOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIGh1bWFuLXJlYWRhYmxlIHRpdGxlIGZvciB0aGUgZWxlbWVudCB0aGF0IGNvbnRhaW5zIGl0LlxuICAgKiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHLWFjY2Vzcy8jRXF1aXZhbGVudFxuICAgKi9cbiAgdGl0bGVBY2Nlc3M6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIEFsbG93cyB5b3UgdG8gcmVkZWZpbmUgd2hhdCB0aGUgY29vcmRpbmF0ZXMgd2l0aG91dCB1bml0cyBtZWFuIGluc2lkZSBhbiBTVkcgZWxlbWVudC5cbiAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBTVkcgZWxlbWVudCBpcyA1MDAgKHdpZHRoKSBieSAyMDAgKGhlaWdodCksXG4gICAqIGFuZCB5b3UgcGFzcyB2aWV3Qm94PVwiMCAwIDUwIDIwXCIsXG4gICAqIHRoaXMgbWVhbnMgdGhhdCB0aGUgY29vcmRpbmF0ZXMgaW5zaWRlIHRoZSBTVkcgd2lsbCBnbyBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgKDAsMClcbiAgICogdG8gYm90dG9tIHJpZ2h0ICg1MCwyMCkgYW5kIGVhY2ggdW5pdCB3aWxsIGJlIHdvcnRoIDEwcHguXG4gICAqL1xuICB2aWV3Qm94OiBQcm9wVHlwZXMuc3RyaW5nXG59IDogdm9pZCAwO1xuU3ZnSWNvbi5tdWlOYW1lID0gJ1N2Z0ljb24nO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aVN2Z0ljb24nXG59KShTdmdJY29uKTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgU3ZnSWNvbiBmcm9tICcuLi9TdmdJY29uJztcbi8qKlxuICogUHJpdmF0ZSBtb2R1bGUgcmVzZXJ2ZWQgZm9yIEBtYXRlcmlhbC11aS94IHBhY2thZ2VzLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVN2Z0ljb24ocGF0aCwgZGlzcGxheU5hbWUpIHtcbiAgdmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgcmVmKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFN2Z0ljb24sIF9leHRlbmRzKHtcbiAgICAgIHJlZjogcmVmXG4gICAgfSwgcHJvcHMpLCBwYXRoKTtcbiAgfTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIE5lZWQgdG8gc2V0IGBkaXNwbGF5TmFtZWAgb24gdGhlIGlubmVyIGNvbXBvbmVudCBmb3IgUmVhY3QubWVtby5cbiAgICAvLyBSZWFjdCBwcmlvciB0byAxNi4xNCBpZ25vcmVzIGBkaXNwbGF5TmFtZWAgb24gdGhlIHdyYXBwZXIuXG4gICAgQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gXCJcIi5jb25jYXQoZGlzcGxheU5hbWUsIFwiSWNvblwiKTtcbiAgfVxuXG4gIENvbXBvbmVudC5tdWlOYW1lID0gU3ZnSWNvbi5tdWlOYW1lO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oIC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKENvbXBvbmVudCkpO1xufSIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjcmVhdGVTdmdJY29uIGZyb20gJy4uLy4uL3V0aWxzL2NyZWF0ZVN2Z0ljb24nO1xuLyoqXG4gKiBAaWdub3JlIC0gaW50ZXJuYWwgY29tcG9uZW50LlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVN2Z0ljb24oIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gIGQ6IFwiTTEyIDJDNi40NyAyIDIgNi40NyAyIDEyczQuNDcgMTAgMTAgMTAgMTAtNC40NyAxMC0xMFMxNy41MyAyIDEyIDJ6bTUgMTMuNTlMMTUuNTkgMTcgMTIgMTMuNDEgOC40MSAxNyA3IDE1LjU5IDEwLjU5IDEyIDcgOC40MSA4LjQxIDcgMTIgMTAuNTkgMTUuNTkgNyAxNyA4LjQxIDEzLjQxIDEyIDE3IDE1LjU5elwiXG59KSwgJ0NhbmNlbCcpOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVuc3VwcG9ydGVkUHJvcChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwcm9wRnVsbE5hbWVTYWZlID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gIGlmICh0eXBlb2YgcHJvcHNbcHJvcE5hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJUaGUgcHJvcCBgXCIuY29uY2F0KHByb3BGdWxsTmFtZVNhZmUsIFwiYCBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgcmVtb3ZlIGl0LlwiKSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgQ2FuY2VsSWNvbiBmcm9tICcuLi9pbnRlcm5hbC9zdmctaWNvbnMvQ2FuY2VsJztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCB7IGVtcGhhc2l6ZSwgYWxwaGEgfSBmcm9tICcuLi9zdHlsZXMvY29sb3JNYW5pcHVsYXRvcic7XG5pbXBvcnQgdXNlRm9ya1JlZiBmcm9tICcuLi91dGlscy91c2VGb3JrUmVmJztcbmltcG9ydCB1bnN1cHBvcnRlZFByb3AgZnJvbSAnLi4vdXRpbHMvdW5zdXBwb3J0ZWRQcm9wJztcbmltcG9ydCBjYXBpdGFsaXplIGZyb20gJy4uL3V0aWxzL2NhcGl0YWxpemUnO1xuaW1wb3J0IEJ1dHRvbkJhc2UgZnJvbSAnLi4vQnV0dG9uQmFzZSc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICB2YXIgYmFja2dyb3VuZENvbG9yID0gdGhlbWUucGFsZXR0ZS50eXBlID09PSAnbGlnaHQnID8gdGhlbWUucGFsZXR0ZS5ncmV5WzMwMF0gOiB0aGVtZS5wYWxldHRlLmdyZXlbNzAwXTtcbiAgdmFyIGRlbGV0ZUljb25Db2xvciA9IGFscGhhKHRoZW1lLnBhbGV0dGUudGV4dC5wcmltYXJ5LCAwLjI2KTtcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IHtcbiAgICAgIGZvbnRGYW1pbHk6IHRoZW1lLnR5cG9ncmFwaHkuZm9udEZhbWlseSxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LnB4VG9SZW0oMTMpLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1mbGV4JyxcbiAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgaGVpZ2h0OiAzMixcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmdldENvbnRyYXN0VGV4dChiYWNrZ3JvdW5kQ29sb3IpLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBib3JkZXJSYWRpdXM6IDMyIC8gMixcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgICAgdHJhbnNpdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKFsnYmFja2dyb3VuZC1jb2xvcicsICdib3gtc2hhZG93J10pLFxuICAgICAgLy8gbGFiZWwgd2lsbCBpbmhlcml0IHRoaXMgZnJvbSByb290LCB0aGVuIGBjbGlja2FibGVgIGNsYXNzIG92ZXJyaWRlcyB0aGlzIGZvciBib3RoXG4gICAgICBjdXJzb3I6ICdkZWZhdWx0JyxcbiAgICAgIC8vIFdlIGRpc2FibGUgdGhlIGZvY3VzIHJpbmcgZm9yIG1vdXNlLCB0b3VjaCBhbmQga2V5Ym9hcmQgdXNlcnMuXG4gICAgICBvdXRsaW5lOiAwLFxuICAgICAgdGV4dERlY29yYXRpb246ICdub25lJyxcbiAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgLy8gUmVtb3ZlIGBidXR0b25gIGJvcmRlclxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIC8vIFJlbW92ZSBgYnV0dG9uYCBwYWRkaW5nXG4gICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgJyYkZGlzYWJsZWQnOiB7XG4gICAgICAgIG9wYWNpdHk6IDAuNSxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICB9LFxuICAgICAgJyYgJGF2YXRhcic6IHtcbiAgICAgICAgbWFyZ2luTGVmdDogNSxcbiAgICAgICAgbWFyZ2luUmlnaHQ6IC02LFxuICAgICAgICB3aWR0aDogMjQsXG4gICAgICAgIGhlaWdodDogMjQsXG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCcgPyB0aGVtZS5wYWxldHRlLmdyZXlbNzAwXSA6IHRoZW1lLnBhbGV0dGUuZ3JleVszMDBdLFxuICAgICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5weFRvUmVtKDEyKVxuICAgICAgfSxcbiAgICAgICcmICRhdmF0YXJDb2xvclByaW1hcnknOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnByaW1hcnkuY29udHJhc3RUZXh0LFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUucHJpbWFyeS5kYXJrXG4gICAgICB9LFxuICAgICAgJyYgJGF2YXRhckNvbG9yU2Vjb25kYXJ5Jzoge1xuICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkuY29udHJhc3RUZXh0LFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5LmRhcmtcbiAgICAgIH0sXG4gICAgICAnJiAkYXZhdGFyU21hbGwnOiB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IDQsXG4gICAgICAgIG1hcmdpblJpZ2h0OiAtNCxcbiAgICAgICAgd2lkdGg6IDE4LFxuICAgICAgICBoZWlnaHQ6IDE4LFxuICAgICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5weFRvUmVtKDEwKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBzaXplPVwic21hbGxcImAuICovXG4gICAgc2l6ZVNtYWxsOiB7XG4gICAgICBoZWlnaHQ6IDI0XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbG9yPVwicHJpbWFyeVwiYC4gKi9cbiAgICBjb2xvclByaW1hcnk6IHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW4sXG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5wcmltYXJ5LmNvbnRyYXN0VGV4dFxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBjb2xvcj1cInNlY29uZGFyeVwiYC4gKi9cbiAgICBjb2xvclNlY29uZGFyeToge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLnNlY29uZGFyeS5tYWluLFxuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5LmNvbnRyYXN0VGV4dFxuICAgIH0sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBkaXNhYmxlZD17dHJ1ZX1gLiAqL1xuICAgIGRpc2FibGVkOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYG9uQ2xpY2tgIGlzIGRlZmluZWQgb3IgYGNsaWNrYWJsZT17dHJ1ZX1gLiAqL1xuICAgIGNsaWNrYWJsZToge1xuICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgV2Via2l0VGFwSGlnaGxpZ2h0Q29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICcmOmhvdmVyLCAmOmZvY3VzJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGVtcGhhc2l6ZShiYWNrZ3JvdW5kQ29sb3IsIDAuMDgpXG4gICAgICB9LFxuICAgICAgJyY6YWN0aXZlJzoge1xuICAgICAgICBib3hTaGFkb3c6IHRoZW1lLnNoYWRvd3NbMV1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgb25DbGlja2AgYW5kIGBjb2xvcj1cInByaW1hcnlcImAgaXMgZGVmaW5lZCBvciBgY2xpY2thYmxlPXt0cnVlfWAuICovXG4gICAgY2xpY2thYmxlQ29sb3JQcmltYXJ5OiB7XG4gICAgICAnJjpob3ZlciwgJjpmb2N1cyc6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlbXBoYXNpemUodGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW4sIDAuMDgpXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYG9uQ2xpY2tgIGFuZCBgY29sb3I9XCJzZWNvbmRhcnlcImAgaXMgZGVmaW5lZCBvciBgY2xpY2thYmxlPXt0cnVlfWAuICovXG4gICAgY2xpY2thYmxlQ29sb3JTZWNvbmRhcnk6IHtcbiAgICAgICcmOmhvdmVyLCAmOmZvY3VzJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGVtcGhhc2l6ZSh0aGVtZS5wYWxldHRlLnNlY29uZGFyeS5tYWluLCAwLjA4KVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBvbkRlbGV0ZWAgaXMgZGVmaW5lZC4gKi9cbiAgICBkZWxldGFibGU6IHtcbiAgICAgICcmOmZvY3VzJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGVtcGhhc2l6ZShiYWNrZ3JvdW5kQ29sb3IsIDAuMDgpXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYG9uRGVsZXRlYCBhbmQgYGNvbG9yPVwicHJpbWFyeVwiYCBpcyBkZWZpbmVkLiAqL1xuICAgIGRlbGV0YWJsZUNvbG9yUHJpbWFyeToge1xuICAgICAgJyY6Zm9jdXMnOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogZW1waGFzaXplKHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluLCAwLjIpXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYG9uRGVsZXRlYCBhbmQgYGNvbG9yPVwic2Vjb25kYXJ5XCJgIGlzIGRlZmluZWQuICovXG4gICAgZGVsZXRhYmxlQ29sb3JTZWNvbmRhcnk6IHtcbiAgICAgICcmOmZvY3VzJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGVtcGhhc2l6ZSh0aGVtZS5wYWxldHRlLnNlY29uZGFyeS5tYWluLCAwLjIpXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHZhcmlhbnQ9XCJvdXRsaW5lZFwiYC4gKi9cbiAgICBvdXRsaW5lZDoge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCBcIi5jb25jYXQodGhlbWUucGFsZXR0ZS50eXBlID09PSAnbGlnaHQnID8gJ3JnYmEoMCwgMCwgMCwgMC4yMyknIDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4yMyknKSxcbiAgICAgICckY2xpY2thYmxlJjpob3ZlciwgJGNsaWNrYWJsZSY6Zm9jdXMsICRkZWxldGFibGUmOmZvY3VzJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGFscGhhKHRoZW1lLnBhbGV0dGUudGV4dC5wcmltYXJ5LCB0aGVtZS5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHkpXG4gICAgICB9LFxuICAgICAgJyYgJGF2YXRhcic6IHtcbiAgICAgICAgbWFyZ2luTGVmdDogNFxuICAgICAgfSxcbiAgICAgICcmICRhdmF0YXJTbWFsbCc6IHtcbiAgICAgICAgbWFyZ2luTGVmdDogMlxuICAgICAgfSxcbiAgICAgICcmICRpY29uJzoge1xuICAgICAgICBtYXJnaW5MZWZ0OiA0XG4gICAgICB9LFxuICAgICAgJyYgJGljb25TbWFsbCc6IHtcbiAgICAgICAgbWFyZ2luTGVmdDogMlxuICAgICAgfSxcbiAgICAgICcmICRkZWxldGVJY29uJzoge1xuICAgICAgICBtYXJnaW5SaWdodDogNVxuICAgICAgfSxcbiAgICAgICcmICRkZWxldGVJY29uU21hbGwnOiB7XG4gICAgICAgIG1hcmdpblJpZ2h0OiAzXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHZhcmlhbnQ9XCJvdXRsaW5lZFwiYCBhbmQgYGNvbG9yPVwicHJpbWFyeVwiYC4gKi9cbiAgICBvdXRsaW5lZFByaW1hcnk6IHtcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnByaW1hcnkubWFpbixcbiAgICAgIGJvcmRlcjogXCIxcHggc29saWQgXCIuY29uY2F0KHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluKSxcbiAgICAgICckY2xpY2thYmxlJjpob3ZlciwgJGNsaWNrYWJsZSY6Zm9jdXMsICRkZWxldGFibGUmOmZvY3VzJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGFscGhhKHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluLCB0aGVtZS5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHkpXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHZhcmlhbnQ9XCJvdXRsaW5lZFwiYCBhbmQgYGNvbG9yPVwic2Vjb25kYXJ5XCJgLiAqL1xuICAgIG91dGxpbmVkU2Vjb25kYXJ5OiB7XG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkubWFpbixcbiAgICAgIGJvcmRlcjogXCIxcHggc29saWQgXCIuY29uY2F0KHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW4pLFxuICAgICAgJyRjbGlja2FibGUmOmhvdmVyLCAkY2xpY2thYmxlJjpmb2N1cywgJGRlbGV0YWJsZSY6Zm9jdXMnOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYWxwaGEodGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkubWFpbiwgdGhlbWUucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5KVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gVE9ETyB2NTogcmVtb3ZlXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGF2YXRhcmAgZWxlbWVudC4gKi9cbiAgICBhdmF0YXI6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBhdmF0YXJgIGVsZW1lbnQgaWYgYHNpemU9XCJzbWFsbFwiYC4gKi9cbiAgICBhdmF0YXJTbWFsbDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGF2YXRhcmAgZWxlbWVudCBpZiBgY29sb3I9XCJwcmltYXJ5XCJgLiAqL1xuICAgIGF2YXRhckNvbG9yUHJpbWFyeToge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGF2YXRhcmAgZWxlbWVudCBpZiBgY29sb3I9XCJzZWNvbmRhcnlcImAuICovXG4gICAgYXZhdGFyQ29sb3JTZWNvbmRhcnk6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpY29uYCBlbGVtZW50LiAqL1xuICAgIGljb246IHtcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCcgPyB0aGVtZS5wYWxldHRlLmdyZXlbNzAwXSA6IHRoZW1lLnBhbGV0dGUuZ3JleVszMDBdLFxuICAgICAgbWFyZ2luTGVmdDogNSxcbiAgICAgIG1hcmdpblJpZ2h0OiAtNlxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGljb25gIGVsZW1lbnQgaWYgYHNpemU9XCJzbWFsbFwiYC4gKi9cbiAgICBpY29uU21hbGw6IHtcbiAgICAgIHdpZHRoOiAxOCxcbiAgICAgIGhlaWdodDogMTgsXG4gICAgICBtYXJnaW5MZWZ0OiA0LFxuICAgICAgbWFyZ2luUmlnaHQ6IC00XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaWNvbmAgZWxlbWVudCBpZiBgY29sb3I9XCJwcmltYXJ5XCJgLiAqL1xuICAgIGljb25Db2xvclByaW1hcnk6IHtcbiAgICAgIGNvbG9yOiAnaW5oZXJpdCdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpY29uYCBlbGVtZW50IGlmIGBjb2xvcj1cInNlY29uZGFyeVwiYC4gKi9cbiAgICBpY29uQ29sb3JTZWNvbmRhcnk6IHtcbiAgICAgIGNvbG9yOiAnaW5oZXJpdCdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGxhYmVsIGBzcGFuYCBlbGVtZW50LiAqL1xuICAgIGxhYmVsOiB7XG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICB0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcycsXG4gICAgICBwYWRkaW5nTGVmdDogMTIsXG4gICAgICBwYWRkaW5nUmlnaHQ6IDEyLFxuICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGxhYmVsIGBzcGFuYCBlbGVtZW50IGlmIGBzaXplPVwic21hbGxcImAuICovXG4gICAgbGFiZWxTbWFsbDoge1xuICAgICAgcGFkZGluZ0xlZnQ6IDgsXG4gICAgICBwYWRkaW5nUmlnaHQ6IDhcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBkZWxldGVJY29uYCBlbGVtZW50LiAqL1xuICAgIGRlbGV0ZUljb246IHtcbiAgICAgIFdlYmtpdFRhcEhpZ2hsaWdodENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgY29sb3I6IGRlbGV0ZUljb25Db2xvcixcbiAgICAgIGhlaWdodDogMjIsXG4gICAgICB3aWR0aDogMjIsXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgIG1hcmdpbjogJzAgNXB4IDAgLTZweCcsXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgY29sb3I6IGFscGhhKGRlbGV0ZUljb25Db2xvciwgMC40KVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGRlbGV0ZUljb25gIGVsZW1lbnQgaWYgYHNpemU9XCJzbWFsbFwiYC4gKi9cbiAgICBkZWxldGVJY29uU21hbGw6IHtcbiAgICAgIGhlaWdodDogMTYsXG4gICAgICB3aWR0aDogMTYsXG4gICAgICBtYXJnaW5SaWdodDogNCxcbiAgICAgIG1hcmdpbkxlZnQ6IC00XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBkZWxldGVJY29uIGVsZW1lbnQgaWYgYGNvbG9yPVwicHJpbWFyeVwiYCBhbmQgYHZhcmlhbnQ9XCJkZWZhdWx0XCJgLiAqL1xuICAgIGRlbGV0ZUljb25Db2xvclByaW1hcnk6IHtcbiAgICAgIGNvbG9yOiBhbHBoYSh0aGVtZS5wYWxldHRlLnByaW1hcnkuY29udHJhc3RUZXh0LCAwLjcpLFxuICAgICAgJyY6aG92ZXIsICY6YWN0aXZlJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5wcmltYXJ5LmNvbnRyYXN0VGV4dFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgZGVsZXRlSWNvbiBlbGVtZW50IGlmIGBjb2xvcj1cInNlY29uZGFyeVwiYCBhbmQgYHZhcmlhbnQ9XCJkZWZhdWx0XCJgLiAqL1xuICAgIGRlbGV0ZUljb25Db2xvclNlY29uZGFyeToge1xuICAgICAgY29sb3I6IGFscGhhKHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5LmNvbnRyYXN0VGV4dCwgMC43KSxcbiAgICAgICcmOmhvdmVyLCAmOmFjdGl2ZSc6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5LmNvbnRyYXN0VGV4dFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgZGVsZXRlSWNvbiBlbGVtZW50IGlmIGBjb2xvcj1cInByaW1hcnlcImAgYW5kIGB2YXJpYW50PVwib3V0bGluZWRcImAuICovXG4gICAgZGVsZXRlSWNvbk91dGxpbmVkQ29sb3JQcmltYXJ5OiB7XG4gICAgICBjb2xvcjogYWxwaGEodGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW4sIDAuNyksXG4gICAgICAnJjpob3ZlciwgJjphY3RpdmUnOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnByaW1hcnkubWFpblxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgZGVsZXRlSWNvbiBlbGVtZW50IGlmIGBjb2xvcj1cInNlY29uZGFyeVwiYCBhbmQgYHZhcmlhbnQ9XCJvdXRsaW5lZFwiYC4gKi9cbiAgICBkZWxldGVJY29uT3V0bGluZWRDb2xvclNlY29uZGFyeToge1xuICAgICAgY29sb3I6IGFscGhhKHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW4sIDAuNyksXG4gICAgICAnJjpob3ZlciwgJjphY3RpdmUnOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnNlY29uZGFyeS5tYWluXG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gaXNEZWxldGVLZXlib2FyZEV2ZW50KGtleWJvYXJkRXZlbnQpIHtcbiAgcmV0dXJuIGtleWJvYXJkRXZlbnQua2V5ID09PSAnQmFja3NwYWNlJyB8fCBrZXlib2FyZEV2ZW50LmtleSA9PT0gJ0RlbGV0ZSc7XG59XG4vKipcbiAqIENoaXBzIHJlcHJlc2VudCBjb21wbGV4IGVudGl0aWVzIGluIHNtYWxsIGJsb2Nrcywgc3VjaCBhcyBhIGNvbnRhY3QuXG4gKi9cblxuXG52YXIgQ2hpcCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENoaXAocHJvcHMsIHJlZikge1xuICB2YXIgYXZhdGFyUHJvcCA9IHByb3BzLmF2YXRhcixcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY2xpY2thYmxlUHJvcCA9IHByb3BzLmNsaWNrYWJsZSxcbiAgICAgIF9wcm9wcyRjb2xvciA9IHByb3BzLmNvbG9yLFxuICAgICAgY29sb3IgPSBfcHJvcHMkY29sb3IgPT09IHZvaWQgMCA/ICdkZWZhdWx0JyA6IF9wcm9wcyRjb2xvcixcbiAgICAgIENvbXBvbmVudFByb3AgPSBwcm9wcy5jb21wb25lbnQsXG4gICAgICBkZWxldGVJY29uUHJvcCA9IHByb3BzLmRlbGV0ZUljb24sXG4gICAgICBfcHJvcHMkZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGRpc2FibGVkID0gX3Byb3BzJGRpc2FibGVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlZCxcbiAgICAgIGljb25Qcm9wID0gcHJvcHMuaWNvbixcbiAgICAgIGxhYmVsID0gcHJvcHMubGFiZWwsXG4gICAgICBvbkNsaWNrID0gcHJvcHMub25DbGljayxcbiAgICAgIG9uRGVsZXRlID0gcHJvcHMub25EZWxldGUsXG4gICAgICBvbktleURvd24gPSBwcm9wcy5vbktleURvd24sXG4gICAgICBvbktleVVwID0gcHJvcHMub25LZXlVcCxcbiAgICAgIF9wcm9wcyRzaXplID0gcHJvcHMuc2l6ZSxcbiAgICAgIHNpemUgPSBfcHJvcHMkc2l6ZSA9PT0gdm9pZCAwID8gJ21lZGl1bScgOiBfcHJvcHMkc2l6ZSxcbiAgICAgIF9wcm9wcyR2YXJpYW50ID0gcHJvcHMudmFyaWFudCxcbiAgICAgIHZhcmlhbnQgPSBfcHJvcHMkdmFyaWFudCA9PT0gdm9pZCAwID8gJ2RlZmF1bHQnIDogX3Byb3BzJHZhcmlhbnQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYXZhdGFyXCIsIFwiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcImNsaWNrYWJsZVwiLCBcImNvbG9yXCIsIFwiY29tcG9uZW50XCIsIFwiZGVsZXRlSWNvblwiLCBcImRpc2FibGVkXCIsIFwiaWNvblwiLCBcImxhYmVsXCIsIFwib25DbGlja1wiLCBcIm9uRGVsZXRlXCIsIFwib25LZXlEb3duXCIsIFwib25LZXlVcFwiLCBcInNpemVcIiwgXCJ2YXJpYW50XCJdKTtcblxuICB2YXIgY2hpcFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIGhhbmRsZVJlZiA9IHVzZUZvcmtSZWYoY2hpcFJlZiwgcmVmKTtcblxuICB2YXIgaGFuZGxlRGVsZXRlSWNvbkNsaWNrID0gZnVuY3Rpb24gaGFuZGxlRGVsZXRlSWNvbkNsaWNrKGV2ZW50KSB7XG4gICAgLy8gU3RvcCB0aGUgZXZlbnQgZnJvbSBidWJibGluZyB1cCB0byB0aGUgYENoaXBgXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBpZiAob25EZWxldGUpIHtcbiAgICAgIG9uRGVsZXRlKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUtleURvd24gPSBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgLy8gSWdub3JlIGV2ZW50cyBmcm9tIGNoaWxkcmVuIG9mIGBDaGlwYC5cbiAgICBpZiAoZXZlbnQuY3VycmVudFRhcmdldCA9PT0gZXZlbnQudGFyZ2V0ICYmIGlzRGVsZXRlS2V5Ym9hcmRFdmVudChldmVudCkpIHtcbiAgICAgIC8vIHdpbGwgYmUgaGFuZGxlZCBpbiBrZXlVcCwgb3RoZXJ3aXNlIHNvbWUgYnJvd3NlcnNcbiAgICAgIC8vIG1pZ2h0IGluaXQgbmF2aWdhdGlvblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAob25LZXlEb3duKSB7XG4gICAgICBvbktleURvd24oZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlS2V5VXAgPSBmdW5jdGlvbiBoYW5kbGVLZXlVcChldmVudCkge1xuICAgIC8vIElnbm9yZSBldmVudHMgZnJvbSBjaGlsZHJlbiBvZiBgQ2hpcGAuXG4gICAgaWYgKGV2ZW50LmN1cnJlbnRUYXJnZXQgPT09IGV2ZW50LnRhcmdldCkge1xuICAgICAgaWYgKG9uRGVsZXRlICYmIGlzRGVsZXRlS2V5Ym9hcmRFdmVudChldmVudCkpIHtcbiAgICAgICAgb25EZWxldGUoZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnICYmIGNoaXBSZWYuY3VycmVudCkge1xuICAgICAgICBjaGlwUmVmLmN1cnJlbnQuYmx1cigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvbktleVVwKSB7XG4gICAgICBvbktleVVwKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNsaWNrYWJsZSA9IGNsaWNrYWJsZVByb3AgIT09IGZhbHNlICYmIG9uQ2xpY2sgPyB0cnVlIDogY2xpY2thYmxlUHJvcDtcbiAgdmFyIHNtYWxsID0gc2l6ZSA9PT0gJ3NtYWxsJztcbiAgdmFyIENvbXBvbmVudCA9IENvbXBvbmVudFByb3AgfHwgKGNsaWNrYWJsZSA/IEJ1dHRvbkJhc2UgOiAnZGl2Jyk7XG4gIHZhciBtb3JlUHJvcHMgPSBDb21wb25lbnQgPT09IEJ1dHRvbkJhc2UgPyB7XG4gICAgY29tcG9uZW50OiAnZGl2J1xuICB9IDoge307XG4gIHZhciBkZWxldGVJY29uID0gbnVsbDtcblxuICBpZiAob25EZWxldGUpIHtcbiAgICB2YXIgY3VzdG9tQ2xhc3NlcyA9IGNsc3goY29sb3IgIT09ICdkZWZhdWx0JyAmJiAodmFyaWFudCA9PT0gXCJkZWZhdWx0XCIgPyBjbGFzc2VzW1wiZGVsZXRlSWNvbkNvbG9yXCIuY29uY2F0KGNhcGl0YWxpemUoY29sb3IpKV0gOiBjbGFzc2VzW1wiZGVsZXRlSWNvbk91dGxpbmVkQ29sb3JcIi5jb25jYXQoY2FwaXRhbGl6ZShjb2xvcikpXSksIHNtYWxsICYmIGNsYXNzZXMuZGVsZXRlSWNvblNtYWxsKTtcbiAgICBkZWxldGVJY29uID0gZGVsZXRlSWNvblByb3AgJiYgLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGRlbGV0ZUljb25Qcm9wKSA/IC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoZGVsZXRlSWNvblByb3AsIHtcbiAgICAgIGNsYXNzTmFtZTogY2xzeChkZWxldGVJY29uUHJvcC5wcm9wcy5jbGFzc05hbWUsIGNsYXNzZXMuZGVsZXRlSWNvbiwgY3VzdG9tQ2xhc3NlcyksXG4gICAgICBvbkNsaWNrOiBoYW5kbGVEZWxldGVJY29uQ2xpY2tcbiAgICB9KSA6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENhbmNlbEljb24sIHtcbiAgICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLmRlbGV0ZUljb24sIGN1c3RvbUNsYXNzZXMpLFxuICAgICAgb25DbGljazogaGFuZGxlRGVsZXRlSWNvbkNsaWNrXG4gICAgfSk7XG4gIH1cblxuICB2YXIgYXZhdGFyID0gbnVsbDtcblxuICBpZiAoYXZhdGFyUHJvcCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoYXZhdGFyUHJvcCkpIHtcbiAgICBhdmF0YXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGF2YXRhclByb3AsIHtcbiAgICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLmF2YXRhciwgYXZhdGFyUHJvcC5wcm9wcy5jbGFzc05hbWUsIHNtYWxsICYmIGNsYXNzZXMuYXZhdGFyU21hbGwsIGNvbG9yICE9PSAnZGVmYXVsdCcgJiYgY2xhc3Nlc1tcImF2YXRhckNvbG9yXCIuY29uY2F0KGNhcGl0YWxpemUoY29sb3IpKV0pXG4gICAgfSk7XG4gIH1cblxuICB2YXIgaWNvbiA9IG51bGw7XG5cbiAgaWYgKGljb25Qcm9wICYmIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChpY29uUHJvcCkpIHtcbiAgICBpY29uID0gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChpY29uUHJvcCwge1xuICAgICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMuaWNvbiwgaWNvblByb3AucHJvcHMuY2xhc3NOYW1lLCBzbWFsbCAmJiBjbGFzc2VzLmljb25TbWFsbCwgY29sb3IgIT09ICdkZWZhdWx0JyAmJiBjbGFzc2VzW1wiaWNvbkNvbG9yXCIuY29uY2F0KGNhcGl0YWxpemUoY29sb3IpKV0pXG4gICAgfSk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChhdmF0YXIgJiYgaWNvbikge1xuICAgICAgY29uc29sZS5lcnJvcignTWF0ZXJpYWwtVUk6IFRoZSBDaGlwIGNvbXBvbmVudCBjYW4gbm90IGhhbmRsZSB0aGUgYXZhdGFyICcgKyAnYW5kIHRoZSBpY29uIHByb3AgYXQgdGhlIHNhbWUgdGltZS4gUGljayBvbmUuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIHJvbGU6IGNsaWNrYWJsZSB8fCBvbkRlbGV0ZSA/ICdidXR0b24nIDogdW5kZWZpbmVkLFxuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSwgY29sb3IgIT09ICdkZWZhdWx0JyAmJiBbY2xhc3Nlc1tcImNvbG9yXCIuY29uY2F0KGNhcGl0YWxpemUoY29sb3IpKV0sIGNsaWNrYWJsZSAmJiBjbGFzc2VzW1wiY2xpY2thYmxlQ29sb3JcIi5jb25jYXQoY2FwaXRhbGl6ZShjb2xvcikpXSwgb25EZWxldGUgJiYgY2xhc3Nlc1tcImRlbGV0YWJsZUNvbG9yXCIuY29uY2F0KGNhcGl0YWxpemUoY29sb3IpKV1dLCB2YXJpYW50ICE9PSBcImRlZmF1bHRcIiAmJiBbY2xhc3Nlcy5vdXRsaW5lZCwge1xuICAgICAgJ3ByaW1hcnknOiBjbGFzc2VzLm91dGxpbmVkUHJpbWFyeSxcbiAgICAgICdzZWNvbmRhcnknOiBjbGFzc2VzLm91dGxpbmVkU2Vjb25kYXJ5XG4gICAgfVtjb2xvcl1dLCBkaXNhYmxlZCAmJiBjbGFzc2VzLmRpc2FibGVkLCBzbWFsbCAmJiBjbGFzc2VzLnNpemVTbWFsbCwgY2xpY2thYmxlICYmIGNsYXNzZXMuY2xpY2thYmxlLCBvbkRlbGV0ZSAmJiBjbGFzc2VzLmRlbGV0YWJsZSksXG4gICAgXCJhcmlhLWRpc2FibGVkXCI6IGRpc2FibGVkID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICB0YWJJbmRleDogY2xpY2thYmxlIHx8IG9uRGVsZXRlID8gMCA6IHVuZGVmaW5lZCxcbiAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICBvbktleVVwOiBoYW5kbGVLZXlVcCxcbiAgICByZWY6IGhhbmRsZVJlZlxuICB9LCBtb3JlUHJvcHMsIG90aGVyKSwgYXZhdGFyIHx8IGljb24sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMubGFiZWwsIHNtYWxsICYmIGNsYXNzZXMubGFiZWxTbWFsbClcbiAgfSwgbGFiZWwpLCBkZWxldGVJY29uKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gQ2hpcC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBBdmF0YXIgZWxlbWVudC5cbiAgICovXG4gIGF2YXRhcjogUHJvcFR5cGVzLmVsZW1lbnQsXG5cbiAgLyoqXG4gICAqIFRoaXMgcHJvcCBpc24ndCBzdXBwb3J0ZWQuXG4gICAqIFVzZSB0aGUgYGNvbXBvbmVudGAgcHJvcCBpZiB5b3UgbmVlZCB0byBjaGFuZ2UgdGhlIGNoaWxkcmVuIHN0cnVjdHVyZS5cbiAgICovXG4gIGNoaWxkcmVuOiB1bnN1cHBvcnRlZFByb3AsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjaGlwIHdpbGwgYXBwZWFyIGNsaWNrYWJsZSwgYW5kIHdpbGwgcmFpc2Ugd2hlbiBwcmVzc2VkLFxuICAgKiBldmVuIGlmIHRoZSBvbkNsaWNrIHByb3AgaXMgbm90IGRlZmluZWQuXG4gICAqIElmIGZhbHNlLCB0aGUgY2hpcCB3aWxsIG5vdCBiZSBjbGlja2FibGUsIGV2ZW4gaWYgb25DbGljayBwcm9wIGlzIGRlZmluZWQuXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLFxuICAgKiBhbG9uZyB3aXRoIHRoZSBjb21wb25lbnQgcHJvcCB0byBpbmRpY2F0ZSBhbiBhbmNob3IgQ2hpcCBpcyBjbGlja2FibGUuXG4gICAqL1xuICBjbGlja2FibGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2YgdGhlIGNvbXBvbmVudC4gSXQgc3VwcG9ydHMgdGhvc2UgdGhlbWUgY29sb3JzIHRoYXQgbWFrZSBzZW5zZSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnZGVmYXVsdCcsICdwcmltYXJ5JywgJ3NlY29uZGFyeSddKSxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgcm9vdCBub2RlLlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgY29tcG9uZW50OiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAuZWxlbWVudFR5cGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGRlbGV0ZSBpY29uIGVsZW1lbnQuIFNob3duIG9ubHkgaWYgYG9uRGVsZXRlYCBpcyBzZXQuXG4gICAqL1xuICBkZWxldGVJY29uOiBQcm9wVHlwZXMuZWxlbWVudCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY2hpcCBzaG91bGQgYmUgZGlzcGxheWVkIGluIGEgZGlzYWJsZWQgc3RhdGUuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEljb24gZWxlbWVudC5cbiAgICovXG4gIGljb246IFByb3BUeXBlcy5lbGVtZW50LFxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgbGFiZWwuXG4gICAqL1xuICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBmaXJlZCB3aGVuIHRoZSBkZWxldGUgaWNvbiBpcyBjbGlja2VkLlxuICAgKiBJZiBzZXQsIHRoZSBkZWxldGUgaWNvbiB3aWxsIGJlIHNob3duLlxuICAgKi9cbiAgb25EZWxldGU6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbktleURvd246IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbktleVVwOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIGNoaXAuXG4gICAqL1xuICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydtZWRpdW0nLCAnc21hbGwnXSksXG5cbiAgLyoqXG4gICAqIFRoZSB2YXJpYW50IHRvIHVzZS5cbiAgICovXG4gIHZhcmlhbnQ6IFByb3BUeXBlcy5vbmVPZihbJ2RlZmF1bHQnLCAnb3V0bGluZWQnXSlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpQ2hpcCdcbn0pKENoaXApOyIsIi8vIENvcnJlc3BvbmRzIHRvIDEwIGZyYW1lcyBhdCA2MCBIei5cbi8vIEEgZmV3IGJ5dGVzIHBheWxvYWQgb3ZlcmhlYWQgd2hlbiBsb2Rhc2gvZGVib3VuY2UgaXMgfjMga0IgYW5kIGRlYm91bmNlIH4zMDAgQi5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMpIHtcbiAgdmFyIHdhaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE2NjtcbiAgdmFyIHRpbWVvdXQ7XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC10aGlzXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgICBmdW5jLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICB9XG5cbiAgZGVib3VuY2VkLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgfTtcblxuICByZXR1cm4gZGVib3VuY2VkO1xufSIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzTXVpRWxlbWVudChlbGVtZW50LCBtdWlOYW1lcykge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpICYmIG11aU5hbWVzLmluZGV4T2YoZWxlbWVudC50eXBlLm11aU5hbWUpICE9PSAtMTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvd25lckRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xufSIsImltcG9ydCBvd25lckRvY3VtZW50IGZyb20gJy4vb3duZXJEb2N1bWVudCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvd25lcldpbmRvdyhub2RlKSB7XG4gIHZhciBkb2MgPSBvd25lckRvY3VtZW50KG5vZGUpO1xuICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbn0iLCIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rcywgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VDb250cm9sbGVkKF9yZWYpIHtcbiAgdmFyIGNvbnRyb2xsZWQgPSBfcmVmLmNvbnRyb2xsZWQsXG4gICAgICBkZWZhdWx0UHJvcCA9IF9yZWYuZGVmYXVsdCxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBfcmVmJHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIHN0YXRlID0gX3JlZiRzdGF0ZSA9PT0gdm9pZCAwID8gJ3ZhbHVlJyA6IF9yZWYkc3RhdGU7XG5cbiAgdmFyIF9SZWFjdCR1c2VSZWYgPSBSZWFjdC51c2VSZWYoY29udHJvbGxlZCAhPT0gdW5kZWZpbmVkKSxcbiAgICAgIGlzQ29udHJvbGxlZCA9IF9SZWFjdCR1c2VSZWYuY3VycmVudDtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZGVmYXVsdFByb3ApLFxuICAgICAgdmFsdWVTdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldFZhbHVlID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciB2YWx1ZSA9IGlzQ29udHJvbGxlZCA/IGNvbnRyb2xsZWQgOiB2YWx1ZVN0YXRlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0NvbnRyb2xsZWQgIT09IChjb250cm9sbGVkICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoW1wiTWF0ZXJpYWwtVUk6IEEgY29tcG9uZW50IGlzIGNoYW5naW5nIHRoZSBcIi5jb25jYXQoaXNDb250cm9sbGVkID8gJycgOiAndW4nLCBcImNvbnRyb2xsZWQgXCIpLmNvbmNhdChzdGF0ZSwgXCIgc3RhdGUgb2YgXCIpLmNvbmNhdChuYW1lLCBcIiB0byBiZSBcIikuY29uY2F0KGlzQ29udHJvbGxlZCA/ICd1bicgOiAnJywgXCJjb250cm9sbGVkLlwiKSwgJ0VsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLicsIFwiRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBcIi5jb25jYXQobmFtZSwgXCIgXCIpICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LicsIFwiVGhlIG5hdHVyZSBvZiB0aGUgc3RhdGUgaXMgZGV0ZXJtaW5lZCBkdXJpbmcgdGhlIGZpcnN0IHJlbmRlciwgaXQncyBjb25zaWRlcmVkIGNvbnRyb2xsZWQgaWYgdGhlIHZhbHVlIGlzIG5vdCBgdW5kZWZpbmVkYC5cIiwgJ01vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfSwgW2NvbnRyb2xsZWRdKTtcblxuICAgIHZhciBfUmVhY3QkdXNlUmVmMiA9IFJlYWN0LnVzZVJlZihkZWZhdWx0UHJvcCksXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IF9SZWFjdCR1c2VSZWYyLmN1cnJlbnQ7XG5cbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFpc0NvbnRyb2xsZWQgJiYgZGVmYXVsdFZhbHVlICE9PSBkZWZhdWx0UHJvcCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFtcIk1hdGVyaWFsLVVJOiBBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyB0aGUgZGVmYXVsdCBcIi5jb25jYXQoc3RhdGUsIFwiIHN0YXRlIG9mIGFuIHVuY29udHJvbGxlZCBcIikuY29uY2F0KG5hbWUsIFwiIGFmdGVyIGJlaW5nIGluaXRpYWxpemVkLiBcIikgKyBcIlRvIHN1cHByZXNzIHRoaXMgd2FybmluZyBvcHQgdG8gdXNlIGEgY29udHJvbGxlZCBcIi5jb25jYXQobmFtZSwgXCIuXCIpXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfSwgW0pTT04uc3RyaW5naWZ5KGRlZmF1bHRQcm9wKV0pO1xuICB9XG5cbiAgdmFyIHNldFZhbHVlSWZVbmNvbnRyb2xsZWQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICBpZiAoIWlzQ29udHJvbGxlZCkge1xuICAgICAgc2V0VmFsdWUobmV3VmFsdWUpO1xuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gW3ZhbHVlLCBzZXRWYWx1ZUlmVW5jb250cm9sbGVkXTtcbn0iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG4vKipcbiAqIFByaXZhdGUgbW9kdWxlIHJlc2VydmVkIGZvciBAbWF0ZXJpYWwtdWkveCBwYWNrYWdlcy5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VJZChpZE92ZXJyaWRlKSB7XG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShpZE92ZXJyaWRlKSxcbiAgICAgIGRlZmF1bHRJZCA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldERlZmF1bHRJZCA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICB2YXIgaWQgPSBpZE92ZXJyaWRlIHx8IGRlZmF1bHRJZDtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZGVmYXVsdElkID09IG51bGwpIHtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIHRoaXMgZGVmYXVsdCBpZCB3aGVuIHBvc3NpYmxlLlxuICAgICAgLy8gVXNlIHRoZSByYW5kb20gdmFsdWUgZm9yIGNsaWVudC1zaWRlIHJlbmRlcmluZyBvbmx5LlxuICAgICAgLy8gV2UgY2FuJ3QgdXNlIGl0IHNlcnZlci1zaWRlLlxuICAgICAgc2V0RGVmYXVsdElkKFwibXVpLVwiLmNvbmNhdChNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxZTUpKSk7XG4gICAgfVxuICB9LCBbZGVmYXVsdElkXSk7XG4gIHJldHVybiBpZDtcbn0iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVTdmdJY29uIH0gZnJvbSAnQG1hdGVyaWFsLXVpL2NvcmUvdXRpbHMnO1xuLyoqXHJcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXHJcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTdmdJY29uKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICBkOiBcIk0xOSA2LjQxTDE3LjU5IDUgMTIgMTAuNTkgNi40MSA1IDUgNi40MSAxMC41OSAxMiA1IDE3LjU5IDYuNDEgMTkgMTIgMTMuNDEgMTcuNTkgMTkgMTkgMTcuNTkgMTMuNDEgMTJ6XCJcbn0pLCAnQ2xvc2UnKTsiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVTdmdJY29uIH0gZnJvbSAnQG1hdGVyaWFsLXVpL2NvcmUvdXRpbHMnO1xuLyoqXHJcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXHJcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTdmdJY29uKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICBkOiBcIk03IDEwbDUgNSA1LTV6XCJcbn0pLCAnQXJyb3dEcm9wRG93bicpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgX3R5cGVvZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mXCI7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnN0YW50LWNvbmRpdGlvbiAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgc2V0UmVmLCB1c2VFdmVudENhbGxiYWNrLCB1c2VDb250cm9sbGVkLCB1bnN0YWJsZV91c2VJZCBhcyB1c2VJZCB9IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL3V0aWxzJzsgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTkwOTA0L3JlbW92ZS1hY2NlbnRzLWRpYWNyaXRpY3MtaW4tYS1zdHJpbmctaW4tamF2YXNjcmlwdFxuLy8gR2l2ZSB1cCBvbiBJRSAxMSBzdXBwb3J0IGZvciB0aGlzIGZlYXR1cmVcblxuZnVuY3Rpb24gc3RyaXBEaWFjcml0aWNzKHN0cmluZykge1xuICByZXR1cm4gdHlwZW9mIHN0cmluZy5ub3JtYWxpemUgIT09ICd1bmRlZmluZWQnID8gc3RyaW5nLm5vcm1hbGl6ZSgnTkZEJykucmVwbGFjZSgvW1xcdTAzMDAtXFx1MDM2Zl0vZywgJycpIDogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRmlsdGVyT3B0aW9ucygpIHtcbiAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBfY29uZmlnJGlnbm9yZUFjY2VudHMgPSBjb25maWcuaWdub3JlQWNjZW50cyxcbiAgICAgIGlnbm9yZUFjY2VudHMgPSBfY29uZmlnJGlnbm9yZUFjY2VudHMgPT09IHZvaWQgMCA/IHRydWUgOiBfY29uZmlnJGlnbm9yZUFjY2VudHMsXG4gICAgICBfY29uZmlnJGlnbm9yZUNhc2UgPSBjb25maWcuaWdub3JlQ2FzZSxcbiAgICAgIGlnbm9yZUNhc2UgPSBfY29uZmlnJGlnbm9yZUNhc2UgPT09IHZvaWQgMCA/IHRydWUgOiBfY29uZmlnJGlnbm9yZUNhc2UsXG4gICAgICBsaW1pdCA9IGNvbmZpZy5saW1pdCxcbiAgICAgIF9jb25maWckbWF0Y2hGcm9tID0gY29uZmlnLm1hdGNoRnJvbSxcbiAgICAgIG1hdGNoRnJvbSA9IF9jb25maWckbWF0Y2hGcm9tID09PSB2b2lkIDAgPyAnYW55JyA6IF9jb25maWckbWF0Y2hGcm9tLFxuICAgICAgc3RyaW5naWZ5ID0gY29uZmlnLnN0cmluZ2lmeSxcbiAgICAgIF9jb25maWckdHJpbSA9IGNvbmZpZy50cmltLFxuICAgICAgdHJpbSA9IF9jb25maWckdHJpbSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfY29uZmlnJHRyaW07XG4gIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucywgX3JlZikge1xuICAgIHZhciBpbnB1dFZhbHVlID0gX3JlZi5pbnB1dFZhbHVlLFxuICAgICAgICBnZXRPcHRpb25MYWJlbCA9IF9yZWYuZ2V0T3B0aW9uTGFiZWw7XG4gICAgdmFyIGlucHV0ID0gdHJpbSA/IGlucHV0VmFsdWUudHJpbSgpIDogaW5wdXRWYWx1ZTtcblxuICAgIGlmIChpZ25vcmVDYXNlKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKGlnbm9yZUFjY2VudHMpIHtcbiAgICAgIGlucHV0ID0gc3RyaXBEaWFjcml0aWNzKGlucHV0KTtcbiAgICB9XG5cbiAgICB2YXIgZmlsdGVyZWRPcHRpb25zID0gb3B0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgdmFyIGNhbmRpZGF0ZSA9IChzdHJpbmdpZnkgfHwgZ2V0T3B0aW9uTGFiZWwpKG9wdGlvbik7XG5cbiAgICAgIGlmIChpZ25vcmVDYXNlKSB7XG4gICAgICAgIGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWdub3JlQWNjZW50cykge1xuICAgICAgICBjYW5kaWRhdGUgPSBzdHJpcERpYWNyaXRpY3MoY2FuZGlkYXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdGNoRnJvbSA9PT0gJ3N0YXJ0JyA/IGNhbmRpZGF0ZS5pbmRleE9mKGlucHV0KSA9PT0gMCA6IGNhbmRpZGF0ZS5pbmRleE9mKGlucHV0KSA+IC0xO1xuICAgIH0pO1xuICAgIHJldHVybiB0eXBlb2YgbGltaXQgPT09ICdudW1iZXInID8gZmlsdGVyZWRPcHRpb25zLnNsaWNlKDAsIGxpbWl0KSA6IGZpbHRlcmVkT3B0aW9ucztcbiAgfTtcbn0gLy8gVG8gcmVwbGFjZSB3aXRoIC5maW5kSW5kZXgoKSBvbmNlIHdlIHN0b3AgSUUgMTEgc3VwcG9ydC5cblxuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBjb21wKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoY29tcChhcnJheVtpXSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxudmFyIGRlZmF1bHRGaWx0ZXJPcHRpb25zID0gY3JlYXRlRmlsdGVyT3B0aW9ucygpOyAvLyBOdW1iZXIgb2Ygb3B0aW9ucyB0byBqdW1wIGluIGxpc3QgYm94IHdoZW4gcGFnZXVwIGFuZCBwYWdlZG93biBrZXlzIGFyZSB1c2VkLlxuXG52YXIgcGFnZVNpemUgPSA1O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlQXV0b2NvbXBsZXRlKHByb3BzKSB7XG4gIHZhciBfcHJvcHMkYXV0b0NvbXBsZXRlID0gcHJvcHMuYXV0b0NvbXBsZXRlLFxuICAgICAgYXV0b0NvbXBsZXRlID0gX3Byb3BzJGF1dG9Db21wbGV0ZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkYXV0b0NvbXBsZXRlLFxuICAgICAgX3Byb3BzJGF1dG9IaWdobGlnaHQgPSBwcm9wcy5hdXRvSGlnaGxpZ2h0LFxuICAgICAgYXV0b0hpZ2hsaWdodCA9IF9wcm9wcyRhdXRvSGlnaGxpZ2h0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRhdXRvSGlnaGxpZ2h0LFxuICAgICAgX3Byb3BzJGF1dG9TZWxlY3QgPSBwcm9wcy5hdXRvU2VsZWN0LFxuICAgICAgYXV0b1NlbGVjdCA9IF9wcm9wcyRhdXRvU2VsZWN0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRhdXRvU2VsZWN0LFxuICAgICAgX3Byb3BzJGJsdXJPblNlbGVjdCA9IHByb3BzLmJsdXJPblNlbGVjdCxcbiAgICAgIGJsdXJPblNlbGVjdCA9IF9wcm9wcyRibHVyT25TZWxlY3QgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGJsdXJPblNlbGVjdCxcbiAgICAgIF9wcm9wcyRjbGVhck9uQmx1ciA9IHByb3BzLmNsZWFyT25CbHVyLFxuICAgICAgY2xlYXJPbkJsdXIgPSBfcHJvcHMkY2xlYXJPbkJsdXIgPT09IHZvaWQgMCA/ICFwcm9wcy5mcmVlU29sbyA6IF9wcm9wcyRjbGVhck9uQmx1cixcbiAgICAgIF9wcm9wcyRjbGVhck9uRXNjYXBlID0gcHJvcHMuY2xlYXJPbkVzY2FwZSxcbiAgICAgIGNsZWFyT25Fc2NhcGUgPSBfcHJvcHMkY2xlYXJPbkVzY2FwZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkY2xlYXJPbkVzY2FwZSxcbiAgICAgIF9wcm9wcyRjb21wb25lbnROYW1lID0gcHJvcHMuY29tcG9uZW50TmFtZSxcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBfcHJvcHMkY29tcG9uZW50TmFtZSA9PT0gdm9pZCAwID8gJ3VzZUF1dG9jb21wbGV0ZScgOiBfcHJvcHMkY29tcG9uZW50TmFtZSxcbiAgICAgIF9wcm9wcyRkZWJ1ZyA9IHByb3BzLmRlYnVnLFxuICAgICAgZGVidWcgPSBfcHJvcHMkZGVidWcgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRlYnVnLFxuICAgICAgX3Byb3BzJGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgIGRlZmF1bHRWYWx1ZSA9IF9wcm9wcyRkZWZhdWx0VmFsdWUgPT09IHZvaWQgMCA/IHByb3BzLm11bHRpcGxlID8gW10gOiBudWxsIDogX3Byb3BzJGRlZmF1bHRWYWx1ZSxcbiAgICAgIF9wcm9wcyRkaXNhYmxlQ2xlYXJhYiA9IHByb3BzLmRpc2FibGVDbGVhcmFibGUsXG4gICAgICBkaXNhYmxlQ2xlYXJhYmxlID0gX3Byb3BzJGRpc2FibGVDbGVhcmFiID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlQ2xlYXJhYixcbiAgICAgIF9wcm9wcyRkaXNhYmxlQ2xvc2VPbiA9IHByb3BzLmRpc2FibGVDbG9zZU9uU2VsZWN0LFxuICAgICAgZGlzYWJsZUNsb3NlT25TZWxlY3QgPSBfcHJvcHMkZGlzYWJsZUNsb3NlT24gPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVDbG9zZU9uLFxuICAgICAgX3Byb3BzJGRpc2FibGVkSXRlbXNGID0gcHJvcHMuZGlzYWJsZWRJdGVtc0ZvY3VzYWJsZSxcbiAgICAgIGRpc2FibGVkSXRlbXNGb2N1c2FibGUgPSBfcHJvcHMkZGlzYWJsZWRJdGVtc0YgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVkSXRlbXNGLFxuICAgICAgX3Byb3BzJGRpc2FibGVMaXN0V3JhID0gcHJvcHMuZGlzYWJsZUxpc3RXcmFwLFxuICAgICAgZGlzYWJsZUxpc3RXcmFwID0gX3Byb3BzJGRpc2FibGVMaXN0V3JhID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlTGlzdFdyYSxcbiAgICAgIF9wcm9wcyRmaWx0ZXJPcHRpb25zID0gcHJvcHMuZmlsdGVyT3B0aW9ucyxcbiAgICAgIGZpbHRlck9wdGlvbnMgPSBfcHJvcHMkZmlsdGVyT3B0aW9ucyA9PT0gdm9pZCAwID8gZGVmYXVsdEZpbHRlck9wdGlvbnMgOiBfcHJvcHMkZmlsdGVyT3B0aW9ucyxcbiAgICAgIF9wcm9wcyRmaWx0ZXJTZWxlY3RlZCA9IHByb3BzLmZpbHRlclNlbGVjdGVkT3B0aW9ucyxcbiAgICAgIGZpbHRlclNlbGVjdGVkT3B0aW9ucyA9IF9wcm9wcyRmaWx0ZXJTZWxlY3RlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZmlsdGVyU2VsZWN0ZWQsXG4gICAgICBfcHJvcHMkZnJlZVNvbG8gPSBwcm9wcy5mcmVlU29sbyxcbiAgICAgIGZyZWVTb2xvID0gX3Byb3BzJGZyZWVTb2xvID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRmcmVlU29sbyxcbiAgICAgIGdldE9wdGlvbkRpc2FibGVkID0gcHJvcHMuZ2V0T3B0aW9uRGlzYWJsZWQsXG4gICAgICBfcHJvcHMkZ2V0T3B0aW9uTGFiZWwgPSBwcm9wcy5nZXRPcHRpb25MYWJlbCxcbiAgICAgIGdldE9wdGlvbkxhYmVsUHJvcCA9IF9wcm9wcyRnZXRPcHRpb25MYWJlbCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIHJldHVybiBvcHRpb247XG4gIH0gOiBfcHJvcHMkZ2V0T3B0aW9uTGFiZWwsXG4gICAgICBfcHJvcHMkZ2V0T3B0aW9uU2VsZWMgPSBwcm9wcy5nZXRPcHRpb25TZWxlY3RlZCxcbiAgICAgIGdldE9wdGlvblNlbGVjdGVkID0gX3Byb3BzJGdldE9wdGlvblNlbGVjID09PSB2b2lkIDAgPyBmdW5jdGlvbiAob3B0aW9uLCB2YWx1ZSkge1xuICAgIHJldHVybiBvcHRpb24gPT09IHZhbHVlO1xuICB9IDogX3Byb3BzJGdldE9wdGlvblNlbGVjLFxuICAgICAgZ3JvdXBCeSA9IHByb3BzLmdyb3VwQnksXG4gICAgICBfcHJvcHMkaGFuZGxlSG9tZUVuZEsgPSBwcm9wcy5oYW5kbGVIb21lRW5kS2V5cyxcbiAgICAgIGhhbmRsZUhvbWVFbmRLZXlzID0gX3Byb3BzJGhhbmRsZUhvbWVFbmRLID09PSB2b2lkIDAgPyAhcHJvcHMuZnJlZVNvbG8gOiBfcHJvcHMkaGFuZGxlSG9tZUVuZEssXG4gICAgICBpZFByb3AgPSBwcm9wcy5pZCxcbiAgICAgIF9wcm9wcyRpbmNsdWRlSW5wdXRJbiA9IHByb3BzLmluY2x1ZGVJbnB1dEluTGlzdCxcbiAgICAgIGluY2x1ZGVJbnB1dEluTGlzdCA9IF9wcm9wcyRpbmNsdWRlSW5wdXRJbiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkaW5jbHVkZUlucHV0SW4sXG4gICAgICBpbnB1dFZhbHVlUHJvcCA9IHByb3BzLmlucHV0VmFsdWUsXG4gICAgICBfcHJvcHMkbXVsdGlwbGUgPSBwcm9wcy5tdWx0aXBsZSxcbiAgICAgIG11bHRpcGxlID0gX3Byb3BzJG11bHRpcGxlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRtdWx0aXBsZSxcbiAgICAgIG9uQ2hhbmdlID0gcHJvcHMub25DaGFuZ2UsXG4gICAgICBvbkNsb3NlID0gcHJvcHMub25DbG9zZSxcbiAgICAgIG9uSGlnaGxpZ2h0Q2hhbmdlID0gcHJvcHMub25IaWdobGlnaHRDaGFuZ2UsXG4gICAgICBvbklucHV0Q2hhbmdlID0gcHJvcHMub25JbnB1dENoYW5nZSxcbiAgICAgIG9uT3BlbiA9IHByb3BzLm9uT3BlbixcbiAgICAgIG9wZW5Qcm9wID0gcHJvcHMub3BlbixcbiAgICAgIF9wcm9wcyRvcGVuT25Gb2N1cyA9IHByb3BzLm9wZW5PbkZvY3VzLFxuICAgICAgb3Blbk9uRm9jdXMgPSBfcHJvcHMkb3Blbk9uRm9jdXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJG9wZW5PbkZvY3VzLFxuICAgICAgb3B0aW9ucyA9IHByb3BzLm9wdGlvbnMsXG4gICAgICBfcHJvcHMkc2VsZWN0T25Gb2N1cyA9IHByb3BzLnNlbGVjdE9uRm9jdXMsXG4gICAgICBzZWxlY3RPbkZvY3VzID0gX3Byb3BzJHNlbGVjdE9uRm9jdXMgPT09IHZvaWQgMCA/ICFwcm9wcy5mcmVlU29sbyA6IF9wcm9wcyRzZWxlY3RPbkZvY3VzLFxuICAgICAgdmFsdWVQcm9wID0gcHJvcHMudmFsdWU7XG4gIHZhciBpZCA9IHVzZUlkKGlkUHJvcCk7XG4gIHZhciBnZXRPcHRpb25MYWJlbCA9IGdldE9wdGlvbkxhYmVsUHJvcDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGdldE9wdGlvbkxhYmVsID0gZnVuY3Rpb24gZ2V0T3B0aW9uTGFiZWwob3B0aW9uKSB7XG4gICAgICB2YXIgb3B0aW9uTGFiZWwgPSBnZXRPcHRpb25MYWJlbFByb3Aob3B0aW9uKTtcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25MYWJlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGVycm9uZW91c1JldHVybiA9IG9wdGlvbkxhYmVsID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJyA6IFwiXCIuY29uY2F0KF90eXBlb2Yob3B0aW9uTGFiZWwpLCBcIiAoXCIpLmNvbmNhdChvcHRpb25MYWJlbCwgXCIpXCIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTWF0ZXJpYWwtVUk6IFRoZSBgZ2V0T3B0aW9uTGFiZWxgIG1ldGhvZCBvZiBcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCIgcmV0dXJuZWQgXCIpLmNvbmNhdChlcnJvbmVvdXNSZXR1cm4sIFwiIGluc3RlYWQgb2YgYSBzdHJpbmcgZm9yIFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkob3B0aW9uKSwgXCIuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvbkxhYmVsO1xuICAgIH07XG4gIH1cblxuICB2YXIgaWdub3JlRm9jdXMgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICB2YXIgZmlyc3RGb2N1cyA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgdmFyIGlucHV0UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgbGlzdGJveFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUobnVsbCksXG4gICAgICBhbmNob3JFbCA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldEFuY2hvckVsID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUyID0gUmVhY3QudXNlU3RhdGUoLTEpLFxuICAgICAgZm9jdXNlZFRhZyA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRGb2N1c2VkVGFnID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICB2YXIgZGVmYXVsdEhpZ2hsaWdodGVkID0gYXV0b0hpZ2hsaWdodCA/IDAgOiAtMTtcbiAgdmFyIGhpZ2hsaWdodGVkSW5kZXhSZWYgPSBSZWFjdC51c2VSZWYoZGVmYXVsdEhpZ2hsaWdodGVkKTtcblxuICB2YXIgX3VzZUNvbnRyb2xsZWQgPSB1c2VDb250cm9sbGVkKHtcbiAgICBjb250cm9sbGVkOiB2YWx1ZVByb3AsXG4gICAgZGVmYXVsdDogZGVmYXVsdFZhbHVlLFxuICAgIG5hbWU6IGNvbXBvbmVudE5hbWVcbiAgfSksXG4gICAgICBfdXNlQ29udHJvbGxlZDIgPSBfc2xpY2VkVG9BcnJheShfdXNlQ29udHJvbGxlZCwgMiksXG4gICAgICB2YWx1ZSA9IF91c2VDb250cm9sbGVkMlswXSxcbiAgICAgIHNldFZhbHVlID0gX3VzZUNvbnRyb2xsZWQyWzFdO1xuXG4gIHZhciBfdXNlQ29udHJvbGxlZDMgPSB1c2VDb250cm9sbGVkKHtcbiAgICBjb250cm9sbGVkOiBpbnB1dFZhbHVlUHJvcCxcbiAgICBkZWZhdWx0OiAnJyxcbiAgICBuYW1lOiBjb21wb25lbnROYW1lLFxuICAgIHN0YXRlOiAnaW5wdXRWYWx1ZSdcbiAgfSksXG4gICAgICBfdXNlQ29udHJvbGxlZDQgPSBfc2xpY2VkVG9BcnJheShfdXNlQ29udHJvbGxlZDMsIDIpLFxuICAgICAgaW5wdXRWYWx1ZSA9IF91c2VDb250cm9sbGVkNFswXSxcbiAgICAgIHNldElucHV0VmFsdWUgPSBfdXNlQ29udHJvbGxlZDRbMV07XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTMgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgICBmb2N1c2VkID0gX1JlYWN0JHVzZVN0YXRlM1swXSxcbiAgICAgIHNldEZvY3VzZWQgPSBfUmVhY3QkdXNlU3RhdGUzWzFdO1xuXG4gIHZhciByZXNldElucHV0VmFsdWUgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChldmVudCwgbmV3VmFsdWUpIHtcbiAgICB2YXIgbmV3SW5wdXRWYWx1ZTtcblxuICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgbmV3SW5wdXRWYWx1ZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAobmV3VmFsdWUgPT0gbnVsbCkge1xuICAgICAgbmV3SW5wdXRWYWx1ZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3B0aW9uTGFiZWwgPSBnZXRPcHRpb25MYWJlbChuZXdWYWx1ZSk7XG4gICAgICBuZXdJbnB1dFZhbHVlID0gdHlwZW9mIG9wdGlvbkxhYmVsID09PSAnc3RyaW5nJyA/IG9wdGlvbkxhYmVsIDogJyc7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0VmFsdWUgPT09IG5ld0lucHV0VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRJbnB1dFZhbHVlKG5ld0lucHV0VmFsdWUpO1xuXG4gICAgaWYgKG9uSW5wdXRDaGFuZ2UpIHtcbiAgICAgIG9uSW5wdXRDaGFuZ2UoZXZlbnQsIG5ld0lucHV0VmFsdWUsICdyZXNldCcpO1xuICAgIH1cbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVzZXRJbnB1dFZhbHVlKG51bGwsIHZhbHVlKTtcbiAgfSwgW3ZhbHVlLCByZXNldElucHV0VmFsdWVdKTtcblxuICB2YXIgX3VzZUNvbnRyb2xsZWQ1ID0gdXNlQ29udHJvbGxlZCh7XG4gICAgY29udHJvbGxlZDogb3BlblByb3AsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgbmFtZTogY29tcG9uZW50TmFtZSxcbiAgICBzdGF0ZTogJ29wZW4nXG4gIH0pLFxuICAgICAgX3VzZUNvbnRyb2xsZWQ2ID0gX3NsaWNlZFRvQXJyYXkoX3VzZUNvbnRyb2xsZWQ1LCAyKSxcbiAgICAgIG9wZW4gPSBfdXNlQ29udHJvbGxlZDZbMF0sXG4gICAgICBzZXRPcGVuU3RhdGUgPSBfdXNlQ29udHJvbGxlZDZbMV07XG5cbiAgdmFyIGlucHV0VmFsdWVJc1NlbGVjdGVkVmFsdWUgPSAhbXVsdGlwbGUgJiYgdmFsdWUgIT0gbnVsbCAmJiBpbnB1dFZhbHVlID09PSBnZXRPcHRpb25MYWJlbCh2YWx1ZSk7XG4gIHZhciBwb3B1cE9wZW4gPSBvcGVuO1xuICB2YXIgZmlsdGVyZWRPcHRpb25zID0gcG9wdXBPcGVuID8gZmlsdGVyT3B0aW9ucyhvcHRpb25zLmZpbHRlcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgaWYgKGZpbHRlclNlbGVjdGVkT3B0aW9ucyAmJiAobXVsdGlwbGUgPyB2YWx1ZSA6IFt2YWx1ZV0pLnNvbWUoZnVuY3Rpb24gKHZhbHVlMikge1xuICAgICAgcmV0dXJuIHZhbHVlMiAhPT0gbnVsbCAmJiBnZXRPcHRpb25TZWxlY3RlZChvcHRpb24sIHZhbHVlMik7XG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSksIC8vIHdlIHVzZSB0aGUgZW1wdHkgc3RyaW5nIHRvIG1hbmlwdWxhdGUgYGZpbHRlck9wdGlvbnNgIHRvIG5vdCBmaWx0ZXIgYW55IG9wdGlvbnNcbiAgLy8gaS5lLiB0aGUgZmlsdGVyIHByZWRpY2F0ZSBhbHdheXMgcmV0dXJucyB0cnVlXG4gIHtcbiAgICBpbnB1dFZhbHVlOiBpbnB1dFZhbHVlSXNTZWxlY3RlZFZhbHVlID8gJycgOiBpbnB1dFZhbHVlLFxuICAgIGdldE9wdGlvbkxhYmVsOiBnZXRPcHRpb25MYWJlbFxuICB9KSA6IFtdO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmICFmcmVlU29sbyAmJiBvcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBtaXNzaW5nVmFsdWUgPSAobXVsdGlwbGUgPyB2YWx1ZSA6IFt2YWx1ZV0pLmZpbHRlcihmdW5jdGlvbiAodmFsdWUyKSB7XG4gICAgICAgIHJldHVybiAhb3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICByZXR1cm4gZ2V0T3B0aW9uU2VsZWN0ZWQob3B0aW9uLCB2YWx1ZTIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobWlzc2luZ1ZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFtcIk1hdGVyaWFsLVVJOiBUaGUgdmFsdWUgcHJvdmlkZWQgdG8gXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiIGlzIGludmFsaWQuXCIpLCBcIk5vbmUgb2YgdGhlIG9wdGlvbnMgbWF0Y2ggd2l0aCBgXCIuY29uY2F0KG1pc3NpbmdWYWx1ZS5sZW5ndGggPiAxID8gSlNPTi5zdHJpbmdpZnkobWlzc2luZ1ZhbHVlKSA6IEpTT04uc3RyaW5naWZ5KG1pc3NpbmdWYWx1ZVswXSksIFwiYC5cIiksICdZb3UgY2FuIHVzZSB0aGUgYGdldE9wdGlvblNlbGVjdGVkYCBwcm9wIHRvIGN1c3RvbWl6ZSB0aGUgZXF1YWxpdHkgdGVzdC4nXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGZvY3VzVGFnID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAodGFnVG9Gb2N1cykge1xuICAgIGlmICh0YWdUb0ZvY3VzID09PSAtMSkge1xuICAgICAgaW5wdXRSZWYuY3VycmVudC5mb2N1cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmNob3JFbC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtdGFnLWluZGV4PVxcXCJcIi5jb25jYXQodGFnVG9Gb2N1cywgXCJcXFwiXVwiKSkuZm9jdXMoKTtcbiAgICB9XG4gIH0pOyAvLyBFbnN1cmUgdGhlIGZvY3VzZWRUYWcgaXMgbmV2ZXIgaW5jb25zaXN0ZW50XG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobXVsdGlwbGUgJiYgZm9jdXNlZFRhZyA+IHZhbHVlLmxlbmd0aCAtIDEpIHtcbiAgICAgIHNldEZvY3VzZWRUYWcoLTEpO1xuICAgICAgZm9jdXNUYWcoLTEpO1xuICAgIH1cbiAgfSwgW3ZhbHVlLCBtdWx0aXBsZSwgZm9jdXNlZFRhZywgZm9jdXNUYWddKTtcblxuICBmdW5jdGlvbiB2YWxpZE9wdGlvbkluZGV4KGluZGV4LCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoIWxpc3Rib3hSZWYuY3VycmVudCB8fCBpbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEZvY3VzID0gaW5kZXg7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gT3V0IG9mIHJhbmdlXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAnbmV4dCcgJiYgbmV4dEZvY3VzID09PSBmaWx0ZXJlZE9wdGlvbnMubGVuZ3RoIHx8IGRpcmVjdGlvbiA9PT0gJ3ByZXZpb3VzJyAmJiBuZXh0Rm9jdXMgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wdGlvbiA9IGxpc3Rib3hSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtb3B0aW9uLWluZGV4PVxcXCJcIi5jb25jYXQobmV4dEZvY3VzLCBcIlxcXCJdXCIpKTsgLy8gU2FtZSBsb2dpYyBhcyBNZW51TGlzdC5qc1xuXG4gICAgICB2YXIgbmV4dEZvY3VzRGlzYWJsZWQgPSBkaXNhYmxlZEl0ZW1zRm9jdXNhYmxlID8gZmFsc2UgOiBvcHRpb24gJiYgKG9wdGlvbi5kaXNhYmxlZCB8fCBvcHRpb24uZ2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJykgPT09ICd0cnVlJyk7XG5cbiAgICAgIGlmIChvcHRpb24gJiYgIW9wdGlvbi5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykgfHwgbmV4dEZvY3VzRGlzYWJsZWQpIHtcbiAgICAgICAgLy8gTW92ZSB0byB0aGUgbmV4dCBlbGVtZW50LlxuICAgICAgICBuZXh0Rm9jdXMgKz0gZGlyZWN0aW9uID09PSAnbmV4dCcgPyAxIDogLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV4dEZvY3VzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBzZXRIaWdobGlnaHRlZEluZGV4ID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgZXZlbnQgPSBfcmVmMi5ldmVudCxcbiAgICAgICAgaW5kZXggPSBfcmVmMi5pbmRleCxcbiAgICAgICAgX3JlZjIkcmVhc29uID0gX3JlZjIucmVhc29uLFxuICAgICAgICByZWFzb24gPSBfcmVmMiRyZWFzb24gPT09IHZvaWQgMCA/ICdhdXRvJyA6IF9yZWYyJHJlYXNvbjtcbiAgICBoaWdobGlnaHRlZEluZGV4UmVmLmN1cnJlbnQgPSBpbmRleDsgLy8gZG9lcyB0aGUgaW5kZXggZXhpc3Q/XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICBpbnB1dFJlZi5jdXJyZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1hY3RpdmVkZXNjZW5kYW50Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0UmVmLmN1cnJlbnQuc2V0QXR0cmlidXRlKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCBcIlwiLmNvbmNhdChpZCwgXCItb3B0aW9uLVwiKS5jb25jYXQoaW5kZXgpKTtcbiAgICB9XG5cbiAgICBpZiAob25IaWdobGlnaHRDaGFuZ2UpIHtcbiAgICAgIG9uSGlnaGxpZ2h0Q2hhbmdlKGV2ZW50LCBpbmRleCA9PT0gLTEgPyBudWxsIDogZmlsdGVyZWRPcHRpb25zW2luZGV4XSwgcmVhc29uKTtcbiAgICB9XG5cbiAgICBpZiAoIWxpc3Rib3hSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcmV2ID0gbGlzdGJveFJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWZvY3VzXScpO1xuXG4gICAgaWYgKHByZXYpIHtcbiAgICAgIHByZXYucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWZvY3VzJyk7XG4gICAgfVxuXG4gICAgdmFyIGxpc3Rib3hOb2RlID0gbGlzdGJveFJlZi5jdXJyZW50LnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcignW3JvbGU9XCJsaXN0Ym94XCJdJyk7IC8vIFwiTm8gcmVzdWx0c1wiXG5cbiAgICBpZiAoIWxpc3Rib3hOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgbGlzdGJveE5vZGUuc2Nyb2xsVG9wID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3B0aW9uID0gbGlzdGJveFJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1vcHRpb24taW5kZXg9XFxcIlwiLmNvbmNhdChpbmRleCwgXCJcXFwiXVwiKSk7XG5cbiAgICBpZiAoIW9wdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoJ2RhdGEtZm9jdXMnLCAndHJ1ZScpOyAvLyBTY3JvbGwgYWN0aXZlIGRlc2NlbmRhbnQgaW50byB2aWV3LlxuICAgIC8vIExvZ2ljIGNvcGllZCBmcm9tIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS1wcmFjdGljZXMvZXhhbXBsZXMvbGlzdGJveC9qcy9saXN0Ym94LmpzXG4gICAgLy9cbiAgICAvLyBDb25zaWRlciB0aGlzIEFQSSBpbnN0ZWFkIG9uY2UgaXQgaGFzIGEgYmV0dGVyIGJyb3dzZXIgc3VwcG9ydDpcbiAgICAvLyAuc2Nyb2xsSW50b1ZpZXcoeyBzY3JvbGxNb2RlOiAnaWYtbmVlZGVkJywgYmxvY2s6ICduZWFyZXN0JyB9KTtcblxuICAgIGlmIChsaXN0Ym94Tm9kZS5zY3JvbGxIZWlnaHQgPiBsaXN0Ym94Tm9kZS5jbGllbnRIZWlnaHQgJiYgcmVhc29uICE9PSAnbW91c2UnKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IG9wdGlvbjtcbiAgICAgIHZhciBzY3JvbGxCb3R0b20gPSBsaXN0Ym94Tm9kZS5jbGllbnRIZWlnaHQgKyBsaXN0Ym94Tm9kZS5zY3JvbGxUb3A7XG4gICAgICB2YXIgZWxlbWVudEJvdHRvbSA9IGVsZW1lbnQub2Zmc2V0VG9wICsgZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIGlmIChlbGVtZW50Qm90dG9tID4gc2Nyb2xsQm90dG9tKSB7XG4gICAgICAgIGxpc3Rib3hOb2RlLnNjcm9sbFRvcCA9IGVsZW1lbnRCb3R0b20gLSBsaXN0Ym94Tm9kZS5jbGllbnRIZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQub2Zmc2V0VG9wIC0gZWxlbWVudC5vZmZzZXRIZWlnaHQgKiAoZ3JvdXBCeSA/IDEuMyA6IDApIDwgbGlzdGJveE5vZGUuc2Nyb2xsVG9wKSB7XG4gICAgICAgIGxpc3Rib3hOb2RlLnNjcm9sbFRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wIC0gZWxlbWVudC5vZmZzZXRIZWlnaHQgKiAoZ3JvdXBCeSA/IDEuMyA6IDApO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBjaGFuZ2VIaWdobGlnaHRlZEluZGV4ID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICB2YXIgZXZlbnQgPSBfcmVmMy5ldmVudCxcbiAgICAgICAgZGlmZiA9IF9yZWYzLmRpZmYsXG4gICAgICAgIF9yZWYzJGRpcmVjdGlvbiA9IF9yZWYzLmRpcmVjdGlvbixcbiAgICAgICAgZGlyZWN0aW9uID0gX3JlZjMkZGlyZWN0aW9uID09PSB2b2lkIDAgPyAnbmV4dCcgOiBfcmVmMyRkaXJlY3Rpb24sXG4gICAgICAgIF9yZWYzJHJlYXNvbiA9IF9yZWYzLnJlYXNvbixcbiAgICAgICAgcmVhc29uID0gX3JlZjMkcmVhc29uID09PSB2b2lkIDAgPyAnYXV0bycgOiBfcmVmMyRyZWFzb247XG5cbiAgICBpZiAoIXBvcHVwT3Blbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBnZXROZXh0SW5kZXggPSBmdW5jdGlvbiBnZXROZXh0SW5kZXgoKSB7XG4gICAgICB2YXIgbWF4SW5kZXggPSBmaWx0ZXJlZE9wdGlvbnMubGVuZ3RoIC0gMTtcblxuICAgICAgaWYgKGRpZmYgPT09ICdyZXNldCcpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRIaWdobGlnaHRlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpZmYgPT09ICdzdGFydCcpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWZmID09PSAnZW5kJykge1xuICAgICAgICByZXR1cm4gbWF4SW5kZXg7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdJbmRleCA9IGhpZ2hsaWdodGVkSW5kZXhSZWYuY3VycmVudCArIGRpZmY7XG5cbiAgICAgIGlmIChuZXdJbmRleCA8IDApIHtcbiAgICAgICAgaWYgKG5ld0luZGV4ID09PSAtMSAmJiBpbmNsdWRlSW5wdXRJbkxpc3QpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlzYWJsZUxpc3RXcmFwICYmIGhpZ2hsaWdodGVkSW5kZXhSZWYuY3VycmVudCAhPT0gLTEgfHwgTWF0aC5hYnMoZGlmZikgPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF4SW5kZXg7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdJbmRleCA+IG1heEluZGV4KSB7XG4gICAgICAgIGlmIChuZXdJbmRleCA9PT0gbWF4SW5kZXggKyAxICYmIGluY2x1ZGVJbnB1dEluTGlzdCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXNhYmxlTGlzdFdyYXAgfHwgTWF0aC5hYnMoZGlmZikgPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG1heEluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdJbmRleDtcbiAgICB9O1xuXG4gICAgdmFyIG5leHRJbmRleCA9IHZhbGlkT3B0aW9uSW5kZXgoZ2V0TmV4dEluZGV4KCksIGRpcmVjdGlvbik7XG4gICAgc2V0SGlnaGxpZ2h0ZWRJbmRleCh7XG4gICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICBldmVudDogZXZlbnRcbiAgICB9KTsgLy8gU3luYyB0aGUgY29udGVudCBvZiB0aGUgaW5wdXQgd2l0aCB0aGUgaGlnaGxpZ2h0ZWQgb3B0aW9uLlxuXG4gICAgaWYgKGF1dG9Db21wbGV0ZSAmJiBkaWZmICE9PSAncmVzZXQnKSB7XG4gICAgICBpZiAobmV4dEluZGV4ID09PSAtMSkge1xuICAgICAgICBpbnB1dFJlZi5jdXJyZW50LnZhbHVlID0gaW5wdXRWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcHRpb24gPSBnZXRPcHRpb25MYWJlbChmaWx0ZXJlZE9wdGlvbnNbbmV4dEluZGV4XSk7XG4gICAgICAgIGlucHV0UmVmLmN1cnJlbnQudmFsdWUgPSBvcHRpb247IC8vIFRoZSBwb3J0aW9uIG9mIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uIHRoYXQgaGFzIG5vdCBiZWVuIHR5cGVkIGJ5IHRoZSB1c2VyLFxuICAgICAgICAvLyBhIGNvbXBsZXRpb24gc3RyaW5nLCBhcHBlYXJzIGlubGluZSBhZnRlciB0aGUgaW5wdXQgY3Vyc29yIGluIHRoZSB0ZXh0Ym94LlxuXG4gICAgICAgIHZhciBpbmRleCA9IG9wdGlvbi50b0xvd2VyQ2FzZSgpLmluZGV4T2YoaW5wdXRWYWx1ZS50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgaW5wdXRWYWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaW5wdXRSZWYuY3VycmVudC5zZXRTZWxlY3Rpb25SYW5nZShpbnB1dFZhbHVlLmxlbmd0aCwgb3B0aW9uLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB2YXIgc3luY0hpZ2hsaWdodGVkSW5kZXggPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwb3B1cE9wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVJdGVtID0gbXVsdGlwbGUgPyB2YWx1ZVswXSA6IHZhbHVlOyAvLyBUaGUgcG9wdXAgaXMgZW1wdHksIHJlc2V0XG5cbiAgICBpZiAoZmlsdGVyZWRPcHRpb25zLmxlbmd0aCA9PT0gMCB8fCB2YWx1ZUl0ZW0gPT0gbnVsbCkge1xuICAgICAgY2hhbmdlSGlnaGxpZ2h0ZWRJbmRleCh7XG4gICAgICAgIGRpZmY6ICdyZXNldCdcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghbGlzdGJveFJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBTeW5jaHJvbml6ZSB0aGUgdmFsdWUgd2l0aCB0aGUgaGlnaGxpZ2h0ZWQgaW5kZXhcblxuXG4gICAgaWYgKCFmaWx0ZXJTZWxlY3RlZE9wdGlvbnMgJiYgdmFsdWVJdGVtICE9IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50T3B0aW9uID0gZmlsdGVyZWRPcHRpb25zW2hpZ2hsaWdodGVkSW5kZXhSZWYuY3VycmVudF07IC8vIEtlZXAgdGhlIGN1cnJlbnQgaGlnaGxpZ2h0ZWQgaW5kZXggaWYgcG9zc2libGVcblxuICAgICAgaWYgKG11bHRpcGxlICYmIGN1cnJlbnRPcHRpb24gJiYgZmluZEluZGV4KHZhbHVlLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiBnZXRPcHRpb25TZWxlY3RlZChjdXJyZW50T3B0aW9uLCB2YWwpO1xuICAgICAgfSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZW1JbmRleCA9IGZpbmRJbmRleChmaWx0ZXJlZE9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb25JdGVtKSB7XG4gICAgICAgIHJldHVybiBnZXRPcHRpb25TZWxlY3RlZChvcHRpb25JdGVtLCB2YWx1ZUl0ZW0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICAgIGNoYW5nZUhpZ2hsaWdodGVkSW5kZXgoe1xuICAgICAgICAgIGRpZmY6ICdyZXNldCdcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRIaWdobGlnaHRlZEluZGV4KHtcbiAgICAgICAgICBpbmRleDogaXRlbUluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBQcmV2ZW50IHRoZSBoaWdobGlnaHRlZCBpbmRleCB0byBsZWFrIG91dHNpZGUgdGhlIGJvdW5kYXJpZXMuXG5cblxuICAgIGlmIChoaWdobGlnaHRlZEluZGV4UmVmLmN1cnJlbnQgPj0gZmlsdGVyZWRPcHRpb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgIHNldEhpZ2hsaWdodGVkSW5kZXgoe1xuICAgICAgICBpbmRleDogZmlsdGVyZWRPcHRpb25zLmxlbmd0aCAtIDFcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gUmVzdG9yZSB0aGUgZm9jdXMgdG8gdGhlIHByZXZpb3VzIGluZGV4LlxuXG5cbiAgICBzZXRIaWdobGlnaHRlZEluZGV4KHtcbiAgICAgIGluZGV4OiBoaWdobGlnaHRlZEluZGV4UmVmLmN1cnJlbnRcbiAgICB9KTsgLy8gSWdub3JlIGZpbHRlcmVkT3B0aW9ucyAoYW5kIG9wdGlvbnMsIGdldE9wdGlvblNlbGVjdGVkLCBnZXRPcHRpb25MYWJlbCkgbm90IHRvIGJyZWFrIHRoZSBzY3JvbGwgcG9zaXRpb25cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFsvLyBPbmx5IHN5bmMgdGhlIGhpZ2hsaWdodGVkIGluZGV4IHdoZW4gdGhlIG9wdGlvbiBzd2l0Y2ggYmV0d2VlbiBlbXB0eSBhbmQgbm90XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgZmlsdGVyZWRPcHRpb25zLmxlbmd0aCA9PT0gMCwgLy8gRG9uJ3Qgc3luYyB0aGUgaGlnaGxpZ2h0ZWQgaW5kZXggd2l0aCB0aGUgdmFsdWUgd2hlbiBtdWx0aXBsZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIG11bHRpcGxlID8gZmFsc2UgOiB2YWx1ZSwgZmlsdGVyU2VsZWN0ZWRPcHRpb25zLCBjaGFuZ2VIaWdobGlnaHRlZEluZGV4LCBzZXRIaWdobGlnaHRlZEluZGV4LCBwb3B1cE9wZW4sIGlucHV0VmFsdWUsIG11bHRpcGxlXSk7XG4gIHZhciBoYW5kbGVMaXN0Ym94UmVmID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAobm9kZSkge1xuICAgIHNldFJlZihsaXN0Ym94UmVmLCBub2RlKTtcblxuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN5bmNIaWdobGlnaHRlZEluZGV4KCk7XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHN5bmNIaWdobGlnaHRlZEluZGV4KCk7XG4gIH0sIFtzeW5jSGlnaGxpZ2h0ZWRJbmRleF0pO1xuXG4gIHZhciBoYW5kbGVPcGVuID0gZnVuY3Rpb24gaGFuZGxlT3BlbihldmVudCkge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0T3BlblN0YXRlKHRydWUpO1xuXG4gICAgaWYgKG9uT3Blbikge1xuICAgICAgb25PcGVuKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUNsb3NlID0gZnVuY3Rpb24gaGFuZGxlQ2xvc2UoZXZlbnQsIHJlYXNvbikge1xuICAgIGlmICghb3Blbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldE9wZW5TdGF0ZShmYWxzZSk7XG5cbiAgICBpZiAob25DbG9zZSkge1xuICAgICAgb25DbG9zZShldmVudCwgcmVhc29uKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZVZhbHVlID0gZnVuY3Rpb24gaGFuZGxlVmFsdWUoZXZlbnQsIG5ld1ZhbHVlLCByZWFzb24sIGRldGFpbHMpIHtcbiAgICBpZiAodmFsdWUgPT09IG5ld1ZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICBvbkNoYW5nZShldmVudCwgbmV3VmFsdWUsIHJlYXNvbiwgZGV0YWlscyk7XG4gICAgfVxuXG4gICAgc2V0VmFsdWUobmV3VmFsdWUpO1xuICB9O1xuXG4gIHZhciBpc1RvdWNoID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcblxuICB2YXIgc2VsZWN0TmV3VmFsdWUgPSBmdW5jdGlvbiBzZWxlY3ROZXdWYWx1ZShldmVudCwgb3B0aW9uKSB7XG4gICAgdmFyIHJlYXNvblByb3AgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdzZWxlY3Qtb3B0aW9uJztcbiAgICB2YXIgb3JpZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnb3B0aW9ucyc7XG4gICAgdmFyIHJlYXNvbiA9IHJlYXNvblByb3A7XG4gICAgdmFyIG5ld1ZhbHVlID0gb3B0aW9uO1xuXG4gICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICBuZXdWYWx1ZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuc2xpY2UoKSA6IFtdO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IG5ld1ZhbHVlLmZpbHRlcihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIGdldE9wdGlvblNlbGVjdGVkKG9wdGlvbiwgdmFsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoW1wiTWF0ZXJpYWwtVUk6IFRoZSBgZ2V0T3B0aW9uU2VsZWN0ZWRgIG1ldGhvZCBvZiBcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCIgZG8gbm90IGhhbmRsZSB0aGUgYXJndW1lbnRzIGNvcnJlY3RseS5cIiksIFwiVGhlIGNvbXBvbmVudCBleHBlY3RzIGEgc2luZ2xlIHZhbHVlIHRvIG1hdGNoIGEgZ2l2ZW4gb3B0aW9uIGJ1dCBmb3VuZCBcIi5jb25jYXQobWF0Y2hlcy5sZW5ndGgsIFwiIG1hdGNoZXMuXCIpXS5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZW1JbmRleCA9IGZpbmRJbmRleChuZXdWYWx1ZSwgZnVuY3Rpb24gKHZhbHVlSXRlbSkge1xuICAgICAgICByZXR1cm4gZ2V0T3B0aW9uU2VsZWN0ZWQob3B0aW9uLCB2YWx1ZUl0ZW0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICAgIG5ld1ZhbHVlLnB1c2gob3B0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAob3JpZ2luICE9PSAnZnJlZVNvbG8nKSB7XG4gICAgICAgIG5ld1ZhbHVlLnNwbGljZShpdGVtSW5kZXgsIDEpO1xuICAgICAgICByZWFzb24gPSAncmVtb3ZlLW9wdGlvbic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXRJbnB1dFZhbHVlKGV2ZW50LCBuZXdWYWx1ZSk7XG4gICAgaGFuZGxlVmFsdWUoZXZlbnQsIG5ld1ZhbHVlLCByZWFzb24sIHtcbiAgICAgIG9wdGlvbjogb3B0aW9uXG4gICAgfSk7XG5cbiAgICBpZiAoIWRpc2FibGVDbG9zZU9uU2VsZWN0KSB7XG4gICAgICBoYW5kbGVDbG9zZShldmVudCwgcmVhc29uKTtcbiAgICB9XG5cbiAgICBpZiAoYmx1ck9uU2VsZWN0ID09PSB0cnVlIHx8IGJsdXJPblNlbGVjdCA9PT0gJ3RvdWNoJyAmJiBpc1RvdWNoLmN1cnJlbnQgfHwgYmx1ck9uU2VsZWN0ID09PSAnbW91c2UnICYmICFpc1RvdWNoLmN1cnJlbnQpIHtcbiAgICAgIGlucHV0UmVmLmN1cnJlbnQuYmx1cigpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB2YWxpZFRhZ0luZGV4KGluZGV4LCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgdmFyIG5leHRGb2N1cyA9IGluZGV4O1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIE91dCBvZiByYW5nZVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ25leHQnICYmIG5leHRGb2N1cyA9PT0gdmFsdWUubGVuZ3RoIHx8IGRpcmVjdGlvbiA9PT0gJ3ByZXZpb3VzJyAmJiBuZXh0Rm9jdXMgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wdGlvbiA9IGFuY2hvckVsLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS10YWctaW5kZXg9XFxcIlwiLmNvbmNhdChuZXh0Rm9jdXMsIFwiXFxcIl1cIikpOyAvLyBTYW1lIGxvZ2ljIGFzIE1lbnVMaXN0LmpzXG5cbiAgICAgIGlmIChvcHRpb24gJiYgKCFvcHRpb24uaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpIHx8IG9wdGlvbi5kaXNhYmxlZCB8fCBvcHRpb24uZ2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJykgPT09ICd0cnVlJykpIHtcbiAgICAgICAgbmV4dEZvY3VzICs9IGRpcmVjdGlvbiA9PT0gJ25leHQnID8gMSA6IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5leHRGb2N1cztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaGFuZGxlRm9jdXNUYWcgPSBmdW5jdGlvbiBoYW5kbGVGb2N1c1RhZyhldmVudCwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKCFtdWx0aXBsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhhbmRsZUNsb3NlKGV2ZW50LCAndG9nZ2xlSW5wdXQnKTtcbiAgICB2YXIgbmV4dFRhZyA9IGZvY3VzZWRUYWc7XG5cbiAgICBpZiAoZm9jdXNlZFRhZyA9PT0gLTEpIHtcbiAgICAgIGlmIChpbnB1dFZhbHVlID09PSAnJyAmJiBkaXJlY3Rpb24gPT09ICdwcmV2aW91cycpIHtcbiAgICAgICAgbmV4dFRhZyA9IHZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRUYWcgKz0gZGlyZWN0aW9uID09PSAnbmV4dCcgPyAxIDogLTE7XG5cbiAgICAgIGlmIChuZXh0VGFnIDwgMCkge1xuICAgICAgICBuZXh0VGFnID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRUYWcgPT09IHZhbHVlLmxlbmd0aCkge1xuICAgICAgICBuZXh0VGFnID0gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV4dFRhZyA9IHZhbGlkVGFnSW5kZXgobmV4dFRhZywgZGlyZWN0aW9uKTtcbiAgICBzZXRGb2N1c2VkVGFnKG5leHRUYWcpO1xuICAgIGZvY3VzVGFnKG5leHRUYWcpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVDbGVhciA9IGZ1bmN0aW9uIGhhbmRsZUNsZWFyKGV2ZW50KSB7XG4gICAgaWdub3JlRm9jdXMuY3VycmVudCA9IHRydWU7XG4gICAgc2V0SW5wdXRWYWx1ZSgnJyk7XG5cbiAgICBpZiAob25JbnB1dENoYW5nZSkge1xuICAgICAgb25JbnB1dENoYW5nZShldmVudCwgJycsICdjbGVhcicpO1xuICAgIH1cblxuICAgIGhhbmRsZVZhbHVlKGV2ZW50LCBtdWx0aXBsZSA/IFtdIDogbnVsbCwgJ2NsZWFyJyk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUtleURvd24gPSBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKG90aGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGZvY3VzZWRUYWcgIT09IC0xICYmIFsnQXJyb3dMZWZ0JywgJ0Fycm93UmlnaHQnXS5pbmRleE9mKGV2ZW50LmtleSkgPT09IC0xKSB7XG4gICAgICAgIHNldEZvY3VzZWRUYWcoLTEpO1xuICAgICAgICBmb2N1c1RhZygtMSk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgIGNhc2UgJ0hvbWUnOlxuICAgICAgICAgIGlmIChwb3B1cE9wZW4gJiYgaGFuZGxlSG9tZUVuZEtleXMpIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsIG9mIHRoZSBwYWdlXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY2hhbmdlSGlnaGxpZ2h0ZWRJbmRleCh7XG4gICAgICAgICAgICAgIGRpZmY6ICdzdGFydCcsXG4gICAgICAgICAgICAgIGRpcmVjdGlvbjogJ25leHQnLFxuICAgICAgICAgICAgICByZWFzb246ICdrZXlib2FyZCcsXG4gICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnRW5kJzpcbiAgICAgICAgICBpZiAocG9wdXBPcGVuICYmIGhhbmRsZUhvbWVFbmRLZXlzKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbCBvZiB0aGUgcGFnZVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNoYW5nZUhpZ2hsaWdodGVkSW5kZXgoe1xuICAgICAgICAgICAgICBkaWZmOiAnZW5kJyxcbiAgICAgICAgICAgICAgZGlyZWN0aW9uOiAncHJldmlvdXMnLFxuICAgICAgICAgICAgICByZWFzb246ICdrZXlib2FyZCcsXG4gICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUGFnZVVwJzpcbiAgICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbCBvZiB0aGUgcGFnZVxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgY2hhbmdlSGlnaGxpZ2h0ZWRJbmRleCh7XG4gICAgICAgICAgICBkaWZmOiAtcGFnZVNpemUsXG4gICAgICAgICAgICBkaXJlY3Rpb246ICdwcmV2aW91cycsXG4gICAgICAgICAgICByZWFzb246ICdrZXlib2FyZCcsXG4gICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBoYW5kbGVPcGVuKGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdQYWdlRG93bic6XG4gICAgICAgICAgLy8gUHJldmVudCBzY3JvbGwgb2YgdGhlIHBhZ2VcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNoYW5nZUhpZ2hsaWdodGVkSW5kZXgoe1xuICAgICAgICAgICAgZGlmZjogcGFnZVNpemUsXG4gICAgICAgICAgICBkaXJlY3Rpb246ICduZXh0JyxcbiAgICAgICAgICAgIHJlYXNvbjogJ2tleWJvYXJkJyxcbiAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGhhbmRsZU9wZW4oZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgLy8gUHJldmVudCBjdXJzb3IgbW92ZVxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgY2hhbmdlSGlnaGxpZ2h0ZWRJbmRleCh7XG4gICAgICAgICAgICBkaWZmOiAxLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAnbmV4dCcsXG4gICAgICAgICAgICByZWFzb246ICdrZXlib2FyZCcsXG4gICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBoYW5kbGVPcGVuKGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAvLyBQcmV2ZW50IGN1cnNvciBtb3ZlXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBjaGFuZ2VIaWdobGlnaHRlZEluZGV4KHtcbiAgICAgICAgICAgIGRpZmY6IC0xLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAncHJldmlvdXMnLFxuICAgICAgICAgICAgcmVhc29uOiAna2V5Ym9hcmQnLFxuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaGFuZGxlT3BlbihldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgICBoYW5kbGVGb2N1c1RhZyhldmVudCwgJ3ByZXZpb3VzJyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICAgICAgaGFuZGxlRm9jdXNUYWcoZXZlbnQsICduZXh0Jyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgIC8vIFdhaXQgdW50aWwgSU1FIGlzIHNldHRsZWQuXG4gICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSAyMjkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoaWdobGlnaHRlZEluZGV4UmVmLmN1cnJlbnQgIT09IC0xICYmIHBvcHVwT3Blbikge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGZpbHRlcmVkT3B0aW9uc1toaWdobGlnaHRlZEluZGV4UmVmLmN1cnJlbnRdO1xuICAgICAgICAgICAgdmFyIGRpc2FibGVkID0gZ2V0T3B0aW9uRGlzYWJsZWQgPyBnZXRPcHRpb25EaXNhYmxlZChvcHRpb24pIDogZmFsc2U7IC8vIFdlIGRvbid0IHdhbnQgdG8gdmFsaWRhdGUgdGhlIGZvcm0uXG5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGVjdE5ld1ZhbHVlKGV2ZW50LCBvcHRpb24sICdzZWxlY3Qtb3B0aW9uJyk7IC8vIE1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgZW5kLlxuXG4gICAgICAgICAgICBpZiAoYXV0b0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgIGlucHV0UmVmLmN1cnJlbnQuc2V0U2VsZWN0aW9uUmFuZ2UoaW5wdXRSZWYuY3VycmVudC52YWx1ZS5sZW5ndGgsIGlucHV0UmVmLmN1cnJlbnQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGZyZWVTb2xvICYmIGlucHV0VmFsdWUgIT09ICcnICYmIGlucHV0VmFsdWVJc1NlbGVjdGVkVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgLy8gQWxsb3cgcGVvcGxlIHRvIGFkZCBuZXcgdmFsdWVzIGJlZm9yZSB0aGV5IHN1Ym1pdCB0aGUgZm9ybS5cbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZWN0TmV3VmFsdWUoZXZlbnQsIGlucHV0VmFsdWUsICdjcmVhdGUtb3B0aW9uJywgJ2ZyZWVTb2xvJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgICBpZiAocG9wdXBPcGVuKSB7XG4gICAgICAgICAgICAvLyBBdm9pZCBPcGVyYSB0byBleGl0IGZ1bGxzY3JlZW4gbW9kZS5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIEF2b2lkIHRoZSBNb2RhbCB0byBoYW5kbGUgdGhlIGV2ZW50LlxuXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGhhbmRsZUNsb3NlKGV2ZW50LCAnZXNjYXBlJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGVhck9uRXNjYXBlICYmIChpbnB1dFZhbHVlICE9PSAnJyB8fCBtdWx0aXBsZSAmJiB2YWx1ZS5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgLy8gQXZvaWQgT3BlcmEgdG8gZXhpdCBmdWxsc2NyZWVuIG1vZGUuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBBdm9pZCB0aGUgTW9kYWwgdG8gaGFuZGxlIHRoZSBldmVudC5cblxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBoYW5kbGVDbGVhcihldmVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQmFja3NwYWNlJzpcbiAgICAgICAgICBpZiAobXVsdGlwbGUgJiYgaW5wdXRWYWx1ZSA9PT0gJycgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZm9jdXNlZFRhZyA9PT0gLTEgPyB2YWx1ZS5sZW5ndGggLSAxIDogZm9jdXNlZFRhZztcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICBuZXdWYWx1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgaGFuZGxlVmFsdWUoZXZlbnQsIG5ld1ZhbHVlLCAncmVtb3ZlLW9wdGlvbicsIHtcbiAgICAgICAgICAgICAgb3B0aW9uOiB2YWx1ZVtpbmRleF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG5cbiAgICAgIGlmIChvdGhlci5vbktleURvd24pIHtcbiAgICAgICAgb3RoZXIub25LZXlEb3duKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBoYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIGhhbmRsZUZvY3VzKGV2ZW50KSB7XG4gICAgc2V0Rm9jdXNlZCh0cnVlKTtcblxuICAgIGlmIChvcGVuT25Gb2N1cyAmJiAhaWdub3JlRm9jdXMuY3VycmVudCkge1xuICAgICAgaGFuZGxlT3BlbihldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVCbHVyID0gZnVuY3Rpb24gaGFuZGxlQmx1cihldmVudCkge1xuICAgIC8vIElnbm9yZSB0aGUgZXZlbnQgd2hlbiB1c2luZyB0aGUgc2Nyb2xsYmFyIHdpdGggSUUgMTFcbiAgICBpZiAobGlzdGJveFJlZi5jdXJyZW50ICE9PSBudWxsICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGxpc3Rib3hSZWYuY3VycmVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBpbnB1dFJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0Rm9jdXNlZChmYWxzZSk7XG4gICAgZmlyc3RGb2N1cy5jdXJyZW50ID0gdHJ1ZTtcbiAgICBpZ25vcmVGb2N1cy5jdXJyZW50ID0gZmFsc2U7XG5cbiAgICBpZiAoZGVidWcgJiYgaW5wdXRWYWx1ZSAhPT0gJycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYXV0b1NlbGVjdCAmJiBoaWdobGlnaHRlZEluZGV4UmVmLmN1cnJlbnQgIT09IC0xICYmIHBvcHVwT3Blbikge1xuICAgICAgc2VsZWN0TmV3VmFsdWUoZXZlbnQsIGZpbHRlcmVkT3B0aW9uc1toaWdobGlnaHRlZEluZGV4UmVmLmN1cnJlbnRdLCAnYmx1cicpO1xuICAgIH0gZWxzZSBpZiAoYXV0b1NlbGVjdCAmJiBmcmVlU29sbyAmJiBpbnB1dFZhbHVlICE9PSAnJykge1xuICAgICAgc2VsZWN0TmV3VmFsdWUoZXZlbnQsIGlucHV0VmFsdWUsICdibHVyJywgJ2ZyZWVTb2xvJyk7XG4gICAgfSBlbHNlIGlmIChjbGVhck9uQmx1cikge1xuICAgICAgcmVzZXRJbnB1dFZhbHVlKGV2ZW50LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlQ2xvc2UoZXZlbnQsICdibHVyJyk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUlucHV0Q2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlSW5wdXRDaGFuZ2UoZXZlbnQpIHtcbiAgICB2YXIgbmV3VmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG5cbiAgICBpZiAoaW5wdXRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIHNldElucHV0VmFsdWUobmV3VmFsdWUpO1xuXG4gICAgICBpZiAob25JbnB1dENoYW5nZSkge1xuICAgICAgICBvbklucHV0Q2hhbmdlKGV2ZW50LCBuZXdWYWx1ZSwgJ2lucHV0Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5ld1ZhbHVlID09PSAnJykge1xuICAgICAgaWYgKCFkaXNhYmxlQ2xlYXJhYmxlICYmICFtdWx0aXBsZSkge1xuICAgICAgICBoYW5kbGVWYWx1ZShldmVudCwgbnVsbCwgJ2NsZWFyJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZU9wZW4oZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlT3B0aW9uTW91c2VPdmVyID0gZnVuY3Rpb24gaGFuZGxlT3B0aW9uTW91c2VPdmVyKGV2ZW50KSB7XG4gICAgc2V0SGlnaGxpZ2h0ZWRJbmRleCh7XG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBpbmRleDogTnVtYmVyKGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLW9wdGlvbi1pbmRleCcpKSxcbiAgICAgIHJlYXNvbjogJ21vdXNlJ1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBoYW5kbGVPcHRpb25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24gaGFuZGxlT3B0aW9uVG91Y2hTdGFydCgpIHtcbiAgICBpc1RvdWNoLmN1cnJlbnQgPSB0cnVlO1xuICB9O1xuXG4gIHZhciBoYW5kbGVPcHRpb25DbGljayA9IGZ1bmN0aW9uIGhhbmRsZU9wdGlvbkNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIGluZGV4ID0gTnVtYmVyKGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLW9wdGlvbi1pbmRleCcpKTtcbiAgICBzZWxlY3ROZXdWYWx1ZShldmVudCwgZmlsdGVyZWRPcHRpb25zW2luZGV4XSwgJ3NlbGVjdC1vcHRpb24nKTtcbiAgICBpc1RvdWNoLmN1cnJlbnQgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgaGFuZGxlVGFnRGVsZXRlID0gZnVuY3Rpb24gaGFuZGxlVGFnRGVsZXRlKGluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gdmFsdWUuc2xpY2UoKTtcbiAgICAgIG5ld1ZhbHVlLnNwbGljZShpbmRleCwgMSk7XG4gICAgICBoYW5kbGVWYWx1ZShldmVudCwgbmV3VmFsdWUsICdyZW1vdmUtb3B0aW9uJywge1xuICAgICAgICBvcHRpb246IHZhbHVlW2luZGV4XVxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wdXBJbmRpY2F0b3IgPSBmdW5jdGlvbiBoYW5kbGVQb3B1cEluZGljYXRvcihldmVudCkge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBoYW5kbGVDbG9zZShldmVudCwgJ3RvZ2dsZUlucHV0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZU9wZW4oZXZlbnQpO1xuICAgIH1cbiAgfTsgLy8gUHJldmVudCBpbnB1dCBibHVyIHdoZW4gaW50ZXJhY3Rpbmcgd2l0aCB0aGUgY29tYm9ib3hcblxuXG4gIHZhciBoYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnaWQnKSAhPT0gaWQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9OyAvLyBGb2N1cyB0aGUgaW5wdXQgd2hlbiBpbnRlcmFjdGluZyB3aXRoIHRoZSBjb21ib2JveFxuXG5cbiAgdmFyIGhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soKSB7XG4gICAgaW5wdXRSZWYuY3VycmVudC5mb2N1cygpO1xuXG4gICAgaWYgKHNlbGVjdE9uRm9jdXMgJiYgZmlyc3RGb2N1cy5jdXJyZW50ICYmIGlucHV0UmVmLmN1cnJlbnQuc2VsZWN0aW9uRW5kIC0gaW5wdXRSZWYuY3VycmVudC5zZWxlY3Rpb25TdGFydCA9PT0gMCkge1xuICAgICAgaW5wdXRSZWYuY3VycmVudC5zZWxlY3QoKTtcbiAgICB9XG5cbiAgICBmaXJzdEZvY3VzLmN1cnJlbnQgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgaGFuZGxlSW5wdXRNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVJbnB1dE1vdXNlRG93bihldmVudCkge1xuICAgIGlmIChpbnB1dFZhbHVlID09PSAnJyB8fCAhb3Blbikge1xuICAgICAgaGFuZGxlUG9wdXBJbmRpY2F0b3IoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZGlydHkgPSBmcmVlU29sbyAmJiBpbnB1dFZhbHVlLmxlbmd0aCA+IDA7XG4gIGRpcnR5ID0gZGlydHkgfHwgKG11bHRpcGxlID8gdmFsdWUubGVuZ3RoID4gMCA6IHZhbHVlICE9PSBudWxsKTtcbiAgdmFyIGdyb3VwZWRPcHRpb25zID0gZmlsdGVyZWRPcHRpb25zO1xuXG4gIGlmIChncm91cEJ5KSB7XG4gICAgLy8gdXNlZCB0byBrZWVwIHRyYWNrIG9mIGtleSBhbmQgaW5kZXhlcyBpbiB0aGUgcmVzdWx0IGFycmF5XG4gICAgdmFyIGluZGV4QnkgPSBuZXcgTWFwKCk7XG4gICAgdmFyIHdhcm4gPSBmYWxzZTtcbiAgICBncm91cGVkT3B0aW9ucyA9IGZpbHRlcmVkT3B0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgb3B0aW9uLCBpbmRleCkge1xuICAgICAgdmFyIGdyb3VwID0gZ3JvdXBCeShvcHRpb24pO1xuXG4gICAgICBpZiAoYWNjLmxlbmd0aCA+IDAgJiYgYWNjW2FjYy5sZW5ndGggLSAxXS5ncm91cCA9PT0gZ3JvdXApIHtcbiAgICAgICAgYWNjW2FjYy5sZW5ndGggLSAxXS5vcHRpb25zLnB1c2gob3B0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGluZGV4QnkuZ2V0KGdyb3VwKSAmJiAhd2Fybikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTWF0ZXJpYWwtVUk6IFRoZSBvcHRpb25zIHByb3ZpZGVkIGNvbWJpbmVkIHdpdGggdGhlIGBncm91cEJ5YCBtZXRob2Qgb2YgXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiIHJldHVybnMgZHVwbGljYXRlZCBoZWFkZXJzLlwiKSwgJ1lvdSBjYW4gc29sdmUgdGhlIGlzc3VlIGJ5IHNvcnRpbmcgdGhlIG9wdGlvbnMgd2l0aCB0aGUgb3V0cHV0IG9mIGBncm91cEJ5YC4nKTtcbiAgICAgICAgICAgIHdhcm4gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZGV4Qnkuc2V0KGdyb3VwLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFjYy5wdXNoKHtcbiAgICAgICAgICBrZXk6IGluZGV4LFxuICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICBncm91cDogZ3JvdXAsXG4gICAgICAgICAgb3B0aW9uczogW29wdGlvbl1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXRSb290UHJvcHM6IGZ1bmN0aW9uIGdldFJvb3RQcm9wcygpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICAnYXJpYS1vd25zJzogcG9wdXBPcGVuID8gXCJcIi5jb25jYXQoaWQsIFwiLXBvcHVwXCIpIDogbnVsbCxcbiAgICAgICAgcm9sZTogJ2NvbWJvYm94JyxcbiAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBwb3B1cE9wZW5cbiAgICAgIH0sIG90aGVyLCB7XG4gICAgICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bihvdGhlciksXG4gICAgICAgIG9uTW91c2VEb3duOiBoYW5kbGVNb3VzZURvd24sXG4gICAgICAgIG9uQ2xpY2s6IGhhbmRsZUNsaWNrXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldElucHV0TGFiZWxQcm9wczogZnVuY3Rpb24gZ2V0SW5wdXRMYWJlbFByb3BzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IFwiXCIuY29uY2F0KGlkLCBcIi1sYWJlbFwiKSxcbiAgICAgICAgaHRtbEZvcjogaWRcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRJbnB1dFByb3BzOiBmdW5jdGlvbiBnZXRJbnB1dFByb3BzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZSxcbiAgICAgICAgb25CbHVyOiBoYW5kbGVCbHVyLFxuICAgICAgICBvbkZvY3VzOiBoYW5kbGVGb2N1cyxcbiAgICAgICAgb25DaGFuZ2U6IGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgICAgICBvbk1vdXNlRG93bjogaGFuZGxlSW5wdXRNb3VzZURvd24sXG4gICAgICAgIC8vIGlmIG9wZW4gdGhlbiB0aGlzIGlzIGhhbmRsZWQgaW1wZXJhdGl2ZWxleSBzbyBkb24ndCBsZXQgcmVhY3Qgb3ZlcnJpZGVcbiAgICAgICAgLy8gb25seSBoYXZlIGFuIG9waW5pb24gYWJvdXQgdGhpcyB3aGVuIGNsb3NlZFxuICAgICAgICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogcG9wdXBPcGVuID8gJycgOiBudWxsLFxuICAgICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiBhdXRvQ29tcGxldGUgPyAnYm90aCcgOiAnbGlzdCcsXG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogcG9wdXBPcGVuID8gXCJcIi5jb25jYXQoaWQsIFwiLXBvcHVwXCIpIDogbnVsbCxcbiAgICAgICAgLy8gRGlzYWJsZSBicm93c2VyJ3Mgc3VnZ2VzdGlvbiB0aGF0IG1pZ2h0IG92ZXJsYXAgd2l0aCB0aGUgcG9wdXAuXG4gICAgICAgIC8vIEhhbmRsZSBhdXRvY29tcGxldGUgYnV0IG5vdCBhdXRvZmlsbC5cbiAgICAgICAgYXV0b0NvbXBsZXRlOiAnb2ZmJyxcbiAgICAgICAgcmVmOiBpbnB1dFJlZixcbiAgICAgICAgYXV0b0NhcGl0YWxpemU6ICdub25lJyxcbiAgICAgICAgc3BlbGxDaGVjazogJ2ZhbHNlJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIGdldENsZWFyUHJvcHM6IGZ1bmN0aW9uIGdldENsZWFyUHJvcHMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YWJJbmRleDogLTEsXG4gICAgICAgIG9uQ2xpY2s6IGhhbmRsZUNsZWFyXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0UG9wdXBJbmRpY2F0b3JQcm9wczogZnVuY3Rpb24gZ2V0UG9wdXBJbmRpY2F0b3JQcm9wcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhYkluZGV4OiAtMSxcbiAgICAgICAgb25DbGljazogaGFuZGxlUG9wdXBJbmRpY2F0b3JcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRUYWdQcm9wczogZnVuY3Rpb24gZ2V0VGFnUHJvcHMoX3JlZjQpIHtcbiAgICAgIHZhciBpbmRleCA9IF9yZWY0LmluZGV4O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBpbmRleCxcbiAgICAgICAgJ2RhdGEtdGFnLWluZGV4JzogaW5kZXgsXG4gICAgICAgIHRhYkluZGV4OiAtMSxcbiAgICAgICAgb25EZWxldGU6IGhhbmRsZVRhZ0RlbGV0ZShpbmRleClcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRMaXN0Ym94UHJvcHM6IGZ1bmN0aW9uIGdldExpc3Rib3hQcm9wcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICdsaXN0Ym94JyxcbiAgICAgICAgaWQ6IFwiXCIuY29uY2F0KGlkLCBcIi1wb3B1cFwiKSxcbiAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IFwiXCIuY29uY2F0KGlkLCBcIi1sYWJlbFwiKSxcbiAgICAgICAgcmVmOiBoYW5kbGVMaXN0Ym94UmVmLFxuICAgICAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24gb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IGJsdXJcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0T3B0aW9uUHJvcHM6IGZ1bmN0aW9uIGdldE9wdGlvblByb3BzKF9yZWY1KSB7XG4gICAgICB2YXIgaW5kZXggPSBfcmVmNS5pbmRleCxcbiAgICAgICAgICBvcHRpb24gPSBfcmVmNS5vcHRpb247XG4gICAgICB2YXIgc2VsZWN0ZWQgPSAobXVsdGlwbGUgPyB2YWx1ZSA6IFt2YWx1ZV0pLnNvbWUoZnVuY3Rpb24gKHZhbHVlMikge1xuICAgICAgICByZXR1cm4gdmFsdWUyICE9IG51bGwgJiYgZ2V0T3B0aW9uU2VsZWN0ZWQob3B0aW9uLCB2YWx1ZTIpO1xuICAgICAgfSk7XG4gICAgICB2YXIgZGlzYWJsZWQgPSBnZXRPcHRpb25EaXNhYmxlZCA/IGdldE9wdGlvbkRpc2FibGVkKG9wdGlvbikgOiBmYWxzZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgIHRhYkluZGV4OiAtMSxcbiAgICAgICAgcm9sZTogJ29wdGlvbicsXG4gICAgICAgIGlkOiBcIlwiLmNvbmNhdChpZCwgXCItb3B0aW9uLVwiKS5jb25jYXQoaW5kZXgpLFxuICAgICAgICBvbk1vdXNlT3ZlcjogaGFuZGxlT3B0aW9uTW91c2VPdmVyLFxuICAgICAgICBvbkNsaWNrOiBoYW5kbGVPcHRpb25DbGljayxcbiAgICAgICAgb25Ub3VjaFN0YXJ0OiBoYW5kbGVPcHRpb25Ub3VjaFN0YXJ0LFxuICAgICAgICAnZGF0YS1vcHRpb24taW5kZXgnOiBpbmRleCxcbiAgICAgICAgJ2FyaWEtZGlzYWJsZWQnOiBkaXNhYmxlZCxcbiAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBzZWxlY3RlZFxuICAgICAgfTtcbiAgICB9LFxuICAgIGlkOiBpZCxcbiAgICBpbnB1dFZhbHVlOiBpbnB1dFZhbHVlLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBkaXJ0eTogZGlydHksXG4gICAgcG9wdXBPcGVuOiBwb3B1cE9wZW4sXG4gICAgZm9jdXNlZDogZm9jdXNlZCB8fCBmb2N1c2VkVGFnICE9PSAtMSxcbiAgICBhbmNob3JFbDogYW5jaG9yRWwsXG4gICAgc2V0QW5jaG9yRWw6IHNldEFuY2hvckVsLFxuICAgIGZvY3VzZWRUYWc6IGZvY3VzZWRUYWcsXG4gICAgZ3JvdXBlZE9wdGlvbnM6IGdyb3VwZWRPcHRpb25zXG4gIH07XG59IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IHdpdGhTdHlsZXMgfSBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS9zdHlsZXMnO1xuaW1wb3J0IFBvcHBlciBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS9Qb3BwZXInO1xuaW1wb3J0IExpc3RTdWJoZWFkZXIgZnJvbSAnQG1hdGVyaWFsLXVpL2NvcmUvTGlzdFN1YmhlYWRlcic7XG5pbXBvcnQgUGFwZXIgZnJvbSAnQG1hdGVyaWFsLXVpL2NvcmUvUGFwZXInO1xuaW1wb3J0IEljb25CdXR0b24gZnJvbSAnQG1hdGVyaWFsLXVpL2NvcmUvSWNvbkJ1dHRvbic7XG5pbXBvcnQgQ2hpcCBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS9DaGlwJztcbmltcG9ydCBDbG9zZUljb24gZnJvbSAnLi4vaW50ZXJuYWwvc3ZnLWljb25zL0Nsb3NlJztcbmltcG9ydCBBcnJvd0Ryb3BEb3duSWNvbiBmcm9tICcuLi9pbnRlcm5hbC9zdmctaWNvbnMvQXJyb3dEcm9wRG93bic7XG5pbXBvcnQgdXNlQXV0b2NvbXBsZXRlLCB7IGNyZWF0ZUZpbHRlck9wdGlvbnMgfSBmcm9tICcuLi91c2VBdXRvY29tcGxldGUnO1xuZXhwb3J0IHsgY3JlYXRlRmlsdGVyT3B0aW9ucyB9O1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgdmFyIF9vcHRpb247XG5cbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IHtcbiAgICAgICcmJGZvY3VzZWQgJGNsZWFySW5kaWNhdG9yRGlydHknOiB7XG4gICAgICAgIHZpc2liaWxpdHk6ICd2aXNpYmxlJ1xuICAgICAgfSxcblxuICAgICAgLyogQXZvaWQgZG91YmxlIHRhcCBpc3N1ZSBvbiBpT1MgKi9cbiAgICAgICdAbWVkaWEgKHBvaW50ZXI6IGZpbmUpJzoge1xuICAgICAgICAnJjpob3ZlciAkY2xlYXJJbmRpY2F0b3JEaXJ0eSc6IHtcbiAgICAgICAgICB2aXNpYmlsaXR5OiAndmlzaWJsZSdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBmdWxsV2lkdGg9e3RydWV9YC4gKi9cbiAgICBmdWxsV2lkdGg6IHtcbiAgICAgIHdpZHRoOiAnMTAwJSdcbiAgICB9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBmb2N1c2VkLiAqL1xuICAgIGZvY3VzZWQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHRhZyBlbGVtZW50cywgZS5nLiB0aGUgY2hpcHMuICovXG4gICAgdGFnOiB7XG4gICAgICBtYXJnaW46IDMsXG4gICAgICBtYXhXaWR0aDogJ2NhbGMoMTAwJSAtIDZweCknXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSB0YWcgZWxlbWVudHMsIGUuZy4gdGhlIGNoaXBzIGlmIGBzaXplPVwic21hbGxcImAuICovXG4gICAgdGFnU2l6ZVNtYWxsOiB7XG4gICAgICBtYXJnaW46IDIsXG4gICAgICBtYXhXaWR0aDogJ2NhbGMoMTAwJSAtIDRweCknXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHdoZW4gdGhlIHBvcHVwIGljb24gaXMgcmVuZGVyZWQuICovXG4gICAgaGFzUG9wdXBJY29uOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHdoZW4gdGhlIGNsZWFyIGljb24gaXMgcmVuZGVyZWQuICovXG4gICAgaGFzQ2xlYXJJY29uOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBJbnB1dCBlbGVtZW50LiAqL1xuICAgIGlucHV0Um9vdDoge1xuICAgICAgZmxleFdyYXA6ICd3cmFwJyxcbiAgICAgICckaGFzUG9wdXBJY29uICYsICRoYXNDbGVhckljb24gJic6IHtcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiAyNiArIDRcbiAgICAgIH0sXG4gICAgICAnJGhhc1BvcHVwSWNvbiRoYXNDbGVhckljb24gJic6IHtcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiA1MiArIDRcbiAgICAgIH0sXG4gICAgICAnJiAkaW5wdXQnOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBtaW5XaWR0aDogMzBcbiAgICAgIH0sXG4gICAgICAnJltjbGFzcyo9XCJNdWlJbnB1dC1yb290XCJdJzoge1xuICAgICAgICBwYWRkaW5nQm90dG9tOiAxLFxuICAgICAgICAnJiAkaW5wdXQnOiB7XG4gICAgICAgICAgcGFkZGluZzogNFxuICAgICAgICB9LFxuICAgICAgICAnJiAkaW5wdXQ6Zmlyc3QtY2hpbGQnOiB7XG4gICAgICAgICAgcGFkZGluZzogJzZweCAwJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJyZbY2xhc3MqPVwiTXVpSW5wdXQtcm9vdFwiXVtjbGFzcyo9XCJNdWlJbnB1dC1tYXJnaW5EZW5zZVwiXSc6IHtcbiAgICAgICAgJyYgJGlucHV0Jzoge1xuICAgICAgICAgIHBhZGRpbmc6ICc0cHggNHB4IDVweCdcbiAgICAgICAgfSxcbiAgICAgICAgJyYgJGlucHV0OmZpcnN0LWNoaWxkJzoge1xuICAgICAgICAgIHBhZGRpbmc6ICczcHggMCA2cHgnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnJltjbGFzcyo9XCJNdWlPdXRsaW5lZElucHV0LXJvb3RcIl0nOiB7XG4gICAgICAgIHBhZGRpbmc6IDksXG4gICAgICAgICckaGFzUG9wdXBJY29uICYsICRoYXNDbGVhckljb24gJic6IHtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQ6IDI2ICsgNCArIDlcbiAgICAgICAgfSxcbiAgICAgICAgJyRoYXNQb3B1cEljb24kaGFzQ2xlYXJJY29uICYnOiB7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0OiA1MiArIDQgKyA5XG4gICAgICAgIH0sXG4gICAgICAgICcmICRpbnB1dCc6IHtcbiAgICAgICAgICBwYWRkaW5nOiAnOS41cHggNHB4J1xuICAgICAgICB9LFxuICAgICAgICAnJiAkaW5wdXQ6Zmlyc3QtY2hpbGQnOiB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQ6IDZcbiAgICAgICAgfSxcbiAgICAgICAgJyYgJGVuZEFkb3JubWVudCc6IHtcbiAgICAgICAgICByaWdodDogOVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJyZbY2xhc3MqPVwiTXVpT3V0bGluZWRJbnB1dC1yb290XCJdW2NsYXNzKj1cIk11aU91dGxpbmVkSW5wdXQtbWFyZ2luRGVuc2VcIl0nOiB7XG4gICAgICAgIHBhZGRpbmc6IDYsXG4gICAgICAgICcmICRpbnB1dCc6IHtcbiAgICAgICAgICBwYWRkaW5nOiAnNC41cHggNHB4J1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJyZbY2xhc3MqPVwiTXVpRmlsbGVkSW5wdXQtcm9vdFwiXSc6IHtcbiAgICAgICAgcGFkZGluZ1RvcDogMTksXG4gICAgICAgIHBhZGRpbmdMZWZ0OiA4LFxuICAgICAgICAnJGhhc1BvcHVwSWNvbiAmLCAkaGFzQ2xlYXJJY29uICYnOiB7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0OiAyNiArIDQgKyA5XG4gICAgICAgIH0sXG4gICAgICAgICckaGFzUG9wdXBJY29uJGhhc0NsZWFySWNvbiAmJzoge1xuICAgICAgICAgIHBhZGRpbmdSaWdodDogNTIgKyA0ICsgOVxuICAgICAgICB9LFxuICAgICAgICAnJiAkaW5wdXQnOiB7XG4gICAgICAgICAgcGFkZGluZzogJzlweCA0cHgnXG4gICAgICAgIH0sXG4gICAgICAgICcmICRlbmRBZG9ybm1lbnQnOiB7XG4gICAgICAgICAgcmlnaHQ6IDlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICcmW2NsYXNzKj1cIk11aUZpbGxlZElucHV0LXJvb3RcIl1bY2xhc3MqPVwiTXVpRmlsbGVkSW5wdXQtbWFyZ2luRGVuc2VcIl0nOiB7XG4gICAgICAgIHBhZGRpbmdCb3R0b206IDEsXG4gICAgICAgICcmICRpbnB1dCc6IHtcbiAgICAgICAgICBwYWRkaW5nOiAnNC41cHggNHB4J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBpbnB1dCBlbGVtZW50LiAqL1xuICAgIGlucHV0OiB7XG4gICAgICBmbGV4R3JvdzogMSxcbiAgICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICAgIG9wYWNpdHk6IDBcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGlucHV0IGVsZW1lbnQgaWYgdGFnIGZvY3VzZWQuICovXG4gICAgaW5wdXRGb2N1c2VkOiB7XG4gICAgICBvcGFjaXR5OiAxXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBlbmRBZG9ybm1lbnQgZWxlbWVudC4gKi9cbiAgICBlbmRBZG9ybm1lbnQ6IHtcbiAgICAgIC8vIFdlIHVzZSBhIHBvc2l0aW9uIGFic29sdXRlIHRvIHN1cHBvcnQgd3JhcHBpbmcgdGFncy5cbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6ICdjYWxjKDUwJSAtIDE0cHgpJyAvLyBDZW50ZXIgdmVydGljYWxseVxuXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjbGVhciBpbmRpY2F0b3IuICovXG4gICAgY2xlYXJJbmRpY2F0b3I6IHtcbiAgICAgIG1hcmdpblJpZ2h0OiAtMixcbiAgICAgIHBhZGRpbmc6IDQsXG4gICAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJ1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgY2xlYXIgaW5kaWNhdG9yIGlmIHRoZSBpbnB1dCBpcyBkaXJ0eS4gKi9cbiAgICBjbGVhckluZGljYXRvckRpcnR5OiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBwb3B1cCBpbmRpY2F0b3IuICovXG4gICAgcG9wdXBJbmRpY2F0b3I6IHtcbiAgICAgIHBhZGRpbmc6IDIsXG4gICAgICBtYXJnaW5SaWdodDogLTJcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHBvcHVwIGluZGljYXRvciBpZiB0aGUgcG9wdXAgaXMgb3Blbi4gKi9cbiAgICBwb3B1cEluZGljYXRvck9wZW46IHtcbiAgICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgxODBkZWcpJ1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcG9wcGVyIGVsZW1lbnQuICovXG4gICAgcG9wcGVyOiB7XG4gICAgICB6SW5kZXg6IHRoZW1lLnpJbmRleC5tb2RhbFxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcG9wcGVyIGVsZW1lbnQgaWYgYGRpc2FibGVQb3J0YWw9e3RydWV9YC4gKi9cbiAgICBwb3BwZXJEaXNhYmxlUG9ydGFsOiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYFBhcGVyYCBjb21wb25lbnQuICovXG4gICAgcGFwZXI6IF9leHRlbmRzKHt9LCB0aGVtZS50eXBvZ3JhcGh5LmJvZHkxLCB7XG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICBtYXJnaW46ICc0cHggMCdcbiAgICB9KSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgbGlzdGJveGAgY29tcG9uZW50LiAqL1xuICAgIGxpc3Rib3g6IHtcbiAgICAgIGxpc3RTdHlsZTogJ25vbmUnLFxuICAgICAgbWFyZ2luOiAwLFxuICAgICAgcGFkZGluZzogJzhweCAwJyxcbiAgICAgIG1heEhlaWdodDogJzQwdmgnLFxuICAgICAgb3ZlcmZsb3c6ICdhdXRvJ1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgbG9hZGluZyB3cmFwcGVyLiAqL1xuICAgIGxvYWRpbmc6IHtcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnRleHQuc2Vjb25kYXJ5LFxuICAgICAgcGFkZGluZzogJzE0cHggMTZweCdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIG5vIG9wdGlvbiB3cmFwcGVyLiAqL1xuICAgIG5vT3B0aW9uczoge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudGV4dC5zZWNvbmRhcnksXG4gICAgICBwYWRkaW5nOiAnMTRweCAxNnB4J1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgb3B0aW9uIGVsZW1lbnRzLiAqL1xuICAgIG9wdGlvbjogKF9vcHRpb24gPSB7XG4gICAgICBtaW5IZWlnaHQ6IDQ4LFxuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LXN0YXJ0JyxcbiAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICBwYWRkaW5nVG9wOiA2LFxuICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICBvdXRsaW5lOiAnMCcsXG4gICAgICBXZWJraXRUYXBIaWdobGlnaHRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgIHBhZGRpbmdCb3R0b206IDYsXG4gICAgICBwYWRkaW5nTGVmdDogMTYsXG4gICAgICBwYWRkaW5nUmlnaHQ6IDE2XG4gICAgfSwgX2RlZmluZVByb3BlcnR5KF9vcHRpb24sIHRoZW1lLmJyZWFrcG9pbnRzLnVwKCdzbScpLCB7XG4gICAgICBtaW5IZWlnaHQ6ICdhdXRvJ1xuICAgIH0pLCBfZGVmaW5lUHJvcGVydHkoX29wdGlvbiwgJyZbYXJpYS1zZWxlY3RlZD1cInRydWVcIl0nLCB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUuYWN0aW9uLnNlbGVjdGVkXG4gICAgfSksIF9kZWZpbmVQcm9wZXJ0eShfb3B0aW9uLCAnJltkYXRhLWZvY3VzPVwidHJ1ZVwiXScsIHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5hY3Rpb24uaG92ZXJcbiAgICB9KSwgX2RlZmluZVByb3BlcnR5KF9vcHRpb24sICcmOmFjdGl2ZScsIHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWRcbiAgICB9KSwgX2RlZmluZVByb3BlcnR5KF9vcHRpb24sICcmW2FyaWEtZGlzYWJsZWQ9XCJ0cnVlXCJdJywge1xuICAgICAgb3BhY2l0eTogdGhlbWUucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWRPcGFjaXR5LFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgfSksIF9vcHRpb24pLFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGdyb3VwJ3MgbGFiZWwgZWxlbWVudHMuICovXG4gICAgZ3JvdXBMYWJlbDoge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLmJhY2tncm91bmQucGFwZXIsXG4gICAgICB0b3A6IC04XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBncm91cCdzIHVsIGVsZW1lbnRzLiAqL1xuICAgIGdyb3VwVWw6IHtcbiAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAnJiAkb3B0aW9uJzoge1xuICAgICAgICBwYWRkaW5nTGVmdDogMjRcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBEaXNhYmxlUG9ydGFsKHByb3BzKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9wcm9wLXR5cGVzXG4gIHZhciBhbmNob3JFbCA9IHByb3BzLmFuY2hvckVsLFxuICAgICAgb3BlbiA9IHByb3BzLm9wZW4sXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYW5jaG9yRWxcIiwgXCJvcGVuXCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgb3RoZXIpO1xufVxuXG52YXIgX3JlZiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENsb3NlSWNvbiwge1xuICBmb250U2l6ZTogXCJzbWFsbFwiXG59KTtcblxudmFyIF9yZWYyID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXJyb3dEcm9wRG93bkljb24sIG51bGwpO1xuXG52YXIgQXV0b2NvbXBsZXRlID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQXV0b2NvbXBsZXRlKHByb3BzLCByZWYpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgdmFyIF9wcm9wcyRhdXRvQ29tcGxldGUgPSBwcm9wcy5hdXRvQ29tcGxldGUsXG4gICAgICBhdXRvQ29tcGxldGUgPSBfcHJvcHMkYXV0b0NvbXBsZXRlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRhdXRvQ29tcGxldGUsXG4gICAgICBfcHJvcHMkYXV0b0hpZ2hsaWdodCA9IHByb3BzLmF1dG9IaWdobGlnaHQsXG4gICAgICBhdXRvSGlnaGxpZ2h0ID0gX3Byb3BzJGF1dG9IaWdobGlnaHQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGF1dG9IaWdobGlnaHQsXG4gICAgICBfcHJvcHMkYXV0b1NlbGVjdCA9IHByb3BzLmF1dG9TZWxlY3QsXG4gICAgICBhdXRvU2VsZWN0ID0gX3Byb3BzJGF1dG9TZWxlY3QgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGF1dG9TZWxlY3QsXG4gICAgICBfcHJvcHMkYmx1ck9uU2VsZWN0ID0gcHJvcHMuYmx1ck9uU2VsZWN0LFxuICAgICAgYmx1ck9uU2VsZWN0ID0gX3Byb3BzJGJsdXJPblNlbGVjdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkYmx1ck9uU2VsZWN0LFxuICAgICAgQ2hpcFByb3BzID0gcHJvcHMuQ2hpcFByb3BzLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkY2xlYXJPbkJsdXIgPSBwcm9wcy5jbGVhck9uQmx1cixcbiAgICAgIGNsZWFyT25CbHVyID0gX3Byb3BzJGNsZWFyT25CbHVyID09PSB2b2lkIDAgPyAhcHJvcHMuZnJlZVNvbG8gOiBfcHJvcHMkY2xlYXJPbkJsdXIsXG4gICAgICBfcHJvcHMkY2xlYXJPbkVzY2FwZSA9IHByb3BzLmNsZWFyT25Fc2NhcGUsXG4gICAgICBjbGVhck9uRXNjYXBlID0gX3Byb3BzJGNsZWFyT25Fc2NhcGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGNsZWFyT25Fc2NhcGUsXG4gICAgICBfcHJvcHMkY2xlYXJUZXh0ID0gcHJvcHMuY2xlYXJUZXh0LFxuICAgICAgY2xlYXJUZXh0ID0gX3Byb3BzJGNsZWFyVGV4dCA9PT0gdm9pZCAwID8gJ0NsZWFyJyA6IF9wcm9wcyRjbGVhclRleHQsXG4gICAgICBfcHJvcHMkY2xvc2VJY29uID0gcHJvcHMuY2xvc2VJY29uLFxuICAgICAgY2xvc2VJY29uID0gX3Byb3BzJGNsb3NlSWNvbiA9PT0gdm9pZCAwID8gX3JlZiA6IF9wcm9wcyRjbG9zZUljb24sXG4gICAgICBfcHJvcHMkY2xvc2VUZXh0ID0gcHJvcHMuY2xvc2VUZXh0LFxuICAgICAgY2xvc2VUZXh0ID0gX3Byb3BzJGNsb3NlVGV4dCA9PT0gdm9pZCAwID8gJ0Nsb3NlJyA6IF9wcm9wcyRjbG9zZVRleHQsXG4gICAgICBfcHJvcHMkZGVidWcgPSBwcm9wcy5kZWJ1ZyxcbiAgICAgIGRlYnVnID0gX3Byb3BzJGRlYnVnID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkZWJ1ZyxcbiAgICAgIF9wcm9wcyRkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICBkZWZhdWx0VmFsdWUgPSBfcHJvcHMkZGVmYXVsdFZhbHVlID09PSB2b2lkIDAgPyBwcm9wcy5tdWx0aXBsZSA/IFtdIDogbnVsbCA6IF9wcm9wcyRkZWZhdWx0VmFsdWUsXG4gICAgICBfcHJvcHMkZGlzYWJsZUNsZWFyYWIgPSBwcm9wcy5kaXNhYmxlQ2xlYXJhYmxlLFxuICAgICAgZGlzYWJsZUNsZWFyYWJsZSA9IF9wcm9wcyRkaXNhYmxlQ2xlYXJhYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZUNsZWFyYWIsXG4gICAgICBfcHJvcHMkZGlzYWJsZUNsb3NlT24gPSBwcm9wcy5kaXNhYmxlQ2xvc2VPblNlbGVjdCxcbiAgICAgIGRpc2FibGVDbG9zZU9uU2VsZWN0ID0gX3Byb3BzJGRpc2FibGVDbG9zZU9uID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlQ2xvc2VPbixcbiAgICAgIF9wcm9wcyRkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkLFxuICAgICAgZGlzYWJsZWQgPSBfcHJvcHMkZGlzYWJsZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVkLFxuICAgICAgX3Byb3BzJGRpc2FibGVkSXRlbXNGID0gcHJvcHMuZGlzYWJsZWRJdGVtc0ZvY3VzYWJsZSxcbiAgICAgIGRpc2FibGVkSXRlbXNGb2N1c2FibGUgPSBfcHJvcHMkZGlzYWJsZWRJdGVtc0YgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVkSXRlbXNGLFxuICAgICAgX3Byb3BzJGRpc2FibGVMaXN0V3JhID0gcHJvcHMuZGlzYWJsZUxpc3RXcmFwLFxuICAgICAgZGlzYWJsZUxpc3RXcmFwID0gX3Byb3BzJGRpc2FibGVMaXN0V3JhID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlTGlzdFdyYSxcbiAgICAgIF9wcm9wcyRkaXNhYmxlUG9ydGFsID0gcHJvcHMuZGlzYWJsZVBvcnRhbCxcbiAgICAgIGRpc2FibGVQb3J0YWwgPSBfcHJvcHMkZGlzYWJsZVBvcnRhbCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZVBvcnRhbCxcbiAgICAgIGZpbHRlck9wdGlvbnMgPSBwcm9wcy5maWx0ZXJPcHRpb25zLFxuICAgICAgX3Byb3BzJGZpbHRlclNlbGVjdGVkID0gcHJvcHMuZmlsdGVyU2VsZWN0ZWRPcHRpb25zLFxuICAgICAgZmlsdGVyU2VsZWN0ZWRPcHRpb25zID0gX3Byb3BzJGZpbHRlclNlbGVjdGVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRmaWx0ZXJTZWxlY3RlZCxcbiAgICAgIF9wcm9wcyRmb3JjZVBvcHVwSWNvbiA9IHByb3BzLmZvcmNlUG9wdXBJY29uLFxuICAgICAgZm9yY2VQb3B1cEljb24gPSBfcHJvcHMkZm9yY2VQb3B1cEljb24gPT09IHZvaWQgMCA/ICdhdXRvJyA6IF9wcm9wcyRmb3JjZVBvcHVwSWNvbixcbiAgICAgIF9wcm9wcyRmcmVlU29sbyA9IHByb3BzLmZyZWVTb2xvLFxuICAgICAgZnJlZVNvbG8gPSBfcHJvcHMkZnJlZVNvbG8gPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGZyZWVTb2xvLFxuICAgICAgX3Byb3BzJGZ1bGxXaWR0aCA9IHByb3BzLmZ1bGxXaWR0aCxcbiAgICAgIGZ1bGxXaWR0aCA9IF9wcm9wcyRmdWxsV2lkdGggPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGZ1bGxXaWR0aCxcbiAgICAgIF9wcm9wcyRnZXRMaW1pdFRhZ3NUZSA9IHByb3BzLmdldExpbWl0VGFnc1RleHQsXG4gICAgICBnZXRMaW1pdFRhZ3NUZXh0ID0gX3Byb3BzJGdldExpbWl0VGFnc1RlID09PSB2b2lkIDAgPyBmdW5jdGlvbiAobW9yZSkge1xuICAgIHJldHVybiBcIitcIi5jb25jYXQobW9yZSk7XG4gIH0gOiBfcHJvcHMkZ2V0TGltaXRUYWdzVGUsXG4gICAgICBnZXRPcHRpb25EaXNhYmxlZCA9IHByb3BzLmdldE9wdGlvbkRpc2FibGVkLFxuICAgICAgX3Byb3BzJGdldE9wdGlvbkxhYmVsID0gcHJvcHMuZ2V0T3B0aW9uTGFiZWwsXG4gICAgICBnZXRPcHRpb25MYWJlbCA9IF9wcm9wcyRnZXRPcHRpb25MYWJlbCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geDtcbiAgfSA6IF9wcm9wcyRnZXRPcHRpb25MYWJlbCxcbiAgICAgIGdldE9wdGlvblNlbGVjdGVkID0gcHJvcHMuZ2V0T3B0aW9uU2VsZWN0ZWQsXG4gICAgICBncm91cEJ5ID0gcHJvcHMuZ3JvdXBCeSxcbiAgICAgIF9wcm9wcyRoYW5kbGVIb21lRW5kSyA9IHByb3BzLmhhbmRsZUhvbWVFbmRLZXlzLFxuICAgICAgaGFuZGxlSG9tZUVuZEtleXMgPSBfcHJvcHMkaGFuZGxlSG9tZUVuZEsgPT09IHZvaWQgMCA/ICFwcm9wcy5mcmVlU29sbyA6IF9wcm9wcyRoYW5kbGVIb21lRW5kSyxcbiAgICAgIGlkUHJvcCA9IHByb3BzLmlkLFxuICAgICAgX3Byb3BzJGluY2x1ZGVJbnB1dEluID0gcHJvcHMuaW5jbHVkZUlucHV0SW5MaXN0LFxuICAgICAgaW5jbHVkZUlucHV0SW5MaXN0ID0gX3Byb3BzJGluY2x1ZGVJbnB1dEluID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRpbmNsdWRlSW5wdXRJbixcbiAgICAgIGlucHV0VmFsdWVQcm9wID0gcHJvcHMuaW5wdXRWYWx1ZSxcbiAgICAgIF9wcm9wcyRsaW1pdFRhZ3MgPSBwcm9wcy5saW1pdFRhZ3MsXG4gICAgICBsaW1pdFRhZ3MgPSBfcHJvcHMkbGltaXRUYWdzID09PSB2b2lkIDAgPyAtMSA6IF9wcm9wcyRsaW1pdFRhZ3MsXG4gICAgICBfcHJvcHMkTGlzdGJveENvbXBvbmUgPSBwcm9wcy5MaXN0Ym94Q29tcG9uZW50LFxuICAgICAgTGlzdGJveENvbXBvbmVudCA9IF9wcm9wcyRMaXN0Ym94Q29tcG9uZSA9PT0gdm9pZCAwID8gJ3VsJyA6IF9wcm9wcyRMaXN0Ym94Q29tcG9uZSxcbiAgICAgIExpc3Rib3hQcm9wcyA9IHByb3BzLkxpc3Rib3hQcm9wcyxcbiAgICAgIF9wcm9wcyRsb2FkaW5nID0gcHJvcHMubG9hZGluZyxcbiAgICAgIGxvYWRpbmcgPSBfcHJvcHMkbG9hZGluZyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkbG9hZGluZyxcbiAgICAgIF9wcm9wcyRsb2FkaW5nVGV4dCA9IHByb3BzLmxvYWRpbmdUZXh0LFxuICAgICAgbG9hZGluZ1RleHQgPSBfcHJvcHMkbG9hZGluZ1RleHQgPT09IHZvaWQgMCA/ICdMb2FkaW5n4oCmJyA6IF9wcm9wcyRsb2FkaW5nVGV4dCxcbiAgICAgIF9wcm9wcyRtdWx0aXBsZSA9IHByb3BzLm11bHRpcGxlLFxuICAgICAgbXVsdGlwbGUgPSBfcHJvcHMkbXVsdGlwbGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJG11bHRpcGxlLFxuICAgICAgX3Byb3BzJG5vT3B0aW9uc1RleHQgPSBwcm9wcy5ub09wdGlvbnNUZXh0LFxuICAgICAgbm9PcHRpb25zVGV4dCA9IF9wcm9wcyRub09wdGlvbnNUZXh0ID09PSB2b2lkIDAgPyAnTm8gb3B0aW9ucycgOiBfcHJvcHMkbm9PcHRpb25zVGV4dCxcbiAgICAgIG9uQ2hhbmdlID0gcHJvcHMub25DaGFuZ2UsXG4gICAgICBvbkNsb3NlID0gcHJvcHMub25DbG9zZSxcbiAgICAgIG9uSGlnaGxpZ2h0Q2hhbmdlID0gcHJvcHMub25IaWdobGlnaHRDaGFuZ2UsXG4gICAgICBvbklucHV0Q2hhbmdlID0gcHJvcHMub25JbnB1dENoYW5nZSxcbiAgICAgIG9uT3BlbiA9IHByb3BzLm9uT3BlbixcbiAgICAgIG9wZW4gPSBwcm9wcy5vcGVuLFxuICAgICAgX3Byb3BzJG9wZW5PbkZvY3VzID0gcHJvcHMub3Blbk9uRm9jdXMsXG4gICAgICBvcGVuT25Gb2N1cyA9IF9wcm9wcyRvcGVuT25Gb2N1cyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkb3Blbk9uRm9jdXMsXG4gICAgICBfcHJvcHMkb3BlblRleHQgPSBwcm9wcy5vcGVuVGV4dCxcbiAgICAgIG9wZW5UZXh0ID0gX3Byb3BzJG9wZW5UZXh0ID09PSB2b2lkIDAgPyAnT3BlbicgOiBfcHJvcHMkb3BlblRleHQsXG4gICAgICBvcHRpb25zID0gcHJvcHMub3B0aW9ucyxcbiAgICAgIF9wcm9wcyRQYXBlckNvbXBvbmVudCA9IHByb3BzLlBhcGVyQ29tcG9uZW50LFxuICAgICAgUGFwZXJDb21wb25lbnQgPSBfcHJvcHMkUGFwZXJDb21wb25lbnQgPT09IHZvaWQgMCA/IFBhcGVyIDogX3Byb3BzJFBhcGVyQ29tcG9uZW50LFxuICAgICAgX3Byb3BzJFBvcHBlckNvbXBvbmVuID0gcHJvcHMuUG9wcGVyQ29tcG9uZW50LFxuICAgICAgUG9wcGVyQ29tcG9uZW50UHJvcCA9IF9wcm9wcyRQb3BwZXJDb21wb25lbiA9PT0gdm9pZCAwID8gUG9wcGVyIDogX3Byb3BzJFBvcHBlckNvbXBvbmVuLFxuICAgICAgX3Byb3BzJHBvcHVwSWNvbiA9IHByb3BzLnBvcHVwSWNvbixcbiAgICAgIHBvcHVwSWNvbiA9IF9wcm9wcyRwb3B1cEljb24gPT09IHZvaWQgMCA/IF9yZWYyIDogX3Byb3BzJHBvcHVwSWNvbixcbiAgICAgIHJlbmRlckdyb3VwUHJvcCA9IHByb3BzLnJlbmRlckdyb3VwLFxuICAgICAgcmVuZGVySW5wdXQgPSBwcm9wcy5yZW5kZXJJbnB1dCxcbiAgICAgIHJlbmRlck9wdGlvblByb3AgPSBwcm9wcy5yZW5kZXJPcHRpb24sXG4gICAgICByZW5kZXJUYWdzID0gcHJvcHMucmVuZGVyVGFncyxcbiAgICAgIF9wcm9wcyRzZWxlY3RPbkZvY3VzID0gcHJvcHMuc2VsZWN0T25Gb2N1cyxcbiAgICAgIHNlbGVjdE9uRm9jdXMgPSBfcHJvcHMkc2VsZWN0T25Gb2N1cyA9PT0gdm9pZCAwID8gIXByb3BzLmZyZWVTb2xvIDogX3Byb3BzJHNlbGVjdE9uRm9jdXMsXG4gICAgICBfcHJvcHMkc2l6ZSA9IHByb3BzLnNpemUsXG4gICAgICBzaXplID0gX3Byb3BzJHNpemUgPT09IHZvaWQgMCA/ICdtZWRpdW0nIDogX3Byb3BzJHNpemUsXG4gICAgICB2YWx1ZVByb3AgPSBwcm9wcy52YWx1ZSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJhdXRvQ29tcGxldGVcIiwgXCJhdXRvSGlnaGxpZ2h0XCIsIFwiYXV0b1NlbGVjdFwiLCBcImJsdXJPblNlbGVjdFwiLCBcIkNoaXBQcm9wc1wiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjbGVhck9uQmx1clwiLCBcImNsZWFyT25Fc2NhcGVcIiwgXCJjbGVhclRleHRcIiwgXCJjbG9zZUljb25cIiwgXCJjbG9zZVRleHRcIiwgXCJkZWJ1Z1wiLCBcImRlZmF1bHRWYWx1ZVwiLCBcImRpc2FibGVDbGVhcmFibGVcIiwgXCJkaXNhYmxlQ2xvc2VPblNlbGVjdFwiLCBcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRJdGVtc0ZvY3VzYWJsZVwiLCBcImRpc2FibGVMaXN0V3JhcFwiLCBcImRpc2FibGVQb3J0YWxcIiwgXCJmaWx0ZXJPcHRpb25zXCIsIFwiZmlsdGVyU2VsZWN0ZWRPcHRpb25zXCIsIFwiZm9yY2VQb3B1cEljb25cIiwgXCJmcmVlU29sb1wiLCBcImZ1bGxXaWR0aFwiLCBcImdldExpbWl0VGFnc1RleHRcIiwgXCJnZXRPcHRpb25EaXNhYmxlZFwiLCBcImdldE9wdGlvbkxhYmVsXCIsIFwiZ2V0T3B0aW9uU2VsZWN0ZWRcIiwgXCJncm91cEJ5XCIsIFwiaGFuZGxlSG9tZUVuZEtleXNcIiwgXCJpZFwiLCBcImluY2x1ZGVJbnB1dEluTGlzdFwiLCBcImlucHV0VmFsdWVcIiwgXCJsaW1pdFRhZ3NcIiwgXCJMaXN0Ym94Q29tcG9uZW50XCIsIFwiTGlzdGJveFByb3BzXCIsIFwibG9hZGluZ1wiLCBcImxvYWRpbmdUZXh0XCIsIFwibXVsdGlwbGVcIiwgXCJub09wdGlvbnNUZXh0XCIsIFwib25DaGFuZ2VcIiwgXCJvbkNsb3NlXCIsIFwib25IaWdobGlnaHRDaGFuZ2VcIiwgXCJvbklucHV0Q2hhbmdlXCIsIFwib25PcGVuXCIsIFwib3BlblwiLCBcIm9wZW5PbkZvY3VzXCIsIFwib3BlblRleHRcIiwgXCJvcHRpb25zXCIsIFwiUGFwZXJDb21wb25lbnRcIiwgXCJQb3BwZXJDb21wb25lbnRcIiwgXCJwb3B1cEljb25cIiwgXCJyZW5kZXJHcm91cFwiLCBcInJlbmRlcklucHV0XCIsIFwicmVuZGVyT3B0aW9uXCIsIFwicmVuZGVyVGFnc1wiLCBcInNlbGVjdE9uRm9jdXNcIiwgXCJzaXplXCIsIFwidmFsdWVcIl0pO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cblxuICB2YXIgUG9wcGVyQ29tcG9uZW50ID0gZGlzYWJsZVBvcnRhbCA/IERpc2FibGVQb3J0YWwgOiBQb3BwZXJDb21wb25lbnRQcm9wO1xuXG4gIHZhciBfdXNlQXV0b2NvbXBsZXRlID0gdXNlQXV0b2NvbXBsZXRlKF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGNvbXBvbmVudE5hbWU6ICdBdXRvY29tcGxldGUnXG4gIH0pKSxcbiAgICAgIGdldFJvb3RQcm9wcyA9IF91c2VBdXRvY29tcGxldGUuZ2V0Um9vdFByb3BzLFxuICAgICAgZ2V0SW5wdXRQcm9wcyA9IF91c2VBdXRvY29tcGxldGUuZ2V0SW5wdXRQcm9wcyxcbiAgICAgIGdldElucHV0TGFiZWxQcm9wcyA9IF91c2VBdXRvY29tcGxldGUuZ2V0SW5wdXRMYWJlbFByb3BzLFxuICAgICAgZ2V0UG9wdXBJbmRpY2F0b3JQcm9wcyA9IF91c2VBdXRvY29tcGxldGUuZ2V0UG9wdXBJbmRpY2F0b3JQcm9wcyxcbiAgICAgIGdldENsZWFyUHJvcHMgPSBfdXNlQXV0b2NvbXBsZXRlLmdldENsZWFyUHJvcHMsXG4gICAgICBnZXRUYWdQcm9wcyA9IF91c2VBdXRvY29tcGxldGUuZ2V0VGFnUHJvcHMsXG4gICAgICBnZXRMaXN0Ym94UHJvcHMgPSBfdXNlQXV0b2NvbXBsZXRlLmdldExpc3Rib3hQcm9wcyxcbiAgICAgIGdldE9wdGlvblByb3BzID0gX3VzZUF1dG9jb21wbGV0ZS5nZXRPcHRpb25Qcm9wcyxcbiAgICAgIHZhbHVlID0gX3VzZUF1dG9jb21wbGV0ZS52YWx1ZSxcbiAgICAgIGRpcnR5ID0gX3VzZUF1dG9jb21wbGV0ZS5kaXJ0eSxcbiAgICAgIGlkID0gX3VzZUF1dG9jb21wbGV0ZS5pZCxcbiAgICAgIHBvcHVwT3BlbiA9IF91c2VBdXRvY29tcGxldGUucG9wdXBPcGVuLFxuICAgICAgZm9jdXNlZCA9IF91c2VBdXRvY29tcGxldGUuZm9jdXNlZCxcbiAgICAgIGZvY3VzZWRUYWcgPSBfdXNlQXV0b2NvbXBsZXRlLmZvY3VzZWRUYWcsXG4gICAgICBhbmNob3JFbCA9IF91c2VBdXRvY29tcGxldGUuYW5jaG9yRWwsXG4gICAgICBzZXRBbmNob3JFbCA9IF91c2VBdXRvY29tcGxldGUuc2V0QW5jaG9yRWwsXG4gICAgICBpbnB1dFZhbHVlID0gX3VzZUF1dG9jb21wbGV0ZS5pbnB1dFZhbHVlLFxuICAgICAgZ3JvdXBlZE9wdGlvbnMgPSBfdXNlQXV0b2NvbXBsZXRlLmdyb3VwZWRPcHRpb25zO1xuXG4gIHZhciBzdGFydEFkb3JubWVudDtcblxuICBpZiAobXVsdGlwbGUgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgIHZhciBnZXRDdXN0b21pemVkVGFnUHJvcHMgPSBmdW5jdGlvbiBnZXRDdXN0b21pemVkVGFnUHJvcHMocGFyYW1zKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy50YWcsIHNpemUgPT09ICdzbWFsbCcgJiYgY2xhc3Nlcy50YWdTaXplU21hbGwpLFxuICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWRcbiAgICAgIH0sIGdldFRhZ1Byb3BzKHBhcmFtcykpO1xuICAgIH07XG5cbiAgICBpZiAocmVuZGVyVGFncykge1xuICAgICAgc3RhcnRBZG9ybm1lbnQgPSByZW5kZXJUYWdzKHZhbHVlLCBnZXRDdXN0b21pemVkVGFnUHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydEFkb3JubWVudCA9IHZhbHVlLm1hcChmdW5jdGlvbiAob3B0aW9uLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hpcCwgX2V4dGVuZHMoe1xuICAgICAgICAgIGxhYmVsOiBnZXRPcHRpb25MYWJlbChvcHRpb24pLFxuICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgfSwgZ2V0Q3VzdG9taXplZFRhZ1Byb3BzKHtcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfSksIENoaXBQcm9wcykpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxpbWl0VGFncyA+IC0xICYmIEFycmF5LmlzQXJyYXkoc3RhcnRBZG9ybm1lbnQpKSB7XG4gICAgdmFyIG1vcmUgPSBzdGFydEFkb3JubWVudC5sZW5ndGggLSBsaW1pdFRhZ3M7XG5cbiAgICBpZiAoIWZvY3VzZWQgJiYgbW9yZSA+IDApIHtcbiAgICAgIHN0YXJ0QWRvcm5tZW50ID0gc3RhcnRBZG9ybm1lbnQuc3BsaWNlKDAsIGxpbWl0VGFncyk7XG4gICAgICBzdGFydEFkb3JubWVudC5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzZXMudGFnLFxuICAgICAgICBrZXk6IHN0YXJ0QWRvcm5tZW50Lmxlbmd0aFxuICAgICAgfSwgZ2V0TGltaXRUYWdzVGV4dChtb3JlKSkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UmVuZGVyR3JvdXAgPSBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyR3JvdXAocGFyYW1zKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGlcIiwge1xuICAgICAga2V5OiBwYXJhbXMua2V5XG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGlzdFN1YmhlYWRlciwge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzLmdyb3VwTGFiZWwsXG4gICAgICBjb21wb25lbnQ6IFwiZGl2XCJcbiAgICB9LCBwYXJhbXMuZ3JvdXApLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5ncm91cFVsXG4gICAgfSwgcGFyYW1zLmNoaWxkcmVuKSk7XG4gIH07XG5cbiAgdmFyIHJlbmRlckdyb3VwID0gcmVuZGVyR3JvdXBQcm9wIHx8IGRlZmF1bHRSZW5kZXJHcm91cDtcbiAgdmFyIHJlbmRlck9wdGlvbiA9IHJlbmRlck9wdGlvblByb3AgfHwgZ2V0T3B0aW9uTGFiZWw7XG5cbiAgdmFyIHJlbmRlckxpc3RPcHRpb24gPSBmdW5jdGlvbiByZW5kZXJMaXN0T3B0aW9uKG9wdGlvbiwgaW5kZXgpIHtcbiAgICB2YXIgb3B0aW9uUHJvcHMgPSBnZXRPcHRpb25Qcm9wcyh7XG4gICAgICBvcHRpb246IG9wdGlvbixcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpXCIsIF9leHRlbmRzKHt9LCBvcHRpb25Qcm9wcywge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzLm9wdGlvblxuICAgIH0pLCByZW5kZXJPcHRpb24ob3B0aW9uLCB7XG4gICAgICBzZWxlY3RlZDogb3B0aW9uUHJvcHNbJ2FyaWEtc2VsZWN0ZWQnXSxcbiAgICAgIGlucHV0VmFsdWU6IGlucHV0VmFsdWVcbiAgICB9KSk7XG4gIH07XG5cbiAgdmFyIGhhc0NsZWFySWNvbiA9ICFkaXNhYmxlQ2xlYXJhYmxlICYmICFkaXNhYmxlZDtcbiAgdmFyIGhhc1BvcHVwSWNvbiA9ICghZnJlZVNvbG8gfHwgZm9yY2VQb3B1cEljb24gPT09IHRydWUpICYmIGZvcmNlUG9wdXBJY29uICE9PSBmYWxzZTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiByZWYsXG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lLCBmb2N1c2VkICYmIGNsYXNzZXMuZm9jdXNlZCwgZnVsbFdpZHRoICYmIGNsYXNzZXMuZnVsbFdpZHRoLCBoYXNDbGVhckljb24gJiYgY2xhc3Nlcy5oYXNDbGVhckljb24sIGhhc1BvcHVwSWNvbiAmJiBjbGFzc2VzLmhhc1BvcHVwSWNvbilcbiAgfSwgZ2V0Um9vdFByb3BzKG90aGVyKSksIHJlbmRlcklucHV0KHtcbiAgICBpZDogaWQsXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgIGZ1bGxXaWR0aDogdHJ1ZSxcbiAgICBzaXplOiBzaXplID09PSAnc21hbGwnID8gJ3NtYWxsJyA6IHVuZGVmaW5lZCxcbiAgICBJbnB1dExhYmVsUHJvcHM6IGdldElucHV0TGFiZWxQcm9wcygpLFxuICAgIElucHV0UHJvcHM6IHtcbiAgICAgIHJlZjogc2V0QW5jaG9yRWwsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzZXMuaW5wdXRSb290LFxuICAgICAgc3RhcnRBZG9ybm1lbnQ6IHN0YXJ0QWRvcm5tZW50LFxuICAgICAgZW5kQWRvcm5tZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5lbmRBZG9ybm1lbnRcbiAgICAgIH0sIGhhc0NsZWFySWNvbiA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEljb25CdXR0b24sIF9leHRlbmRzKHt9LCBnZXRDbGVhclByb3BzKCksIHtcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IGNsZWFyVGV4dCxcbiAgICAgICAgdGl0bGU6IGNsZWFyVGV4dCxcbiAgICAgICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMuY2xlYXJJbmRpY2F0b3IsIGRpcnR5ICYmIGNsYXNzZXMuY2xlYXJJbmRpY2F0b3JEaXJ0eSlcbiAgICAgIH0pLCBjbG9zZUljb24pIDogbnVsbCwgaGFzUG9wdXBJY29uID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwgX2V4dGVuZHMoe30sIGdldFBvcHVwSW5kaWNhdG9yUHJvcHMoKSwge1xuICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwb3B1cE9wZW4gPyBjbG9zZVRleHQgOiBvcGVuVGV4dCxcbiAgICAgICAgdGl0bGU6IHBvcHVwT3BlbiA/IGNsb3NlVGV4dCA6IG9wZW5UZXh0LFxuICAgICAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5wb3B1cEluZGljYXRvciwgcG9wdXBPcGVuICYmIGNsYXNzZXMucG9wdXBJbmRpY2F0b3JPcGVuKVxuICAgICAgfSksIHBvcHVwSWNvbikgOiBudWxsKVxuICAgIH0sXG4gICAgaW5wdXRQcm9wczogX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMuaW5wdXQsIGZvY3VzZWRUYWcgPT09IC0xICYmIGNsYXNzZXMuaW5wdXRGb2N1c2VkKSxcbiAgICAgIGRpc2FibGVkOiBkaXNhYmxlZFxuICAgIH0sIGdldElucHV0UHJvcHMoKSlcbiAgfSkpLCBwb3B1cE9wZW4gJiYgYW5jaG9yRWwgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQb3BwZXJDb21wb25lbnQsIHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5wb3BwZXIsIGRpc2FibGVQb3J0YWwgJiYgY2xhc3Nlcy5wb3BwZXJEaXNhYmxlUG9ydGFsKSxcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6IGFuY2hvckVsID8gYW5jaG9yRWwuY2xpZW50V2lkdGggOiBudWxsXG4gICAgfSxcbiAgICByb2xlOiBcInByZXNlbnRhdGlvblwiLFxuICAgIGFuY2hvckVsOiBhbmNob3JFbCxcbiAgICBvcGVuOiB0cnVlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBhcGVyQ29tcG9uZW50LCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzLnBhcGVyXG4gIH0sIGxvYWRpbmcgJiYgZ3JvdXBlZE9wdGlvbnMubGVuZ3RoID09PSAwID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5sb2FkaW5nXG4gIH0sIGxvYWRpbmdUZXh0KSA6IG51bGwsIGdyb3VwZWRPcHRpb25zLmxlbmd0aCA9PT0gMCAmJiAhZnJlZVNvbG8gJiYgIWxvYWRpbmcgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzLm5vT3B0aW9uc1xuICB9LCBub09wdGlvbnNUZXh0KSA6IG51bGwsIGdyb3VwZWRPcHRpb25zLmxlbmd0aCA+IDAgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaXN0Ym94Q29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzLmxpc3Rib3hcbiAgfSwgZ2V0TGlzdGJveFByb3BzKCksIExpc3Rib3hQcm9wcyksIGdyb3VwZWRPcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uLCBpbmRleCkge1xuICAgIGlmIChncm91cEJ5KSB7XG4gICAgICByZXR1cm4gcmVuZGVyR3JvdXAoe1xuICAgICAgICBrZXk6IG9wdGlvbi5rZXksXG4gICAgICAgIGdyb3VwOiBvcHRpb24uZ3JvdXAsXG4gICAgICAgIGNoaWxkcmVuOiBvcHRpb24ub3B0aW9ucy5tYXAoZnVuY3Rpb24gKG9wdGlvbjIsIGluZGV4Mikge1xuICAgICAgICAgIHJldHVybiByZW5kZXJMaXN0T3B0aW9uKG9wdGlvbjIsIG9wdGlvbi5pbmRleCArIGluZGV4Mik7XG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyTGlzdE9wdGlvbihvcHRpb24sIGluZGV4KTtcbiAgfSkpIDogbnVsbCkpIDogbnVsbCk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IEF1dG9jb21wbGV0ZS5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxyXG4gICAqIElmIGB0cnVlYCwgdGhlIHBvcnRpb24gb2YgdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24gdGhhdCBoYXMgbm90IGJlZW4gdHlwZWQgYnkgdGhlIHVzZXIsXHJcbiAgICoga25vd24gYXMgdGhlIGNvbXBsZXRpb24gc3RyaW5nLCBhcHBlYXJzIGlubGluZSBhZnRlciB0aGUgaW5wdXQgY3Vyc29yIGluIHRoZSB0ZXh0Ym94LlxyXG4gICAqIFRoZSBpbmxpbmUgY29tcGxldGlvbiBzdHJpbmcgaXMgdmlzdWFsbHkgaGlnaGxpZ2h0ZWQgYW5kIGhhcyBhIHNlbGVjdGVkIHN0YXRlLlxyXG4gICAqL1xuICBhdXRvQ29tcGxldGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxyXG4gICAqIElmIGB0cnVlYCwgdGhlIGZpcnN0IG9wdGlvbiBpcyBhdXRvbWF0aWNhbGx5IGhpZ2hsaWdodGVkLlxyXG4gICAqL1xuICBhdXRvSGlnaGxpZ2h0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcclxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBzZWxlY3RlZCBvcHRpb24gYmVjb21lcyB0aGUgdmFsdWUgb2YgdGhlIGlucHV0XHJcbiAgICogd2hlbiB0aGUgQXV0b2NvbXBsZXRlIGxvc2VzIGZvY3VzIHVubGVzcyB0aGUgdXNlciBjaG9vc2VzXHJcbiAgICogYSBkaWZmZXJlbnQgb3B0aW9uIG9yIGNoYW5nZXMgdGhlIGNoYXJhY3RlciBzdHJpbmcgaW4gdGhlIGlucHV0LlxyXG4gICAqL1xuICBhdXRvU2VsZWN0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcclxuICAgKiBDb250cm9sIGlmIHRoZSBpbnB1dCBzaG91bGQgYmUgYmx1cnJlZCB3aGVuIGFuIG9wdGlvbiBpcyBzZWxlY3RlZDpcclxuICAgKlxyXG4gICAqIC0gYGZhbHNlYCB0aGUgaW5wdXQgaXMgbm90IGJsdXJyZWQuXHJcbiAgICogLSBgdHJ1ZWAgdGhlIGlucHV0IGlzIGFsd2F5cyBibHVycmVkLlxyXG4gICAqIC0gYHRvdWNoYCB0aGUgaW5wdXQgaXMgYmx1cnJlZCBhZnRlciBhIHRvdWNoIGV2ZW50LlxyXG4gICAqIC0gYG1vdXNlYCB0aGUgaW5wdXQgaXMgYmx1cnJlZCBhZnRlciBhIG1vdXNlIGV2ZW50LlxyXG4gICAqL1xuICBibHVyT25TZWxlY3Q6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbJ21vdXNlJywgJ3RvdWNoJ10pLCBQcm9wVHlwZXMuYm9vbF0pLFxuXG4gIC8qKlxyXG4gICAqIFByb3BzIGFwcGxpZWQgdG8gdGhlIFtgQ2hpcGBdKC9hcGkvY2hpcC8pIGVsZW1lbnQuXHJcbiAgICovXG4gIENoaXBQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcclxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXHJcbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxyXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0J3MgdGV4dCB3aWxsIGJlIGNsZWFyZWQgb24gYmx1ciBpZiBubyB2YWx1ZSBpcyBzZWxlY3RlZC5cclxuICAgKlxyXG4gICAqIFNldCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gaGVscCB0aGUgdXNlciBlbnRlciBhIG5ldyB2YWx1ZS5cclxuICAgKiBTZXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBoZWxwIHRoZSB1c2VyIHJlc3VtZSBoaXMgc2VhcmNoLlxyXG4gICAqL1xuICBjbGVhck9uQmx1cjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXHJcbiAgICogSWYgYHRydWVgLCBjbGVhciBhbGwgdmFsdWVzIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBlc2NhcGUgYW5kIHRoZSBwb3B1cCBpcyBjbG9zZWQuXHJcbiAgICovXG4gIGNsZWFyT25Fc2NhcGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxyXG4gICAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHRleHQgZm9yIHRoZSAqY2xlYXIqIGljb24gYnV0dG9uLlxyXG4gICAqXHJcbiAgICogRm9yIGxvY2FsaXphdGlvbiBwdXJwb3NlcywgeW91IGNhbiB1c2UgdGhlIHByb3ZpZGVkIFt0cmFuc2xhdGlvbnNdKC9ndWlkZXMvbG9jYWxpemF0aW9uLykuXHJcbiAgICovXG4gIGNsZWFyVGV4dDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcclxuICAgKiBUaGUgaWNvbiB0byBkaXNwbGF5IGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IGNsb3NlIGljb24uXHJcbiAgICovXG4gIGNsb3NlSWNvbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXHJcbiAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgdGV4dCBmb3IgdGhlICpjbG9zZSBwb3B1cCogaWNvbiBidXR0b24uXHJcbiAgICpcclxuICAgKiBGb3IgbG9jYWxpemF0aW9uIHB1cnBvc2VzLCB5b3UgY2FuIHVzZSB0aGUgcHJvdmlkZWQgW3RyYW5zbGF0aW9uc10oL2d1aWRlcy9sb2NhbGl6YXRpb24vKS5cclxuICAgKi9cbiAgY2xvc2VUZXh0OiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxyXG4gICAqIElmIGB0cnVlYCwgdGhlIHBvcHVwIHdpbGwgaWdub3JlIHRoZSBibHVyIGV2ZW50IGlmIHRoZSBpbnB1dCBpcyBmaWxsZWQuXHJcbiAgICogWW91IGNhbiBpbnNwZWN0IHRoZSBwb3B1cCBtYXJrdXAgd2l0aCB5b3VyIGJyb3dzZXIgdG9vbHMuXHJcbiAgICogQ29uc2lkZXIgdGhpcyBvcHRpb24gd2hlbiB5b3UgbmVlZCB0byBjdXN0b21pemUgdGhlIGNvbXBvbmVudC5cclxuICAgKi9cbiAgZGVidWc6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxyXG4gICAqIFRoZSBkZWZhdWx0IGlucHV0IHZhbHVlLiBVc2Ugd2hlbiB0aGUgY29tcG9uZW50IGlzIG5vdCBjb250cm9sbGVkLlxyXG4gICAqL1xuICBkZWZhdWx0VmFsdWU6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXHJcbiAgICogSWYgYHRydWVgLCB0aGUgaW5wdXQgY2FuJ3QgYmUgY2xlYXJlZC5cclxuICAgKi9cbiAgZGlzYWJsZUNsZWFyYWJsZTogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLmJvb2wsXG5cbiAgLyoqXHJcbiAgICogSWYgYHRydWVgLCB0aGUgcG9wdXAgd29uJ3QgY2xvc2Ugd2hlbiBhIHZhbHVlIGlzIHNlbGVjdGVkLlxyXG4gICAqL1xuICBkaXNhYmxlQ2xvc2VPblNlbGVjdDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXHJcbiAgICogSWYgYHRydWVgLCB0aGUgaW5wdXQgd2lsbCBiZSBkaXNhYmxlZC5cclxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxyXG4gICAqIElmIGB0cnVlYCwgd2lsbCBhbGxvdyBmb2N1cyBvbiBkaXNhYmxlZCBpdGVtcy5cclxuICAgKi9cbiAgZGlzYWJsZWRJdGVtc0ZvY3VzYWJsZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXHJcbiAgICogSWYgYHRydWVgLCB0aGUgbGlzdCBib3ggaW4gdGhlIHBvcHVwIHdpbGwgbm90IHdyYXAgZm9jdXMuXHJcbiAgICovXG4gIGRpc2FibGVMaXN0V3JhcDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXHJcbiAgICogRGlzYWJsZSB0aGUgcG9ydGFsIGJlaGF2aW9yLlxyXG4gICAqIFRoZSBjaGlsZHJlbiBzdGF5IHdpdGhpbiBpdCdzIHBhcmVudCBET00gaGllcmFyY2h5LlxyXG4gICAqL1xuICBkaXNhYmxlUG9ydGFsOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcclxuICAgKiBBIGZpbHRlciBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgdGhlIG9wdGlvbnMgdGhhdCBhcmUgZWxpZ2libGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RbXX0gb3B0aW9ucyBUaGUgb3B0aW9ucyB0byByZW5kZXIuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIFRoZSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAqIEByZXR1cm5zIHtUW119XHJcbiAgICovXG4gIGZpbHRlck9wdGlvbnM6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxyXG4gICAqIElmIGB0cnVlYCwgaGlkZSB0aGUgc2VsZWN0ZWQgb3B0aW9ucyBmcm9tIHRoZSBsaXN0IGJveC5cclxuICAgKi9cbiAgZmlsdGVyU2VsZWN0ZWRPcHRpb25zOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcclxuICAgKiBGb3JjZSB0aGUgdmlzaWJpbGl0eSBkaXNwbGF5IG9mIHRoZSBwb3B1cCBpY29uLlxyXG4gICAqL1xuICBmb3JjZVBvcHVwSWNvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9uZU9mKFsnYXV0byddKSwgUHJvcFR5cGVzLmJvb2xdKSxcblxuICAvKipcclxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBBdXRvY29tcGxldGUgaXMgZnJlZSBzb2xvLCBtZWFuaW5nIHRoYXQgdGhlIHVzZXIgaW5wdXQgaXMgbm90IGJvdW5kIHRvIHByb3ZpZGVkIG9wdGlvbnMuXHJcbiAgICovXG4gIGZyZWVTb2xvOiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAuYm9vbCxcblxuICAvKipcclxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBpbnB1dCB3aWxsIHRha2UgdXAgdGhlIGZ1bGwgd2lkdGggb2YgaXRzIGNvbnRhaW5lci5cclxuICAgKi9cbiAgZnVsbFdpZHRoOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcclxuICAgKiBUaGUgbGFiZWwgdG8gZGlzcGxheSB3aGVuIHRoZSB0YWdzIGFyZSB0cnVuY2F0ZWQgKGBsaW1pdFRhZ3NgKS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtb3JlIFRoZSBudW1iZXIgb2YgdHJ1bmNhdGVkIHRhZ3MuXHJcbiAgICogQHJldHVybnMge1JlYWN0Tm9kZX1cclxuICAgKi9cbiAgZ2V0TGltaXRUYWdzVGV4dDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXHJcbiAgICogVXNlZCB0byBkZXRlcm1pbmUgdGhlIGRpc2FibGVkIHN0YXRlIGZvciBhIGdpdmVuIG9wdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VH0gb3B0aW9uIFRoZSBvcHRpb24gdG8gdGVzdC5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cbiAgZ2V0T3B0aW9uRGlzYWJsZWQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxyXG4gICAqIFVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBzdHJpbmcgdmFsdWUgZm9yIGEgZ2l2ZW4gb3B0aW9uLlxyXG4gICAqIEl0J3MgdXNlZCB0byBmaWxsIHRoZSBpbnB1dCAoYW5kIHRoZSBsaXN0IGJveCBvcHRpb25zIGlmIGByZW5kZXJPcHRpb25gIGlzIG5vdCBwcm92aWRlZCkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1R9IG9wdGlvblxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICovXG4gIGdldE9wdGlvbkxhYmVsOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcclxuICAgKiBVc2VkIHRvIGRldGVybWluZSBpZiBhbiBvcHRpb24gaXMgc2VsZWN0ZWQsIGNvbnNpZGVyaW5nIHRoZSBjdXJyZW50IHZhbHVlLlxyXG4gICAqIFVzZXMgc3RyaWN0IGVxdWFsaXR5IGJ5IGRlZmF1bHQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1R9IG9wdGlvbiBUaGUgb3B0aW9uIHRvIHRlc3QuXHJcbiAgICogQHBhcmFtIHtUfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdCBhZ2FpbnN0LlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xuICBnZXRPcHRpb25TZWxlY3RlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXHJcbiAgICogSWYgcHJvdmlkZWQsIHRoZSBvcHRpb25zIHdpbGwgYmUgZ3JvdXBlZCB1bmRlciB0aGUgcmV0dXJuZWQgc3RyaW5nLlxyXG4gICAqIFRoZSBncm91cEJ5IHZhbHVlIGlzIGFsc28gdXNlZCBhcyB0aGUgdGV4dCBmb3IgZ3JvdXAgaGVhZGluZ3Mgd2hlbiBgcmVuZGVyR3JvdXBgIGlzIG5vdCBwcm92aWRlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VH0gb3B0aW9ucyBUaGUgb3B0aW9ucyB0byBncm91cC5cclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAqL1xuICBncm91cEJ5OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcclxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjb21wb25lbnQgaGFuZGxlcyB0aGUgXCJIb21lXCIgYW5kIFwiRW5kXCIga2V5cyB3aGVuIHRoZSBwb3B1cCBpcyBvcGVuLlxyXG4gICAqIEl0IHNob3VsZCBtb3ZlIGZvY3VzIHRvIHRoZSBmaXJzdCBvcHRpb24gYW5kIGxhc3Qgb3B0aW9uLCByZXNwZWN0aXZlbHkuXHJcbiAgICovXG4gIGhhbmRsZUhvbWVFbmRLZXlzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcclxuICAgKiBUaGlzIHByb3AgaXMgdXNlZCB0byBoZWxwIGltcGxlbWVudCB0aGUgYWNjZXNzaWJpbGl0eSBsb2dpYy5cclxuICAgKiBJZiB5b3UgZG9uJ3QgcHJvdmlkZSB0aGlzIHByb3AuIEl0IGZhbGxzIGJhY2sgdG8gYSByYW5kb21seSBnZW5lcmF0ZWQgaWQuXHJcbiAgICovXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxyXG4gICAqIElmIGB0cnVlYCwgdGhlIGhpZ2hsaWdodCBjYW4gbW92ZSB0byB0aGUgaW5wdXQuXHJcbiAgICovXG4gIGluY2x1ZGVJbnB1dEluTGlzdDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXHJcbiAgICogVGhlIGlucHV0IHZhbHVlLlxyXG4gICAqL1xuICBpbnB1dFZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxyXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0YWdzIHRoYXQgd2lsbCBiZSB2aXNpYmxlIHdoZW4gbm90IGZvY3VzZWQuXHJcbiAgICogU2V0IGAtMWAgdG8gZGlzYWJsZSB0aGUgbGltaXQuXHJcbiAgICovXG4gIGxpbWl0VGFnczogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcclxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgdG8gcmVuZGVyIHRoZSBsaXN0Ym94LlxyXG4gICAqL1xuICBMaXN0Ym94Q29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG5cbiAgLyoqXHJcbiAgICogUHJvcHMgYXBwbGllZCB0byB0aGUgTGlzdGJveCBlbGVtZW50LlxyXG4gICAqL1xuICBMaXN0Ym94UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXHJcbiAgICogSWYgYHRydWVgLCB0aGUgY29tcG9uZW50IGlzIGluIGEgbG9hZGluZyBzdGF0ZS5cclxuICAgKi9cbiAgbG9hZGluZzogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXHJcbiAgICogVGV4dCB0byBkaXNwbGF5IHdoZW4gaW4gYSBsb2FkaW5nIHN0YXRlLlxyXG4gICAqXHJcbiAgICogRm9yIGxvY2FsaXphdGlvbiBwdXJwb3NlcywgeW91IGNhbiB1c2UgdGhlIHByb3ZpZGVkIFt0cmFuc2xhdGlvbnNdKC9ndWlkZXMvbG9jYWxpemF0aW9uLykuXHJcbiAgICovXG4gIGxvYWRpbmdUZXh0OiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcclxuICAgKiBJZiBgdHJ1ZWAsIGB2YWx1ZWAgbXVzdCBiZSBhbiBhcnJheSBhbmQgdGhlIG1lbnUgd2lsbCBzdXBwb3J0IG11bHRpcGxlIHNlbGVjdGlvbnMuXHJcbiAgICovXG4gIG11bHRpcGxlOiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAuYm9vbCxcblxuICAvKipcclxuICAgKiBUZXh0IHRvIGRpc3BsYXkgd2hlbiB0aGVyZSBhcmUgbm8gb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEZvciBsb2NhbGl6YXRpb24gcHVycG9zZXMsIHlvdSBjYW4gdXNlIHRoZSBwcm92aWRlZCBbdHJhbnNsYXRpb25zXSgvZ3VpZGVzL2xvY2FsaXphdGlvbi8pLlxyXG4gICAqL1xuICBub09wdGlvbnNUZXh0OiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcclxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxyXG4gICAqIEBwYXJhbSB7VHxUW119IHZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGNvbXBvbmVudC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIE9uZSBvZiBcImNyZWF0ZS1vcHRpb25cIiwgXCJzZWxlY3Qtb3B0aW9uXCIsIFwicmVtb3ZlLW9wdGlvblwiLCBcImJsdXJcIiBvciBcImNsZWFyXCIuXHJcbiAgICovXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcclxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBwb3B1cCByZXF1ZXN0cyB0byBiZSBjbG9zZWQuXHJcbiAgICogVXNlIGluIGNvbnRyb2xsZWQgbW9kZSAoc2VlIG9wZW4pLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gQ2FuIGJlOiBgXCJ0b2dnbGVJbnB1dFwiYCwgYFwiZXNjYXBlXCJgLCBgXCJzZWxlY3Qtb3B0aW9uXCJgLCBgXCJibHVyXCJgLlxyXG4gICAqL1xuICBvbkNsb3NlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcclxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBoaWdobGlnaHQgb3B0aW9uIGNoYW5nZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXHJcbiAgICogQHBhcmFtIHtUfSBvcHRpb24gVGhlIGhpZ2hsaWdodGVkIG9wdGlvbi5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIENhbiBiZTogYFwia2V5Ym9hcmRcImAsIGBcImF1dG9cImAsIGBcIm1vdXNlXCJgLlxyXG4gICAqL1xuICBvbkhpZ2hsaWdodENoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXHJcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgaW5wdXQgdmFsdWUgY2hhbmdlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgdGV4dCBpbnB1dC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIENhbiBiZTogYFwiaW5wdXRcImAgKHVzZXIgaW5wdXQpLCBgXCJyZXNldFwiYCAocHJvZ3JhbW1hdGljIGNoYW5nZSksIGBcImNsZWFyXCJgLlxyXG4gICAqL1xuICBvbklucHV0Q2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcclxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBwb3B1cCByZXF1ZXN0cyB0byBiZSBvcGVuZWQuXHJcbiAgICogVXNlIGluIGNvbnRyb2xsZWQgbW9kZSAoc2VlIG9wZW4pLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxyXG4gICAqL1xuICBvbk9wZW46IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxyXG4gICAqIENvbnRyb2wgdGhlIHBvcHVwYCBvcGVuIHN0YXRlLlxyXG4gICAqL1xuICBvcGVuOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcclxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBwb3B1cCB3aWxsIG9wZW4gb24gaW5wdXQgZm9jdXMuXHJcbiAgICovXG4gIG9wZW5PbkZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcclxuICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCB0ZXh0IGZvciB0aGUgKm9wZW4gcG9wdXAqIGljb24gYnV0dG9uLlxyXG4gICAqXHJcbiAgICogRm9yIGxvY2FsaXphdGlvbiBwdXJwb3NlcywgeW91IGNhbiB1c2UgdGhlIHByb3ZpZGVkIFt0cmFuc2xhdGlvbnNdKC9ndWlkZXMvbG9jYWxpemF0aW9uLykuXHJcbiAgICovXG4gIG9wZW5UZXh0OiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxyXG4gICAqIEFycmF5IG9mIG9wdGlvbnMuXHJcbiAgICovXG4gIG9wdGlvbnM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuXG4gIC8qKlxyXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCB0byByZW5kZXIgdGhlIGJvZHkgb2YgdGhlIHBvcHVwLlxyXG4gICAqL1xuICBQYXBlckNvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxyXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wdXAuXHJcbiAgICovXG4gIFBvcHBlckNvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxyXG4gICAqIFRoZSBpY29uIHRvIGRpc3BsYXkgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgcG9wdXAgaWNvbi5cclxuICAgKi9cbiAgcG9wdXBJY29uOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcclxuICAgKiBSZW5kZXIgdGhlIGdyb3VwLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHthbnl9IG9wdGlvbiBUaGUgZ3JvdXAgdG8gcmVuZGVyLlxyXG4gICAqIEByZXR1cm5zIHtSZWFjdE5vZGV9XHJcbiAgICovXG4gIHJlbmRlckdyb3VwOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcclxuICAgKiBSZW5kZXIgdGhlIGlucHV0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xyXG4gICAqIEByZXR1cm5zIHtSZWFjdE5vZGV9XHJcbiAgICovXG4gIHJlbmRlcklucHV0OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXG4gIC8qKlxyXG4gICAqIFJlbmRlciB0aGUgb3B0aW9uLCB1c2UgYGdldE9wdGlvbkxhYmVsYCBieSBkZWZhdWx0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUfSBvcHRpb24gVGhlIG9wdGlvbiB0byByZW5kZXIuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIFRoZSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAqIEByZXR1cm5zIHtSZWFjdE5vZGV9XHJcbiAgICovXG4gIHJlbmRlck9wdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXHJcbiAgICogUmVuZGVyIHRoZSBzZWxlY3RlZCB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VFtdfSB2YWx1ZSBUaGUgYHZhbHVlYCBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50LlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGdldFRhZ1Byb3BzIEEgdGFnIHByb3BzIGdldHRlci5cclxuICAgKiBAcmV0dXJucyB7UmVhY3ROb2RlfVxyXG4gICAqL1xuICByZW5kZXJUYWdzOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcclxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBpbnB1dCdzIHRleHQgd2lsbCBiZSBzZWxlY3RlZCBvbiBmb2N1cy5cclxuICAgKiBJdCBoZWxwcyB0aGUgdXNlciBjbGVhciB0aGUgc2VsZWN0ZWQgdmFsdWUuXHJcbiAgICovXG4gIHNlbGVjdE9uRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxyXG4gICAqIFRoZSBzaXplIG9mIHRoZSBhdXRvY29tcGxldGUuXHJcbiAgICovXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ21lZGl1bScsICdzbWFsbCddKSxcblxuICAvKipcclxuICAgKiBUaGUgdmFsdWUgb2YgdGhlIGF1dG9jb21wbGV0ZS5cclxuICAgKlxyXG4gICAqIFRoZSB2YWx1ZSBtdXN0IGhhdmUgcmVmZXJlbmNlIGVxdWFsaXR5IHdpdGggdGhlIG9wdGlvbiBpbiBvcmRlciB0byBiZSBzZWxlY3RlZC5cclxuICAgKiBZb3UgY2FuIGN1c3RvbWl6ZSB0aGUgZXF1YWxpdHkgYmVoYXZpb3Igd2l0aCB0aGUgYGdldE9wdGlvblNlbGVjdGVkYCBwcm9wLlxyXG4gICAqL1xuICB2YWx1ZTogUHJvcFR5cGVzLmFueVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlBdXRvY29tcGxldGUnXG59KShBdXRvY29tcGxldGUpOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1Db250cm9sU3RhdGUoX3JlZikge1xuICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgc3RhdGVzID0gX3JlZi5zdGF0ZXMsXG4gICAgICBtdWlGb3JtQ29udHJvbCA9IF9yZWYubXVpRm9ybUNvbnRyb2w7XG4gIHJldHVybiBzdGF0ZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHN0YXRlKSB7XG4gICAgYWNjW3N0YXRlXSA9IHByb3BzW3N0YXRlXTtcblxuICAgIGlmIChtdWlGb3JtQ29udHJvbCkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wc1tzdGF0ZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGFjY1tzdGF0ZV0gPSBtdWlGb3JtQ29udHJvbFtzdGF0ZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufSIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0Jztcbi8qKlxuICogQGlnbm9yZSAtIGludGVybmFsIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgRm9ybUNvbnRyb2xDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCgpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBGb3JtQ29udHJvbENvbnRleHQuZGlzcGxheU5hbWUgPSAnRm9ybUNvbnRyb2xDb250ZXh0Jztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvcm1Db250cm9sKCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChGb3JtQ29udHJvbENvbnRleHQpO1xufVxuZXhwb3J0IGRlZmF1bHQgRm9ybUNvbnRyb2xDb250ZXh0OyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnLi4vdXRpbHMvZGVib3VuY2UnO1xuaW1wb3J0IHVzZUZvcmtSZWYgZnJvbSAnLi4vdXRpbHMvdXNlRm9ya1JlZic7XG5pbXBvcnQgZGVwcmVjYXRlZFByb3BUeXBlIGZyb20gJy4uL3V0aWxzL2RlcHJlY2F0ZWRQcm9wVHlwZSc7XG5cbmZ1bmN0aW9uIGdldFN0eWxlVmFsdWUoY29tcHV0ZWRTdHlsZSwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbcHJvcGVydHldLCAxMCkgfHwgMDtcbn1cblxudmFyIHVzZUVuaGFuY2VkRWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG52YXIgc3R5bGVzID0ge1xuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgc2hhZG93IHRleHRhcmVhIGVsZW1lbnQuICovXG4gIHNoYWRvdzoge1xuICAgIC8vIFZpc2liaWxpdHkgbmVlZGVkIHRvIGhpZGUgdGhlIGV4dHJhIHRleHQgYXJlYSBvbiBpUGFkc1xuICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBjb250ZW50IGZsb3dcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAvLyBJZ25vcmUgdGhlIHNjcm9sbGJhciB3aWR0aFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICBoZWlnaHQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGxheWVyLCBpbmNyZWFzZSB0aGUgaXNvbGF0aW9uIG9mIHRoZSBjb21wdXRlZCB2YWx1ZXNcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVaKDApJ1xuICB9XG59O1xudmFyIFRleHRhcmVhQXV0b3NpemUgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBUZXh0YXJlYUF1dG9zaXplKHByb3BzLCByZWYpIHtcbiAgdmFyIG9uQ2hhbmdlID0gcHJvcHMub25DaGFuZ2UsXG4gICAgICByb3dzID0gcHJvcHMucm93cyxcbiAgICAgIHJvd3NNYXggPSBwcm9wcy5yb3dzTWF4LFxuICAgICAgcm93c01pblByb3AgPSBwcm9wcy5yb3dzTWluLFxuICAgICAgbWF4Um93c1Byb3AgPSBwcm9wcy5tYXhSb3dzLFxuICAgICAgX3Byb3BzJG1pblJvd3MgPSBwcm9wcy5taW5Sb3dzLFxuICAgICAgbWluUm93c1Byb3AgPSBfcHJvcHMkbWluUm93cyA9PT0gdm9pZCAwID8gMSA6IF9wcm9wcyRtaW5Sb3dzLFxuICAgICAgc3R5bGUgPSBwcm9wcy5zdHlsZSxcbiAgICAgIHZhbHVlID0gcHJvcHMudmFsdWUsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wib25DaGFuZ2VcIiwgXCJyb3dzXCIsIFwicm93c01heFwiLCBcInJvd3NNaW5cIiwgXCJtYXhSb3dzXCIsIFwibWluUm93c1wiLCBcInN0eWxlXCIsIFwidmFsdWVcIl0pO1xuXG4gIHZhciBtYXhSb3dzID0gbWF4Um93c1Byb3AgfHwgcm93c01heDtcbiAgdmFyIG1pblJvd3MgPSByb3dzIHx8IHJvd3NNaW5Qcm9wIHx8IG1pblJvd3NQcm9wO1xuXG4gIHZhciBfUmVhY3QkdXNlUmVmID0gUmVhY3QudXNlUmVmKHZhbHVlICE9IG51bGwpLFxuICAgICAgaXNDb250cm9sbGVkID0gX1JlYWN0JHVzZVJlZi5jdXJyZW50O1xuXG4gIHZhciBpbnB1dFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIGhhbmRsZVJlZiA9IHVzZUZvcmtSZWYocmVmLCBpbnB1dFJlZik7XG4gIHZhciBzaGFkb3dSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciByZW5kZXJzID0gUmVhY3QudXNlUmVmKDApO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZSh7fSksXG4gICAgICBzdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldFN0YXRlID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciBzeW5jSGVpZ2h0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnB1dCA9IGlucHV0UmVmLmN1cnJlbnQ7XG4gICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpbnB1dCk7XG4gICAgdmFyIGlucHV0U2hhbGxvdyA9IHNoYWRvd1JlZi5jdXJyZW50O1xuICAgIGlucHV0U2hhbGxvdy5zdHlsZS53aWR0aCA9IGNvbXB1dGVkU3R5bGUud2lkdGg7XG4gICAgaW5wdXRTaGFsbG93LnZhbHVlID0gaW5wdXQudmFsdWUgfHwgcHJvcHMucGxhY2Vob2xkZXIgfHwgJ3gnO1xuXG4gICAgaWYgKGlucHV0U2hhbGxvdy52YWx1ZS5zbGljZSgtMSkgPT09ICdcXG4nKSB7XG4gICAgICAvLyBDZXJ0YWluIGZvbnRzIHdoaWNoIG92ZXJmbG93IHRoZSBsaW5lIGhlaWdodCB3aWxsIGNhdXNlIHRoZSB0ZXh0YXJlYVxuICAgICAgLy8gdG8gcmVwb3J0IGEgZGlmZmVyZW50IHNjcm9sbEhlaWdodCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgbGFzdCBsaW5lXG4gICAgICAvLyBpcyBlbXB0eS4gTWFrZSBpdCBub24tZW1wdHkgdG8gYXZvaWQgdGhpcyBpc3N1ZS5cbiAgICAgIGlucHV0U2hhbGxvdy52YWx1ZSArPSAnICc7XG4gICAgfVxuXG4gICAgdmFyIGJveFNpemluZyA9IGNvbXB1dGVkU3R5bGVbJ2JveC1zaXppbmcnXTtcbiAgICB2YXIgcGFkZGluZyA9IGdldFN0eWxlVmFsdWUoY29tcHV0ZWRTdHlsZSwgJ3BhZGRpbmctYm90dG9tJykgKyBnZXRTdHlsZVZhbHVlKGNvbXB1dGVkU3R5bGUsICdwYWRkaW5nLXRvcCcpO1xuICAgIHZhciBib3JkZXIgPSBnZXRTdHlsZVZhbHVlKGNvbXB1dGVkU3R5bGUsICdib3JkZXItYm90dG9tLXdpZHRoJykgKyBnZXRTdHlsZVZhbHVlKGNvbXB1dGVkU3R5bGUsICdib3JkZXItdG9wLXdpZHRoJyk7IC8vIFRoZSBoZWlnaHQgb2YgdGhlIGlubmVyIGNvbnRlbnRcblxuICAgIHZhciBpbm5lckhlaWdodCA9IGlucHV0U2hhbGxvdy5zY3JvbGxIZWlnaHQgLSBwYWRkaW5nOyAvLyBNZWFzdXJlIGhlaWdodCBvZiBhIHRleHRhcmVhIHdpdGggYSBzaW5nbGUgcm93XG5cbiAgICBpbnB1dFNoYWxsb3cudmFsdWUgPSAneCc7XG4gICAgdmFyIHNpbmdsZVJvd0hlaWdodCA9IGlucHV0U2hhbGxvdy5zY3JvbGxIZWlnaHQgLSBwYWRkaW5nOyAvLyBUaGUgaGVpZ2h0IG9mIHRoZSBvdXRlciBjb250ZW50XG5cbiAgICB2YXIgb3V0ZXJIZWlnaHQgPSBpbm5lckhlaWdodDtcblxuICAgIGlmIChtaW5Sb3dzKSB7XG4gICAgICBvdXRlckhlaWdodCA9IE1hdGgubWF4KE51bWJlcihtaW5Sb3dzKSAqIHNpbmdsZVJvd0hlaWdodCwgb3V0ZXJIZWlnaHQpO1xuICAgIH1cblxuICAgIGlmIChtYXhSb3dzKSB7XG4gICAgICBvdXRlckhlaWdodCA9IE1hdGgubWluKE51bWJlcihtYXhSb3dzKSAqIHNpbmdsZVJvd0hlaWdodCwgb3V0ZXJIZWlnaHQpO1xuICAgIH1cblxuICAgIG91dGVySGVpZ2h0ID0gTWF0aC5tYXgob3V0ZXJIZWlnaHQsIHNpbmdsZVJvd0hlaWdodCk7IC8vIFRha2UgdGhlIGJveCBzaXppbmcgaW50byBhY2NvdW50IGZvciBhcHBseWluZyB0aGlzIHZhbHVlIGFzIGEgc3R5bGUuXG5cbiAgICB2YXIgb3V0ZXJIZWlnaHRTdHlsZSA9IG91dGVySGVpZ2h0ICsgKGJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnID8gcGFkZGluZyArIGJvcmRlciA6IDApO1xuICAgIHZhciBvdmVyZmxvdyA9IE1hdGguYWJzKG91dGVySGVpZ2h0IC0gaW5uZXJIZWlnaHQpIDw9IDE7XG4gICAgc2V0U3RhdGUoZnVuY3Rpb24gKHByZXZTdGF0ZSkge1xuICAgICAgLy8gTmVlZCBhIGxhcmdlIGVub3VnaCBkaWZmZXJlbmNlIHRvIHVwZGF0ZSB0aGUgaGVpZ2h0LlxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyBpbmZpbml0ZSByZW5kZXJpbmcgbG9vcC5cbiAgICAgIGlmIChyZW5kZXJzLmN1cnJlbnQgPCAyMCAmJiAob3V0ZXJIZWlnaHRTdHlsZSA+IDAgJiYgTWF0aC5hYnMoKHByZXZTdGF0ZS5vdXRlckhlaWdodFN0eWxlIHx8IDApIC0gb3V0ZXJIZWlnaHRTdHlsZSkgPiAxIHx8IHByZXZTdGF0ZS5vdmVyZmxvdyAhPT0gb3ZlcmZsb3cpKSB7XG4gICAgICAgIHJlbmRlcnMuY3VycmVudCArPSAxO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG92ZXJmbG93OiBvdmVyZmxvdyxcbiAgICAgICAgICBvdXRlckhlaWdodFN0eWxlOiBvdXRlckhlaWdodFN0eWxlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChyZW5kZXJzLmN1cnJlbnQgPT09IDIwKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihbJ01hdGVyaWFsLVVJOiBUb28gbWFueSByZS1yZW5kZXJzLiBUaGUgbGF5b3V0IGlzIHVuc3RhYmxlLicsICdUZXh0YXJlYUF1dG9zaXplIGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLiddLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgIH0pO1xuICB9LCBbbWF4Um93cywgbWluUm93cywgcHJvcHMucGxhY2Vob2xkZXJdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlUmVzaXplID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgcmVuZGVycy5jdXJyZW50ID0gMDtcbiAgICAgIHN5bmNIZWlnaHQoKTtcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaGFuZGxlUmVzaXplLmNsZWFyKCk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICB9O1xuICB9LCBbc3luY0hlaWdodF0pO1xuICB1c2VFbmhhbmNlZEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgc3luY0hlaWdodCgpO1xuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZW5kZXJzLmN1cnJlbnQgPSAwO1xuICB9LCBbdmFsdWVdKTtcblxuICB2YXIgaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gICAgcmVuZGVycy5jdXJyZW50ID0gMDtcblxuICAgIGlmICghaXNDb250cm9sbGVkKSB7XG4gICAgICBzeW5jSGVpZ2h0KCk7XG4gICAgfVxuXG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICBvbkNoYW5nZShldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiLCBfZXh0ZW5kcyh7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2UsXG4gICAgcmVmOiBoYW5kbGVSZWYgLy8gQXBwbHkgdGhlIHJvd3MgcHJvcCB0byBnZXQgYSBcImNvcnJlY3RcIiBmaXJzdCBTU1IgcGFpbnRcbiAgICAsXG4gICAgcm93czogbWluUm93cyxcbiAgICBzdHlsZTogX2V4dGVuZHMoe1xuICAgICAgaGVpZ2h0OiBzdGF0ZS5vdXRlckhlaWdodFN0eWxlLFxuICAgICAgLy8gTmVlZCBhIGxhcmdlIGVub3VnaCBkaWZmZXJlbmNlIHRvIGFsbG93IHNjcm9sbGluZy5cbiAgICAgIC8vIFRoaXMgcHJldmVudHMgaW5maW5pdGUgcmVuZGVyaW5nIGxvb3AuXG4gICAgICBvdmVyZmxvdzogc3RhdGUub3ZlcmZsb3cgPyAnaGlkZGVuJyA6IG51bGxcbiAgICB9LCBzdHlsZSlcbiAgfSwgb3RoZXIpKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiLCB7XG4gICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgIGNsYXNzTmFtZTogcHJvcHMuY2xhc3NOYW1lLFxuICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgIHJlZjogc2hhZG93UmVmLFxuICAgIHRhYkluZGV4OiAtMSxcbiAgICBzdHlsZTogX2V4dGVuZHMoe30sIHN0eWxlcy5zaGFkb3csIHN0eWxlKVxuICB9KSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFRleHRhcmVhQXV0b3NpemUucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkuXG4gICAqL1xuICBtYXhSb3dzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheS5cbiAgICovXG4gIG1pblJvd3M6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5LlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYG1pblJvd3NgIGluc3RlYWQuXG4gICAqL1xuICByb3dzOiBkZXByZWNhdGVkUHJvcFR5cGUoUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLCAnVXNlIGBtaW5Sb3dzYCBpbnN0ZWFkLicpLFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgbWF4Um93c2AgaW5zdGVhZC5cbiAgICovXG4gIHJvd3NNYXg6IGRlcHJlY2F0ZWRQcm9wVHlwZShQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksICdVc2UgYG1heFJvd3NgIGluc3RlYWQuJyksXG5cbiAgLyoqXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBtaW5Sb3dzYCBpbnN0ZWFkLlxuICAgKi9cbiAgcm93c01pbjogZGVwcmVjYXRlZFByb3BUeXBlKFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSwgJ1VzZSBgbWluUm93c2AgaW5zdGVhZC4nKSxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSwgUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgVGV4dGFyZWFBdXRvc2l6ZTsiLCIvLyBTdXBwb3J0cyBkZXRlcm1pbmF0aW9uIG9mIGlzQ29udHJvbGxlZCgpLlxuLy8gQ29udHJvbGxlZCBpbnB1dCBhY2NlcHRzIGl0cyBjdXJyZW50IHZhbHVlIGFzIGEgcHJvcC5cbi8vXG4vLyBAc2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZm9ybXMuaHRtbCNjb250cm9sbGVkLWNvbXBvbmVudHNcbi8vIEBwYXJhbSB2YWx1ZVxuLy8gQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgc3RyaW5nIChpbmNsdWRpbmcgJycpIG9yIG51bWJlciAoaW5jbHVkaW5nIHplcm8pXG5leHBvcnQgZnVuY3Rpb24gaGFzVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgIShBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApO1xufSAvLyBEZXRlcm1pbmUgaWYgZmllbGQgaXMgZW1wdHkgb3IgZmlsbGVkLlxuLy8gUmVzcG9uc2UgZGV0ZXJtaW5lcyBpZiBsYWJlbCBpcyBwcmVzZW50ZWQgYWJvdmUgZmllbGQgb3IgYXMgcGxhY2Vob2xkZXIuXG4vL1xuLy8gQHBhcmFtIG9ialxuLy8gQHBhcmFtIFNTUlxuLy8gQHJldHVybnMge2Jvb2xlYW59IEZhbHNlIHdoZW4gbm90IHByZXNlbnQgb3IgZW1wdHkgc3RyaW5nLlxuLy8gICAgICAgICAgICAgICAgICAgIFRydWUgd2hlbiBhbnkgbnVtYmVyIG9yIHN0cmluZyB3aXRoIGxlbmd0aC5cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsbGVkKG9iaikge1xuICB2YXIgU1NSID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgcmV0dXJuIG9iaiAmJiAoaGFzVmFsdWUob2JqLnZhbHVlKSAmJiBvYmoudmFsdWUgIT09ICcnIHx8IFNTUiAmJiBoYXNWYWx1ZShvYmouZGVmYXVsdFZhbHVlKSAmJiBvYmouZGVmYXVsdFZhbHVlICE9PSAnJyk7XG59IC8vIERldGVybWluZSBpZiBhbiBJbnB1dCBpcyBhZG9ybmVkIG9uIHN0YXJ0LlxuLy8gSXQncyBjb3JyZXNwb25kaW5nIHRvIHRoZSBsZWZ0IHdpdGggTFRSLlxuLy9cbi8vIEBwYXJhbSBvYmpcbi8vIEByZXR1cm5zIHtib29sZWFufSBGYWxzZSB3aGVuIG5vIGFkb3JubWVudHMuXG4vLyAgICAgICAgICAgICAgICAgICAgVHJ1ZSB3aGVuIGFkb3JuZWQgYXQgdGhlIHN0YXJ0LlxuXG5leHBvcnQgZnVuY3Rpb24gaXNBZG9ybmVkU3RhcnQob2JqKSB7XG4gIHJldHVybiBvYmouc3RhcnRBZG9ybm1lbnQ7XG59IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IHsgZm9ybWF0TXVpRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRNdWlFcnJvck1lc3NhZ2UgfSBmcm9tIFwiQG1hdGVyaWFsLXVpL3V0aWxzXCI7XG5cbi8qIGVzbGludC1kaXNhYmxlIGpzeC1hMTF5L2NsaWNrLWV2ZW50cy1oYXZlLWtleS1ldmVudHMsIGpzeC1hMTF5L25vLXN0YXRpYy1lbGVtZW50LWludGVyYWN0aW9ucyAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHsgcmVmVHlwZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgZm9ybUNvbnRyb2xTdGF0ZSBmcm9tICcuLi9Gb3JtQ29udHJvbC9mb3JtQ29udHJvbFN0YXRlJztcbmltcG9ydCBGb3JtQ29udHJvbENvbnRleHQsIHsgdXNlRm9ybUNvbnRyb2wgfSBmcm9tICcuLi9Gb3JtQ29udHJvbC9Gb3JtQ29udHJvbENvbnRleHQnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IGNhcGl0YWxpemUgZnJvbSAnLi4vdXRpbHMvY2FwaXRhbGl6ZSc7XG5pbXBvcnQgdXNlRm9ya1JlZiBmcm9tICcuLi91dGlscy91c2VGb3JrUmVmJztcbmltcG9ydCBUZXh0YXJlYUF1dG9zaXplIGZyb20gJy4uL1RleHRhcmVhQXV0b3NpemUnO1xuaW1wb3J0IHsgaXNGaWxsZWQgfSBmcm9tICcuL3V0aWxzJztcbmV4cG9ydCB2YXIgc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKHRoZW1lKSB7XG4gIHZhciBsaWdodCA9IHRoZW1lLnBhbGV0dGUudHlwZSA9PT0gJ2xpZ2h0JztcbiAgdmFyIHBsYWNlaG9sZGVyID0ge1xuICAgIGNvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICBvcGFjaXR5OiBsaWdodCA/IDAuNDIgOiAwLjUsXG4gICAgdHJhbnNpdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKCdvcGFjaXR5Jywge1xuICAgICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXJcbiAgICB9KVxuICB9O1xuICB2YXIgcGxhY2Vob2xkZXJIaWRkZW4gPSB7XG4gICAgb3BhY2l0eTogJzAgIWltcG9ydGFudCdcbiAgfTtcbiAgdmFyIHBsYWNlaG9sZGVyVmlzaWJsZSA9IHtcbiAgICBvcGFjaXR5OiBsaWdodCA/IDAuNDIgOiAwLjVcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICAnQGdsb2JhbCc6IHtcbiAgICAgICdAa2V5ZnJhbWVzIG11aS1hdXRvLWZpbGwnOiB7fSxcbiAgICAgICdAa2V5ZnJhbWVzIG11aS1hdXRvLWZpbGwtY2FuY2VsJzoge31cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgICByb290OiBfZXh0ZW5kcyh7fSwgdGhlbWUudHlwb2dyYXBoeS5ib2R5MSwge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudGV4dC5wcmltYXJ5LFxuICAgICAgbGluZUhlaWdodDogJzEuMTg3NmVtJyxcbiAgICAgIC8vIFJlc2V0ICgxOXB4KSwgbWF0Y2ggdGhlIG5hdGl2ZSBpbnB1dCBsaW5lLWhlaWdodFxuICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAvLyBQcmV2ZW50IHBhZGRpbmcgaXNzdWUgd2l0aCBmdWxsV2lkdGguXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIGN1cnNvcjogJ3RleHQnLFxuICAgICAgZGlzcGxheTogJ2lubGluZS1mbGV4JyxcbiAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgJyYkZGlzYWJsZWQnOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnRleHQuZGlzYWJsZWQsXG4gICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnXG4gICAgICB9XG4gICAgfSksXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIHRoZSBjb21wb25lbnQgaXMgYSBkZXNjZW5kYW50IG9mIGBGb3JtQ29udHJvbGAuICovXG4gICAgZm9ybUNvbnRyb2w6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiB0aGUgY29tcG9uZW50IGlzIGZvY3VzZWQuICovXG4gICAgZm9jdXNlZDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBkaXNhYmxlZD17dHJ1ZX1gLiAqL1xuICAgIGRpc2FibGVkOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHN0YXJ0QWRvcm5tZW50YCBpcyBwcm92aWRlZC4gKi9cbiAgICBhZG9ybmVkU3RhcnQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZW5kQWRvcm5tZW50YCBpcyBwcm92aWRlZC4gKi9cbiAgICBhZG9ybmVkRW5kOiB7fSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGVycm9yPXt0cnVlfWAuICovXG4gICAgZXJyb3I6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgbWFyZ2luPVwiZGVuc2VcImAuICovXG4gICAgbWFyZ2luRGVuc2U6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgbXVsdGlsaW5lPXt0cnVlfWAuICovXG4gICAgbXVsdGlsaW5lOiB7XG4gICAgICBwYWRkaW5nOiBcIlwiLmNvbmNhdCg4IC0gMiwgXCJweCAwIFwiKS5jb25jYXQoOCAtIDEsIFwicHhcIiksXG4gICAgICAnJiRtYXJnaW5EZW5zZSc6IHtcbiAgICAgICAgcGFkZGluZ1RvcDogNCAtIDFcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiB0aGUgY29sb3IgaXMgc2Vjb25kYXJ5LiAqL1xuICAgIGNvbG9yU2Vjb25kYXJ5OiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGZ1bGxXaWR0aD17dHJ1ZX1gLiAqL1xuICAgIGZ1bGxXaWR0aDoge1xuICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50LiAqL1xuICAgIGlucHV0OiB7XG4gICAgICBmb250OiAnaW5oZXJpdCcsXG4gICAgICBsZXR0ZXJTcGFjaW5nOiAnaW5oZXJpdCcsXG4gICAgICBjb2xvcjogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBwYWRkaW5nOiBcIlwiLmNvbmNhdCg4IC0gMiwgXCJweCAwIFwiKS5jb25jYXQoOCAtIDEsIFwicHhcIiksXG4gICAgICBib3JkZXI6IDAsXG4gICAgICBib3hTaXppbmc6ICdjb250ZW50LWJveCcsXG4gICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXG4gICAgICBoZWlnaHQ6ICcxLjE4NzZlbScsXG4gICAgICAvLyBSZXNldCAoMTlweCksIG1hdGNoIHRoZSBuYXRpdmUgaW5wdXQgbGluZS1oZWlnaHRcbiAgICAgIG1hcmdpbjogMCxcbiAgICAgIC8vIFJlc2V0IGZvciBTYWZhcmlcbiAgICAgIFdlYmtpdFRhcEhpZ2hsaWdodENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgIC8vIE1ha2UgdGhlIGZsZXggaXRlbSBzaHJpbmsgd2l0aCBGaXJlZm94XG4gICAgICBtaW5XaWR0aDogMCxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAvLyBGaXggSUUgMTEgd2lkdGggaXNzdWVcbiAgICAgIGFuaW1hdGlvbk5hbWU6ICdtdWktYXV0by1maWxsLWNhbmNlbCcsXG4gICAgICBhbmltYXRpb25EdXJhdGlvbjogJzEwbXMnLFxuICAgICAgJyY6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXInOiBwbGFjZWhvbGRlcixcbiAgICAgICcmOjotbW96LXBsYWNlaG9sZGVyJzogcGxhY2Vob2xkZXIsXG4gICAgICAvLyBGaXJlZm94IDE5K1xuICAgICAgJyY6LW1zLWlucHV0LXBsYWNlaG9sZGVyJzogcGxhY2Vob2xkZXIsXG4gICAgICAvLyBJRSAxMVxuICAgICAgJyY6Oi1tcy1pbnB1dC1wbGFjZWhvbGRlcic6IHBsYWNlaG9sZGVyLFxuICAgICAgLy8gRWRnZVxuICAgICAgJyY6Zm9jdXMnOiB7XG4gICAgICAgIG91dGxpbmU6IDBcbiAgICAgIH0sXG4gICAgICAvLyBSZXNldCBGaXJlZm94IGludmFsaWQgcmVxdWlyZWQgaW5wdXQgc3R5bGVcbiAgICAgICcmOmludmFsaWQnOiB7XG4gICAgICAgIGJveFNoYWRvdzogJ25vbmUnXG4gICAgICB9LFxuICAgICAgJyY6Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24nOiB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcGFkZGluZyB3aGVuIHR5cGU9c2VhcmNoLlxuICAgICAgICAnLXdlYmtpdC1hcHBlYXJhbmNlJzogJ25vbmUnXG4gICAgICB9LFxuICAgICAgLy8gU2hvdyBhbmQgaGlkZSB0aGUgcGxhY2Vob2xkZXIgbG9naWNcbiAgICAgICdsYWJlbFtkYXRhLXNocmluaz1mYWxzZV0gKyAkZm9ybUNvbnRyb2wgJic6IHtcbiAgICAgICAgJyY6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXInOiBwbGFjZWhvbGRlckhpZGRlbixcbiAgICAgICAgJyY6Oi1tb3otcGxhY2Vob2xkZXInOiBwbGFjZWhvbGRlckhpZGRlbixcbiAgICAgICAgLy8gRmlyZWZveCAxOStcbiAgICAgICAgJyY6LW1zLWlucHV0LXBsYWNlaG9sZGVyJzogcGxhY2Vob2xkZXJIaWRkZW4sXG4gICAgICAgIC8vIElFIDExXG4gICAgICAgICcmOjotbXMtaW5wdXQtcGxhY2Vob2xkZXInOiBwbGFjZWhvbGRlckhpZGRlbixcbiAgICAgICAgLy8gRWRnZVxuICAgICAgICAnJjpmb2N1czo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcic6IHBsYWNlaG9sZGVyVmlzaWJsZSxcbiAgICAgICAgJyY6Zm9jdXM6Oi1tb3otcGxhY2Vob2xkZXInOiBwbGFjZWhvbGRlclZpc2libGUsXG4gICAgICAgIC8vIEZpcmVmb3ggMTkrXG4gICAgICAgICcmOmZvY3VzOi1tcy1pbnB1dC1wbGFjZWhvbGRlcic6IHBsYWNlaG9sZGVyVmlzaWJsZSxcbiAgICAgICAgLy8gSUUgMTFcbiAgICAgICAgJyY6Zm9jdXM6Oi1tcy1pbnB1dC1wbGFjZWhvbGRlcic6IHBsYWNlaG9sZGVyVmlzaWJsZSAvLyBFZGdlXG5cbiAgICAgIH0sXG4gICAgICAnJiRkaXNhYmxlZCc6IHtcbiAgICAgICAgb3BhY2l0eTogMSAvLyBSZXNldCBpT1Mgb3BhY2l0eVxuXG4gICAgICB9LFxuICAgICAgJyY6LXdlYmtpdC1hdXRvZmlsbCc6IHtcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246ICc1MDAwcycsXG4gICAgICAgIGFuaW1hdGlvbk5hbWU6ICdtdWktYXV0by1maWxsJ1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBtYXJnaW49XCJkZW5zZVwiYC4gKi9cbiAgICBpbnB1dE1hcmdpbkRlbnNlOiB7XG4gICAgICBwYWRkaW5nVG9wOiA0IC0gMVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBtdWx0aWxpbmU9e3RydWV9YC4gKi9cbiAgICBpbnB1dE11bHRpbGluZToge1xuICAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICByZXNpemU6ICdub25lJyxcbiAgICAgIHBhZGRpbmc6IDBcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgdHlwZT1cInNlYXJjaFwiYC4gKi9cbiAgICBpbnB1dFR5cGVTZWFyY2g6IHtcbiAgICAgIC8vIEltcHJvdmUgdHlwZSBzZWFyY2ggc3R5bGUuXG4gICAgICAnLW1vei1hcHBlYXJhbmNlJzogJ3RleHRmaWVsZCcsXG4gICAgICAnLXdlYmtpdC1hcHBlYXJhbmNlJzogJ3RleHRmaWVsZCdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgc3RhcnRBZG9ybm1lbnRgIGlzIHByb3ZpZGVkLiAqL1xuICAgIGlucHV0QWRvcm5lZFN0YXJ0OiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYGVuZEFkb3JubWVudGAgaXMgcHJvdmlkZWQuICovXG4gICAgaW5wdXRBZG9ybmVkRW5kOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYGhpZGRlbkxhYmVsPXt0cnVlfWAuICovXG4gICAgaW5wdXRIaWRkZW5MYWJlbDoge31cbiAgfTtcbn07XG52YXIgdXNlRW5oYW5jZWRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IFJlYWN0LnVzZUVmZmVjdCA6IFJlYWN0LnVzZUxheW91dEVmZmVjdDtcbi8qKlxuICogYElucHV0QmFzZWAgY29udGFpbnMgYXMgZmV3IHN0eWxlcyBhcyBwb3NzaWJsZS5cbiAqIEl0IGFpbXMgdG8gYmUgYSBzaW1wbGUgYnVpbGRpbmcgYmxvY2sgZm9yIGNyZWF0aW5nIGFuIGlucHV0LlxuICogSXQgY29udGFpbnMgYSBsb2FkIG9mIHN0eWxlIHJlc2V0IGFuZCBzb21lIHN0YXRlIGxvZ2ljLlxuICovXG5cbnZhciBJbnB1dEJhc2UgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBJbnB1dEJhc2UocHJvcHMsIHJlZikge1xuICB2YXIgYXJpYURlc2NyaWJlZGJ5ID0gcHJvcHNbJ2FyaWEtZGVzY3JpYmVkYnknXSxcbiAgICAgIGF1dG9Db21wbGV0ZSA9IHByb3BzLmF1dG9Db21wbGV0ZSxcbiAgICAgIGF1dG9Gb2N1cyA9IHByb3BzLmF1dG9Gb2N1cyxcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY29sb3IgPSBwcm9wcy5jb2xvcixcbiAgICAgIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQsXG4gICAgICBlbmRBZG9ybm1lbnQgPSBwcm9wcy5lbmRBZG9ybm1lbnQsXG4gICAgICBlcnJvciA9IHByb3BzLmVycm9yLFxuICAgICAgX3Byb3BzJGZ1bGxXaWR0aCA9IHByb3BzLmZ1bGxXaWR0aCxcbiAgICAgIGZ1bGxXaWR0aCA9IF9wcm9wcyRmdWxsV2lkdGggPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGZ1bGxXaWR0aCxcbiAgICAgIGlkID0gcHJvcHMuaWQsXG4gICAgICBfcHJvcHMkaW5wdXRDb21wb25lbnQgPSBwcm9wcy5pbnB1dENvbXBvbmVudCxcbiAgICAgIGlucHV0Q29tcG9uZW50ID0gX3Byb3BzJGlucHV0Q29tcG9uZW50ID09PSB2b2lkIDAgPyAnaW5wdXQnIDogX3Byb3BzJGlucHV0Q29tcG9uZW50LFxuICAgICAgX3Byb3BzJGlucHV0UHJvcHMgPSBwcm9wcy5pbnB1dFByb3BzLFxuICAgICAgaW5wdXRQcm9wc1Byb3AgPSBfcHJvcHMkaW5wdXRQcm9wcyA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkaW5wdXRQcm9wcyxcbiAgICAgIGlucHV0UmVmUHJvcCA9IHByb3BzLmlucHV0UmVmLFxuICAgICAgbWFyZ2luID0gcHJvcHMubWFyZ2luLFxuICAgICAgX3Byb3BzJG11bHRpbGluZSA9IHByb3BzLm11bHRpbGluZSxcbiAgICAgIG11bHRpbGluZSA9IF9wcm9wcyRtdWx0aWxpbmUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJG11bHRpbGluZSxcbiAgICAgIG5hbWUgPSBwcm9wcy5uYW1lLFxuICAgICAgb25CbHVyID0gcHJvcHMub25CbHVyLFxuICAgICAgb25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZSxcbiAgICAgIG9uQ2xpY2sgPSBwcm9wcy5vbkNsaWNrLFxuICAgICAgb25Gb2N1cyA9IHByb3BzLm9uRm9jdXMsXG4gICAgICBvbktleURvd24gPSBwcm9wcy5vbktleURvd24sXG4gICAgICBvbktleVVwID0gcHJvcHMub25LZXlVcCxcbiAgICAgIHBsYWNlaG9sZGVyID0gcHJvcHMucGxhY2Vob2xkZXIsXG4gICAgICByZWFkT25seSA9IHByb3BzLnJlYWRPbmx5LFxuICAgICAgcmVuZGVyU3VmZml4ID0gcHJvcHMucmVuZGVyU3VmZml4LFxuICAgICAgcm93cyA9IHByb3BzLnJvd3MsXG4gICAgICByb3dzTWF4ID0gcHJvcHMucm93c01heCxcbiAgICAgIHJvd3NNaW4gPSBwcm9wcy5yb3dzTWluLFxuICAgICAgbWF4Um93cyA9IHByb3BzLm1heFJvd3MsXG4gICAgICBtaW5Sb3dzID0gcHJvcHMubWluUm93cyxcbiAgICAgIHN0YXJ0QWRvcm5tZW50ID0gcHJvcHMuc3RhcnRBZG9ybm1lbnQsXG4gICAgICBfcHJvcHMkdHlwZSA9IHByb3BzLnR5cGUsXG4gICAgICB0eXBlID0gX3Byb3BzJHR5cGUgPT09IHZvaWQgMCA/ICd0ZXh0JyA6IF9wcm9wcyR0eXBlLFxuICAgICAgdmFsdWVQcm9wID0gcHJvcHMudmFsdWUsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYXJpYS1kZXNjcmliZWRieVwiLCBcImF1dG9Db21wbGV0ZVwiLCBcImF1dG9Gb2N1c1wiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjb2xvclwiLCBcImRlZmF1bHRWYWx1ZVwiLCBcImRpc2FibGVkXCIsIFwiZW5kQWRvcm5tZW50XCIsIFwiZXJyb3JcIiwgXCJmdWxsV2lkdGhcIiwgXCJpZFwiLCBcImlucHV0Q29tcG9uZW50XCIsIFwiaW5wdXRQcm9wc1wiLCBcImlucHV0UmVmXCIsIFwibWFyZ2luXCIsIFwibXVsdGlsaW5lXCIsIFwibmFtZVwiLCBcIm9uQmx1clwiLCBcIm9uQ2hhbmdlXCIsIFwib25DbGlja1wiLCBcIm9uRm9jdXNcIiwgXCJvbktleURvd25cIiwgXCJvbktleVVwXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJyZWFkT25seVwiLCBcInJlbmRlclN1ZmZpeFwiLCBcInJvd3NcIiwgXCJyb3dzTWF4XCIsIFwicm93c01pblwiLCBcIm1heFJvd3NcIiwgXCJtaW5Sb3dzXCIsIFwic3RhcnRBZG9ybm1lbnRcIiwgXCJ0eXBlXCIsIFwidmFsdWVcIl0pO1xuXG4gIHZhciB2YWx1ZSA9IGlucHV0UHJvcHNQcm9wLnZhbHVlICE9IG51bGwgPyBpbnB1dFByb3BzUHJvcC52YWx1ZSA6IHZhbHVlUHJvcDtcblxuICB2YXIgX1JlYWN0JHVzZVJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSAhPSBudWxsKSxcbiAgICAgIGlzQ29udHJvbGxlZCA9IF9SZWFjdCR1c2VSZWYuY3VycmVudDtcblxuICB2YXIgaW5wdXRSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgdmFyIGhhbmRsZUlucHV0UmVmV2FybmluZyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2Uubm9kZU5hbWUgIT09ICdJTlBVVCcgJiYgIWluc3RhbmNlLmZvY3VzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoWydNYXRlcmlhbC1VSTogWW91IGhhdmUgcHJvdmlkZWQgYSBgaW5wdXRDb21wb25lbnRgIHRvIHRoZSBpbnB1dCBjb21wb25lbnQnLCAndGhhdCBkb2VzIG5vdCBjb3JyZWN0bHkgaGFuZGxlIHRoZSBgaW5wdXRSZWZgIHByb3AuJywgJ01ha2Ugc3VyZSB0aGUgYGlucHV0UmVmYCBwcm9wIGlzIGNhbGxlZCB3aXRoIGEgSFRNTElucHV0RWxlbWVudC4nXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbXSk7XG4gIHZhciBoYW5kbGVJbnB1dFByb3BzUmVmUHJvcCA9IHVzZUZvcmtSZWYoaW5wdXRQcm9wc1Byb3AucmVmLCBoYW5kbGVJbnB1dFJlZldhcm5pbmcpO1xuICB2YXIgaGFuZGxlSW5wdXRSZWZQcm9wID0gdXNlRm9ya1JlZihpbnB1dFJlZlByb3AsIGhhbmRsZUlucHV0UHJvcHNSZWZQcm9wKTtcbiAgdmFyIGhhbmRsZUlucHV0UmVmID0gdXNlRm9ya1JlZihpbnB1dFJlZiwgaGFuZGxlSW5wdXRSZWZQcm9wKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgZm9jdXNlZCA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldEZvY3VzZWQgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIG11aUZvcm1Db250cm9sID0gdXNlRm9ybUNvbnRyb2woKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobXVpRm9ybUNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIG11aUZvcm1Db250cm9sLnJlZ2lzdGVyRWZmZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSwgW211aUZvcm1Db250cm9sXSk7XG4gIH1cblxuICB2YXIgZmNzID0gZm9ybUNvbnRyb2xTdGF0ZSh7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIG11aUZvcm1Db250cm9sOiBtdWlGb3JtQ29udHJvbCxcbiAgICBzdGF0ZXM6IFsnY29sb3InLCAnZGlzYWJsZWQnLCAnZXJyb3InLCAnaGlkZGVuTGFiZWwnLCAnbWFyZ2luJywgJ3JlcXVpcmVkJywgJ2ZpbGxlZCddXG4gIH0pO1xuICBmY3MuZm9jdXNlZCA9IG11aUZvcm1Db250cm9sID8gbXVpRm9ybUNvbnRyb2wuZm9jdXNlZCA6IGZvY3VzZWQ7IC8vIFRoZSBibHVyIHdvbid0IGZpcmUgd2hlbiB0aGUgZGlzYWJsZWQgc3RhdGUgaXMgc2V0IG9uIGEgZm9jdXNlZCBpbnB1dC5cbiAgLy8gV2UgbmVlZCB0byBib29rIGtlZXAgdGhlIGZvY3VzZWQgc3RhdGUgbWFudWFsbHkuXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIW11aUZvcm1Db250cm9sICYmIGRpc2FibGVkICYmIGZvY3VzZWQpIHtcbiAgICAgIHNldEZvY3VzZWQoZmFsc2UpO1xuXG4gICAgICBpZiAob25CbHVyKSB7XG4gICAgICAgIG9uQmx1cigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW211aUZvcm1Db250cm9sLCBkaXNhYmxlZCwgZm9jdXNlZCwgb25CbHVyXSk7XG4gIHZhciBvbkZpbGxlZCA9IG11aUZvcm1Db250cm9sICYmIG11aUZvcm1Db250cm9sLm9uRmlsbGVkO1xuICB2YXIgb25FbXB0eSA9IG11aUZvcm1Db250cm9sICYmIG11aUZvcm1Db250cm9sLm9uRW1wdHk7XG4gIHZhciBjaGVja0RpcnR5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChpc0ZpbGxlZChvYmopKSB7XG4gICAgICBpZiAob25GaWxsZWQpIHtcbiAgICAgICAgb25GaWxsZWQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9uRW1wdHkpIHtcbiAgICAgIG9uRW1wdHkoKTtcbiAgICB9XG4gIH0sIFtvbkZpbGxlZCwgb25FbXB0eV0pO1xuICB1c2VFbmhhbmNlZEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzQ29udHJvbGxlZCkge1xuICAgICAgY2hlY2tEaXJ0eSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbdmFsdWUsIGNoZWNrRGlydHksIGlzQ29udHJvbGxlZF0pO1xuXG4gIHZhciBoYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIGhhbmRsZUZvY3VzKGV2ZW50KSB7XG4gICAgLy8gRml4IGEgYnVnIHdpdGggSUUgMTEgd2hlcmUgdGhlIGZvY3VzL2JsdXIgZXZlbnRzIGFyZSB0cmlnZ2VyZWRcbiAgICAvLyB3aGlsZSB0aGUgaW5wdXQgaXMgZGlzYWJsZWQuXG4gICAgaWYgKGZjcy5kaXNhYmxlZCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9uRm9jdXMpIHtcbiAgICAgIG9uRm9jdXMoZXZlbnQpO1xuICAgIH1cblxuICAgIGlmIChpbnB1dFByb3BzUHJvcC5vbkZvY3VzKSB7XG4gICAgICBpbnB1dFByb3BzUHJvcC5vbkZvY3VzKGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAobXVpRm9ybUNvbnRyb2wgJiYgbXVpRm9ybUNvbnRyb2wub25Gb2N1cykge1xuICAgICAgbXVpRm9ybUNvbnRyb2wub25Gb2N1cyhldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEZvY3VzZWQodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVCbHVyID0gZnVuY3Rpb24gaGFuZGxlQmx1cihldmVudCkge1xuICAgIGlmIChvbkJsdXIpIHtcbiAgICAgIG9uQmx1cihldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0UHJvcHNQcm9wLm9uQmx1cikge1xuICAgICAgaW5wdXRQcm9wc1Byb3Aub25CbHVyKGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAobXVpRm9ybUNvbnRyb2wgJiYgbXVpRm9ybUNvbnRyb2wub25CbHVyKSB7XG4gICAgICBtdWlGb3JtQ29udHJvbC5vbkJsdXIoZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRGb2N1c2VkKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZShldmVudCkge1xuICAgIGlmICghaXNDb250cm9sbGVkKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRhcmdldCB8fCBpbnB1dFJlZi5jdXJyZW50O1xuXG4gICAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk1hdGVyaWFsLVVJOiBFeHBlY3RlZCB2YWxpZCBpbnB1dCB0YXJnZXQuIERpZCB5b3UgdXNlIGEgY3VzdG9tIGBpbnB1dENvbXBvbmVudGAgYW5kIGZvcmdldCB0byBmb3J3YXJkIHJlZnM/IFNlZSBodHRwczovL21hdGVyaWFsLXVpLmNvbS9yL2lucHV0LWNvbXBvbmVudC1yZWYtaW50ZXJmYWNlIGZvciBtb3JlIGluZm8uXCIgOiBfZm9ybWF0TXVpRXJyb3JNZXNzYWdlKDEpKTtcbiAgICAgIH1cblxuICAgICAgY2hlY2tEaXJ0eSh7XG4gICAgICAgIHZhbHVlOiBlbGVtZW50LnZhbHVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXRQcm9wc1Byb3Aub25DaGFuZ2UpIHtcbiAgICAgIGlucHV0UHJvcHNQcm9wLm9uQ2hhbmdlLmFwcGx5KGlucHV0UHJvcHNQcm9wLCBbZXZlbnRdLmNvbmNhdChhcmdzKSk7XG4gICAgfSAvLyBQZXJmb3JtIGluIHRoZSB3aWxsVXBkYXRlXG5cblxuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgb25DaGFuZ2UuYXBwbHkodm9pZCAwLCBbZXZlbnRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9OyAvLyBDaGVjayB0aGUgaW5wdXQgc3RhdGUgb24gbW91bnQsIGluIGNhc2UgaXQgd2FzIGZpbGxlZCBieSB0aGUgdXNlclxuICAvLyBvciBhdXRvIGZpbGxlZCBieSB0aGUgYnJvd3NlciBiZWZvcmUgdGhlIGh5ZHJhdGlvbiAoZm9yIFNTUikuXG5cblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGNoZWNrRGlydHkoaW5wdXRSZWYuY3VycmVudCk7XG4gIH0sIFtdKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcblxuICB2YXIgaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGlmIChpbnB1dFJlZi5jdXJyZW50ICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQgPT09IGV2ZW50LnRhcmdldCkge1xuICAgICAgaW5wdXRSZWYuY3VycmVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICBvbkNsaWNrKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIElucHV0Q29tcG9uZW50ID0gaW5wdXRDb21wb25lbnQ7XG5cbiAgdmFyIGlucHV0UHJvcHMgPSBfZXh0ZW5kcyh7fSwgaW5wdXRQcm9wc1Byb3AsIHtcbiAgICByZWY6IGhhbmRsZUlucHV0UmVmXG4gIH0pO1xuXG4gIGlmICh0eXBlb2YgSW5wdXRDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgaW5wdXRQcm9wcyA9IF9leHRlbmRzKHtcbiAgICAgIC8vIFJlbmFtZSByZWYgdG8gaW5wdXRSZWYgYXMgd2UgZG9uJ3Qga25vdyB0aGVcbiAgICAgIC8vIHByb3ZpZGVkIGBpbnB1dENvbXBvbmVudGAgc3RydWN0dXJlLlxuICAgICAgaW5wdXRSZWY6IGhhbmRsZUlucHV0UmVmLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH0sIGlucHV0UHJvcHMsIHtcbiAgICAgIHJlZjogbnVsbFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKG11bHRpbGluZSkge1xuICAgIGlmIChyb3dzICYmICFtYXhSb3dzICYmICFtaW5Sb3dzICYmICFyb3dzTWF4ICYmICFyb3dzTWluKSB7XG4gICAgICBJbnB1dENvbXBvbmVudCA9ICd0ZXh0YXJlYSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0UHJvcHMgPSBfZXh0ZW5kcyh7XG4gICAgICAgIG1pblJvd3M6IHJvd3MgfHwgbWluUm93cyxcbiAgICAgICAgcm93c01heDogcm93c01heCxcbiAgICAgICAgbWF4Um93czogbWF4Um93c1xuICAgICAgfSwgaW5wdXRQcm9wcyk7XG4gICAgICBJbnB1dENvbXBvbmVudCA9IFRleHRhcmVhQXV0b3NpemU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlucHV0UHJvcHMgPSBfZXh0ZW5kcyh7XG4gICAgICB0eXBlOiB0eXBlXG4gICAgfSwgaW5wdXRQcm9wcyk7XG4gIH1cblxuICB2YXIgaGFuZGxlQXV0b0ZpbGwgPSBmdW5jdGlvbiBoYW5kbGVBdXRvRmlsbChldmVudCkge1xuICAgIC8vIFByb3ZpZGUgYSBmYWtlIHZhbHVlIGFzIENocm9tZSBtaWdodCBub3QgbGV0IHlvdSBhY2Nlc3MgaXQgZm9yIHNlY3VyaXR5IHJlYXNvbnMuXG4gICAgY2hlY2tEaXJ0eShldmVudC5hbmltYXRpb25OYW1lID09PSAnbXVpLWF1dG8tZmlsbC1jYW5jZWwnID8gaW5wdXRSZWYuY3VycmVudCA6IHtcbiAgICAgIHZhbHVlOiAneCdcbiAgICB9KTtcbiAgfTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChtdWlGb3JtQ29udHJvbCkge1xuICAgICAgbXVpRm9ybUNvbnRyb2wuc2V0QWRvcm5lZFN0YXJ0KEJvb2xlYW4oc3RhcnRBZG9ybm1lbnQpKTtcbiAgICB9XG4gIH0sIFttdWlGb3JtQ29udHJvbCwgc3RhcnRBZG9ybm1lbnRdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc2VzW1wiY29sb3JcIi5jb25jYXQoY2FwaXRhbGl6ZShmY3MuY29sb3IgfHwgJ3ByaW1hcnknKSldLCBjbGFzc05hbWUsIGZjcy5kaXNhYmxlZCAmJiBjbGFzc2VzLmRpc2FibGVkLCBmY3MuZXJyb3IgJiYgY2xhc3Nlcy5lcnJvciwgZnVsbFdpZHRoICYmIGNsYXNzZXMuZnVsbFdpZHRoLCBmY3MuZm9jdXNlZCAmJiBjbGFzc2VzLmZvY3VzZWQsIG11aUZvcm1Db250cm9sICYmIGNsYXNzZXMuZm9ybUNvbnRyb2wsIG11bHRpbGluZSAmJiBjbGFzc2VzLm11bHRpbGluZSwgc3RhcnRBZG9ybm1lbnQgJiYgY2xhc3Nlcy5hZG9ybmVkU3RhcnQsIGVuZEFkb3JubWVudCAmJiBjbGFzc2VzLmFkb3JuZWRFbmQsIGZjcy5tYXJnaW4gPT09ICdkZW5zZScgJiYgY2xhc3Nlcy5tYXJnaW5EZW5zZSksXG4gICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpLCBzdGFydEFkb3JubWVudCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybUNvbnRyb2xDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IG51bGxcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXRDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICBcImFyaWEtaW52YWxpZFwiOiBmY3MuZXJyb3IsXG4gICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGFyaWFEZXNjcmliZWRieSxcbiAgICBhdXRvQ29tcGxldGU6IGF1dG9Db21wbGV0ZSxcbiAgICBhdXRvRm9jdXM6IGF1dG9Gb2N1cyxcbiAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBkaXNhYmxlZDogZmNzLmRpc2FibGVkLFxuICAgIGlkOiBpZCxcbiAgICBvbkFuaW1hdGlvblN0YXJ0OiBoYW5kbGVBdXRvRmlsbCxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICByZWFkT25seTogcmVhZE9ubHksXG4gICAgcmVxdWlyZWQ6IGZjcy5yZXF1aXJlZCxcbiAgICByb3dzOiByb3dzLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBvbktleURvd246IG9uS2V5RG93bixcbiAgICBvbktleVVwOiBvbktleVVwXG4gIH0sIGlucHV0UHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5pbnB1dCwgaW5wdXRQcm9wc1Byb3AuY2xhc3NOYW1lLCBmY3MuZGlzYWJsZWQgJiYgY2xhc3Nlcy5kaXNhYmxlZCwgbXVsdGlsaW5lICYmIGNsYXNzZXMuaW5wdXRNdWx0aWxpbmUsIGZjcy5oaWRkZW5MYWJlbCAmJiBjbGFzc2VzLmlucHV0SGlkZGVuTGFiZWwsIHN0YXJ0QWRvcm5tZW50ICYmIGNsYXNzZXMuaW5wdXRBZG9ybmVkU3RhcnQsIGVuZEFkb3JubWVudCAmJiBjbGFzc2VzLmlucHV0QWRvcm5lZEVuZCwgdHlwZSA9PT0gJ3NlYXJjaCcgJiYgY2xhc3Nlcy5pbnB1dFR5cGVTZWFyY2gsIGZjcy5tYXJnaW4gPT09ICdkZW5zZScgJiYgY2xhc3Nlcy5pbnB1dE1hcmdpbkRlbnNlKSxcbiAgICBvbkJsdXI6IGhhbmRsZUJsdXIsXG4gICAgb25DaGFuZ2U6IGhhbmRsZUNoYW5nZSxcbiAgICBvbkZvY3VzOiBoYW5kbGVGb2N1c1xuICB9KSkpLCBlbmRBZG9ybm1lbnQsIHJlbmRlclN1ZmZpeCA/IHJlbmRlclN1ZmZpeChfZXh0ZW5kcyh7fSwgZmNzLCB7XG4gICAgc3RhcnRBZG9ybm1lbnQ6IHN0YXJ0QWRvcm5tZW50XG4gIH0pKSA6IG51bGwpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBJbnB1dEJhc2UucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGlzIHByb3AgaGVscHMgdXNlcnMgdG8gZmlsbCBmb3JtcyBmYXN0ZXIsIGVzcGVjaWFsbHkgb24gbW9iaWxlIGRldmljZXMuXG4gICAqIFRoZSBuYW1lIGNhbiBiZSBjb25mdXNpbmcsIGFzIGl0J3MgbW9yZSBsaWtlIGFuIGF1dG9maWxsLlxuICAgKiBZb3UgY2FuIGxlYXJuIG1vcmUgYWJvdXQgaXQgW2ZvbGxvd2luZyB0aGUgc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjYXV0b2ZpbGwpLlxuICAgKi9cbiAgYXV0b0NvbXBsZXRlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBgaW5wdXRgIGVsZW1lbnQgd2lsbCBiZSBmb2N1c2VkIGR1cmluZyB0aGUgZmlyc3QgbW91bnQuXG4gICAqL1xuICBhdXRvRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIHRob3NlIHRoZW1lIGNvbG9ycyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBgaW5wdXRgIGVsZW1lbnQgdmFsdWUuIFVzZSB3aGVuIHRoZSBjb21wb25lbnQgaXMgbm90IGNvbnRyb2xsZWQuXG4gICAqL1xuICBkZWZhdWx0VmFsdWU6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBFbmQgYElucHV0QWRvcm5tZW50YCBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBlbmRBZG9ybm1lbnQ6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBpbnB1dCB3aWxsIGluZGljYXRlIGFuIGVycm9yLiBUaGlzIGlzIG5vcm1hbGx5IG9idGFpbmVkIHZpYSBjb250ZXh0IGZyb21cbiAgICogRm9ybUNvbnRyb2wuXG4gICAqL1xuICBlcnJvcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IHdpbGwgdGFrZSB1cCB0aGUgZnVsbCB3aWR0aCBvZiBpdHMgY29udGFpbmVyLlxuICAgKi9cbiAgZnVsbFdpZHRoOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGlkIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgaW5wdXRDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogW0F0dHJpYnV0ZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNBdHRyaWJ1dGVzKSBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBQYXNzIGEgcmVmIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFJlZjogcmVmVHlwZSxcblxuICAvKipcbiAgICogSWYgYGRlbnNlYCwgd2lsbCBhZGp1c3QgdmVydGljYWwgc3BhY2luZy4gVGhpcyBpcyBub3JtYWxseSBvYnRhaW5lZCB2aWEgY29udGV4dCBmcm9tXG4gICAqIEZvcm1Db250cm9sLlxuICAgKi9cbiAgbWFyZ2luOiBQcm9wVHlwZXMub25lT2YoWydkZW5zZScsICdub25lJ10pLFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgd2hlbiBtdWx0aWxpbmUgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgKi9cbiAgbWF4Um93czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBNaW5pbXVtIG51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgd2hlbiBtdWx0aWxpbmUgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgKi9cbiAgbWluUm93czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGEgdGV4dGFyZWEgZWxlbWVudCB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgbXVsdGlsaW5lOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTmFtZSBhdHRyaWJ1dGUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGlucHV0IGlzIGJsdXJyZWQuXG4gICAqXG4gICAqIE5vdGljZSB0aGF0IHRoZSBmaXJzdCBhcmd1bWVudCAoZXZlbnQpIG1pZ2h0IGJlIHVuZGVmaW5lZC5cbiAgICovXG4gIG9uQmx1cjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cbiAgICogWW91IGNhbiBwdWxsIG91dCB0aGUgbmV3IHZhbHVlIGJ5IGFjY2Vzc2luZyBgZXZlbnQudGFyZ2V0LnZhbHVlYCAoc3RyaW5nKS5cbiAgICovXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbktleURvd246IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbktleVVwOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogVGhlIHNob3J0IGhpbnQgZGlzcGxheWVkIGluIHRoZSBpbnB1dCBiZWZvcmUgdGhlIHVzZXIgZW50ZXJzIGEgdmFsdWUuXG4gICAqL1xuICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSXQgcHJldmVudHMgdGhlIHVzZXIgZnJvbSBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkXG4gICAqIChub3QgZnJvbSBpbnRlcmFjdGluZyB3aXRoIHRoZSBmaWVsZCkuXG4gICAqL1xuICByZWFkT25seTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHJlbmRlclN1ZmZpeDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIHJlcXVpcmVkLlxuICAgKi9cbiAgcmVxdWlyZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IHdoZW4gbXVsdGlsaW5lIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICovXG4gIHJvd3M6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5LlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYG1heFJvd3NgIGluc3RlYWQuXG4gICAqL1xuICByb3dzTWF4OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBtaW5Sb3dzYCBpbnN0ZWFkLlxuICAgKi9cbiAgcm93c01pbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBTdGFydCBgSW5wdXRBZG9ybm1lbnRgIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIHN0YXJ0QWRvcm5tZW50OiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogVHlwZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LiBJdCBzaG91bGQgYmUgW2EgdmFsaWQgSFRNTDUgaW5wdXQgdHlwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0I0Zvcm1fJTNDaW5wdXQlM0VfdHlwZXMpLlxuICAgKi9cbiAgdHlwZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQsIHJlcXVpcmVkIGZvciBhIGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgKi9cbiAgdmFsdWU6IFByb3BUeXBlcy5hbnlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpSW5wdXRCYXNlJ1xufSkoSW5wdXRCYXNlKTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyByZWZUeXBlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCBJbnB1dEJhc2UgZnJvbSAnLi4vSW5wdXRCYXNlJztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmV4cG9ydCB2YXIgc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKHRoZW1lKSB7XG4gIHZhciBsaWdodCA9IHRoZW1lLnBhbGV0dGUudHlwZSA9PT0gJ2xpZ2h0JztcbiAgdmFyIGJvdHRvbUxpbmVDb2xvciA9IGxpZ2h0ID8gJ3JnYmEoMCwgMCwgMCwgMC40MiknIDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSc7XG4gIHJldHVybiB7XG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgICByb290OiB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIHRoZSBjb21wb25lbnQgaXMgYSBkZXNjZW5kYW50IG9mIGBGb3JtQ29udHJvbGAuICovXG4gICAgZm9ybUNvbnRyb2w6IHtcbiAgICAgICdsYWJlbCArICYnOiB7XG4gICAgICAgIG1hcmdpblRvcDogMTZcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiB0aGUgY29tcG9uZW50IGlzIGZvY3VzZWQuICovXG4gICAgZm9jdXNlZDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBkaXNhYmxlZD17dHJ1ZX1gLiAqL1xuICAgIGRpc2FibGVkOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgY29sb3Igc2Vjb25kYXJ5LiAqL1xuICAgIGNvbG9yU2Vjb25kYXJ5OiB7XG4gICAgICAnJiR1bmRlcmxpbmU6YWZ0ZXInOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0aGVtZS5wYWxldHRlLnNlY29uZGFyeS5tYWluXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVVbmRlcmxpbmU9e2ZhbHNlfWAuICovXG4gICAgdW5kZXJsaW5lOiB7XG4gICAgICAnJjphZnRlcic6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tOiBcIjJweCBzb2xpZCBcIi5jb25jYXQodGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW4pLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIC8vIERvaW5nIHRoZSBvdGhlciB3YXkgYXJvdW5kIGNyYXNoIG9uIElFIDExIFwiJydcIiBodHRwczovL2dpdGh1Yi5jb20vY3NzaW5qcy9qc3MvaXNzdWVzLzI0MlxuICAgICAgICBjb250ZW50OiAnXCJcIicsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGVYKDApJyxcbiAgICAgICAgdHJhbnNpdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKCd0cmFuc2Zvcm0nLCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXIsXG4gICAgICAgICAgZWFzaW5nOiB0aGVtZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZU91dFxuICAgICAgICB9KSxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnIC8vIFRyYW5zcGFyZW50IHRvIHRoZSBob3ZlciBzdHlsZS5cblxuICAgICAgfSxcbiAgICAgICcmJGZvY3VzZWQ6YWZ0ZXInOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlWCgxKSdcbiAgICAgIH0sXG4gICAgICAnJiRlcnJvcjphZnRlcic6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IHRoZW1lLnBhbGV0dGUuZXJyb3IubWFpbixcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGVYKDEpJyAvLyBlcnJvciBpcyBhbHdheXMgdW5kZXJsaW5lZCBpbiByZWRcblxuICAgICAgfSxcbiAgICAgICcmOmJlZm9yZSc6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCBcIi5jb25jYXQoYm90dG9tTGluZUNvbG9yKSxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAvLyBEb2luZyB0aGUgb3RoZXIgd2F5IGFyb3VuZCBjcmFzaCBvbiBJRSAxMSBcIicnXCIgaHR0cHM6Ly9naXRodWIuY29tL2Nzc2luanMvanNzL2lzc3Vlcy8yNDJcbiAgICAgICAgY29udGVudDogJ1wiXFxcXDAwYTBcIicsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgdHJhbnNpdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKCdib3JkZXItYm90dG9tLWNvbG9yJywge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVyXG4gICAgICAgIH0pLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScgLy8gVHJhbnNwYXJlbnQgdG8gdGhlIGhvdmVyIHN0eWxlLlxuXG4gICAgICB9LFxuICAgICAgJyY6aG92ZXI6bm90KCRkaXNhYmxlZCk6YmVmb3JlJzoge1xuICAgICAgICBib3JkZXJCb3R0b206IFwiMnB4IHNvbGlkIFwiLmNvbmNhdCh0aGVtZS5wYWxldHRlLnRleHQucHJpbWFyeSksXG4gICAgICAgIC8vIFJlc2V0IG9uIHRvdWNoIGRldmljZXMsIGl0IGRvZXNuJ3QgYWRkIHNwZWNpZmljaXR5XG4gICAgICAgICdAbWVkaWEgKGhvdmVyOiBub25lKSc6IHtcbiAgICAgICAgICBib3JkZXJCb3R0b206IFwiMXB4IHNvbGlkIFwiLmNvbmNhdChib3R0b21MaW5lQ29sb3IpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnJiRkaXNhYmxlZDpiZWZvcmUnOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbVN0eWxlOiAnZG90dGVkJ1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBlcnJvcj17dHJ1ZX1gLiAqL1xuICAgIGVycm9yOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYG1hcmdpbj1cImRlbnNlXCJgLiAqL1xuICAgIG1hcmdpbkRlbnNlOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYG11bHRpbGluZT17dHJ1ZX1gLiAqL1xuICAgIG11bHRpbGluZToge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBmdWxsV2lkdGg9e3RydWV9YC4gKi9cbiAgICBmdWxsV2lkdGg6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudC4gKi9cbiAgICBpbnB1dDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBtYXJnaW49XCJkZW5zZVwiYC4gKi9cbiAgICBpbnB1dE1hcmdpbkRlbnNlOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYG11bHRpbGluZT17dHJ1ZX1gLiAqL1xuICAgIGlucHV0TXVsdGlsaW5lOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYHR5cGU9XCJzZWFyY2hcImAuICovXG4gICAgaW5wdXRUeXBlU2VhcmNoOiB7fVxuICB9O1xufTtcbnZhciBJbnB1dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIElucHV0KHByb3BzLCByZWYpIHtcbiAgdmFyIGRpc2FibGVVbmRlcmxpbmUgPSBwcm9wcy5kaXNhYmxlVW5kZXJsaW5lLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBfcHJvcHMkZnVsbFdpZHRoID0gcHJvcHMuZnVsbFdpZHRoLFxuICAgICAgZnVsbFdpZHRoID0gX3Byb3BzJGZ1bGxXaWR0aCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZnVsbFdpZHRoLFxuICAgICAgX3Byb3BzJGlucHV0Q29tcG9uZW50ID0gcHJvcHMuaW5wdXRDb21wb25lbnQsXG4gICAgICBpbnB1dENvbXBvbmVudCA9IF9wcm9wcyRpbnB1dENvbXBvbmVudCA9PT0gdm9pZCAwID8gJ2lucHV0JyA6IF9wcm9wcyRpbnB1dENvbXBvbmVudCxcbiAgICAgIF9wcm9wcyRtdWx0aWxpbmUgPSBwcm9wcy5tdWx0aWxpbmUsXG4gICAgICBtdWx0aWxpbmUgPSBfcHJvcHMkbXVsdGlsaW5lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRtdWx0aWxpbmUsXG4gICAgICBfcHJvcHMkdHlwZSA9IHByb3BzLnR5cGUsXG4gICAgICB0eXBlID0gX3Byb3BzJHR5cGUgPT09IHZvaWQgMCA/ICd0ZXh0JyA6IF9wcm9wcyR0eXBlLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImRpc2FibGVVbmRlcmxpbmVcIiwgXCJjbGFzc2VzXCIsIFwiZnVsbFdpZHRoXCIsIFwiaW5wdXRDb21wb25lbnRcIiwgXCJtdWx0aWxpbmVcIiwgXCJ0eXBlXCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXRCYXNlLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NlczogX2V4dGVuZHMoe30sIGNsYXNzZXMsIHtcbiAgICAgIHJvb3Q6IGNsc3goY2xhc3Nlcy5yb290LCAhZGlzYWJsZVVuZGVybGluZSAmJiBjbGFzc2VzLnVuZGVybGluZSksXG4gICAgICB1bmRlcmxpbmU6IG51bGxcbiAgICB9KSxcbiAgICBmdWxsV2lkdGg6IGZ1bGxXaWR0aCxcbiAgICBpbnB1dENvbXBvbmVudDogaW5wdXRDb21wb25lbnQsXG4gICAgbXVsdGlsaW5lOiBtdWx0aWxpbmUsXG4gICAgcmVmOiByZWYsXG4gICAgdHlwZTogdHlwZVxuICB9LCBvdGhlcikpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBJbnB1dC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBUaGlzIHByb3AgaGVscHMgdXNlcnMgdG8gZmlsbCBmb3JtcyBmYXN0ZXIsIGVzcGVjaWFsbHkgb24gbW9iaWxlIGRldmljZXMuXG4gICAqIFRoZSBuYW1lIGNhbiBiZSBjb25mdXNpbmcsIGFzIGl0J3MgbW9yZSBsaWtlIGFuIGF1dG9maWxsLlxuICAgKiBZb3UgY2FuIGxlYXJuIG1vcmUgYWJvdXQgaXQgW2ZvbGxvd2luZyB0aGUgc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjYXV0b2ZpbGwpLlxuICAgKi9cbiAgYXV0b0NvbXBsZXRlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBgaW5wdXRgIGVsZW1lbnQgd2lsbCBiZSBmb2N1c2VkIGR1cmluZyB0aGUgZmlyc3QgbW91bnQuXG4gICAqL1xuICBhdXRvRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29tcG9uZW50LiBJdCBzdXBwb3J0cyB0aG9zZSB0aGVtZSBjb2xvcnMgdGhhdCBtYWtlIHNlbnNlIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoWydwcmltYXJ5JywgJ3NlY29uZGFyeSddKSxcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgYGlucHV0YCBlbGVtZW50IHZhbHVlLiBVc2Ugd2hlbiB0aGUgY29tcG9uZW50IGlzIG5vdCBjb250cm9sbGVkLlxuICAgKi9cbiAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMuYW55LFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBgaW5wdXRgIGVsZW1lbnQgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgaW5wdXQgd2lsbCBub3QgaGF2ZSBhbiB1bmRlcmxpbmUuXG4gICAqL1xuICBkaXNhYmxlVW5kZXJsaW5lOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogRW5kIGBJbnB1dEFkb3JubWVudGAgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgZW5kQWRvcm5tZW50OiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgaW5wdXQgd2lsbCBpbmRpY2F0ZSBhbiBlcnJvci4gVGhpcyBpcyBub3JtYWxseSBvYnRhaW5lZCB2aWEgY29udGV4dCBmcm9tXG4gICAqIEZvcm1Db250cm9sLlxuICAgKi9cbiAgZXJyb3I6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBpbnB1dCB3aWxsIHRha2UgdXAgdGhlIGZ1bGwgd2lkdGggb2YgaXRzIGNvbnRhaW5lci5cbiAgICovXG4gIGZ1bGxXaWR0aDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBpZCBvZiB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGlucHV0Q29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG5cbiAgLyoqXG4gICAqIFtBdHRyaWJ1dGVzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQjQXR0cmlidXRlcykgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgaW5wdXRQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogUGFzcyBhIHJlZiB0byB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgaW5wdXRSZWY6IHJlZlR5cGUsXG5cbiAgLyoqXG4gICAqIElmIGBkZW5zZWAsIHdpbGwgYWRqdXN0IHZlcnRpY2FsIHNwYWNpbmcuIFRoaXMgaXMgbm9ybWFsbHkgb2J0YWluZWQgdmlhIGNvbnRleHQgZnJvbVxuICAgKiBGb3JtQ29udHJvbC5cbiAgICovXG4gIG1hcmdpbjogUHJvcFR5cGVzLm9uZU9mKFsnZGVuc2UnLCAnbm9uZSddKSxcblxuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IHdoZW4gbXVsdGlsaW5lIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICovXG4gIG1heFJvd3M6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBhIHRleHRhcmVhIGVsZW1lbnQgd2lsbCBiZSByZW5kZXJlZC5cbiAgICovXG4gIG11bHRpbGluZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE5hbWUgYXR0cmlidXRlIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqIFlvdSBjYW4gcHVsbCBvdXQgdGhlIG5ldyB2YWx1ZSBieSBhY2Nlc3NpbmcgYGV2ZW50LnRhcmdldC52YWx1ZWAgKHN0cmluZykuXG4gICAqL1xuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIFRoZSBzaG9ydCBoaW50IGRpc3BsYXllZCBpbiB0aGUgaW5wdXQgYmVmb3JlIHRoZSB1c2VyIGVudGVycyBhIHZhbHVlLlxuICAgKi9cbiAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIEl0IHByZXZlbnRzIHRoZSB1c2VyIGZyb20gY2hhbmdpbmcgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZFxuICAgKiAobm90IGZyb20gaW50ZXJhY3Rpbmcgd2l0aCB0aGUgZmllbGQpLlxuICAgKi9cbiAgcmVhZE9ubHk6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBgaW5wdXRgIGVsZW1lbnQgd2lsbCBiZSByZXF1aXJlZC5cbiAgICovXG4gIHJlcXVpcmVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheSB3aGVuIG11bHRpbGluZSBvcHRpb24gaXMgc2V0IHRvIHRydWUuXG4gICAqL1xuICByb3dzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIFN0YXJ0IGBJbnB1dEFkb3JubWVudGAgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgc3RhcnRBZG9ybm1lbnQ6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBUeXBlIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuIEl0IHNob3VsZCBiZSBbYSB2YWxpZCBIVE1MNSBpbnB1dCB0eXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQjRm9ybV8lM0NpbnB1dCUzRV90eXBlcykuXG4gICAqL1xuICB0eXBlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudCwgcmVxdWlyZWQgZm9yIGEgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAqL1xuICB2YWx1ZTogUHJvcFR5cGVzLmFueVxufSA6IHZvaWQgMDtcbklucHV0Lm11aU5hbWUgPSAnSW5wdXQnO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUlucHV0J1xufSkoSW5wdXQpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IHJlZlR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IElucHV0QmFzZSBmcm9tICcuLi9JbnB1dEJhc2UnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgdmFyIGxpZ2h0ID0gdGhlbWUucGFsZXR0ZS50eXBlID09PSAnbGlnaHQnO1xuICB2YXIgYm90dG9tTGluZUNvbG9yID0gbGlnaHQgPyAncmdiYSgwLCAwLCAwLCAwLjQyKScgOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpJztcbiAgdmFyIGJhY2tncm91bmRDb2xvciA9IGxpZ2h0ID8gJ3JnYmEoMCwgMCwgMCwgMC4wOSknIDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4wOSknO1xuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gICAgcm9vdDoge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvcixcbiAgICAgIGJvcmRlclRvcExlZnRSYWRpdXM6IHRoZW1lLnNoYXBlLmJvcmRlclJhZGl1cyxcbiAgICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiB0aGVtZS5zaGFwZS5ib3JkZXJSYWRpdXMsXG4gICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ2JhY2tncm91bmQtY29sb3InLCB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVyLFxuICAgICAgICBlYXNpbmc6IHRoZW1lLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlT3V0XG4gICAgICB9KSxcbiAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0ID8gJ3JnYmEoMCwgMCwgMCwgMC4xMyknIDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4xMyknLFxuICAgICAgICAvLyBSZXNldCBvbiB0b3VjaCBkZXZpY2VzLCBpdCBkb2Vzbid0IGFkZCBzcGVjaWZpY2l0eVxuICAgICAgICAnQG1lZGlhIChob3Zlcjogbm9uZSknOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICcmJGZvY3VzZWQnOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogbGlnaHQgPyAncmdiYSgwLCAwLCAwLCAwLjA5KScgOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjA5KSdcbiAgICAgIH0sXG4gICAgICAnJiRkaXNhYmxlZCc6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBsaWdodCA/ICdyZ2JhKDAsIDAsIDAsIDAuMTIpJyA6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTIpJ1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGNvbG9yIHNlY29uZGFyeS4gKi9cbiAgICBjb2xvclNlY29uZGFyeToge1xuICAgICAgJyYkdW5kZXJsaW5lOmFmdGVyJzoge1xuICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogdGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkubWFpblxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBkaXNhYmxlVW5kZXJsaW5lPXtmYWxzZX1gLiAqL1xuICAgIHVuZGVybGluZToge1xuICAgICAgJyY6YWZ0ZXInOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbTogXCIycHggc29saWQgXCIuY29uY2F0KHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluKSxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAvLyBEb2luZyB0aGUgb3RoZXIgd2F5IGFyb3VuZCBjcmFzaCBvbiBJRSAxMSBcIicnXCIgaHR0cHM6Ly9naXRodWIuY29tL2Nzc2luanMvanNzL2lzc3Vlcy8yNDJcbiAgICAgICAgY29udGVudDogJ1wiXCInLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlWCgwKScsXG4gICAgICAgIHRyYW5zaXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgndHJhbnNmb3JtJywge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVyLFxuICAgICAgICAgIGVhc2luZzogdGhlbWUudHJhbnNpdGlvbnMuZWFzaW5nLmVhc2VPdXRcbiAgICAgICAgfSksXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyAvLyBUcmFuc3BhcmVudCB0byB0aGUgaG92ZXIgc3R5bGUuXG5cbiAgICAgIH0sXG4gICAgICAnJiRmb2N1c2VkOmFmdGVyJzoge1xuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZVgoMSknXG4gICAgICB9LFxuICAgICAgJyYkZXJyb3I6YWZ0ZXInOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0aGVtZS5wYWxldHRlLmVycm9yLm1haW4sXG4gICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlWCgxKScgLy8gZXJyb3IgaXMgYWx3YXlzIHVuZGVybGluZWQgaW4gcmVkXG5cbiAgICAgIH0sXG4gICAgICAnJjpiZWZvcmUnOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgXCIuY29uY2F0KGJvdHRvbUxpbmVDb2xvciksXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgLy8gRG9pbmcgdGhlIG90aGVyIHdheSBhcm91bmQgY3Jhc2ggb24gSUUgMTEgXCInJ1wiIGh0dHBzOi8vZ2l0aHViLmNvbS9jc3NpbmpzL2pzcy9pc3N1ZXMvMjQyXG4gICAgICAgIGNvbnRlbnQ6ICdcIlxcXFwwMGEwXCInLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIHRyYW5zaXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgnYm9yZGVyLWJvdHRvbS1jb2xvcicsIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlclxuICAgICAgICB9KSxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnIC8vIFRyYW5zcGFyZW50IHRvIHRoZSBob3ZlciBzdHlsZS5cblxuICAgICAgfSxcbiAgICAgICcmOmhvdmVyOmJlZm9yZSc6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCBcIi5jb25jYXQodGhlbWUucGFsZXR0ZS50ZXh0LnByaW1hcnkpXG4gICAgICB9LFxuICAgICAgJyYkZGlzYWJsZWQ6YmVmb3JlJzoge1xuICAgICAgICBib3JkZXJCb3R0b21TdHlsZTogJ2RvdHRlZCdcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiB0aGUgY29tcG9uZW50IGlzIGZvY3VzZWQuICovXG4gICAgZm9jdXNlZDoge30sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBkaXNhYmxlZD17dHJ1ZX1gLiAqL1xuICAgIGRpc2FibGVkOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHN0YXJ0QWRvcm5tZW50YCBpcyBwcm92aWRlZC4gKi9cbiAgICBhZG9ybmVkU3RhcnQ6IHtcbiAgICAgIHBhZGRpbmdMZWZ0OiAxMlxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBlbmRBZG9ybm1lbnRgIGlzIHByb3ZpZGVkLiAqL1xuICAgIGFkb3JuZWRFbmQ6IHtcbiAgICAgIHBhZGRpbmdSaWdodDogMTJcbiAgICB9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZXJyb3I9e3RydWV9YC4gKi9cbiAgICBlcnJvcjoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBtYXJnaW49XCJkZW5zZVwiYC4gKi9cbiAgICBtYXJnaW5EZW5zZToge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBtdWx0aWxpbmU9e3RydWV9YC4gKi9cbiAgICBtdWx0aWxpbmU6IHtcbiAgICAgIHBhZGRpbmc6ICcyN3B4IDEycHggMTBweCcsXG4gICAgICAnJiRtYXJnaW5EZW5zZSc6IHtcbiAgICAgICAgcGFkZGluZ1RvcDogMjMsXG4gICAgICAgIHBhZGRpbmdCb3R0b206IDZcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudC4gKi9cbiAgICBpbnB1dDoge1xuICAgICAgcGFkZGluZzogJzI3cHggMTJweCAxMHB4JyxcbiAgICAgICcmOi13ZWJraXQtYXV0b2ZpbGwnOiB7XG4gICAgICAgIFdlYmtpdEJveFNoYWRvdzogdGhlbWUucGFsZXR0ZS50eXBlID09PSAnbGlnaHQnID8gbnVsbCA6ICcwIDAgMCAxMDBweCAjMjY2Nzk4IGluc2V0JyxcbiAgICAgICAgV2Via2l0VGV4dEZpbGxDb2xvcjogdGhlbWUucGFsZXR0ZS50eXBlID09PSAnbGlnaHQnID8gbnVsbCA6ICcjZmZmJyxcbiAgICAgICAgY2FyZXRDb2xvcjogdGhlbWUucGFsZXR0ZS50eXBlID09PSAnbGlnaHQnID8gbnVsbCA6ICcjZmZmJyxcbiAgICAgICAgYm9yZGVyVG9wTGVmdFJhZGl1czogJ2luaGVyaXQnLFxuICAgICAgICBib3JkZXJUb3BSaWdodFJhZGl1czogJ2luaGVyaXQnXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYG1hcmdpbj1cImRlbnNlXCJgLiAqL1xuICAgIGlucHV0TWFyZ2luRGVuc2U6IHtcbiAgICAgIHBhZGRpbmdUb3A6IDIzLFxuICAgICAgcGFkZGluZ0JvdHRvbTogNlxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBpZiBpbiBgPEZvcm1Db250cm9sIGhpZGRlbkxhYmVsIC8+YC4gKi9cbiAgICBpbnB1dEhpZGRlbkxhYmVsOiB7XG4gICAgICBwYWRkaW5nVG9wOiAxOCxcbiAgICAgIHBhZGRpbmdCb3R0b206IDE5LFxuICAgICAgJyYkaW5wdXRNYXJnaW5EZW5zZSc6IHtcbiAgICAgICAgcGFkZGluZ1RvcDogMTAsXG4gICAgICAgIHBhZGRpbmdCb3R0b206IDExXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYG11bHRpbGluZT17dHJ1ZX1gLiAqL1xuICAgIGlucHV0TXVsdGlsaW5lOiB7XG4gICAgICBwYWRkaW5nOiAwXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYHN0YXJ0QWRvcm5tZW50YCBpcyBwcm92aWRlZC4gKi9cbiAgICBpbnB1dEFkb3JuZWRTdGFydDoge1xuICAgICAgcGFkZGluZ0xlZnQ6IDBcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgZW5kQWRvcm5tZW50YCBpcyBwcm92aWRlZC4gKi9cbiAgICBpbnB1dEFkb3JuZWRFbmQ6IHtcbiAgICAgIHBhZGRpbmdSaWdodDogMFxuICAgIH1cbiAgfTtcbn07XG52YXIgRmlsbGVkSW5wdXQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBGaWxsZWRJbnB1dChwcm9wcywgcmVmKSB7XG4gIHZhciBkaXNhYmxlVW5kZXJsaW5lID0gcHJvcHMuZGlzYWJsZVVuZGVybGluZSxcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgX3Byb3BzJGZ1bGxXaWR0aCA9IHByb3BzLmZ1bGxXaWR0aCxcbiAgICAgIGZ1bGxXaWR0aCA9IF9wcm9wcyRmdWxsV2lkdGggPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGZ1bGxXaWR0aCxcbiAgICAgIF9wcm9wcyRpbnB1dENvbXBvbmVudCA9IHByb3BzLmlucHV0Q29tcG9uZW50LFxuICAgICAgaW5wdXRDb21wb25lbnQgPSBfcHJvcHMkaW5wdXRDb21wb25lbnQgPT09IHZvaWQgMCA/ICdpbnB1dCcgOiBfcHJvcHMkaW5wdXRDb21wb25lbnQsXG4gICAgICBfcHJvcHMkbXVsdGlsaW5lID0gcHJvcHMubXVsdGlsaW5lLFxuICAgICAgbXVsdGlsaW5lID0gX3Byb3BzJG11bHRpbGluZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkbXVsdGlsaW5lLFxuICAgICAgX3Byb3BzJHR5cGUgPSBwcm9wcy50eXBlLFxuICAgICAgdHlwZSA9IF9wcm9wcyR0eXBlID09PSB2b2lkIDAgPyAndGV4dCcgOiBfcHJvcHMkdHlwZSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJkaXNhYmxlVW5kZXJsaW5lXCIsIFwiY2xhc3Nlc1wiLCBcImZ1bGxXaWR0aFwiLCBcImlucHV0Q29tcG9uZW50XCIsIFwibXVsdGlsaW5lXCIsIFwidHlwZVwiXSk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KElucHV0QmFzZSwgX2V4dGVuZHMoe1xuICAgIGNsYXNzZXM6IF9leHRlbmRzKHt9LCBjbGFzc2VzLCB7XG4gICAgICByb290OiBjbHN4KGNsYXNzZXMucm9vdCwgIWRpc2FibGVVbmRlcmxpbmUgJiYgY2xhc3Nlcy51bmRlcmxpbmUpLFxuICAgICAgdW5kZXJsaW5lOiBudWxsXG4gICAgfSksXG4gICAgZnVsbFdpZHRoOiBmdWxsV2lkdGgsXG4gICAgaW5wdXRDb21wb25lbnQ6IGlucHV0Q29tcG9uZW50LFxuICAgIG11bHRpbGluZTogbXVsdGlsaW5lLFxuICAgIHJlZjogcmVmLFxuICAgIHR5cGU6IHR5cGVcbiAgfSwgb3RoZXIpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gRmlsbGVkSW5wdXQucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogVGhpcyBwcm9wIGhlbHBzIHVzZXJzIHRvIGZpbGwgZm9ybXMgZmFzdGVyLCBlc3BlY2lhbGx5IG9uIG1vYmlsZSBkZXZpY2VzLlxuICAgKiBUaGUgbmFtZSBjYW4gYmUgY29uZnVzaW5nLCBhcyBpdCdzIG1vcmUgbGlrZSBhbiBhdXRvZmlsbC5cbiAgICogWW91IGNhbiBsZWFybiBtb3JlIGFib3V0IGl0IFtmb2xsb3dpbmcgdGhlIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI2F1dG9maWxsKS5cbiAgICovXG4gIGF1dG9Db21wbGV0ZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYGlucHV0YCBlbGVtZW50IHdpbGwgYmUgZm9jdXNlZCBkdXJpbmcgdGhlIGZpcnN0IG1vdW50LlxuICAgKi9cbiAgYXV0b0ZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2YgdGhlIGNvbXBvbmVudC4gSXQgc3VwcG9ydHMgdGhvc2UgdGhlbWUgY29sb3JzIHRoYXQgbWFrZSBzZW5zZSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsncHJpbWFyeScsICdzZWNvbmRhcnknXSksXG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGBpbnB1dGAgZWxlbWVudCB2YWx1ZS4gVXNlIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBub3QgY29udHJvbGxlZC5cbiAgICovXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLmFueSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYGlucHV0YCBlbGVtZW50IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IHdpbGwgbm90IGhhdmUgYW4gdW5kZXJsaW5lLlxuICAgKi9cbiAgZGlzYWJsZVVuZGVybGluZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEVuZCBgSW5wdXRBZG9ybm1lbnRgIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIGVuZEFkb3JubWVudDogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IHdpbGwgaW5kaWNhdGUgYW4gZXJyb3IuIFRoaXMgaXMgbm9ybWFsbHkgb2J0YWluZWQgdmlhIGNvbnRleHQgZnJvbVxuICAgKiBGb3JtQ29udHJvbC5cbiAgICovXG4gIGVycm9yOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgaW5wdXQgd2lsbCB0YWtlIHVwIHRoZSBmdWxsIHdpZHRoIG9mIGl0cyBjb250YWluZXIuXG4gICAqL1xuICBmdWxsV2lkdGg6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgaWQgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBpbnB1dENvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBbQXR0cmlidXRlc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0I0F0dHJpYnV0ZXMpIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGlucHV0UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFBhc3MgYSByZWYgdG8gdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGlucHV0UmVmOiByZWZUeXBlLFxuXG4gIC8qKlxuICAgKiBJZiBgZGVuc2VgLCB3aWxsIGFkanVzdCB2ZXJ0aWNhbCBzcGFjaW5nLiBUaGlzIGlzIG5vcm1hbGx5IG9idGFpbmVkIHZpYSBjb250ZXh0IGZyb21cbiAgICogRm9ybUNvbnRyb2wuXG4gICAqL1xuICBtYXJnaW46IFByb3BUeXBlcy5vbmVPZihbJ2RlbnNlJywgJ25vbmUnXSksXG5cbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheSB3aGVuIG11bHRpbGluZSBvcHRpb24gaXMgc2V0IHRvIHRydWUuXG4gICAqL1xuICBtYXhSb3dzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgYSB0ZXh0YXJlYSBlbGVtZW50IHdpbGwgYmUgcmVuZGVyZWQuXG4gICAqL1xuICBtdWx0aWxpbmU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBOYW1lIGF0dHJpYnV0ZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgdmFsdWUgaXMgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBZb3UgY2FuIHB1bGwgb3V0IHRoZSBuZXcgdmFsdWUgYnkgYWNjZXNzaW5nIGBldmVudC50YXJnZXQudmFsdWVgIChzdHJpbmcpLlxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBUaGUgc2hvcnQgaGludCBkaXNwbGF5ZWQgaW4gdGhlIGlucHV0IGJlZm9yZSB0aGUgdXNlciBlbnRlcnMgYSB2YWx1ZS5cbiAgICovXG4gIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBJdCBwcmV2ZW50cyB0aGUgdXNlciBmcm9tIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiB0aGUgZmllbGRcbiAgICogKG5vdCBmcm9tIGludGVyYWN0aW5nIHdpdGggdGhlIGZpZWxkKS5cbiAgICovXG4gIHJlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYGlucHV0YCBlbGVtZW50IHdpbGwgYmUgcmVxdWlyZWQuXG4gICAqL1xuICByZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgd2hlbiBtdWx0aWxpbmUgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgKi9cbiAgcm93czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBTdGFydCBgSW5wdXRBZG9ybm1lbnRgIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIHN0YXJ0QWRvcm5tZW50OiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogVHlwZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LiBJdCBzaG91bGQgYmUgW2EgdmFsaWQgSFRNTDUgaW5wdXQgdHlwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0I0Zvcm1fJTNDaW5wdXQlM0VfdHlwZXMpLlxuICAgKi9cbiAgdHlwZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQsIHJlcXVpcmVkIGZvciBhIGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgKi9cbiAgdmFsdWU6IFByb3BUeXBlcy5hbnlcbn0gOiB2b2lkIDA7XG5GaWxsZWRJbnB1dC5tdWlOYW1lID0gJ0lucHV0JztcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlGaWxsZWRJbnB1dCdcbn0pKEZpbGxlZElucHV0KTsiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IHVzZVRoZW1lIGZyb20gJy4uL3N0eWxlcy91c2VUaGVtZSc7XG5pbXBvcnQgY2FwaXRhbGl6ZSBmcm9tICcuLi91dGlscy9jYXBpdGFsaXplJztcbmV4cG9ydCB2YXIgc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKHRoZW1lKSB7XG4gIHJldHVybiB7XG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgICByb290OiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAtNSxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBtYXJnaW46IDAsXG4gICAgICBwYWRkaW5nOiAnMCA4cHgnLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnaW5oZXJpdCcsXG4gICAgICBib3JkZXJTdHlsZTogJ3NvbGlkJyxcbiAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBsZWdlbmQgZWxlbWVudCB3aGVuIGBsYWJlbFdpZHRoYCBpcyBwcm92aWRlZC4gKi9cbiAgICBsZWdlbmQ6IHtcbiAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIGxpbmVIZWlnaHQ6ICcxMXB4JyxcbiAgICAgIC8vIHN5bmMgd2l0aCBgaGVpZ2h0YCBpbiBgbGVnZW5kYCBzdHlsZXNcbiAgICAgIHRyYW5zaXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgnd2lkdGgnLCB7XG4gICAgICAgIGR1cmF0aW9uOiAxNTAsXG4gICAgICAgIGVhc2luZzogdGhlbWUudHJhbnNpdGlvbnMuZWFzaW5nLmVhc2VPdXRcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBsZWdlbmQgZWxlbWVudC4gKi9cbiAgICBsZWdlbmRMYWJlbGxlZDoge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgIHdpZHRoOiAnYXV0bycsXG4gICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAgIHBhZGRpbmc6IDAsXG4gICAgICBoZWlnaHQ6IDExLFxuICAgICAgLy8gc3luYyB3aXRoIGBsaW5lSGVpZ2h0YCBpbiBgbGVnZW5kYCBzdHlsZXNcbiAgICAgIGZvbnRTaXplOiAnMC43NWVtJyxcbiAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgbWF4V2lkdGg6IDAuMDEsXG4gICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ21heC13aWR0aCcsIHtcbiAgICAgICAgZHVyYXRpb246IDUwLFxuICAgICAgICBlYXNpbmc6IHRoZW1lLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlT3V0XG4gICAgICB9KSxcbiAgICAgICcmID4gc3Bhbic6IHtcbiAgICAgICAgcGFkZGluZ0xlZnQ6IDUsXG4gICAgICAgIHBhZGRpbmdSaWdodDogNSxcbiAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaydcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGxlZ2VuZCBlbGVtZW50IGlzIG5vdGNoZWQuICovXG4gICAgbGVnZW5kTm90Y2hlZDoge1xuICAgICAgbWF4V2lkdGg6IDEwMDAsXG4gICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ21heC13aWR0aCcsIHtcbiAgICAgICAgZHVyYXRpb246IDEwMCxcbiAgICAgICAgZWFzaW5nOiB0aGVtZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZU91dCxcbiAgICAgICAgZGVsYXk6IDUwXG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXG4gKi9cblxudmFyIE5vdGNoZWRPdXRsaW5lID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gTm90Y2hlZE91dGxpbmUocHJvcHMsIHJlZikge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgbGFiZWwgPSBwcm9wcy5sYWJlbCxcbiAgICAgIGxhYmVsV2lkdGhQcm9wID0gcHJvcHMubGFiZWxXaWR0aCxcbiAgICAgIG5vdGNoZWQgPSBwcm9wcy5ub3RjaGVkLFxuICAgICAgc3R5bGUgPSBwcm9wcy5zdHlsZSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJsYWJlbFwiLCBcImxhYmVsV2lkdGhcIiwgXCJub3RjaGVkXCIsIFwic3R5bGVcIl0pO1xuXG4gIHZhciB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIHZhciBhbGlnbiA9IHRoZW1lLmRpcmVjdGlvbiA9PT0gJ3J0bCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuXG4gIGlmIChsYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIiwgX2V4dGVuZHMoe1xuICAgICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lKSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgc3R5bGU6IHN0eWxlXG4gICAgfSwgb3RoZXIpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxlZ2VuZFwiLCB7XG4gICAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5sZWdlbmRMYWJlbGxlZCwgbm90Y2hlZCAmJiBjbGFzc2VzLmxlZ2VuZE5vdGNoZWQpXG4gICAgfSwgbGFiZWwgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgbGFiZWwpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgIF9faHRtbDogJyYjODIwMzsnXG4gICAgICB9XG4gICAgfSkpKTtcbiAgfVxuXG4gIHZhciBsYWJlbFdpZHRoID0gbGFiZWxXaWR0aFByb3AgPiAwID8gbGFiZWxXaWR0aFByb3AgKiAwLjc1ICsgOCA6IDAuMDE7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIsIF9leHRlbmRzKHtcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgc3R5bGU6IF9leHRlbmRzKF9kZWZpbmVQcm9wZXJ0eSh7fSwgXCJwYWRkaW5nXCIuY29uY2F0KGNhcGl0YWxpemUoYWxpZ24pKSwgOCksIHN0eWxlKSxcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUpLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsZWdlbmRcIiwge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5sZWdlbmQsXG4gICAgc3R5bGU6IHtcbiAgICAgIC8vIElFIDExOiBmaWVsZHNldCB3aXRoIGxlZ2VuZCBkb2VzIG5vdCByZW5kZXJcbiAgICAgIC8vIGEgYm9yZGVyIHJhZGl1cy4gVGhpcyBtYWludGFpbnMgY29uc2lzdGVuY3lcbiAgICAgIC8vIGJ5IGFsd2F5cyBoYXZpbmcgYSBsZWdlbmQgcmVuZGVyZWRcbiAgICAgIHdpZHRoOiBub3RjaGVkID8gbGFiZWxXaWR0aCA6IDAuMDFcbiAgICB9XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgIF9faHRtbDogJyYjODIwMzsnXG4gICAgfVxuICB9KSkpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBOb3RjaGVkT3V0bGluZS5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGxhYmVsLlxuICAgKi9cbiAgbGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgdGhlIGxhYmVsLlxuICAgKi9cbiAgbGFiZWxXaWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBvdXRsaW5lIGlzIG5vdGNoZWQgdG8gYWNjb21tb2RhdGUgdGhlIGxhYmVsLlxuICAgKi9cbiAgbm90Y2hlZDogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3Rcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnUHJpdmF0ZU5vdGNoZWRPdXRsaW5lJ1xufSkoTm90Y2hlZE91dGxpbmUpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IHJlZlR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IElucHV0QmFzZSBmcm9tICcuLi9JbnB1dEJhc2UnO1xuaW1wb3J0IE5vdGNoZWRPdXRsaW5lIGZyb20gJy4vTm90Y2hlZE91dGxpbmUnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgdmFyIGJvcmRlckNvbG9yID0gdGhlbWUucGFsZXR0ZS50eXBlID09PSAnbGlnaHQnID8gJ3JnYmEoMCwgMCwgMCwgMC4yMyknIDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4yMyknO1xuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gICAgcm9vdDoge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICBib3JkZXJSYWRpdXM6IHRoZW1lLnNoYXBlLmJvcmRlclJhZGl1cyxcbiAgICAgICcmOmhvdmVyICRub3RjaGVkT3V0bGluZSc6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6IHRoZW1lLnBhbGV0dGUudGV4dC5wcmltYXJ5XG4gICAgICB9LFxuICAgICAgLy8gUmVzZXQgb24gdG91Y2ggZGV2aWNlcywgaXQgZG9lc24ndCBhZGQgc3BlY2lmaWNpdHlcbiAgICAgICdAbWVkaWEgKGhvdmVyOiBub25lKSc6IHtcbiAgICAgICAgJyY6aG92ZXIgJG5vdGNoZWRPdXRsaW5lJzoge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBib3JkZXJDb2xvclxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJyYkZm9jdXNlZCAkbm90Y2hlZE91dGxpbmUnOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGVtZS5wYWxldHRlLnByaW1hcnkubWFpbixcbiAgICAgICAgYm9yZGVyV2lkdGg6IDJcbiAgICAgIH0sXG4gICAgICAnJiRlcnJvciAkbm90Y2hlZE91dGxpbmUnOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGVtZS5wYWxldHRlLmVycm9yLm1haW5cbiAgICAgIH0sXG4gICAgICAnJiRkaXNhYmxlZCAkbm90Y2hlZE91dGxpbmUnOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGVtZS5wYWxldHRlLmFjdGlvbi5kaXNhYmxlZFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIHRoZSBjb2xvciBpcyBzZWNvbmRhcnkuICovXG4gICAgY29sb3JTZWNvbmRhcnk6IHtcbiAgICAgICcmJGZvY3VzZWQgJG5vdGNoZWRPdXRsaW5lJzoge1xuICAgICAgICBib3JkZXJDb2xvcjogdGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkubWFpblxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIHRoZSBjb21wb25lbnQgaXMgZm9jdXNlZC4gKi9cbiAgICBmb2N1c2VkOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVkPXt0cnVlfWAuICovXG4gICAgZGlzYWJsZWQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgc3RhcnRBZG9ybm1lbnRgIGlzIHByb3ZpZGVkLiAqL1xuICAgIGFkb3JuZWRTdGFydDoge1xuICAgICAgcGFkZGluZ0xlZnQ6IDE0XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGVuZEFkb3JubWVudGAgaXMgcHJvdmlkZWQuICovXG4gICAgYWRvcm5lZEVuZDoge1xuICAgICAgcGFkZGluZ1JpZ2h0OiAxNFxuICAgIH0sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBlcnJvcj17dHJ1ZX1gLiAqL1xuICAgIGVycm9yOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYG1hcmdpbj1cImRlbnNlXCJgLiAqL1xuICAgIG1hcmdpbkRlbnNlOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYG11bHRpbGluZT17dHJ1ZX1gLiAqL1xuICAgIG11bHRpbGluZToge1xuICAgICAgcGFkZGluZzogJzE4LjVweCAxNHB4JyxcbiAgICAgICcmJG1hcmdpbkRlbnNlJzoge1xuICAgICAgICBwYWRkaW5nVG9wOiAxMC41LFxuICAgICAgICBwYWRkaW5nQm90dG9tOiAxMC41XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgTm90Y2hlZE91dGxpbmVgIGVsZW1lbnQuICovXG4gICAgbm90Y2hlZE91dGxpbmU6IHtcbiAgICAgIGJvcmRlckNvbG9yOiBib3JkZXJDb2xvclxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50LiAqL1xuICAgIGlucHV0OiB7XG4gICAgICBwYWRkaW5nOiAnMTguNXB4IDE0cHgnLFxuICAgICAgJyY6LXdlYmtpdC1hdXRvZmlsbCc6IHtcbiAgICAgICAgV2Via2l0Qm94U2hhZG93OiB0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCcgPyBudWxsIDogJzAgMCAwIDEwMHB4ICMyNjY3OTggaW5zZXQnLFxuICAgICAgICBXZWJraXRUZXh0RmlsbENvbG9yOiB0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCcgPyBudWxsIDogJyNmZmYnLFxuICAgICAgICBjYXJldENvbG9yOiB0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCcgPyBudWxsIDogJyNmZmYnLFxuICAgICAgICBib3JkZXJSYWRpdXM6ICdpbmhlcml0J1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBtYXJnaW49XCJkZW5zZVwiYC4gKi9cbiAgICBpbnB1dE1hcmdpbkRlbnNlOiB7XG4gICAgICBwYWRkaW5nVG9wOiAxMC41LFxuICAgICAgcGFkZGluZ0JvdHRvbTogMTAuNVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBtdWx0aWxpbmU9e3RydWV9YC4gKi9cbiAgICBpbnB1dE11bHRpbGluZToge1xuICAgICAgcGFkZGluZzogMFxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBzdGFydEFkb3JubWVudGAgaXMgcHJvdmlkZWQuICovXG4gICAgaW5wdXRBZG9ybmVkU3RhcnQ6IHtcbiAgICAgIHBhZGRpbmdMZWZ0OiAwXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYGVuZEFkb3JubWVudGAgaXMgcHJvdmlkZWQuICovXG4gICAgaW5wdXRBZG9ybmVkRW5kOiB7XG4gICAgICBwYWRkaW5nUmlnaHQ6IDBcbiAgICB9XG4gIH07XG59O1xudmFyIE91dGxpbmVkSW5wdXQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBPdXRsaW5lZElucHV0KHByb3BzLCByZWYpIHtcbiAgdmFyIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgX3Byb3BzJGZ1bGxXaWR0aCA9IHByb3BzLmZ1bGxXaWR0aCxcbiAgICAgIGZ1bGxXaWR0aCA9IF9wcm9wcyRmdWxsV2lkdGggPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGZ1bGxXaWR0aCxcbiAgICAgIF9wcm9wcyRpbnB1dENvbXBvbmVudCA9IHByb3BzLmlucHV0Q29tcG9uZW50LFxuICAgICAgaW5wdXRDb21wb25lbnQgPSBfcHJvcHMkaW5wdXRDb21wb25lbnQgPT09IHZvaWQgMCA/ICdpbnB1dCcgOiBfcHJvcHMkaW5wdXRDb21wb25lbnQsXG4gICAgICBsYWJlbCA9IHByb3BzLmxhYmVsLFxuICAgICAgX3Byb3BzJGxhYmVsV2lkdGggPSBwcm9wcy5sYWJlbFdpZHRoLFxuICAgICAgbGFiZWxXaWR0aCA9IF9wcm9wcyRsYWJlbFdpZHRoID09PSB2b2lkIDAgPyAwIDogX3Byb3BzJGxhYmVsV2lkdGgsXG4gICAgICBfcHJvcHMkbXVsdGlsaW5lID0gcHJvcHMubXVsdGlsaW5lLFxuICAgICAgbXVsdGlsaW5lID0gX3Byb3BzJG11bHRpbGluZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkbXVsdGlsaW5lLFxuICAgICAgbm90Y2hlZCA9IHByb3BzLm5vdGNoZWQsXG4gICAgICBfcHJvcHMkdHlwZSA9IHByb3BzLnR5cGUsXG4gICAgICB0eXBlID0gX3Byb3BzJHR5cGUgPT09IHZvaWQgMCA/ICd0ZXh0JyA6IF9wcm9wcyR0eXBlLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNsYXNzZXNcIiwgXCJmdWxsV2lkdGhcIiwgXCJpbnB1dENvbXBvbmVudFwiLCBcImxhYmVsXCIsIFwibGFiZWxXaWR0aFwiLCBcIm11bHRpbGluZVwiLCBcIm5vdGNoZWRcIiwgXCJ0eXBlXCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXRCYXNlLCBfZXh0ZW5kcyh7XG4gICAgcmVuZGVyU3VmZml4OiBmdW5jdGlvbiByZW5kZXJTdWZmaXgoc3RhdGUpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChOb3RjaGVkT3V0bGluZSwge1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzZXMubm90Y2hlZE91dGxpbmUsXG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgbGFiZWxXaWR0aDogbGFiZWxXaWR0aCxcbiAgICAgICAgbm90Y2hlZDogdHlwZW9mIG5vdGNoZWQgIT09ICd1bmRlZmluZWQnID8gbm90Y2hlZCA6IEJvb2xlYW4oc3RhdGUuc3RhcnRBZG9ybm1lbnQgfHwgc3RhdGUuZmlsbGVkIHx8IHN0YXRlLmZvY3VzZWQpXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNsYXNzZXM6IF9leHRlbmRzKHt9LCBjbGFzc2VzLCB7XG4gICAgICByb290OiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3Nlcy51bmRlcmxpbmUpLFxuICAgICAgbm90Y2hlZE91dGxpbmU6IG51bGxcbiAgICB9KSxcbiAgICBmdWxsV2lkdGg6IGZ1bGxXaWR0aCxcbiAgICBpbnB1dENvbXBvbmVudDogaW5wdXRDb21wb25lbnQsXG4gICAgbXVsdGlsaW5lOiBtdWx0aWxpbmUsXG4gICAgcmVmOiByZWYsXG4gICAgdHlwZTogdHlwZVxuICB9LCBvdGhlcikpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBPdXRsaW5lZElucHV0LnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoaXMgcHJvcCBoZWxwcyB1c2VycyB0byBmaWxsIGZvcm1zIGZhc3RlciwgZXNwZWNpYWxseSBvbiBtb2JpbGUgZGV2aWNlcy5cbiAgICogVGhlIG5hbWUgY2FuIGJlIGNvbmZ1c2luZywgYXMgaXQncyBtb3JlIGxpa2UgYW4gYXV0b2ZpbGwuXG4gICAqIFlvdSBjYW4gbGVhcm4gbW9yZSBhYm91dCBpdCBbZm9sbG93aW5nIHRoZSBzcGVjaWZpY2F0aW9uXShodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNhdXRvZmlsbCkuXG4gICAqL1xuICBhdXRvQ29tcGxldGU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIGZvY3VzZWQgZHVyaW5nIHRoZSBmaXJzdCBtb3VudC5cbiAgICovXG4gIGF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIHRob3NlIHRoZW1lIGNvbG9ycyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBgaW5wdXRgIGVsZW1lbnQgdmFsdWUuIFVzZSB3aGVuIHRoZSBjb21wb25lbnQgaXMgbm90IGNvbnRyb2xsZWQuXG4gICAqL1xuICBkZWZhdWx0VmFsdWU6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBFbmQgYElucHV0QWRvcm5tZW50YCBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBlbmRBZG9ybm1lbnQ6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBpbnB1dCB3aWxsIGluZGljYXRlIGFuIGVycm9yLiBUaGlzIGlzIG5vcm1hbGx5IG9idGFpbmVkIHZpYSBjb250ZXh0IGZyb21cbiAgICogRm9ybUNvbnRyb2wuXG4gICAqL1xuICBlcnJvcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IHdpbGwgdGFrZSB1cCB0aGUgZnVsbCB3aWR0aCBvZiBpdHMgY29udGFpbmVyLlxuICAgKi9cbiAgZnVsbFdpZHRoOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGlkIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgaW5wdXRDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogW0F0dHJpYnV0ZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNBdHRyaWJ1dGVzKSBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBQYXNzIGEgcmVmIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFJlZjogcmVmVHlwZSxcblxuICAvKipcbiAgICogVGhlIGxhYmVsIG9mIHRoZSBpbnB1dC4gSXQgaXMgb25seSB1c2VkIGZvciBsYXlvdXQuIFRoZSBhY3R1YWwgbGFiZWxsaW5nXG4gICAqIGlzIGhhbmRsZWQgYnkgYElucHV0TGFiZWxgLiBJZiBzcGVjaWZpZWQgYGxhYmVsV2lkdGhgIGlzIGlnbm9yZWQuXG4gICAqL1xuICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBvZiB0aGUgbGFiZWwuIElzIGlnbm9yZWQgaWYgYGxhYmVsYCBpcyBwcm92aWRlZC4gUHJlZmVyIGBsYWJlbGBcbiAgICogaWYgdGhlIGlucHV0IGxhYmVsIGFwcGVhcnMgd2l0aCBhIHN0cmlrZSB0aHJvdWdoLlxuICAgKi9cbiAgbGFiZWxXaWR0aDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogSWYgYGRlbnNlYCwgd2lsbCBhZGp1c3QgdmVydGljYWwgc3BhY2luZy4gVGhpcyBpcyBub3JtYWxseSBvYnRhaW5lZCB2aWEgY29udGV4dCBmcm9tXG4gICAqIEZvcm1Db250cm9sLlxuICAgKi9cbiAgbWFyZ2luOiBQcm9wVHlwZXMub25lT2YoWydkZW5zZScsICdub25lJ10pLFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgd2hlbiBtdWx0aWxpbmUgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgKi9cbiAgbWF4Um93czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGEgdGV4dGFyZWEgZWxlbWVudCB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgbXVsdGlsaW5lOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTmFtZSBhdHRyaWJ1dGUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIG91dGxpbmUgaXMgbm90Y2hlZCB0byBhY2NvbW1vZGF0ZSB0aGUgbGFiZWwuXG4gICAqL1xuICBub3RjaGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgdmFsdWUgaXMgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBZb3UgY2FuIHB1bGwgb3V0IHRoZSBuZXcgdmFsdWUgYnkgYWNjZXNzaW5nIGBldmVudC50YXJnZXQudmFsdWVgIChzdHJpbmcpLlxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBUaGUgc2hvcnQgaGludCBkaXNwbGF5ZWQgaW4gdGhlIGlucHV0IGJlZm9yZSB0aGUgdXNlciBlbnRlcnMgYSB2YWx1ZS5cbiAgICovXG4gIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBJdCBwcmV2ZW50cyB0aGUgdXNlciBmcm9tIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiB0aGUgZmllbGRcbiAgICogKG5vdCBmcm9tIGludGVyYWN0aW5nIHdpdGggdGhlIGZpZWxkKS5cbiAgICovXG4gIHJlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYGlucHV0YCBlbGVtZW50IHdpbGwgYmUgcmVxdWlyZWQuXG4gICAqL1xuICByZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgd2hlbiBtdWx0aWxpbmUgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgKi9cbiAgcm93czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBTdGFydCBgSW5wdXRBZG9ybm1lbnRgIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIHN0YXJ0QWRvcm5tZW50OiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogVHlwZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LiBJdCBzaG91bGQgYmUgW2EgdmFsaWQgSFRNTDUgaW5wdXQgdHlwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0I0Zvcm1fJTNDaW5wdXQlM0VfdHlwZXMpLlxuICAgKi9cbiAgdHlwZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQsIHJlcXVpcmVkIGZvciBhIGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgKi9cbiAgdmFsdWU6IFByb3BUeXBlcy5hbnlcbn0gOiB2b2lkIDA7XG5PdXRsaW5lZElucHV0Lm11aU5hbWUgPSAnSW5wdXQnO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aU91dGxpbmVkSW5wdXQnXG59KShPdXRsaW5lZElucHV0KTsiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRm9ybUNvbnRyb2xDb250ZXh0IGZyb20gJy4vRm9ybUNvbnRyb2xDb250ZXh0JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZUZvcm1Db250cm9sKCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChGb3JtQ29udHJvbENvbnRleHQpO1xufSIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCBmb3JtQ29udHJvbFN0YXRlIGZyb20gJy4uL0Zvcm1Db250cm9sL2Zvcm1Db250cm9sU3RhdGUnO1xuaW1wb3J0IHVzZUZvcm1Db250cm9sIGZyb20gJy4uL0Zvcm1Db250cm9sL3VzZUZvcm1Db250cm9sJztcbmltcG9ydCBjYXBpdGFsaXplIGZyb20gJy4uL3V0aWxzL2NhcGl0YWxpemUnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IF9leHRlbmRzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnRleHQuc2Vjb25kYXJ5XG4gICAgfSwgdGhlbWUudHlwb2dyYXBoeS5ib2R5MSwge1xuICAgICAgbGluZUhlaWdodDogMSxcbiAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAnJiRmb2N1c2VkJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW5cbiAgICAgIH0sXG4gICAgICAnJiRkaXNhYmxlZCc6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudGV4dC5kaXNhYmxlZFxuICAgICAgfSxcbiAgICAgICcmJGVycm9yJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5lcnJvci5tYWluXG4gICAgICB9XG4gICAgfSksXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIHRoZSBjb2xvciBpcyBzZWNvbmRhcnkuICovXG4gICAgY29sb3JTZWNvbmRhcnk6IHtcbiAgICAgICcmJGZvY3VzZWQnOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnNlY29uZGFyeS5tYWluXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGZvY3VzZWQ9e3RydWV9YC4gKi9cbiAgICBmb2N1c2VkOiB7fSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVkPXt0cnVlfWAuICovXG4gICAgZGlzYWJsZWQ6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZXJyb3I9e3RydWV9YC4gKi9cbiAgICBlcnJvcjoge30sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBmaWxsZWQ9e3RydWV9YC4gKi9cbiAgICBmaWxsZWQ6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgcmVxdWlyZWQ9e3RydWV9YC4gKi9cbiAgICByZXF1aXJlZDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYXN0ZXJpc2sgZWxlbWVudC4gKi9cbiAgICBhc3Rlcmlzazoge1xuICAgICAgJyYkZXJyb3InOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmVycm9yLm1haW5cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xudmFyIEZvcm1MYWJlbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZvcm1MYWJlbChwcm9wcywgcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjb2xvciA9IHByb3BzLmNvbG9yLFxuICAgICAgX3Byb3BzJGNvbXBvbmVudCA9IHByb3BzLmNvbXBvbmVudCxcbiAgICAgIENvbXBvbmVudCA9IF9wcm9wcyRjb21wb25lbnQgPT09IHZvaWQgMCA/ICdsYWJlbCcgOiBfcHJvcHMkY29tcG9uZW50LFxuICAgICAgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGVycm9yID0gcHJvcHMuZXJyb3IsXG4gICAgICBmaWxsZWQgPSBwcm9wcy5maWxsZWQsXG4gICAgICBmb2N1c2VkID0gcHJvcHMuZm9jdXNlZCxcbiAgICAgIHJlcXVpcmVkID0gcHJvcHMucmVxdWlyZWQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29sb3JcIiwgXCJjb21wb25lbnRcIiwgXCJkaXNhYmxlZFwiLCBcImVycm9yXCIsIFwiZmlsbGVkXCIsIFwiZm9jdXNlZFwiLCBcInJlcXVpcmVkXCJdKTtcblxuICB2YXIgbXVpRm9ybUNvbnRyb2wgPSB1c2VGb3JtQ29udHJvbCgpO1xuICB2YXIgZmNzID0gZm9ybUNvbnRyb2xTdGF0ZSh7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIG11aUZvcm1Db250cm9sOiBtdWlGb3JtQ29udHJvbCxcbiAgICBzdGF0ZXM6IFsnY29sb3InLCAncmVxdWlyZWQnLCAnZm9jdXNlZCcsICdkaXNhYmxlZCcsICdlcnJvcicsICdmaWxsZWQnXVxuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzZXNbXCJjb2xvclwiLmNvbmNhdChjYXBpdGFsaXplKGZjcy5jb2xvciB8fCAncHJpbWFyeScpKV0sIGNsYXNzTmFtZSwgZmNzLmRpc2FibGVkICYmIGNsYXNzZXMuZGlzYWJsZWQsIGZjcy5lcnJvciAmJiBjbGFzc2VzLmVycm9yLCBmY3MuZmlsbGVkICYmIGNsYXNzZXMuZmlsbGVkLCBmY3MuZm9jdXNlZCAmJiBjbGFzc2VzLmZvY3VzZWQsIGZjcy5yZXF1aXJlZCAmJiBjbGFzc2VzLnJlcXVpcmVkKSxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlciksIGNoaWxkcmVuLCBmY3MucmVxdWlyZWQgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMuYXN0ZXJpc2ssIGZjcy5lcnJvciAmJiBjbGFzc2VzLmVycm9yKVxuICB9LCBcIlxcdTIwMDlcIiwgJyonKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IEZvcm1MYWJlbC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIHRob3NlIHRoZW1lIGNvbG9ycyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbGFiZWwgc2hvdWxkIGJlIGRpc3BsYXllZCBpbiBhIGRpc2FibGVkIHN0YXRlLlxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBsYWJlbCBzaG91bGQgYmUgZGlzcGxheWVkIGluIGFuIGVycm9yIHN0YXRlLlxuICAgKi9cbiAgZXJyb3I6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBsYWJlbCBzaG91bGQgdXNlIGZpbGxlZCBjbGFzc2VzIGtleS5cbiAgICovXG4gIGZpbGxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IG9mIHRoaXMgbGFiZWwgaXMgZm9jdXNlZCAodXNlZCBieSBgRm9ybUdyb3VwYCBjb21wb25lbnRzKS5cbiAgICovXG4gIGZvY3VzZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBsYWJlbCB3aWxsIGluZGljYXRlIHRoYXQgdGhlIGlucHV0IGlzIHJlcXVpcmVkLlxuICAgKi9cbiAgcmVxdWlyZWQ6IFByb3BUeXBlcy5ib29sXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUZvcm1MYWJlbCdcbn0pKEZvcm1MYWJlbCk7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IGZvcm1Db250cm9sU3RhdGUgZnJvbSAnLi4vRm9ybUNvbnRyb2wvZm9ybUNvbnRyb2xTdGF0ZSc7XG5pbXBvcnQgdXNlRm9ybUNvbnRyb2wgZnJvbSAnLi4vRm9ybUNvbnRyb2wvdXNlRm9ybUNvbnRyb2wnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IEZvcm1MYWJlbCBmcm9tICcuLi9Gb3JtTGFiZWwnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICB0cmFuc2Zvcm1PcmlnaW46ICd0b3AgbGVmdCdcbiAgICB9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZm9jdXNlZD17dHJ1ZX1gLiAqL1xuICAgIGZvY3VzZWQ6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZGlzYWJsZWQ9e3RydWV9YC4gKi9cbiAgICBkaXNhYmxlZDoge30sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBlcnJvcj17dHJ1ZX1gLiAqL1xuICAgIGVycm9yOiB7fSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHJlcXVpcmVkPXt0cnVlfWAuICovXG4gICAgcmVxdWlyZWQ6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIGFzdGVyaXNrIGVsZW1lbnQuICovXG4gICAgYXN0ZXJpc2s6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiB0aGUgY29tcG9uZW50IGlzIGEgZGVzY2VuZGFudCBvZiBgRm9ybUNvbnRyb2xgLiAqL1xuICAgIGZvcm1Db250cm9sOiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICAvLyBzbGlnaHQgYWx0ZXJhdGlvbiB0byBzcGVjIHNwYWNpbmcgdG8gbWF0Y2ggdmlzdWFsIHNwZWMgcmVzdWx0XG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwgMjRweCkgc2NhbGUoMSknXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYG1hcmdpbj1cImRlbnNlXCJgLiAqL1xuICAgIG1hcmdpbkRlbnNlOiB7XG4gICAgICAvLyBDb21wZW5zYXRpb24gZm9yIHRoZSBgSW5wdXQuaW5wdXREZW5zZWAgc3R5bGUuXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwgMjFweCkgc2NhbGUoMSknXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYHNocmluaz17dHJ1ZX1gLiAqL1xuICAgIHNocmluazoge1xuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDAsIDEuNXB4KSBzY2FsZSgwLjc1KScsXG4gICAgICB0cmFuc2Zvcm1PcmlnaW46ICd0b3AgbGVmdCdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgZGlzYWJsZUFuaW1hdGlvbj17ZmFsc2V9YC4gKi9cbiAgICBhbmltYXRlZDoge1xuICAgICAgdHJhbnNpdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKFsnY29sb3InLCAndHJhbnNmb3JtJ10sIHtcbiAgICAgICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXIsXG4gICAgICAgIGVhc2luZzogdGhlbWUudHJhbnNpdGlvbnMuZWFzaW5nLmVhc2VPdXRcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHZhcmlhbnQ9XCJmaWxsZWRcImAuICovXG4gICAgZmlsbGVkOiB7XG4gICAgICAvLyBDaHJvbWUncyBhdXRvZmlsbCBmZWF0dXJlIGdpdmVzIHRoZSBpbnB1dCBmaWVsZCBhIHllbGxvdyBiYWNrZ3JvdW5kLlxuICAgICAgLy8gU2luY2UgdGhlIGlucHV0IGZpZWxkIGlzIGJlaGluZCB0aGUgbGFiZWwgaW4gdGhlIEhUTUwgdHJlZSxcbiAgICAgIC8vIHRoZSBpbnB1dCBmaWVsZCBpcyBkcmF3biBsYXN0IGFuZCBoaWRlcyB0aGUgbGFiZWwgd2l0aCBhbiBvcGFxdWUgYmFja2dyb3VuZCBjb2xvci5cbiAgICAgIC8vIHpJbmRleDogMSB3aWxsIHJhaXNlIHRoZSBsYWJlbCBhYm92ZSBvcGFxdWUgYmFja2dyb3VuZC1jb2xvcnMgb2YgaW5wdXQuXG4gICAgICB6SW5kZXg6IDEsXG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMTJweCwgMjBweCkgc2NhbGUoMSknLFxuICAgICAgJyYkbWFyZ2luRGVuc2UnOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgxMnB4LCAxN3B4KSBzY2FsZSgxKSdcbiAgICAgIH0sXG4gICAgICAnJiRzaHJpbmsnOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgxMnB4LCAxMHB4KSBzY2FsZSgwLjc1KScsXG4gICAgICAgICcmJG1hcmdpbkRlbnNlJzoge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgxMnB4LCA3cHgpIHNjYWxlKDAuNzUpJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHZhcmlhbnQ9XCJvdXRsaW5lZFwiYC4gKi9cbiAgICBvdXRsaW5lZDoge1xuICAgICAgLy8gc2VlIGNvbW1lbnQgYWJvdmUgb24gZmlsbGVkLnpJbmRleFxuICAgICAgekluZGV4OiAxLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDE0cHgsIDIwcHgpIHNjYWxlKDEpJyxcbiAgICAgICcmJG1hcmdpbkRlbnNlJzoge1xuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMTRweCwgMTJweCkgc2NhbGUoMSknXG4gICAgICB9LFxuICAgICAgJyYkc2hyaW5rJzoge1xuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMTRweCwgLTZweCkgc2NhbGUoMC43NSknXG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbnZhciBJbnB1dExhYmVsID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gSW5wdXRMYWJlbChwcm9wcywgcmVmKSB7XG4gIHZhciBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRkaXNhYmxlQW5pbWF0aSA9IHByb3BzLmRpc2FibGVBbmltYXRpb24sXG4gICAgICBkaXNhYmxlQW5pbWF0aW9uID0gX3Byb3BzJGRpc2FibGVBbmltYXRpID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlQW5pbWF0aSxcbiAgICAgIG1hcmdpbiA9IHByb3BzLm1hcmdpbixcbiAgICAgIHNocmlua1Byb3AgPSBwcm9wcy5zaHJpbmssXG4gICAgICB2YXJpYW50ID0gcHJvcHMudmFyaWFudCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiZGlzYWJsZUFuaW1hdGlvblwiLCBcIm1hcmdpblwiLCBcInNocmlua1wiLCBcInZhcmlhbnRcIl0pO1xuXG4gIHZhciBtdWlGb3JtQ29udHJvbCA9IHVzZUZvcm1Db250cm9sKCk7XG4gIHZhciBzaHJpbmsgPSBzaHJpbmtQcm9wO1xuXG4gIGlmICh0eXBlb2Ygc2hyaW5rID09PSAndW5kZWZpbmVkJyAmJiBtdWlGb3JtQ29udHJvbCkge1xuICAgIHNocmluayA9IG11aUZvcm1Db250cm9sLmZpbGxlZCB8fCBtdWlGb3JtQ29udHJvbC5mb2N1c2VkIHx8IG11aUZvcm1Db250cm9sLmFkb3JuZWRTdGFydDtcbiAgfVxuXG4gIHZhciBmY3MgPSBmb3JtQ29udHJvbFN0YXRlKHtcbiAgICBwcm9wczogcHJvcHMsXG4gICAgbXVpRm9ybUNvbnRyb2w6IG11aUZvcm1Db250cm9sLFxuICAgIHN0YXRlczogWydtYXJnaW4nLCAndmFyaWFudCddXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybUxhYmVsLCBfZXh0ZW5kcyh7XG4gICAgXCJkYXRhLXNocmlua1wiOiBzaHJpbmssXG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lLCBtdWlGb3JtQ29udHJvbCAmJiBjbGFzc2VzLmZvcm1Db250cm9sLCAhZGlzYWJsZUFuaW1hdGlvbiAmJiBjbGFzc2VzLmFuaW1hdGVkLCBzaHJpbmsgJiYgY2xhc3Nlcy5zaHJpbmssIGZjcy5tYXJnaW4gPT09ICdkZW5zZScgJiYgY2xhc3Nlcy5tYXJnaW5EZW5zZSwge1xuICAgICAgJ2ZpbGxlZCc6IGNsYXNzZXMuZmlsbGVkLFxuICAgICAgJ291dGxpbmVkJzogY2xhc3Nlcy5vdXRsaW5lZFxuICAgIH1bZmNzLnZhcmlhbnRdKSxcbiAgICBjbGFzc2VzOiB7XG4gICAgICBmb2N1c2VkOiBjbGFzc2VzLmZvY3VzZWQsXG4gICAgICBkaXNhYmxlZDogY2xhc3Nlcy5kaXNhYmxlZCxcbiAgICAgIGVycm9yOiBjbGFzc2VzLmVycm9yLFxuICAgICAgcmVxdWlyZWQ6IGNsYXNzZXMucmVxdWlyZWQsXG4gICAgICBhc3RlcmlzazogY2xhc3Nlcy5hc3Rlcmlza1xuICAgIH0sXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gSW5wdXRMYWJlbC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGBJbnB1dExhYmVsYC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29tcG9uZW50LiBJdCBzdXBwb3J0cyB0aG9zZSB0aGVtZSBjb2xvcnMgdGhhdCBtYWtlIHNlbnNlIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoWydwcmltYXJ5JywgJ3NlY29uZGFyeSddKSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgdHJhbnNpdGlvbiBhbmltYXRpb24gaXMgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlQW5pbWF0aW9uOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBhcHBseSBkaXNhYmxlZCBjbGFzcy5cbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbGFiZWwgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gYW4gZXJyb3Igc3RhdGUuXG4gICAqL1xuICBlcnJvcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IG9mIHRoaXMgbGFiZWwgaXMgZm9jdXNlZC5cbiAgICovXG4gIGZvY3VzZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgZGVuc2VgLCB3aWxsIGFkanVzdCB2ZXJ0aWNhbCBzcGFjaW5nLiBUaGlzIGlzIG5vcm1hbGx5IG9idGFpbmVkIHZpYSBjb250ZXh0IGZyb21cbiAgICogRm9ybUNvbnRyb2wuXG4gICAqL1xuICBtYXJnaW46IFByb3BUeXBlcy5vbmVPZihbJ2RlbnNlJ10pLFxuXG4gIC8qKlxuICAgKiBpZiBgdHJ1ZWAsIHRoZSBsYWJlbCB3aWxsIGluZGljYXRlIHRoYXQgdGhlIGlucHV0IGlzIHJlcXVpcmVkLlxuICAgKi9cbiAgcmVxdWlyZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBsYWJlbCBpcyBzaHJ1bmsuXG4gICAqL1xuICBzaHJpbms6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgdmFyaWFudCB0byB1c2UuXG4gICAqL1xuICB2YXJpYW50OiBQcm9wVHlwZXMub25lT2YoWydmaWxsZWQnLCAnb3V0bGluZWQnLCAnc3RhbmRhcmQnXSlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpSW5wdXRMYWJlbCdcbn0pKElucHV0TGFiZWwpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IGlzRmlsbGVkLCBpc0Fkb3JuZWRTdGFydCB9IGZyb20gJy4uL0lucHV0QmFzZS91dGlscyc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5pbXBvcnQgY2FwaXRhbGl6ZSBmcm9tICcuLi91dGlscy9jYXBpdGFsaXplJztcbmltcG9ydCBpc011aUVsZW1lbnQgZnJvbSAnLi4vdXRpbHMvaXNNdWlFbGVtZW50JztcbmltcG9ydCBGb3JtQ29udHJvbENvbnRleHQgZnJvbSAnLi9Gb3JtQ29udHJvbENvbnRleHQnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSB7XG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gIHJvb3Q6IHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWZsZXgnLFxuICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIC8vIFJlc2V0IGZpZWxkc2V0IGRlZmF1bHQgc3R5bGUuXG4gICAgbWluV2lkdGg6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICBtYXJnaW46IDAsXG4gICAgYm9yZGVyOiAwLFxuICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnIC8vIEZpeCBhbGlnbm1lbnQgaXNzdWUgb24gU2FmYXJpLlxuXG4gIH0sXG5cbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgbWFyZ2luPVwibm9ybWFsXCJgLiAqL1xuICBtYXJnaW5Ob3JtYWw6IHtcbiAgICBtYXJnaW5Ub3A6IDE2LFxuICAgIG1hcmdpbkJvdHRvbTogOFxuICB9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYG1hcmdpbj1cImRlbnNlXCJgLiAqL1xuICBtYXJnaW5EZW5zZToge1xuICAgIG1hcmdpblRvcDogOCxcbiAgICBtYXJnaW5Cb3R0b206IDRcbiAgfSxcblxuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBmdWxsV2lkdGg9e3RydWV9YC4gKi9cbiAgZnVsbFdpZHRoOiB7XG4gICAgd2lkdGg6ICcxMDAlJ1xuICB9XG59O1xuLyoqXG4gKiBQcm92aWRlcyBjb250ZXh0IHN1Y2ggYXMgZmlsbGVkL2ZvY3VzZWQvZXJyb3IvcmVxdWlyZWQgZm9yIGZvcm0gaW5wdXRzLlxuICogUmVseWluZyBvbiB0aGUgY29udGV4dCBwcm92aWRlcyBoaWdoIGZsZXhpYmlsaXR5IGFuZCBlbnN1cmVzIHRoYXQgdGhlIHN0YXRlIGFsd2F5cyBzdGF5c1xuICogY29uc2lzdGVudCBhY3Jvc3MgdGhlIGNoaWxkcmVuIG9mIHRoZSBgRm9ybUNvbnRyb2xgLlxuICogVGhpcyBjb250ZXh0IGlzIHVzZWQgYnkgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOlxuICpcbiAqICAtIEZvcm1MYWJlbFxuICogIC0gRm9ybUhlbHBlclRleHRcbiAqICAtIElucHV0XG4gKiAgLSBJbnB1dExhYmVsXG4gKlxuICogWW91IGNhbiBmaW5kIG9uZSBjb21wb3NpdGlvbiBleGFtcGxlIGJlbG93IGFuZCBtb3JlIGdvaW5nIHRvIFt0aGUgZGVtb3NdKC9jb21wb25lbnRzL3RleHQtZmllbGRzLyNjb21wb25lbnRzKS5cbiAqXG4gKiBgYGBqc3hcbiAqIDxGb3JtQ29udHJvbD5cbiAqICAgPElucHV0TGFiZWwgaHRtbEZvcj1cIm15LWlucHV0XCI+RW1haWwgYWRkcmVzczwvSW5wdXRMYWJlbD5cbiAqICAgPElucHV0IGlkPVwibXktaW5wdXRcIiBhcmlhLWRlc2NyaWJlZGJ5PVwibXktaGVscGVyLXRleHRcIiAvPlxuICogICA8Rm9ybUhlbHBlclRleHQgaWQ9XCJteS1oZWxwZXItdGV4dFwiPldlJ2xsIG5ldmVyIHNoYXJlIHlvdXIgZW1haWwuPC9Gb3JtSGVscGVyVGV4dD5cbiAqIDwvRm9ybUNvbnRyb2w+XG4gKiBgYGBcbiAqXG4gKiDimqDvuI9Pbmx5IG9uZSBpbnB1dCBjYW4gYmUgdXNlZCB3aXRoaW4gYSBGb3JtQ29udHJvbC5cbiAqL1xuXG52YXIgRm9ybUNvbnRyb2wgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBGb3JtQ29udHJvbChwcm9wcywgcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkY29sb3IgPSBwcm9wcy5jb2xvcixcbiAgICAgIGNvbG9yID0gX3Byb3BzJGNvbG9yID09PSB2b2lkIDAgPyAncHJpbWFyeScgOiBfcHJvcHMkY29sb3IsXG4gICAgICBfcHJvcHMkY29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50LFxuICAgICAgQ29tcG9uZW50ID0gX3Byb3BzJGNvbXBvbmVudCA9PT0gdm9pZCAwID8gJ2RpdicgOiBfcHJvcHMkY29tcG9uZW50LFxuICAgICAgX3Byb3BzJGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQsXG4gICAgICBkaXNhYmxlZCA9IF9wcm9wcyRkaXNhYmxlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZWQsXG4gICAgICBfcHJvcHMkZXJyb3IgPSBwcm9wcy5lcnJvcixcbiAgICAgIGVycm9yID0gX3Byb3BzJGVycm9yID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRlcnJvcixcbiAgICAgIF9wcm9wcyRmdWxsV2lkdGggPSBwcm9wcy5mdWxsV2lkdGgsXG4gICAgICBmdWxsV2lkdGggPSBfcHJvcHMkZnVsbFdpZHRoID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRmdWxsV2lkdGgsXG4gICAgICB2aXN1YWxseUZvY3VzZWQgPSBwcm9wcy5mb2N1c2VkLFxuICAgICAgX3Byb3BzJGhpZGRlbkxhYmVsID0gcHJvcHMuaGlkZGVuTGFiZWwsXG4gICAgICBoaWRkZW5MYWJlbCA9IF9wcm9wcyRoaWRkZW5MYWJlbCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkaGlkZGVuTGFiZWwsXG4gICAgICBfcHJvcHMkbWFyZ2luID0gcHJvcHMubWFyZ2luLFxuICAgICAgbWFyZ2luID0gX3Byb3BzJG1hcmdpbiA9PT0gdm9pZCAwID8gJ25vbmUnIDogX3Byb3BzJG1hcmdpbixcbiAgICAgIF9wcm9wcyRyZXF1aXJlZCA9IHByb3BzLnJlcXVpcmVkLFxuICAgICAgcmVxdWlyZWQgPSBfcHJvcHMkcmVxdWlyZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJHJlcXVpcmVkLFxuICAgICAgc2l6ZSA9IHByb3BzLnNpemUsXG4gICAgICBfcHJvcHMkdmFyaWFudCA9IHByb3BzLnZhcmlhbnQsXG4gICAgICB2YXJpYW50ID0gX3Byb3BzJHZhcmlhbnQgPT09IHZvaWQgMCA/ICdzdGFuZGFyZCcgOiBfcHJvcHMkdmFyaWFudCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjb2xvclwiLCBcImNvbXBvbmVudFwiLCBcImRpc2FibGVkXCIsIFwiZXJyb3JcIiwgXCJmdWxsV2lkdGhcIiwgXCJmb2N1c2VkXCIsIFwiaGlkZGVuTGFiZWxcIiwgXCJtYXJnaW5cIiwgXCJyZXF1aXJlZFwiLCBcInNpemVcIiwgXCJ2YXJpYW50XCJdKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIC8vIFdlIG5lZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIHRoZSBjaGlsZHJlbiBhbmQgZmluZCB0aGUgSW5wdXQgaW4gb3JkZXJcbiAgICAvLyB0byBmdWxseSBzdXBwb3J0IHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgICB2YXIgaW5pdGlhbEFkb3JuZWRTdGFydCA9IGZhbHNlO1xuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKCFpc011aUVsZW1lbnQoY2hpbGQsIFsnSW5wdXQnLCAnU2VsZWN0J10pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlucHV0ID0gaXNNdWlFbGVtZW50KGNoaWxkLCBbJ1NlbGVjdCddKSA/IGNoaWxkLnByb3BzLmlucHV0IDogY2hpbGQ7XG5cbiAgICAgICAgaWYgKGlucHV0ICYmIGlzQWRvcm5lZFN0YXJ0KGlucHV0LnByb3BzKSkge1xuICAgICAgICAgIGluaXRpYWxBZG9ybmVkU3RhcnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5pdGlhbEFkb3JuZWRTdGFydDtcbiAgfSksXG4gICAgICBhZG9ybmVkU3RhcnQgPSBfUmVhY3QkdXNlU3RhdGVbMF0sXG4gICAgICBzZXRBZG9ybmVkU3RhcnQgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTIgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgLy8gV2UgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggdGhlIGNoaWxkcmVuIGFuZCBmaW5kIHRoZSBJbnB1dCBpbiBvcmRlclxuICAgIC8vIHRvIGZ1bGx5IHN1cHBvcnQgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICAgIHZhciBpbml0aWFsRmlsbGVkID0gZmFsc2U7XG5cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoIWlzTXVpRWxlbWVudChjaGlsZCwgWydJbnB1dCcsICdTZWxlY3QnXSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGaWxsZWQoY2hpbGQucHJvcHMsIHRydWUpKSB7XG4gICAgICAgICAgaW5pdGlhbEZpbGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBpbml0aWFsRmlsbGVkO1xuICB9KSxcbiAgICAgIGZpbGxlZCA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRGaWxsZWQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgX2ZvY3VzZWQgPSBfUmVhY3QkdXNlU3RhdGUzWzBdLFxuICAgICAgc2V0Rm9jdXNlZCA9IF9SZWFjdCR1c2VTdGF0ZTNbMV07XG5cbiAgdmFyIGZvY3VzZWQgPSB2aXN1YWxseUZvY3VzZWQgIT09IHVuZGVmaW5lZCA/IHZpc3VhbGx5Rm9jdXNlZCA6IF9mb2N1c2VkO1xuXG4gIGlmIChkaXNhYmxlZCAmJiBmb2N1c2VkKSB7XG4gICAgc2V0Rm9jdXNlZChmYWxzZSk7XG4gIH1cblxuICB2YXIgcmVnaXN0ZXJFZmZlY3Q7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB2YXIgcmVnaXN0ZXJlZElucHV0ID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcblxuICAgIHJlZ2lzdGVyRWZmZWN0ID0gZnVuY3Rpb24gcmVnaXN0ZXJFZmZlY3QoKSB7XG4gICAgICBpZiAocmVnaXN0ZXJlZElucHV0LmN1cnJlbnQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihbJ01hdGVyaWFsLVVJOiBUaGVyZSBhcmUgbXVsdGlwbGUgSW5wdXRCYXNlIGNvbXBvbmVudHMgaW5zaWRlIGEgRm9ybUNvbnRyb2wuJywgJ1RoaXMgaXMgbm90IHN1cHBvcnRlZC4gSXQgbWlnaHQgY2F1c2UgaW5maW5pdGUgcmVuZGVyaW5nIGxvb3BzLicsICdPbmx5IHVzZSBvbmUgSW5wdXRCYXNlLiddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cblxuICAgICAgcmVnaXN0ZXJlZElucHV0LmN1cnJlbnQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVnaXN0ZXJlZElucHV0LmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHZhciBvbkZpbGxlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzZXRGaWxsZWQodHJ1ZSk7XG4gIH0sIFtdKTtcbiAgdmFyIG9uRW1wdHkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgc2V0RmlsbGVkKGZhbHNlKTtcbiAgfSwgW10pO1xuICB2YXIgY2hpbGRDb250ZXh0ID0ge1xuICAgIGFkb3JuZWRTdGFydDogYWRvcm5lZFN0YXJ0LFxuICAgIHNldEFkb3JuZWRTdGFydDogc2V0QWRvcm5lZFN0YXJ0LFxuICAgIGNvbG9yOiBjb2xvcixcbiAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgZXJyb3I6IGVycm9yLFxuICAgIGZpbGxlZDogZmlsbGVkLFxuICAgIGZvY3VzZWQ6IGZvY3VzZWQsXG4gICAgZnVsbFdpZHRoOiBmdWxsV2lkdGgsXG4gICAgaGlkZGVuTGFiZWw6IGhpZGRlbkxhYmVsLFxuICAgIG1hcmdpbjogKHNpemUgPT09ICdzbWFsbCcgPyAnZGVuc2UnIDogdW5kZWZpbmVkKSB8fCBtYXJnaW4sXG4gICAgb25CbHVyOiBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBzZXRGb2N1c2VkKGZhbHNlKTtcbiAgICB9LFxuICAgIG9uRW1wdHk6IG9uRW1wdHksXG4gICAgb25GaWxsZWQ6IG9uRmlsbGVkLFxuICAgIG9uRm9jdXM6IGZ1bmN0aW9uIG9uRm9jdXMoKSB7XG4gICAgICBzZXRGb2N1c2VkKHRydWUpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJFZmZlY3Q6IHJlZ2lzdGVyRWZmZWN0LFxuICAgIHJlcXVpcmVkOiByZXF1aXJlZCxcbiAgICB2YXJpYW50OiB2YXJpYW50XG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtQ29udHJvbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY2hpbGRDb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSwgbWFyZ2luICE9PSAnbm9uZScgJiYgY2xhc3Nlc1tcIm1hcmdpblwiLmNvbmNhdChjYXBpdGFsaXplKG1hcmdpbikpXSwgZnVsbFdpZHRoICYmIGNsYXNzZXMuZnVsbFdpZHRoKSxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlciksIGNoaWxkcmVuKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IEZvcm1Db250cm9sLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgZm9ybSBjb250cm9sLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIHRob3NlIHRoZW1lIGNvbG9ycyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbGFiZWwsIGlucHV0IGFuZCBoZWxwZXIgdGV4dCBzaG91bGQgYmUgZGlzcGxheWVkIGluIGEgZGlzYWJsZWQgc3RhdGUuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxhYmVsIHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gYW4gZXJyb3Igc3RhdGUuXG4gICAqL1xuICBlcnJvcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNvbXBvbmVudCB3aWxsIGJlIGRpc3BsYXllZCBpbiBmb2N1c2VkIHN0YXRlLlxuICAgKi9cbiAgZm9jdXNlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNvbXBvbmVudCB3aWxsIHRha2UgdXAgdGhlIGZ1bGwgd2lkdGggb2YgaXRzIGNvbnRhaW5lci5cbiAgICovXG4gIGZ1bGxXaWR0aDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxhYmVsIHdpbGwgYmUgaGlkZGVuLlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gaW5jcmVhc2UgZGVuc2l0eSBmb3IgYSBgRmlsbGVkSW5wdXRgLlxuICAgKiBCZSBzdXJlIHRvIGFkZCBgYXJpYS1sYWJlbGAgdG8gdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGhpZGRlbkxhYmVsOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYGRlbnNlYCBvciBgbm9ybWFsYCwgd2lsbCBhZGp1c3QgdmVydGljYWwgc3BhY2luZyBvZiB0aGlzIGFuZCBjb250YWluZWQgY29tcG9uZW50cy5cbiAgICovXG4gIG1hcmdpbjogUHJvcFR5cGVzLm9uZU9mKFsnZGVuc2UnLCAnbm9uZScsICdub3JtYWwnXSksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxhYmVsIHdpbGwgaW5kaWNhdGUgdGhhdCB0aGUgaW5wdXQgaXMgcmVxdWlyZWQuXG4gICAqL1xuICByZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSB0ZXh0IGZpZWxkLlxuICAgKi9cbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnbWVkaXVtJywgJ3NtYWxsJ10pLFxuXG4gIC8qKlxuICAgKiBUaGUgdmFyaWFudCB0byB1c2UuXG4gICAqL1xuICB2YXJpYW50OiBQcm9wVHlwZXMub25lT2YoWydmaWxsZWQnLCAnb3V0bGluZWQnLCAnc3RhbmRhcmQnXSlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpRm9ybUNvbnRyb2wnXG59KShGb3JtQ29udHJvbCk7IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IGZvcm1Db250cm9sU3RhdGUgZnJvbSAnLi4vRm9ybUNvbnRyb2wvZm9ybUNvbnRyb2xTdGF0ZSc7XG5pbXBvcnQgdXNlRm9ybUNvbnRyb2wgZnJvbSAnLi4vRm9ybUNvbnRyb2wvdXNlRm9ybUNvbnRyb2wnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IF9leHRlbmRzKHtcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnRleHQuc2Vjb25kYXJ5XG4gICAgfSwgdGhlbWUudHlwb2dyYXBoeS5jYXB0aW9uLCB7XG4gICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAgIG1hcmdpblRvcDogMyxcbiAgICAgIG1hcmdpbjogMCxcbiAgICAgICcmJGRpc2FibGVkJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS50ZXh0LmRpc2FibGVkXG4gICAgICB9LFxuICAgICAgJyYkZXJyb3InOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmVycm9yLm1haW5cbiAgICAgIH1cbiAgICB9KSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGVycm9yPXt0cnVlfWAuICovXG4gICAgZXJyb3I6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZGlzYWJsZWQ9e3RydWV9YC4gKi9cbiAgICBkaXNhYmxlZDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBtYXJnaW49XCJkZW5zZVwiYC4gKi9cbiAgICBtYXJnaW5EZW5zZToge1xuICAgICAgbWFyZ2luVG9wOiA0XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHZhcmlhbnQ9XCJmaWxsZWRcImAgb3IgYHZhcmlhbnQ9XCJvdXRsaW5lZFwiYC4gKi9cbiAgICBjb250YWluZWQ6IHtcbiAgICAgIG1hcmdpbkxlZnQ6IDE0LFxuICAgICAgbWFyZ2luUmlnaHQ6IDE0XG4gICAgfSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGZvY3VzZWQ9e3RydWV9YC4gKi9cbiAgICBmb2N1c2VkOiB7fSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGZpbGxlZD17dHJ1ZX1gLiAqL1xuICAgIGZpbGxlZDoge30sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGByZXF1aXJlZD17dHJ1ZX1gLiAqL1xuICAgIHJlcXVpcmVkOiB7fVxuICB9O1xufTtcbnZhciBGb3JtSGVscGVyVGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZvcm1IZWxwZXJUZXh0KHByb3BzLCByZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRjb21wb25lbnQgPSBwcm9wcy5jb21wb25lbnQsXG4gICAgICBDb21wb25lbnQgPSBfcHJvcHMkY29tcG9uZW50ID09PSB2b2lkIDAgPyAncCcgOiBfcHJvcHMkY29tcG9uZW50LFxuICAgICAgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGVycm9yID0gcHJvcHMuZXJyb3IsXG4gICAgICBmaWxsZWQgPSBwcm9wcy5maWxsZWQsXG4gICAgICBmb2N1c2VkID0gcHJvcHMuZm9jdXNlZCxcbiAgICAgIG1hcmdpbiA9IHByb3BzLm1hcmdpbixcbiAgICAgIHJlcXVpcmVkID0gcHJvcHMucmVxdWlyZWQsXG4gICAgICB2YXJpYW50ID0gcHJvcHMudmFyaWFudCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjb21wb25lbnRcIiwgXCJkaXNhYmxlZFwiLCBcImVycm9yXCIsIFwiZmlsbGVkXCIsIFwiZm9jdXNlZFwiLCBcIm1hcmdpblwiLCBcInJlcXVpcmVkXCIsIFwidmFyaWFudFwiXSk7XG5cbiAgdmFyIG11aUZvcm1Db250cm9sID0gdXNlRm9ybUNvbnRyb2woKTtcbiAgdmFyIGZjcyA9IGZvcm1Db250cm9sU3RhdGUoe1xuICAgIHByb3BzOiBwcm9wcyxcbiAgICBtdWlGb3JtQ29udHJvbDogbXVpRm9ybUNvbnRyb2wsXG4gICAgc3RhdGVzOiBbJ3ZhcmlhbnQnLCAnbWFyZ2luJywgJ2Rpc2FibGVkJywgJ2Vycm9yJywgJ2ZpbGxlZCcsICdmb2N1c2VkJywgJ3JlcXVpcmVkJ11cbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCAoZmNzLnZhcmlhbnQgPT09ICdmaWxsZWQnIHx8IGZjcy52YXJpYW50ID09PSAnb3V0bGluZWQnKSAmJiBjbGFzc2VzLmNvbnRhaW5lZCwgY2xhc3NOYW1lLCBmY3MuZGlzYWJsZWQgJiYgY2xhc3Nlcy5kaXNhYmxlZCwgZmNzLmVycm9yICYmIGNsYXNzZXMuZXJyb3IsIGZjcy5maWxsZWQgJiYgY2xhc3Nlcy5maWxsZWQsIGZjcy5mb2N1c2VkICYmIGNsYXNzZXMuZm9jdXNlZCwgZmNzLnJlcXVpcmVkICYmIGNsYXNzZXMucmVxdWlyZWQsIGZjcy5tYXJnaW4gPT09ICdkZW5zZScgJiYgY2xhc3Nlcy5tYXJnaW5EZW5zZSksXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpLCBjaGlsZHJlbiA9PT0gJyAnID9cbiAgLyojX19QVVJFX18qL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZGFuZ2VyXG4gIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgX19odG1sOiAnJiM4MjAzOydcbiAgICB9XG4gIH0pIDogY2hpbGRyZW4pO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBGb3JtSGVscGVyVGV4dC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBJZiBgJyAnYCBpcyBwcm92aWRlZCwgdGhlIGNvbXBvbmVudCByZXNlcnZlcyBvbmUgbGluZSBoZWlnaHQgZm9yIGRpc3BsYXlpbmcgYSBmdXR1cmUgbWVzc2FnZS5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBoZWxwZXIgdGV4dCBzaG91bGQgYmUgZGlzcGxheWVkIGluIGEgZGlzYWJsZWQgc3RhdGUuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgaGVscGVyIHRleHQgc2hvdWxkIGJlIGRpc3BsYXllZCBpbiBhbiBlcnJvciBzdGF0ZS5cbiAgICovXG4gIGVycm9yOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgaGVscGVyIHRleHQgc2hvdWxkIHVzZSBmaWxsZWQgY2xhc3NlcyBrZXkuXG4gICAqL1xuICBmaWxsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBoZWxwZXIgdGV4dCBzaG91bGQgdXNlIGZvY3VzZWQgY2xhc3NlcyBrZXkuXG4gICAqL1xuICBmb2N1c2VkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYGRlbnNlYCwgd2lsbCBhZGp1c3QgdmVydGljYWwgc3BhY2luZy4gVGhpcyBpcyBub3JtYWxseSBvYnRhaW5lZCB2aWEgY29udGV4dCBmcm9tXG4gICAqIEZvcm1Db250cm9sLlxuICAgKi9cbiAgbWFyZ2luOiBQcm9wVHlwZXMub25lT2YoWydkZW5zZSddKSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgaGVscGVyIHRleHQgc2hvdWxkIHVzZSByZXF1aXJlZCBjbGFzc2VzIGtleS5cbiAgICovXG4gIHJlcXVpcmVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIHZhcmlhbnQgdG8gdXNlLlxuICAgKi9cbiAgdmFyaWFudDogUHJvcFR5cGVzLm9uZU9mKFsnZmlsbGVkJywgJ291dGxpbmVkJywgJ3N0YW5kYXJkJ10pXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUZvcm1IZWxwZXJUZXh0J1xufSkoRm9ybUhlbHBlclRleHQpOyIsIi8vIEEgY2hhbmdlIG9mIHRoZSBicm93c2VyIHpvb20gY2hhbmdlIHRoZSBzY3JvbGxiYXIgc2l6ZS5cbi8vIENyZWRpdCBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi8zZmZlM2E1ZDgyZjZmNTYxYjgyZmY3OGQ4MmIzMmE3ZDE0YWVkNTU4L2pzL3NyYy9tb2RhbC5qcyNMNTEyLUw1MTlcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNjcm9sbGJhclNpemUoKSB7XG4gIHZhciBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgc2Nyb2xsRGl2LnN0eWxlLndpZHRoID0gJzk5cHgnO1xuICBzY3JvbGxEaXYuc3R5bGUuaGVpZ2h0ID0gJzk5cHgnO1xuICBzY3JvbGxEaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBzY3JvbGxEaXYuc3R5bGUudG9wID0gJy05OTk5cHgnO1xuICBzY3JvbGxEaXYuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpO1xuICB2YXIgc2Nyb2xsYmFyU2l6ZSA9IHNjcm9sbERpdi5vZmZzZXRXaWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aDtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpO1xuICByZXR1cm4gc2Nyb2xsYmFyU2l6ZTtcbn0iLCJpbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5XCI7XG5pbXBvcnQgZ2V0U2Nyb2xsYmFyU2l6ZSBmcm9tICcuLi91dGlscy9nZXRTY3JvbGxiYXJTaXplJztcbmltcG9ydCBvd25lckRvY3VtZW50IGZyb20gJy4uL3V0aWxzL293bmVyRG9jdW1lbnQnO1xuaW1wb3J0IG93bmVyV2luZG93IGZyb20gJy4uL3V0aWxzL293bmVyV2luZG93JzsgLy8gSXMgYSB2ZXJ0aWNhbCBzY3JvbGxiYXIgZGlzcGxheWVkP1xuXG5mdW5jdGlvbiBpc092ZXJmbG93aW5nKGNvbnRhaW5lcikge1xuICB2YXIgZG9jID0gb3duZXJEb2N1bWVudChjb250YWluZXIpO1xuXG4gIGlmIChkb2MuYm9keSA9PT0gY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG93bmVyV2luZG93KGRvYykuaW5uZXJXaWR0aCA+IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyLnNjcm9sbEhlaWdodCA+IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcmlhSGlkZGVuKG5vZGUsIHNob3cpIHtcbiAgaWYgKHNob3cpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBhZGRpbmdSaWdodChub2RlKSB7XG4gIHJldHVybiBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKVsncGFkZGluZy1yaWdodCddLCAxMCkgfHwgMDtcbn1cblxuZnVuY3Rpb24gYXJpYUhpZGRlblNpYmxpbmdzKGNvbnRhaW5lciwgbW91bnROb2RlLCBjdXJyZW50Tm9kZSkge1xuICB2YXIgbm9kZXNUb0V4Y2x1ZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFtdO1xuICB2YXIgc2hvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuICB2YXIgYmxhY2tsaXN0ID0gW21vdW50Tm9kZSwgY3VycmVudE5vZGVdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobm9kZXNUb0V4Y2x1ZGUpKTtcbiAgdmFyIGJsYWNrbGlzdFRhZ05hbWVzID0gWydURU1QTEFURScsICdTQ1JJUFQnLCAnU1RZTEUnXTtcbiAgW10uZm9yRWFjaC5jYWxsKGNvbnRhaW5lci5jaGlsZHJlbiwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBibGFja2xpc3QuaW5kZXhPZihub2RlKSA9PT0gLTEgJiYgYmxhY2tsaXN0VGFnTmFtZXMuaW5kZXhPZihub2RlLnRhZ05hbWUpID09PSAtMSkge1xuICAgICAgYXJpYUhpZGRlbihub2RlLCBzaG93KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmaW5kSW5kZXhPZihjb250YWluZXJJbmZvLCBjYWxsYmFjaykge1xuICB2YXIgaWR4ID0gLTE7XG4gIGNvbnRhaW5lckluZm8uc29tZShmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICBpZiAoY2FsbGJhY2soaXRlbSkpIHtcbiAgICAgIGlkeCA9IGluZGV4O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbiAgcmV0dXJuIGlkeDtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQ29udGFpbmVyKGNvbnRhaW5lckluZm8sIHByb3BzKSB7XG4gIHZhciByZXN0b3JlU3R5bGUgPSBbXTtcbiAgdmFyIHJlc3RvcmVQYWRkaW5ncyA9IFtdO1xuICB2YXIgY29udGFpbmVyID0gY29udGFpbmVySW5mby5jb250YWluZXI7XG4gIHZhciBmaXhlZE5vZGVzO1xuXG4gIGlmICghcHJvcHMuZGlzYWJsZVNjcm9sbExvY2spIHtcbiAgICBpZiAoaXNPdmVyZmxvd2luZyhjb250YWluZXIpKSB7XG4gICAgICAvLyBDb21wdXRlIHRoZSBzaXplIGJlZm9yZSBhcHBseWluZyBvdmVyZmxvdyBoaWRkZW4gdG8gYXZvaWQgYW55IHNjcm9sbCBqdW1wcy5cbiAgICAgIHZhciBzY3JvbGxiYXJTaXplID0gZ2V0U2Nyb2xsYmFyU2l6ZSgpO1xuICAgICAgcmVzdG9yZVN0eWxlLnB1c2goe1xuICAgICAgICB2YWx1ZTogY29udGFpbmVyLnN0eWxlLnBhZGRpbmdSaWdodCxcbiAgICAgICAga2V5OiAncGFkZGluZy1yaWdodCcsXG4gICAgICAgIGVsOiBjb250YWluZXJcbiAgICAgIH0pOyAvLyBVc2UgY29tcHV0ZWQgc3R5bGUsIGhlcmUgdG8gZ2V0IHRoZSByZWFsIHBhZGRpbmcgdG8gYWRkIG91ciBzY3JvbGxiYXIgd2lkdGguXG5cbiAgICAgIGNvbnRhaW5lci5zdHlsZVsncGFkZGluZy1yaWdodCddID0gXCJcIi5jb25jYXQoZ2V0UGFkZGluZ1JpZ2h0KGNvbnRhaW5lcikgKyBzY3JvbGxiYXJTaXplLCBcInB4XCIpOyAvLyAubXVpLWZpeGVkIGlzIGEgZ2xvYmFsIGhlbHBlci5cblxuICAgICAgZml4ZWROb2RlcyA9IG93bmVyRG9jdW1lbnQoY29udGFpbmVyKS5xdWVyeVNlbGVjdG9yQWxsKCcubXVpLWZpeGVkJyk7XG4gICAgICBbXS5mb3JFYWNoLmNhbGwoZml4ZWROb2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmVzdG9yZVBhZGRpbmdzLnB1c2gobm9kZS5zdHlsZS5wYWRkaW5nUmlnaHQpO1xuICAgICAgICBub2RlLnN0eWxlLnBhZGRpbmdSaWdodCA9IFwiXCIuY29uY2F0KGdldFBhZGRpbmdSaWdodChub2RlKSArIHNjcm9sbGJhclNpemUsIFwicHhcIik7XG4gICAgICB9KTtcbiAgICB9IC8vIEltcHJvdmUgR2F0c2J5IHN1cHBvcnRcbiAgICAvLyBodHRwczovL2Nzcy10cmlja3MuY29tL3NuaXBwZXRzL2Nzcy9mb3JjZS12ZXJ0aWNhbC1zY3JvbGxiYXIvXG5cblxuICAgIHZhciBwYXJlbnQgPSBjb250YWluZXIucGFyZW50RWxlbWVudDtcbiAgICB2YXIgc2Nyb2xsQ29udGFpbmVyID0gcGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50KVsnb3ZlcmZsb3cteSddID09PSAnc2Nyb2xsJyA/IHBhcmVudCA6IGNvbnRhaW5lcjsgLy8gQmxvY2sgdGhlIHNjcm9sbCBldmVuIGlmIG5vIHNjcm9sbGJhciBpcyB2aXNpYmxlIHRvIGFjY291bnQgZm9yIG1vYmlsZSBrZXlib2FyZFxuICAgIC8vIHNjcmVlbnNpemUgc2hyaW5rLlxuXG4gICAgcmVzdG9yZVN0eWxlLnB1c2goe1xuICAgICAgdmFsdWU6IHNjcm9sbENvbnRhaW5lci5zdHlsZS5vdmVyZmxvdyxcbiAgICAgIGtleTogJ292ZXJmbG93JyxcbiAgICAgIGVsOiBzY3JvbGxDb250YWluZXJcbiAgICB9KTtcbiAgICBzY3JvbGxDb250YWluZXIuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgfVxuXG4gIHZhciByZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZSgpIHtcbiAgICBpZiAoZml4ZWROb2Rlcykge1xuICAgICAgW10uZm9yRWFjaC5jYWxsKGZpeGVkTm9kZXMsIGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgICAgIGlmIChyZXN0b3JlUGFkZGluZ3NbaV0pIHtcbiAgICAgICAgICBub2RlLnN0eWxlLnBhZGRpbmdSaWdodCA9IHJlc3RvcmVQYWRkaW5nc1tpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdwYWRkaW5nLXJpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlc3RvcmVTdHlsZS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlLFxuICAgICAgICAgIGVsID0gX3JlZi5lbCxcbiAgICAgICAgICBrZXkgPSBfcmVmLmtleTtcblxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gcmVzdG9yZTtcbn1cblxuZnVuY3Rpb24gZ2V0SGlkZGVuU2libGluZ3MoY29udGFpbmVyKSB7XG4gIHZhciBoaWRkZW5TaWJsaW5ncyA9IFtdO1xuICBbXS5mb3JFYWNoLmNhbGwoY29udGFpbmVyLmNoaWxkcmVuLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSA9PT0gJ3RydWUnKSB7XG4gICAgICBoaWRkZW5TaWJsaW5ncy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBoaWRkZW5TaWJsaW5ncztcbn1cbi8qKlxuICogQGlnbm9yZSAtIGRvIG5vdCBkb2N1bWVudC5cbiAqXG4gKiBQcm9wZXIgc3RhdGUgbWFuYWdlbWVudCBmb3IgY29udGFpbmVycyBhbmQgdGhlIG1vZGFscyBpbiB0aG9zZSBjb250YWluZXJzLlxuICogU2ltcGxpZmllZCwgYnV0IGluc3BpcmVkIGJ5IHJlYWN0LW92ZXJsYXkncyBNb2RhbE1hbmFnZXIgY2xhc3MuXG4gKiBVc2VkIGJ5IHRoZSBNb2RhbCB0byBlbnN1cmUgcHJvcGVyIHN0eWxpbmcgb2YgY29udGFpbmVycy5cbiAqL1xuXG5cbnZhciBNb2RhbE1hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNb2RhbE1hbmFnZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZGFsTWFuYWdlcik7XG5cbiAgICAvLyB0aGlzLm1vZGFsc1ttb2RhbEluZGV4XSA9IG1vZGFsXG4gICAgdGhpcy5tb2RhbHMgPSBbXTsgLy8gdGhpcy5jb250YWluZXJzW2NvbnRhaW5lckluZGV4XSA9IHtcbiAgICAvLyAgIG1vZGFsczogW10sXG4gICAgLy8gICBjb250YWluZXIsXG4gICAgLy8gICByZXN0b3JlOiBudWxsLFxuICAgIC8vIH1cblxuICAgIHRoaXMuY29udGFpbmVycyA9IFtdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1vZGFsTWFuYWdlciwgW3tcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChtb2RhbCwgY29udGFpbmVyKSB7XG4gICAgICB2YXIgbW9kYWxJbmRleCA9IHRoaXMubW9kYWxzLmluZGV4T2YobW9kYWwpO1xuXG4gICAgICBpZiAobW9kYWxJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIG1vZGFsSW5kZXg7XG4gICAgICB9XG5cbiAgICAgIG1vZGFsSW5kZXggPSB0aGlzLm1vZGFscy5sZW5ndGg7XG4gICAgICB0aGlzLm1vZGFscy5wdXNoKG1vZGFsKTsgLy8gSWYgdGhlIG1vZGFsIHdlIGFyZSBhZGRpbmcgaXMgYWxyZWFkeSBpbiB0aGUgRE9NLlxuXG4gICAgICBpZiAobW9kYWwubW9kYWxSZWYpIHtcbiAgICAgICAgYXJpYUhpZGRlbihtb2RhbC5tb2RhbFJlZiwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGlkZGVuU2libGluZ05vZGVzID0gZ2V0SGlkZGVuU2libGluZ3MoY29udGFpbmVyKTtcbiAgICAgIGFyaWFIaWRkZW5TaWJsaW5ncyhjb250YWluZXIsIG1vZGFsLm1vdW50Tm9kZSwgbW9kYWwubW9kYWxSZWYsIGhpZGRlblNpYmxpbmdOb2RlcywgdHJ1ZSk7XG4gICAgICB2YXIgY29udGFpbmVySW5kZXggPSBmaW5kSW5kZXhPZih0aGlzLmNvbnRhaW5lcnMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmNvbnRhaW5lciA9PT0gY29udGFpbmVyO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChjb250YWluZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXJzW2NvbnRhaW5lckluZGV4XS5tb2RhbHMucHVzaChtb2RhbCk7XG4gICAgICAgIHJldHVybiBtb2RhbEluZGV4O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRhaW5lcnMucHVzaCh7XG4gICAgICAgIG1vZGFsczogW21vZGFsXSxcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIHJlc3RvcmU6IG51bGwsXG4gICAgICAgIGhpZGRlblNpYmxpbmdOb2RlczogaGlkZGVuU2libGluZ05vZGVzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtb2RhbEluZGV4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3VudChtb2RhbCwgcHJvcHMpIHtcbiAgICAgIHZhciBjb250YWluZXJJbmRleCA9IGZpbmRJbmRleE9mKHRoaXMuY29udGFpbmVycywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubW9kYWxzLmluZGV4T2YobW9kYWwpICE9PSAtMTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSB0aGlzLmNvbnRhaW5lcnNbY29udGFpbmVySW5kZXhdO1xuXG4gICAgICBpZiAoIWNvbnRhaW5lckluZm8ucmVzdG9yZSkge1xuICAgICAgICBjb250YWluZXJJbmZvLnJlc3RvcmUgPSBoYW5kbGVDb250YWluZXIoY29udGFpbmVySW5mbywgcHJvcHMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKG1vZGFsKSB7XG4gICAgICB2YXIgbW9kYWxJbmRleCA9IHRoaXMubW9kYWxzLmluZGV4T2YobW9kYWwpO1xuXG4gICAgICBpZiAobW9kYWxJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIG1vZGFsSW5kZXg7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250YWluZXJJbmRleCA9IGZpbmRJbmRleE9mKHRoaXMuY29udGFpbmVycywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubW9kYWxzLmluZGV4T2YobW9kYWwpICE9PSAtMTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSB0aGlzLmNvbnRhaW5lcnNbY29udGFpbmVySW5kZXhdO1xuICAgICAgY29udGFpbmVySW5mby5tb2RhbHMuc3BsaWNlKGNvbnRhaW5lckluZm8ubW9kYWxzLmluZGV4T2YobW9kYWwpLCAxKTtcbiAgICAgIHRoaXMubW9kYWxzLnNwbGljZShtb2RhbEluZGV4LCAxKTsgLy8gSWYgdGhhdCB3YXMgdGhlIGxhc3QgbW9kYWwgaW4gYSBjb250YWluZXIsIGNsZWFuIHVwIHRoZSBjb250YWluZXIuXG5cbiAgICAgIGlmIChjb250YWluZXJJbmZvLm1vZGFscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gVGhlIG1vZGFsIG1pZ2h0IGJlIGNsb3NlZCBiZWZvcmUgaXQgaGFkIHRoZSBjaGFuY2UgdG8gYmUgbW91bnRlZCBpbiB0aGUgRE9NLlxuICAgICAgICBpZiAoY29udGFpbmVySW5mby5yZXN0b3JlKSB7XG4gICAgICAgICAgY29udGFpbmVySW5mby5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9kYWwubW9kYWxSZWYpIHtcbiAgICAgICAgICAvLyBJbiBjYXNlIHRoZSBtb2RhbCB3YXNuJ3QgaW4gdGhlIERPTSB5ZXQuXG4gICAgICAgICAgYXJpYUhpZGRlbihtb2RhbC5tb2RhbFJlZiwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmlhSGlkZGVuU2libGluZ3MoY29udGFpbmVySW5mby5jb250YWluZXIsIG1vZGFsLm1vdW50Tm9kZSwgbW9kYWwubW9kYWxSZWYsIGNvbnRhaW5lckluZm8uaGlkZGVuU2libGluZ05vZGVzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY29udGFpbmVycy5zcGxpY2UoY29udGFpbmVySW5kZXgsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIG1ha2Ugc3VyZSB0aGUgbmV4dCB0b3AgbW9kYWwgaXMgdmlzaWJsZSB0byBhIHNjcmVlbiByZWFkZXIuXG4gICAgICAgIHZhciBuZXh0VG9wID0gY29udGFpbmVySW5mby5tb2RhbHNbY29udGFpbmVySW5mby5tb2RhbHMubGVuZ3RoIC0gMV07IC8vIGFzIHNvb24gYXMgYSBtb2RhbCBpcyBhZGRpbmcgaXRzIG1vZGFsUmVmIGlzIHVuZGVmaW5lZC4gaXQgY2FuJ3Qgc2V0XG4gICAgICAgIC8vIGFyaWEtaGlkZGVuIGJlY2F1c2UgdGhlIGRvbSBlbGVtZW50IGRvZXNuJ3QgZXhpc3QgZWl0aGVyXG4gICAgICAgIC8vIHdoZW4gbW9kYWwgd2FzIHVubW91bnRlZCBiZWZvcmUgbW9kYWxSZWYgZ2V0cyBudWxsXG5cbiAgICAgICAgaWYgKG5leHRUb3AubW9kYWxSZWYpIHtcbiAgICAgICAgICBhcmlhSGlkZGVuKG5leHRUb3AubW9kYWxSZWYsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW9kYWxJbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNUb3BNb2RhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1RvcE1vZGFsKG1vZGFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2RhbHMubGVuZ3RoID4gMCAmJiB0aGlzLm1vZGFsc1t0aGlzLm1vZGFscy5sZW5ndGggLSAxXSA9PT0gbW9kYWw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1vZGFsTWFuYWdlcjtcbn0oKTtcblxuZXhwb3J0IHsgTW9kYWxNYW5hZ2VyIGFzIGRlZmF1bHQgfTsiLCIvKiBlc2xpbnQtZGlzYWJsZSBjb25zaXN0ZW50LXJldHVybiwganN4LWExMXkvbm8tbm9uaW50ZXJhY3RpdmUtdGFiaW5kZXgsIGNhbWVsY2FzZSAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgb3duZXJEb2N1bWVudCBmcm9tICcuLi91dGlscy9vd25lckRvY3VtZW50JztcbmltcG9ydCB1c2VGb3JrUmVmIGZyb20gJy4uL3V0aWxzL3VzZUZvcmtSZWYnO1xuaW1wb3J0IHsgZXhhY3RQcm9wIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbi8qKlxuICogVXRpbGl0eSBjb21wb25lbnQgdGhhdCBsb2NrcyBmb2N1cyBpbnNpZGUgdGhlIGNvbXBvbmVudC5cbiAqL1xuXG5mdW5jdGlvbiBVbnN0YWJsZV9UcmFwRm9jdXMocHJvcHMpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBfcHJvcHMkZGlzYWJsZUF1dG9Gb2MgPSBwcm9wcy5kaXNhYmxlQXV0b0ZvY3VzLFxuICAgICAgZGlzYWJsZUF1dG9Gb2N1cyA9IF9wcm9wcyRkaXNhYmxlQXV0b0ZvYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZUF1dG9Gb2MsXG4gICAgICBfcHJvcHMkZGlzYWJsZUVuZm9yY2UgPSBwcm9wcy5kaXNhYmxlRW5mb3JjZUZvY3VzLFxuICAgICAgZGlzYWJsZUVuZm9yY2VGb2N1cyA9IF9wcm9wcyRkaXNhYmxlRW5mb3JjZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZUVuZm9yY2UsXG4gICAgICBfcHJvcHMkZGlzYWJsZVJlc3RvcmUgPSBwcm9wcy5kaXNhYmxlUmVzdG9yZUZvY3VzLFxuICAgICAgZGlzYWJsZVJlc3RvcmVGb2N1cyA9IF9wcm9wcyRkaXNhYmxlUmVzdG9yZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZVJlc3RvcmUsXG4gICAgICBnZXREb2MgPSBwcm9wcy5nZXREb2MsXG4gICAgICBpc0VuYWJsZWQgPSBwcm9wcy5pc0VuYWJsZWQsXG4gICAgICBvcGVuID0gcHJvcHMub3BlbjtcbiAgdmFyIGlnbm9yZU5leHRFbmZvcmNlRm9jdXMgPSBSZWFjdC51c2VSZWYoKTtcbiAgdmFyIHNlbnRpbmVsU3RhcnQgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBzZW50aW5lbEVuZCA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIG5vZGVUb1Jlc3RvcmUgPSBSZWFjdC51c2VSZWYoKTtcbiAgdmFyIHJvb3RSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7IC8vIGNhbiBiZSByZW1vdmVkIG9uY2Ugd2UgZHJvcCBzdXBwb3J0IGZvciBub24gcmVmIGZvcndhcmRpbmcgY2xhc3MgY29tcG9uZW50c1xuXG4gIHZhciBoYW5kbGVPd25SZWYgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAvLyAjU3RyaWN0TW9kZSByZWFkeVxuICAgIHJvb3RSZWYuY3VycmVudCA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKGluc3RhbmNlKTtcbiAgfSwgW10pO1xuICB2YXIgaGFuZGxlUmVmID0gdXNlRm9ya1JlZihjaGlsZHJlbi5yZWYsIGhhbmRsZU93blJlZik7XG4gIHZhciBwcmV2T3BlblJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHByZXZPcGVuUmVmLmN1cnJlbnQgPSBvcGVuO1xuICB9LCBbb3Blbl0pO1xuXG4gIGlmICghcHJldk9wZW5SZWYuY3VycmVudCAmJiBvcGVuICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gV0FSTklORzogUG90ZW50aWFsbHkgdW5zYWZlIGluIGNvbmN1cnJlbnQgbW9kZS5cbiAgICAvLyBUaGUgd2F5IHRoZSByZWFkIG9uIGBub2RlVG9SZXN0b3JlYCBpcyBzZXR1cCBjb3VsZCBtYWtlIHRoaXMgYWN0dWFsbHkgc2FmZS5cbiAgICAvLyBTYXkgd2UgcmVuZGVyIGBvcGVuPXtmYWxzZX1gIC0+IGBvcGVuPXt0cnVlfWAgYnV0IG5ldmVyIGNvbW1pdC5cbiAgICAvLyBXZSBoYXZlIG5vdyB3cml0dGVuIGEgc3RhdGUgdGhhdCB3YXNuJ3QgY29tbWl0dGVkLiBCdXQgbm8gY29tbWl0dGVkIGVmZmVjdFxuICAgIC8vIHdpbGwgcmVhZCB0aGlzIHdyb25nIHZhbHVlLiBXZSBvbmx5IHJlYWQgZnJvbSBgbm9kZVRvUmVzdG9yZWAgaW4gZWZmZWN0c1xuICAgIC8vIHRoYXQgd2VyZSBjb21taXR0ZWQgb24gYG9wZW49e3RydWV9YFxuICAgIC8vIFdBUk5JTkc6IFByZXZlbnRzIHRoZSBpbnN0YW5jZSBmcm9tIGJlaW5nIGdhcmJhZ2UgY29sbGVjdGVkLiBTaG91bGQgb25seVxuICAgIC8vIGhvbGQgYSB3ZWFrIHJlZi5cbiAgICBub2RlVG9SZXN0b3JlLmN1cnJlbnQgPSBnZXREb2MoKS5hY3RpdmVFbGVtZW50O1xuICB9XG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZG9jID0gb3duZXJEb2N1bWVudChyb290UmVmLmN1cnJlbnQpOyAvLyBXZSBtaWdodCByZW5kZXIgYW4gZW1wdHkgY2hpbGQuXG5cbiAgICBpZiAoIWRpc2FibGVBdXRvRm9jdXMgJiYgcm9vdFJlZi5jdXJyZW50ICYmICFyb290UmVmLmN1cnJlbnQuY29udGFpbnMoZG9jLmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICBpZiAoIXJvb3RSZWYuY3VycmVudC5oYXNBdHRyaWJ1dGUoJ3RhYkluZGV4JykpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFsnTWF0ZXJpYWwtVUk6IFRoZSBtb2RhbCBjb250ZW50IG5vZGUgZG9lcyBub3QgYWNjZXB0IGZvY3VzLicsICdGb3IgdGhlIGJlbmVmaXQgb2YgYXNzaXN0aXZlIHRlY2hub2xvZ2llcywgJyArICd0aGUgdGFiSW5kZXggb2YgdGhlIG5vZGUgaXMgYmVpbmcgc2V0IHRvIFwiLTFcIi4nXS5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cblxuICAgICAgICByb290UmVmLmN1cnJlbnQuc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsIC0xKTtcbiAgICAgIH1cblxuICAgICAgcm9vdFJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRhaW4gPSBmdW5jdGlvbiBjb250YWluKCkge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gcm9vdFJlZi5jdXJyZW50OyAvLyBDbGVhbnVwIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWQgbGF6aWx5IGluIFJlYWN0IDE3LlxuICAgICAgLy8gQ29udGFpbiBjYW4gYmUgY2FsbGVkIGJldHdlZW4gdGhlIGNvbXBvbmVudCBiZWluZyB1bm1vdW50ZWQgYW5kIGl0cyBjbGVhbnVwIGZ1bmN0aW9uIGJlaW5nIHJ1bi5cblxuICAgICAgaWYgKHJvb3RFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkb2MuaGFzRm9jdXMoKSB8fCBkaXNhYmxlRW5mb3JjZUZvY3VzIHx8ICFpc0VuYWJsZWQoKSB8fCBpZ25vcmVOZXh0RW5mb3JjZUZvY3VzLmN1cnJlbnQpIHtcbiAgICAgICAgaWdub3JlTmV4dEVuZm9yY2VGb2N1cy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvb3RSZWYuY3VycmVudCAmJiAhcm9vdFJlZi5jdXJyZW50LmNvbnRhaW5zKGRvYy5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICByb290UmVmLmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGxvb3BGb2N1cyA9IGZ1bmN0aW9uIGxvb3BGb2N1cyhldmVudCkge1xuICAgICAgLy8gOSA9IFRhYlxuICAgICAgaWYgKGRpc2FibGVFbmZvcmNlRm9jdXMgfHwgIWlzRW5hYmxlZCgpIHx8IGV2ZW50LmtleUNvZGUgIT09IDkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBNYWtlIHN1cmUgdGhlIG5leHQgdGFiIHN0YXJ0cyBmcm9tIHRoZSByaWdodCBwbGFjZS5cblxuXG4gICAgICBpZiAoZG9jLmFjdGl2ZUVsZW1lbnQgPT09IHJvb3RSZWYuY3VycmVudCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGlnbm9yZSB0aGUgbmV4dCBjb250YWluIGFzXG4gICAgICAgIC8vIGl0IHdpbGwgdHJ5IHRvIG1vdmUgdGhlIGZvY3VzIGJhY2sgdG8gdGhlIHJvb3RSZWYgZWxlbWVudC5cbiAgICAgICAgaWdub3JlTmV4dEVuZm9yY2VGb2N1cy5jdXJyZW50ID0gdHJ1ZTtcblxuICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICBzZW50aW5lbEVuZC5jdXJyZW50LmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VudGluZWxTdGFydC5jdXJyZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgY29udGFpbiwgdHJ1ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBsb29wRm9jdXMsIHRydWUpOyAvLyBXaXRoIEVkZ2UsIFNhZmFyaSBhbmQgRmlyZWZveCwgbm8gZm9jdXMgcmVsYXRlZCBldmVudHMgYXJlIGZpcmVkIHdoZW4gdGhlIGZvY3VzZWQgYXJlYSBzdG9wcyBiZWluZyBhIGZvY3VzZWQgYXJlYVxuICAgIC8vIGUuZy4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTU5NTYxLlxuICAgIC8vXG4gICAgLy8gVGhlIHdoYXR3ZyBzcGVjIGRlZmluZXMgaG93IHRoZSBicm93c2VyIHNob3VsZCBiZWhhdmUgYnV0IGRvZXMgbm90IGV4cGxpY2l0bHkgbWVudGlvbiBhbnkgZXZlbnRzOlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjZm9jdXMtZml4dXAtcnVsZS5cblxuICAgIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnRhaW4oKTtcbiAgICB9LCA1MCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgY29udGFpbiwgdHJ1ZSk7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGxvb3BGb2N1cywgdHJ1ZSk7IC8vIHJlc3RvcmVMYXN0Rm9jdXMoKVxuXG4gICAgICBpZiAoIWRpc2FibGVSZXN0b3JlRm9jdXMpIHtcbiAgICAgICAgLy8gSW4gSUUgMTEgaXQgaXMgcG9zc2libGUgZm9yIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgdG8gYmUgbnVsbCByZXN1bHRpbmdcbiAgICAgICAgLy8gaW4gbm9kZVRvUmVzdG9yZS5jdXJyZW50IGJlaW5nIG51bGwuXG4gICAgICAgIC8vIE5vdCBhbGwgZWxlbWVudHMgaW4gSUUgMTEgaGF2ZSBhIGZvY3VzIG1ldGhvZC5cbiAgICAgICAgLy8gT25jZSBJRSAxMSBzdXBwb3J0IGlzIGRyb3BwZWQgdGhlIGZvY3VzKCkgY2FsbCBjYW4gYmUgdW5jb25kaXRpb25hbC5cbiAgICAgICAgaWYgKG5vZGVUb1Jlc3RvcmUuY3VycmVudCAmJiBub2RlVG9SZXN0b3JlLmN1cnJlbnQuZm9jdXMpIHtcbiAgICAgICAgICBub2RlVG9SZXN0b3JlLmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGVUb1Jlc3RvcmUuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVBdXRvRm9jdXMsIGRpc2FibGVFbmZvcmNlRm9jdXMsIGRpc2FibGVSZXN0b3JlRm9jdXMsIGlzRW5hYmxlZCwgb3Blbl0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICB0YWJJbmRleDogMCxcbiAgICByZWY6IHNlbnRpbmVsU3RhcnQsXG4gICAgXCJkYXRhLXRlc3RcIjogXCJzZW50aW5lbFN0YXJ0XCJcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGRyZW4sIHtcbiAgICByZWY6IGhhbmRsZVJlZlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHRhYkluZGV4OiAwLFxuICAgIHJlZjogc2VudGluZWxFbmQsXG4gICAgXCJkYXRhLXRlc3RcIjogXCJzZW50aW5lbEVuZFwiXG4gIH0pKTtcbn1cblxucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVW5zdGFibGVfVHJhcEZvY3VzLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIEEgc2luZ2xlIGNoaWxkIGNvbnRlbnQgZWxlbWVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgdHJhcCBmb2N1cyB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IHNoaWZ0IGZvY3VzIHRvIGl0c2VsZiB3aGVuIGl0IG9wZW5zLCBhbmRcbiAgICogcmVwbGFjZSBpdCB0byB0aGUgbGFzdCBmb2N1c2VkIGVsZW1lbnQgd2hlbiBpdCBjbG9zZXMuXG4gICAqIFRoaXMgYWxzbyB3b3JrcyBjb3JyZWN0bHkgd2l0aCBhbnkgdHJhcCBmb2N1cyBjaGlsZHJlbiB0aGF0IGhhdmUgdGhlIGBkaXNhYmxlQXV0b0ZvY3VzYCBwcm9wLlxuICAgKlxuICAgKiBHZW5lcmFsbHkgdGhpcyBzaG91bGQgbmV2ZXIgYmUgc2V0IHRvIGB0cnVlYCBhcyBpdCBtYWtlcyB0aGUgdHJhcCBmb2N1cyBsZXNzXG4gICAqIGFjY2Vzc2libGUgdG8gYXNzaXN0aXZlIHRlY2hub2xvZ2llcywgbGlrZSBzY3JlZW4gcmVhZGVycy5cbiAgICovXG4gIGRpc2FibGVBdXRvRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSB0cmFwIGZvY3VzIHdpbGwgbm90IHByZXZlbnQgZm9jdXMgZnJvbSBsZWF2aW5nIHRoZSB0cmFwIGZvY3VzIHdoaWxlIG9wZW4uXG4gICAqXG4gICAqIEdlbmVyYWxseSB0aGlzIHNob3VsZCBuZXZlciBiZSBzZXQgdG8gYHRydWVgIGFzIGl0IG1ha2VzIHRoZSB0cmFwIGZvY3VzIGxlc3NcbiAgICogYWNjZXNzaWJsZSB0byBhc3Npc3RpdmUgdGVjaG5vbG9naWVzLCBsaWtlIHNjcmVlbiByZWFkZXJzLlxuICAgKi9cbiAgZGlzYWJsZUVuZm9yY2VGb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHRyYXAgZm9jdXMgd2lsbCBub3QgcmVzdG9yZSBmb2N1cyB0byBwcmV2aW91c2x5IGZvY3VzZWQgZWxlbWVudCBvbmNlXG4gICAqIHRyYXAgZm9jdXMgaXMgaGlkZGVuLlxuICAgKi9cbiAgZGlzYWJsZVJlc3RvcmVGb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZG9jdW1lbnQgdG8gY29uc2lkZXIuXG4gICAqIFdlIHVzZSBpdCB0byBpbXBsZW1lbnQgdGhlIHJlc3RvcmUgZm9jdXMgYmV0d2VlbiBkaWZmZXJlbnQgYnJvd3NlciBkb2N1bWVudHMuXG4gICAqL1xuICBnZXREb2M6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIERvIHdlIHN0aWxsIHdhbnQgdG8gZW5mb3JjZSB0aGUgZm9jdXM/XG4gICAqIFRoaXMgcHJvcCBoZWxwcyBuZXN0aW5nIFRyYXBGb2N1cyBlbGVtZW50cy5cbiAgICovXG4gIGlzRW5hYmxlZDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBmb2N1cyB3aWxsIGJlIGxvY2tlZC5cbiAgICovXG4gIG9wZW46IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWRcbn0gOiB2b2lkIDA7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBVbnN0YWJsZV9UcmFwRm9jdXNbJ3Byb3BUeXBlcycgKyAnJ10gPSBleGFjdFByb3AoVW5zdGFibGVfVHJhcEZvY3VzLnByb3BUeXBlcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFVuc3RhYmxlX1RyYXBGb2N1czsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSB7XG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gIHJvb3Q6IHtcbiAgICB6SW5kZXg6IC0xLFxuICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuNSknLFxuICAgIFdlYmtpdFRhcEhpZ2hsaWdodENvbG9yOiAndHJhbnNwYXJlbnQnXG4gIH0sXG5cbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgaW52aXNpYmxlPXt0cnVlfWAuICovXG4gIGludmlzaWJsZToge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50J1xuICB9XG59O1xuLyoqXG4gKiBAaWdub3JlIC0gaW50ZXJuYWwgY29tcG9uZW50LlxuICovXG5cbnZhciBTaW1wbGVCYWNrZHJvcCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFNpbXBsZUJhY2tkcm9wKHByb3BzLCByZWYpIHtcbiAgdmFyIF9wcm9wcyRpbnZpc2libGUgPSBwcm9wcy5pbnZpc2libGUsXG4gICAgICBpbnZpc2libGUgPSBfcHJvcHMkaW52aXNpYmxlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRpbnZpc2libGUsXG4gICAgICBvcGVuID0gcHJvcHMub3BlbixcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJpbnZpc2libGVcIiwgXCJvcGVuXCJdKTtcblxuICByZXR1cm4gb3BlbiA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIsIHtcbiAgICBzdHlsZTogX2V4dGVuZHMoe30sIHN0eWxlcy5yb290LCBpbnZpc2libGUgPyBzdHlsZXMuaW52aXNpYmxlIDoge30sIG90aGVyLnN0eWxlKVxuICB9KSkgOiBudWxsO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBTaW1wbGVCYWNrZHJvcC5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBiYWNrZHJvcCBpcyBpbnZpc2libGUuXG4gICAqIEl0IGNhbiBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nIGEgcG9wb3ZlciBvciBhIGN1c3RvbSBzZWxlY3QgY29tcG9uZW50LlxuICAgKi9cbiAgaW52aXNpYmxlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYmFja2Ryb3AgaXMgb3Blbi5cbiAgICovXG4gIG9wZW46IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWRcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCBTaW1wbGVCYWNrZHJvcDsiLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGdldFRoZW1lUHJvcHMsIHVzZVRoZW1lIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3N0eWxlcyc7XG5pbXBvcnQgeyBlbGVtZW50QWNjZXB0aW5nUmVmLCBIVE1MRWxlbWVudFR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IGRlcHJlY2F0ZWRQcm9wVHlwZSBmcm9tICcuLi91dGlscy9kZXByZWNhdGVkUHJvcFR5cGUnO1xuaW1wb3J0IG93bmVyRG9jdW1lbnQgZnJvbSAnLi4vdXRpbHMvb3duZXJEb2N1bWVudCc7XG5pbXBvcnQgUG9ydGFsIGZyb20gJy4uL1BvcnRhbCc7XG5pbXBvcnQgY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uIGZyb20gJy4uL3V0aWxzL2NyZWF0ZUNoYWluZWRGdW5jdGlvbic7XG5pbXBvcnQgdXNlRm9ya1JlZiBmcm9tICcuLi91dGlscy91c2VGb3JrUmVmJztcbmltcG9ydCB1c2VFdmVudENhbGxiYWNrIGZyb20gJy4uL3V0aWxzL3VzZUV2ZW50Q2FsbGJhY2snO1xuaW1wb3J0IHpJbmRleCBmcm9tICcuLi9zdHlsZXMvekluZGV4JztcbmltcG9ydCBNb2RhbE1hbmFnZXIsIHsgYXJpYUhpZGRlbiB9IGZyb20gJy4vTW9kYWxNYW5hZ2VyJztcbmltcG9ydCBUcmFwRm9jdXMgZnJvbSAnLi4vVW5zdGFibGVfVHJhcEZvY3VzJztcbmltcG9ydCBTaW1wbGVCYWNrZHJvcCBmcm9tICcuL1NpbXBsZUJhY2tkcm9wJztcblxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyKGNvbnRhaW5lcikge1xuICBjb250YWluZXIgPSB0eXBlb2YgY29udGFpbmVyID09PSAnZnVuY3Rpb24nID8gY29udGFpbmVyKCkgOiBjb250YWluZXI7XG4gIHJldHVybiBSZWFjdERPTS5maW5kRE9NTm9kZShjb250YWluZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRIYXNUcmFuc2l0aW9uKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5jaGlsZHJlbiA/IHByb3BzLmNoaWxkcmVuLnByb3BzLmhhc093blByb3BlcnR5KCdpbicpIDogZmFsc2U7XG59IC8vIEEgbW9kYWwgbWFuYWdlciB1c2VkIHRvIHRyYWNrIGFuZCBtYW5hZ2UgdGhlIHN0YXRlIG9mIG9wZW4gTW9kYWxzLlxuLy8gTW9kYWxzIGRvbid0IG9wZW4gb24gdGhlIHNlcnZlciBzbyB0aGlzIHdvbid0IGNvbmZsaWN0IHdpdGggY29uY3VycmVudCByZXF1ZXN0cy5cblxuXG52YXIgZGVmYXVsdE1hbmFnZXIgPSBuZXcgTW9kYWxNYW5hZ2VyKCk7XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gICAgcm9vdDoge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICB6SW5kZXg6IHRoZW1lLnpJbmRleC5tb2RhbCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMFxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIHRoZSBgTW9kYWxgIGhhcyBleGl0ZWQuICovXG4gICAgaGlkZGVuOiB7XG4gICAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJ1xuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIE1vZGFsIGlzIGEgbG93ZXItbGV2ZWwgY29uc3RydWN0IHRoYXQgaXMgbGV2ZXJhZ2VkIGJ5IHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czpcbiAqXG4gKiAtIFtEaWFsb2ddKC9hcGkvZGlhbG9nLylcbiAqIC0gW0RyYXdlcl0oL2FwaS9kcmF3ZXIvKVxuICogLSBbTWVudV0oL2FwaS9tZW51LylcbiAqIC0gW1BvcG92ZXJdKC9hcGkvcG9wb3Zlci8pXG4gKlxuICogSWYgeW91IGFyZSBjcmVhdGluZyBhIG1vZGFsIGRpYWxvZywgeW91IHByb2JhYmx5IHdhbnQgdG8gdXNlIHRoZSBbRGlhbG9nXSgvYXBpL2RpYWxvZy8pIGNvbXBvbmVudFxuICogcmF0aGVyIHRoYW4gZGlyZWN0bHkgdXNpbmcgTW9kYWwuXG4gKlxuICogVGhpcyBjb21wb25lbnQgc2hhcmVzIG1hbnkgY29uY2VwdHMgd2l0aCBbcmVhY3Qtb3ZlcmxheXNdKGh0dHBzOi8vcmVhY3QtYm9vdHN0cmFwLmdpdGh1Yi5pby9yZWFjdC1vdmVybGF5cy8jbW9kYWxzKS5cbiAqL1xuXG52YXIgTW9kYWwgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBNb2RhbChpblByb3BzLCByZWYpIHtcbiAgdmFyIHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgdmFyIHByb3BzID0gZ2V0VGhlbWVQcm9wcyh7XG4gICAgbmFtZTogJ011aU1vZGFsJyxcbiAgICBwcm9wczogX2V4dGVuZHMoe30sIGluUHJvcHMpLFxuICAgIHRoZW1lOiB0aGVtZVxuICB9KTtcblxuICB2YXIgX3Byb3BzJEJhY2tkcm9wQ29tcG9uID0gcHJvcHMuQmFja2Ryb3BDb21wb25lbnQsXG4gICAgICBCYWNrZHJvcENvbXBvbmVudCA9IF9wcm9wcyRCYWNrZHJvcENvbXBvbiA9PT0gdm9pZCAwID8gU2ltcGxlQmFja2Ryb3AgOiBfcHJvcHMkQmFja2Ryb3BDb21wb24sXG4gICAgICBCYWNrZHJvcFByb3BzID0gcHJvcHMuQmFja2Ryb3BQcm9wcyxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBfcHJvcHMkY2xvc2VBZnRlclRyYW4gPSBwcm9wcy5jbG9zZUFmdGVyVHJhbnNpdGlvbixcbiAgICAgIGNsb3NlQWZ0ZXJUcmFuc2l0aW9uID0gX3Byb3BzJGNsb3NlQWZ0ZXJUcmFuID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRjbG9zZUFmdGVyVHJhbixcbiAgICAgIGNvbnRhaW5lciA9IHByb3BzLmNvbnRhaW5lcixcbiAgICAgIF9wcm9wcyRkaXNhYmxlQXV0b0ZvYyA9IHByb3BzLmRpc2FibGVBdXRvRm9jdXMsXG4gICAgICBkaXNhYmxlQXV0b0ZvY3VzID0gX3Byb3BzJGRpc2FibGVBdXRvRm9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlQXV0b0ZvYyxcbiAgICAgIF9wcm9wcyRkaXNhYmxlQmFja2RybyA9IHByb3BzLmRpc2FibGVCYWNrZHJvcENsaWNrLFxuICAgICAgZGlzYWJsZUJhY2tkcm9wQ2xpY2sgPSBfcHJvcHMkZGlzYWJsZUJhY2tkcm8gPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVCYWNrZHJvLFxuICAgICAgX3Byb3BzJGRpc2FibGVFbmZvcmNlID0gcHJvcHMuZGlzYWJsZUVuZm9yY2VGb2N1cyxcbiAgICAgIGRpc2FibGVFbmZvcmNlRm9jdXMgPSBfcHJvcHMkZGlzYWJsZUVuZm9yY2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVFbmZvcmNlLFxuICAgICAgX3Byb3BzJGRpc2FibGVFc2NhcGVLID0gcHJvcHMuZGlzYWJsZUVzY2FwZUtleURvd24sXG4gICAgICBkaXNhYmxlRXNjYXBlS2V5RG93biA9IF9wcm9wcyRkaXNhYmxlRXNjYXBlSyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZUVzY2FwZUssXG4gICAgICBfcHJvcHMkZGlzYWJsZVBvcnRhbCA9IHByb3BzLmRpc2FibGVQb3J0YWwsXG4gICAgICBkaXNhYmxlUG9ydGFsID0gX3Byb3BzJGRpc2FibGVQb3J0YWwgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVQb3J0YWwsXG4gICAgICBfcHJvcHMkZGlzYWJsZVJlc3RvcmUgPSBwcm9wcy5kaXNhYmxlUmVzdG9yZUZvY3VzLFxuICAgICAgZGlzYWJsZVJlc3RvcmVGb2N1cyA9IF9wcm9wcyRkaXNhYmxlUmVzdG9yZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZVJlc3RvcmUsXG4gICAgICBfcHJvcHMkZGlzYWJsZVNjcm9sbEwgPSBwcm9wcy5kaXNhYmxlU2Nyb2xsTG9jayxcbiAgICAgIGRpc2FibGVTY3JvbGxMb2NrID0gX3Byb3BzJGRpc2FibGVTY3JvbGxMID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlU2Nyb2xsTCxcbiAgICAgIF9wcm9wcyRoaWRlQmFja2Ryb3AgPSBwcm9wcy5oaWRlQmFja2Ryb3AsXG4gICAgICBoaWRlQmFja2Ryb3AgPSBfcHJvcHMkaGlkZUJhY2tkcm9wID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRoaWRlQmFja2Ryb3AsXG4gICAgICBfcHJvcHMka2VlcE1vdW50ZWQgPSBwcm9wcy5rZWVwTW91bnRlZCxcbiAgICAgIGtlZXBNb3VudGVkID0gX3Byb3BzJGtlZXBNb3VudGVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRrZWVwTW91bnRlZCxcbiAgICAgIF9wcm9wcyRtYW5hZ2VyID0gcHJvcHMubWFuYWdlcixcbiAgICAgIG1hbmFnZXIgPSBfcHJvcHMkbWFuYWdlciA9PT0gdm9pZCAwID8gZGVmYXVsdE1hbmFnZXIgOiBfcHJvcHMkbWFuYWdlcixcbiAgICAgIG9uQmFja2Ryb3BDbGljayA9IHByb3BzLm9uQmFja2Ryb3BDbGljayxcbiAgICAgIG9uQ2xvc2UgPSBwcm9wcy5vbkNsb3NlLFxuICAgICAgb25Fc2NhcGVLZXlEb3duID0gcHJvcHMub25Fc2NhcGVLZXlEb3duLFxuICAgICAgb25SZW5kZXJlZCA9IHByb3BzLm9uUmVuZGVyZWQsXG4gICAgICBvcGVuID0gcHJvcHMub3BlbixcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJCYWNrZHJvcENvbXBvbmVudFwiLCBcIkJhY2tkcm9wUHJvcHNcIiwgXCJjaGlsZHJlblwiLCBcImNsb3NlQWZ0ZXJUcmFuc2l0aW9uXCIsIFwiY29udGFpbmVyXCIsIFwiZGlzYWJsZUF1dG9Gb2N1c1wiLCBcImRpc2FibGVCYWNrZHJvcENsaWNrXCIsIFwiZGlzYWJsZUVuZm9yY2VGb2N1c1wiLCBcImRpc2FibGVFc2NhcGVLZXlEb3duXCIsIFwiZGlzYWJsZVBvcnRhbFwiLCBcImRpc2FibGVSZXN0b3JlRm9jdXNcIiwgXCJkaXNhYmxlU2Nyb2xsTG9ja1wiLCBcImhpZGVCYWNrZHJvcFwiLCBcImtlZXBNb3VudGVkXCIsIFwibWFuYWdlclwiLCBcIm9uQmFja2Ryb3BDbGlja1wiLCBcIm9uQ2xvc2VcIiwgXCJvbkVzY2FwZUtleURvd25cIiwgXCJvblJlbmRlcmVkXCIsIFwib3BlblwiXSk7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKHRydWUpLFxuICAgICAgZXhpdGVkID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgc2V0RXhpdGVkID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciBtb2RhbCA9IFJlYWN0LnVzZVJlZih7fSk7XG4gIHZhciBtb3VudE5vZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBtb2RhbFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIGhhbmRsZVJlZiA9IHVzZUZvcmtSZWYobW9kYWxSZWYsIHJlZik7XG4gIHZhciBoYXNUcmFuc2l0aW9uID0gZ2V0SGFzVHJhbnNpdGlvbihwcm9wcyk7XG5cbiAgdmFyIGdldERvYyA9IGZ1bmN0aW9uIGdldERvYygpIHtcbiAgICByZXR1cm4gb3duZXJEb2N1bWVudChtb3VudE5vZGVSZWYuY3VycmVudCk7XG4gIH07XG5cbiAgdmFyIGdldE1vZGFsID0gZnVuY3Rpb24gZ2V0TW9kYWwoKSB7XG4gICAgbW9kYWwuY3VycmVudC5tb2RhbFJlZiA9IG1vZGFsUmVmLmN1cnJlbnQ7XG4gICAgbW9kYWwuY3VycmVudC5tb3VudE5vZGUgPSBtb3VudE5vZGVSZWYuY3VycmVudDtcbiAgICByZXR1cm4gbW9kYWwuY3VycmVudDtcbiAgfTtcblxuICB2YXIgaGFuZGxlTW91bnRlZCA9IGZ1bmN0aW9uIGhhbmRsZU1vdW50ZWQoKSB7XG4gICAgbWFuYWdlci5tb3VudChnZXRNb2RhbCgpLCB7XG4gICAgICBkaXNhYmxlU2Nyb2xsTG9jazogZGlzYWJsZVNjcm9sbExvY2tcbiAgICB9KTsgLy8gRml4IGEgYnVnIG9uIENocm9tZSB3aGVyZSB0aGUgc2Nyb2xsIGlzbid0IGluaXRpYWxseSAwLlxuXG4gICAgbW9kYWxSZWYuY3VycmVudC5zY3JvbGxUb3AgPSAwO1xuICB9O1xuXG4gIHZhciBoYW5kbGVPcGVuID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc29sdmVkQ29udGFpbmVyID0gZ2V0Q29udGFpbmVyKGNvbnRhaW5lcikgfHwgZ2V0RG9jKCkuYm9keTtcbiAgICBtYW5hZ2VyLmFkZChnZXRNb2RhbCgpLCByZXNvbHZlZENvbnRhaW5lcik7IC8vIFRoZSBlbGVtZW50IHdhcyBhbHJlYWR5IG1vdW50ZWQuXG5cbiAgICBpZiAobW9kYWxSZWYuY3VycmVudCkge1xuICAgICAgaGFuZGxlTW91bnRlZCgpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBpc1RvcE1vZGFsID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtYW5hZ2VyLmlzVG9wTW9kYWwoZ2V0TW9kYWwoKSk7XG4gIH0sIFttYW5hZ2VyXSk7XG4gIHZhciBoYW5kbGVQb3J0YWxSZWYgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbW91bnROb2RlUmVmLmN1cnJlbnQgPSBub2RlO1xuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9uUmVuZGVyZWQpIHtcbiAgICAgIG9uUmVuZGVyZWQoKTtcbiAgICB9XG5cbiAgICBpZiAob3BlbiAmJiBpc1RvcE1vZGFsKCkpIHtcbiAgICAgIGhhbmRsZU1vdW50ZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJpYUhpZGRlbihtb2RhbFJlZi5jdXJyZW50LCB0cnVlKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgaGFuZGxlQ2xvc2UgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgbWFuYWdlci5yZW1vdmUoZ2V0TW9kYWwoKSk7XG4gIH0sIFttYW5hZ2VyXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGhhbmRsZUNsb3NlKCk7XG4gICAgfTtcbiAgfSwgW2hhbmRsZUNsb3NlXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIGhhbmRsZU9wZW4oKTtcbiAgICB9IGVsc2UgaWYgKCFoYXNUcmFuc2l0aW9uIHx8ICFjbG9zZUFmdGVyVHJhbnNpdGlvbikge1xuICAgICAgaGFuZGxlQ2xvc2UoKTtcbiAgICB9XG4gIH0sIFtvcGVuLCBoYW5kbGVDbG9zZSwgaGFzVHJhbnNpdGlvbiwgY2xvc2VBZnRlclRyYW5zaXRpb24sIGhhbmRsZU9wZW5dKTtcblxuICBpZiAoIWtlZXBNb3VudGVkICYmICFvcGVuICYmICghaGFzVHJhbnNpdGlvbiB8fCBleGl0ZWQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgaGFuZGxlRW50ZXIgPSBmdW5jdGlvbiBoYW5kbGVFbnRlcigpIHtcbiAgICBzZXRFeGl0ZWQoZmFsc2UpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVFeGl0ZWQgPSBmdW5jdGlvbiBoYW5kbGVFeGl0ZWQoKSB7XG4gICAgc2V0RXhpdGVkKHRydWUpO1xuXG4gICAgaWYgKGNsb3NlQWZ0ZXJUcmFuc2l0aW9uKSB7XG4gICAgICBoYW5kbGVDbG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlQmFja2Ryb3BDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUJhY2tkcm9wQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBldmVudC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9uQmFja2Ryb3BDbGljaykge1xuICAgICAgb25CYWNrZHJvcENsaWNrKGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoIWRpc2FibGVCYWNrZHJvcENsaWNrICYmIG9uQ2xvc2UpIHtcbiAgICAgIG9uQ2xvc2UoZXZlbnQsICdiYWNrZHJvcENsaWNrJyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIC8vIFRoZSBoYW5kbGVyIGRvZXNuJ3QgdGFrZSBldmVudC5kZWZhdWx0UHJldmVudGVkIGludG8gYWNjb3VudDpcbiAgICAvL1xuICAgIC8vIGV2ZW50LnByZXZlbnREZWZhdWx0KCkgaXMgbWVhbnQgdG8gc3RvcCBkZWZhdWx0IGJlaGF2aW91cnMgbGlrZVxuICAgIC8vIGNsaWNraW5nIGEgY2hlY2tib3ggdG8gY2hlY2sgaXQsIGhpdHRpbmcgYSBidXR0b24gdG8gc3VibWl0IGEgZm9ybSxcbiAgICAvLyBhbmQgaGl0dGluZyBsZWZ0IGFycm93IHRvIG1vdmUgdGhlIGN1cnNvciBpbiBhIHRleHQgaW5wdXQgZXRjLlxuICAgIC8vIE9ubHkgc3BlY2lhbCBIVE1MIGVsZW1lbnRzIGhhdmUgdGhlc2UgZGVmYXVsdCBiZWhhdmlvcnMuXG4gICAgaWYgKGV2ZW50LmtleSAhPT0gJ0VzY2FwZScgfHwgIWlzVG9wTW9kYWwoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvbkVzY2FwZUtleURvd24pIHtcbiAgICAgIG9uRXNjYXBlS2V5RG93bihldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKCFkaXNhYmxlRXNjYXBlS2V5RG93bikge1xuICAgICAgLy8gU3dhbGxvdyB0aGUgZXZlbnQsIGluIGNhc2Ugc29tZW9uZSBpcyBsaXN0ZW5pbmcgZm9yIHRoZSBlc2NhcGUga2V5IG9uIHRoZSBib2R5LlxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIGlmIChvbkNsb3NlKSB7XG4gICAgICAgIG9uQ2xvc2UoZXZlbnQsICdlc2NhcGVLZXlEb3duJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbmxpbmVTdHlsZSA9IHN0eWxlcyh0aGVtZSB8fCB7XG4gICAgekluZGV4OiB6SW5kZXhcbiAgfSk7XG4gIHZhciBjaGlsZFByb3BzID0ge307XG5cbiAgaWYgKGNoaWxkcmVuLnByb3BzLnRhYkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICBjaGlsZFByb3BzLnRhYkluZGV4ID0gY2hpbGRyZW4ucHJvcHMudGFiSW5kZXggfHwgJy0xJztcbiAgfSAvLyBJdCdzIGEgVHJhbnNpdGlvbiBsaWtlIGNvbXBvbmVudFxuXG5cbiAgaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgICBjaGlsZFByb3BzLm9uRW50ZXIgPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24oaGFuZGxlRW50ZXIsIGNoaWxkcmVuLnByb3BzLm9uRW50ZXIpO1xuICAgIGNoaWxkUHJvcHMub25FeGl0ZWQgPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24oaGFuZGxlRXhpdGVkLCBjaGlsZHJlbi5wcm9wcy5vbkV4aXRlZCk7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUG9ydGFsLCB7XG4gICAgcmVmOiBoYW5kbGVQb3J0YWxSZWYsXG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgZGlzYWJsZVBvcnRhbDogZGlzYWJsZVBvcnRhbFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBoYW5kbGVSZWYsXG4gICAgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duLFxuICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCJcbiAgfSwgb3RoZXIsIHtcbiAgICBzdHlsZTogX2V4dGVuZHMoe30sIGlubGluZVN0eWxlLnJvb3QsICFvcGVuICYmIGV4aXRlZCA/IGlubGluZVN0eWxlLmhpZGRlbiA6IHt9LCBvdGhlci5zdHlsZSlcbiAgfSksIGhpZGVCYWNrZHJvcCA/IG51bGwgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChCYWNrZHJvcENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIG9wZW46IG9wZW4sXG4gICAgb25DbGljazogaGFuZGxlQmFja2Ryb3BDbGlja1xuICB9LCBCYWNrZHJvcFByb3BzKSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRyYXBGb2N1cywge1xuICAgIGRpc2FibGVFbmZvcmNlRm9jdXM6IGRpc2FibGVFbmZvcmNlRm9jdXMsXG4gICAgZGlzYWJsZUF1dG9Gb2N1czogZGlzYWJsZUF1dG9Gb2N1cyxcbiAgICBkaXNhYmxlUmVzdG9yZUZvY3VzOiBkaXNhYmxlUmVzdG9yZUZvY3VzLFxuICAgIGdldERvYzogZ2V0RG9jLFxuICAgIGlzRW5hYmxlZDogaXNUb3BNb2RhbCxcbiAgICBvcGVuOiBvcGVuXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGRyZW4sIGNoaWxkUHJvcHMpKSkpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBNb2RhbC5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBBIGJhY2tkcm9wIGNvbXBvbmVudC4gVGhpcyBwcm9wIGVuYWJsZXMgY3VzdG9tIGJhY2tkcm9wIHJlbmRlcmluZy5cbiAgICovXG4gIEJhY2tkcm9wQ29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG5cbiAgLyoqXG4gICAqIFByb3BzIGFwcGxpZWQgdG8gdGhlIFtgQmFja2Ryb3BgXSgvYXBpL2JhY2tkcm9wLykgZWxlbWVudC5cbiAgICovXG4gIEJhY2tkcm9wUHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEEgc2luZ2xlIGNoaWxkIGNvbnRlbnQgZWxlbWVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBlbGVtZW50QWNjZXB0aW5nUmVmLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIFdoZW4gc2V0IHRvIHRydWUgdGhlIE1vZGFsIHdhaXRzIHVudGlsIGEgbmVzdGVkIFRyYW5zaXRpb24gaXMgY29tcGxldGVkIGJlZm9yZSBjbG9zaW5nLlxuICAgKi9cbiAgY2xvc2VBZnRlclRyYW5zaXRpb246IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBBIEhUTUwgZWxlbWVudCwgY29tcG9uZW50IGluc3RhbmNlLCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgZWl0aGVyLlxuICAgKiBUaGUgYGNvbnRhaW5lcmAgd2lsbCBoYXZlIHRoZSBwb3J0YWwgY2hpbGRyZW4gYXBwZW5kZWQgdG8gaXQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGl0IHVzZXMgdGhlIGJvZHkgb2YgdGhlIHRvcC1sZXZlbCBkb2N1bWVudCBvYmplY3QsXG4gICAqIHNvIGl0J3Mgc2ltcGx5IGBkb2N1bWVudC5ib2R5YCBtb3N0IG9mIHRoZSB0aW1lLlxuICAgKi9cbiAgY29udGFpbmVyOiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAub25lT2ZUeXBlKFtIVE1MRWxlbWVudFR5cGUsIFByb3BUeXBlcy5pbnN0YW5jZU9mKFJlYWN0LkNvbXBvbmVudCksIFByb3BUeXBlcy5mdW5jXSksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIG1vZGFsIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgc2hpZnQgZm9jdXMgdG8gaXRzZWxmIHdoZW4gaXQgb3BlbnMsIGFuZFxuICAgKiByZXBsYWNlIGl0IHRvIHRoZSBsYXN0IGZvY3VzZWQgZWxlbWVudCB3aGVuIGl0IGNsb3Nlcy5cbiAgICogVGhpcyBhbHNvIHdvcmtzIGNvcnJlY3RseSB3aXRoIGFueSBtb2RhbCBjaGlsZHJlbiB0aGF0IGhhdmUgdGhlIGBkaXNhYmxlQXV0b0ZvY3VzYCBwcm9wLlxuICAgKlxuICAgKiBHZW5lcmFsbHkgdGhpcyBzaG91bGQgbmV2ZXIgYmUgc2V0IHRvIGB0cnVlYCBhcyBpdCBtYWtlcyB0aGUgbW9kYWwgbGVzc1xuICAgKiBhY2Nlc3NpYmxlIHRvIGFzc2lzdGl2ZSB0ZWNobm9sb2dpZXMsIGxpa2Ugc2NyZWVuIHJlYWRlcnMuXG4gICAqL1xuICBkaXNhYmxlQXV0b0ZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBjbGlja2luZyB0aGUgYmFja2Ryb3Agd2lsbCBub3QgZmlyZSBgb25DbG9zZWAuXG4gICAqL1xuICBkaXNhYmxlQmFja2Ryb3BDbGljazogZGVwcmVjYXRlZFByb3BUeXBlKFByb3BUeXBlcy5ib29sLCAnVXNlIHRoZSBvbkNsb3NlIHByb3Agd2l0aCB0aGUgYHJlYXNvbmAgYXJndW1lbnQgdG8gZmlsdGVyIHRoZSBgYmFja2Ryb3BDbGlja2AgZXZlbnRzLicpLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBtb2RhbCB3aWxsIG5vdCBwcmV2ZW50IGZvY3VzIGZyb20gbGVhdmluZyB0aGUgbW9kYWwgd2hpbGUgb3Blbi5cbiAgICpcbiAgICogR2VuZXJhbGx5IHRoaXMgc2hvdWxkIG5ldmVyIGJlIHNldCB0byBgdHJ1ZWAgYXMgaXQgbWFrZXMgdGhlIG1vZGFsIGxlc3NcbiAgICogYWNjZXNzaWJsZSB0byBhc3Npc3RpdmUgdGVjaG5vbG9naWVzLCBsaWtlIHNjcmVlbiByZWFkZXJzLlxuICAgKi9cbiAgZGlzYWJsZUVuZm9yY2VGb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgaGl0dGluZyBlc2NhcGUgd2lsbCBub3QgZmlyZSBgb25DbG9zZWAuXG4gICAqL1xuICBkaXNhYmxlRXNjYXBlS2V5RG93bjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIERpc2FibGUgdGhlIHBvcnRhbCBiZWhhdmlvci5cbiAgICogVGhlIGNoaWxkcmVuIHN0YXkgd2l0aGluIGl0J3MgcGFyZW50IERPTSBoaWVyYXJjaHkuXG4gICAqL1xuICBkaXNhYmxlUG9ydGFsOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbW9kYWwgd2lsbCBub3QgcmVzdG9yZSBmb2N1cyB0byBwcmV2aW91c2x5IGZvY3VzZWQgZWxlbWVudCBvbmNlXG4gICAqIG1vZGFsIGlzIGhpZGRlbi5cbiAgICovXG4gIGRpc2FibGVSZXN0b3JlRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSBzY3JvbGwgbG9jayBiZWhhdmlvci5cbiAgICovXG4gIGRpc2FibGVTY3JvbGxMb2NrOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYmFja2Ryb3AgaXMgbm90IHJlbmRlcmVkLlxuICAgKi9cbiAgaGlkZUJhY2tkcm9wOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQWx3YXlzIGtlZXAgdGhlIGNoaWxkcmVuIGluIHRoZSBET00uXG4gICAqIFRoaXMgcHJvcCBjYW4gYmUgdXNlZnVsIGluIFNFTyBzaXR1YXRpb24gb3JcbiAgICogd2hlbiB5b3Ugd2FudCB0byBtYXhpbWl6ZSB0aGUgcmVzcG9uc2l2ZW5lc3Mgb2YgdGhlIE1vZGFsLlxuICAgKi9cbiAga2VlcE1vdW50ZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBtYW5hZ2VyOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBiYWNrZHJvcCBpcyBjbGlja2VkLlxuICAgKi9cbiAgb25CYWNrZHJvcENsaWNrOiBkZXByZWNhdGVkUHJvcFR5cGUoUHJvcFR5cGVzLmZ1bmMsICdVc2UgdGhlIG9uQ2xvc2UgcHJvcCB3aXRoIHRoZSBgcmVhc29uYCBhcmd1bWVudCB0byBoYW5kbGUgdGhlIGBiYWNrZHJvcENsaWNrYCBldmVudHMuJyksXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGNvbXBvbmVudCByZXF1ZXN0cyB0byBiZSBjbG9zZWQuXG4gICAqIFRoZSBgcmVhc29uYCBwYXJhbWV0ZXIgY2FuIG9wdGlvbmFsbHkgYmUgdXNlZCB0byBjb250cm9sIHRoZSByZXNwb25zZSB0byBgb25DbG9zZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiBDYW4gYmU6IGBcImVzY2FwZUtleURvd25cImAsIGBcImJhY2tkcm9wQ2xpY2tcImAuXG4gICAqL1xuICBvbkNsb3NlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgZXNjYXBlIGtleSBpcyBwcmVzc2VkLFxuICAgKiBgZGlzYWJsZUVzY2FwZUtleURvd25gIGlzIGZhbHNlIGFuZCB0aGUgbW9kYWwgaXMgaW4gZm9jdXMuXG4gICAqL1xuICBvbkVzY2FwZUtleURvd246IGRlcHJlY2F0ZWRQcm9wVHlwZShQcm9wVHlwZXMuZnVuYywgJ1VzZSB0aGUgb25DbG9zZSBwcm9wIHdpdGggdGhlIGByZWFzb25gIGFyZ3VtZW50IHRvIGhhbmRsZSB0aGUgYGVzY2FwZUtleURvd25gIGV2ZW50cy4nKSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgb25jZSB0aGUgY2hpbGRyZW4gaGFzIGJlZW4gbW91bnRlZCBpbnRvIHRoZSBgY29udGFpbmVyYC5cbiAgICogSXQgc2lnbmFscyB0aGF0IHRoZSBgb3Blbj17dHJ1ZX1gIHByb3AgdG9vayBlZmZlY3QuXG4gICAqXG4gICAqIFRoaXMgcHJvcCB3aWxsIGJlIHJlbW92ZWQgaW4gdjUsIHRoZSByZWYgY2FuIGJlIHVzZWQgaW5zdGVhZC5cbiAgICovXG4gIG9uUmVuZGVyZWQ6IGRlcHJlY2F0ZWRQcm9wVHlwZShQcm9wVHlwZXMuZnVuYywgJ1VzZSB0aGUgcmVmIGluc3RlYWQuJyksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIG1vZGFsIGlzIG9wZW4uXG4gICAqL1xuICBvcGVuOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgTW9kYWw7IiwiZXhwb3J0IHZhciByZWZsb3cgPSBmdW5jdGlvbiByZWZsb3cobm9kZSkge1xuICByZXR1cm4gbm9kZS5zY3JvbGxUb3A7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zaXRpb25Qcm9wcyhwcm9wcywgb3B0aW9ucykge1xuICB2YXIgdGltZW91dCA9IHByb3BzLnRpbWVvdXQsXG4gICAgICBfcHJvcHMkc3R5bGUgPSBwcm9wcy5zdHlsZSxcbiAgICAgIHN0eWxlID0gX3Byb3BzJHN0eWxlID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRzdHlsZTtcbiAgcmV0dXJuIHtcbiAgICBkdXJhdGlvbjogc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uIHx8IHR5cGVvZiB0aW1lb3V0ID09PSAnbnVtYmVyJyA/IHRpbWVvdXQgOiB0aW1lb3V0W29wdGlvbnMubW9kZV0gfHwgMCxcbiAgICBkZWxheTogc3R5bGUudHJhbnNpdGlvbkRlbGF5XG4gIH07XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAnO1xuaW1wb3J0IHVzZVRoZW1lIGZyb20gJy4uL3N0eWxlcy91c2VUaGVtZSc7XG5pbXBvcnQgeyByZWZsb3csIGdldFRyYW5zaXRpb25Qcm9wcyB9IGZyb20gJy4uL3RyYW5zaXRpb25zL3V0aWxzJztcbmltcG9ydCB1c2VGb3JrUmVmIGZyb20gJy4uL3V0aWxzL3VzZUZvcmtSZWYnO1xuXG5mdW5jdGlvbiBnZXRTY2FsZSh2YWx1ZSkge1xuICByZXR1cm4gXCJzY2FsZShcIi5jb25jYXQodmFsdWUsIFwiLCBcIikuY29uY2F0KE1hdGgucG93KHZhbHVlLCAyKSwgXCIpXCIpO1xufVxuXG52YXIgc3R5bGVzID0ge1xuICBlbnRlcmluZzoge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgdHJhbnNmb3JtOiBnZXRTY2FsZSgxKVxuICB9LFxuICBlbnRlcmVkOiB7XG4gICAgb3BhY2l0eTogMSxcbiAgICB0cmFuc2Zvcm06ICdub25lJ1xuICB9XG59O1xuLyoqXG4gKiBUaGUgR3JvdyB0cmFuc2l0aW9uIGlzIHVzZWQgYnkgdGhlIFtUb29sdGlwXSgvY29tcG9uZW50cy90b29sdGlwcy8pIGFuZFxuICogW1BvcG92ZXJdKC9jb21wb25lbnRzL3BvcG92ZXIvKSBjb21wb25lbnRzLlxuICogSXQgdXNlcyBbcmVhY3QtdHJhbnNpdGlvbi1ncm91cF0oaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cCkgaW50ZXJuYWxseS5cbiAqL1xuXG52YXIgR3JvdyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEdyb3cocHJvcHMsIHJlZikge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIF9wcm9wcyRkaXNhYmxlU3RyaWN0TSA9IHByb3BzLmRpc2FibGVTdHJpY3RNb2RlQ29tcGF0LFxuICAgICAgZGlzYWJsZVN0cmljdE1vZGVDb21wYXQgPSBfcHJvcHMkZGlzYWJsZVN0cmljdE0gPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVTdHJpY3RNLFxuICAgICAgaW5Qcm9wID0gcHJvcHMuaW4sXG4gICAgICBvbkVudGVyID0gcHJvcHMub25FbnRlcixcbiAgICAgIG9uRW50ZXJlZCA9IHByb3BzLm9uRW50ZXJlZCxcbiAgICAgIG9uRW50ZXJpbmcgPSBwcm9wcy5vbkVudGVyaW5nLFxuICAgICAgb25FeGl0ID0gcHJvcHMub25FeGl0LFxuICAgICAgb25FeGl0ZWQgPSBwcm9wcy5vbkV4aXRlZCxcbiAgICAgIG9uRXhpdGluZyA9IHByb3BzLm9uRXhpdGluZyxcbiAgICAgIHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICBfcHJvcHMkdGltZW91dCA9IHByb3BzLnRpbWVvdXQsXG4gICAgICB0aW1lb3V0ID0gX3Byb3BzJHRpbWVvdXQgPT09IHZvaWQgMCA/ICdhdXRvJyA6IF9wcm9wcyR0aW1lb3V0LFxuICAgICAgX3Byb3BzJFRyYW5zaXRpb25Db21wID0gcHJvcHMuVHJhbnNpdGlvbkNvbXBvbmVudCxcbiAgICAgIFRyYW5zaXRpb25Db21wb25lbnQgPSBfcHJvcHMkVHJhbnNpdGlvbkNvbXAgPT09IHZvaWQgMCA/IFRyYW5zaXRpb24gOiBfcHJvcHMkVHJhbnNpdGlvbkNvbXAsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJkaXNhYmxlU3RyaWN0TW9kZUNvbXBhdFwiLCBcImluXCIsIFwib25FbnRlclwiLCBcIm9uRW50ZXJlZFwiLCBcIm9uRW50ZXJpbmdcIiwgXCJvbkV4aXRcIiwgXCJvbkV4aXRlZFwiLCBcIm9uRXhpdGluZ1wiLCBcInN0eWxlXCIsIFwidGltZW91dFwiLCBcIlRyYW5zaXRpb25Db21wb25lbnRcIl0pO1xuXG4gIHZhciB0aW1lciA9IFJlYWN0LnVzZVJlZigpO1xuICB2YXIgYXV0b1RpbWVvdXQgPSBSZWFjdC51c2VSZWYoKTtcbiAgdmFyIHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgdmFyIGVuYWJsZVN0cmljdE1vZGVDb21wYXQgPSB0aGVtZS51bnN0YWJsZV9zdHJpY3RNb2RlICYmICFkaXNhYmxlU3RyaWN0TW9kZUNvbXBhdDtcbiAgdmFyIG5vZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBmb3JlaWduUmVmID0gdXNlRm9ya1JlZihjaGlsZHJlbi5yZWYsIHJlZik7XG4gIHZhciBoYW5kbGVSZWYgPSB1c2VGb3JrUmVmKGVuYWJsZVN0cmljdE1vZGVDb21wYXQgPyBub2RlUmVmIDogdW5kZWZpbmVkLCBmb3JlaWduUmVmKTtcblxuICB2YXIgbm9ybWFsaXplZFRyYW5zaXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uIG5vcm1hbGl6ZWRUcmFuc2l0aW9uQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGVPckFwcGVhcmluZywgbWF5YmVBcHBlYXJpbmcpIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3JlZiA9IGVuYWJsZVN0cmljdE1vZGVDb21wYXQgPyBbbm9kZVJlZi5jdXJyZW50LCBub2RlT3JBcHBlYXJpbmddIDogW25vZGVPckFwcGVhcmluZywgbWF5YmVBcHBlYXJpbmddLFxuICAgICAgICAgICAgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgIG5vZGUgPSBfcmVmMlswXSxcbiAgICAgICAgICAgIGlzQXBwZWFyaW5nID0gX3JlZjJbMV07IC8vIG9uRW50ZXJYeHggYW5kIG9uRXhpdFh4eCBjYWxsYmFja3MgaGF2ZSBhIGRpZmZlcmVudCBhcmd1bWVudHMubGVuZ3RoIHZhbHVlLlxuXG5cbiAgICAgICAgaWYgKGlzQXBwZWFyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjYWxsYmFjayhub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhub2RlLCBpc0FwcGVhcmluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBoYW5kbGVFbnRlcmluZyA9IG5vcm1hbGl6ZWRUcmFuc2l0aW9uQ2FsbGJhY2sob25FbnRlcmluZyk7XG4gIHZhciBoYW5kbGVFbnRlciA9IG5vcm1hbGl6ZWRUcmFuc2l0aW9uQ2FsbGJhY2soZnVuY3Rpb24gKG5vZGUsIGlzQXBwZWFyaW5nKSB7XG4gICAgcmVmbG93KG5vZGUpOyAvLyBTbyB0aGUgYW5pbWF0aW9uIGFsd2F5cyBzdGFydCBmcm9tIHRoZSBzdGFydC5cblxuICAgIHZhciBfZ2V0VHJhbnNpdGlvblByb3BzID0gZ2V0VHJhbnNpdGlvblByb3BzKHtcbiAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgIHRpbWVvdXQ6IHRpbWVvdXRcbiAgICB9LCB7XG4gICAgICBtb2RlOiAnZW50ZXInXG4gICAgfSksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9nZXRUcmFuc2l0aW9uUHJvcHMuZHVyYXRpb24sXG4gICAgICAgIGRlbGF5ID0gX2dldFRyYW5zaXRpb25Qcm9wcy5kZWxheTtcblxuICAgIHZhciBkdXJhdGlvbjtcblxuICAgIGlmICh0aW1lb3V0ID09PSAnYXV0bycpIHtcbiAgICAgIGR1cmF0aW9uID0gdGhlbWUudHJhbnNpdGlvbnMuZ2V0QXV0b0hlaWdodER1cmF0aW9uKG5vZGUuY2xpZW50SGVpZ2h0KTtcbiAgICAgIGF1dG9UaW1lb3V0LmN1cnJlbnQgPSBkdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb247XG4gICAgfVxuXG4gICAgbm9kZS5zdHlsZS50cmFuc2l0aW9uID0gW3RoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgnb3BhY2l0eScsIHtcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgIGRlbGF5OiBkZWxheVxuICAgIH0pLCB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ3RyYW5zZm9ybScsIHtcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAqIDAuNjY2LFxuICAgICAgZGVsYXk6IGRlbGF5XG4gICAgfSldLmpvaW4oJywnKTtcblxuICAgIGlmIChvbkVudGVyKSB7XG4gICAgICBvbkVudGVyKG5vZGUsIGlzQXBwZWFyaW5nKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgaGFuZGxlRW50ZXJlZCA9IG5vcm1hbGl6ZWRUcmFuc2l0aW9uQ2FsbGJhY2sob25FbnRlcmVkKTtcbiAgdmFyIGhhbmRsZUV4aXRpbmcgPSBub3JtYWxpemVkVHJhbnNpdGlvbkNhbGxiYWNrKG9uRXhpdGluZyk7XG4gIHZhciBoYW5kbGVFeGl0ID0gbm9ybWFsaXplZFRyYW5zaXRpb25DYWxsYmFjayhmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBfZ2V0VHJhbnNpdGlvblByb3BzMiA9IGdldFRyYW5zaXRpb25Qcm9wcyh7XG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICB0aW1lb3V0OiB0aW1lb3V0XG4gICAgfSwge1xuICAgICAgbW9kZTogJ2V4aXQnXG4gICAgfSksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9nZXRUcmFuc2l0aW9uUHJvcHMyLmR1cmF0aW9uLFxuICAgICAgICBkZWxheSA9IF9nZXRUcmFuc2l0aW9uUHJvcHMyLmRlbGF5O1xuXG4gICAgdmFyIGR1cmF0aW9uO1xuXG4gICAgaWYgKHRpbWVvdXQgPT09ICdhdXRvJykge1xuICAgICAgZHVyYXRpb24gPSB0aGVtZS50cmFuc2l0aW9ucy5nZXRBdXRvSGVpZ2h0RHVyYXRpb24obm9kZS5jbGllbnRIZWlnaHQpO1xuICAgICAgYXV0b1RpbWVvdXQuY3VycmVudCA9IGR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdXJhdGlvbiA9IHRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICB9XG5cbiAgICBub2RlLnN0eWxlLnRyYW5zaXRpb24gPSBbdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKCdvcGFjaXR5Jywge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgZGVsYXk6IGRlbGF5XG4gICAgfSksIHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgndHJhbnNmb3JtJywge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uICogMC42NjYsXG4gICAgICBkZWxheTogZGVsYXkgfHwgZHVyYXRpb24gKiAwLjMzM1xuICAgIH0pXS5qb2luKCcsJyk7XG4gICAgbm9kZS5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gZ2V0U2NhbGUoMC43NSk7XG5cbiAgICBpZiAob25FeGl0KSB7XG4gICAgICBvbkV4aXQobm9kZSk7XG4gICAgfVxuICB9KTtcbiAgdmFyIGhhbmRsZUV4aXRlZCA9IG5vcm1hbGl6ZWRUcmFuc2l0aW9uQ2FsbGJhY2sob25FeGl0ZWQpO1xuXG4gIHZhciBhZGRFbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEVuZExpc3RlbmVyKG5vZGVPck5leHQsIG1heWJlTmV4dCkge1xuICAgIHZhciBuZXh0ID0gZW5hYmxlU3RyaWN0TW9kZUNvbXBhdCA/IG5vZGVPck5leHQgOiBtYXliZU5leHQ7XG5cbiAgICBpZiAodGltZW91dCA9PT0gJ2F1dG8nKSB7XG4gICAgICB0aW1lci5jdXJyZW50ID0gc2V0VGltZW91dChuZXh0LCBhdXRvVGltZW91dC5jdXJyZW50IHx8IDApO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIuY3VycmVudCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbkNvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIGFwcGVhcjogdHJ1ZSxcbiAgICBpbjogaW5Qcm9wLFxuICAgIG5vZGVSZWY6IGVuYWJsZVN0cmljdE1vZGVDb21wYXQgPyBub2RlUmVmIDogdW5kZWZpbmVkLFxuICAgIG9uRW50ZXI6IGhhbmRsZUVudGVyLFxuICAgIG9uRW50ZXJlZDogaGFuZGxlRW50ZXJlZCxcbiAgICBvbkVudGVyaW5nOiBoYW5kbGVFbnRlcmluZyxcbiAgICBvbkV4aXQ6IGhhbmRsZUV4aXQsXG4gICAgb25FeGl0ZWQ6IGhhbmRsZUV4aXRlZCxcbiAgICBvbkV4aXRpbmc6IGhhbmRsZUV4aXRpbmcsXG4gICAgYWRkRW5kTGlzdGVuZXI6IGFkZEVuZExpc3RlbmVyLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQgPT09ICdhdXRvJyA/IG51bGwgOiB0aW1lb3V0XG4gIH0sIG90aGVyKSwgZnVuY3Rpb24gKHN0YXRlLCBjaGlsZFByb3BzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGRyZW4sIF9leHRlbmRzKHtcbiAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7XG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIHRyYW5zZm9ybTogZ2V0U2NhbGUoMC43NSksXG4gICAgICAgIHZpc2liaWxpdHk6IHN0YXRlID09PSAnZXhpdGVkJyAmJiAhaW5Qcm9wID8gJ2hpZGRlbicgOiB1bmRlZmluZWRcbiAgICAgIH0sIHN0eWxlc1tzdGF0ZV0sIHN0eWxlLCBjaGlsZHJlbi5wcm9wcy5zdHlsZSksXG4gICAgICByZWY6IGhhbmRsZVJlZlxuICAgIH0sIGNoaWxkUHJvcHMpKTtcbiAgfSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IEdyb3cucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQSBzaW5nbGUgY2hpbGQgY29udGVudCBlbGVtZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5lbGVtZW50LFxuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhpcyBwcm9wIGlmIHlvdSBlbmNvdW50ZXIgJ0Z1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMnLFxuICAgKiB1c2UgYHVuc3RhYmxlX2NyZWF0ZVN0cmljdE1vZGVUaGVtZWAsXG4gICAqIGFuZCBjYW4ndCBmb3J3YXJkIHRoZSByZWYgaW4gdGhlIGNoaWxkIGNvbXBvbmVudC5cbiAgICovXG4gIGRpc2FibGVTdHJpY3RNb2RlQ29tcGF0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBzaG93IHRoZSBjb21wb25lbnQ7IHRyaWdnZXJzIHRoZSBlbnRlciBvciBleGl0IGFuaW1hdGlvbi5cbiAgICovXG4gIGluOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25FbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRW50ZXJlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRW50ZXJpbmc6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkV4aXQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkV4aXRlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRXhpdGluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24gZm9yIHRoZSB0cmFuc2l0aW9uLCBpbiBtaWxsaXNlY29uZHMuXG4gICAqIFlvdSBtYXkgc3BlY2lmeSBhIHNpbmdsZSB0aW1lb3V0IGZvciBhbGwgdHJhbnNpdGlvbnMsIG9yIGluZGl2aWR1YWxseSB3aXRoIGFuIG9iamVjdC5cbiAgICpcbiAgICogU2V0IHRvICdhdXRvJyB0byBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZSB0cmFuc2l0aW9uIHRpbWUgYmFzZWQgb24gaGVpZ2h0LlxuICAgKi9cbiAgdGltZW91dDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9uZU9mKFsnYXV0byddKSwgUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBhcHBlYXI6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgZW50ZXI6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgZXhpdDogUHJvcFR5cGVzLm51bWJlclxuICB9KV0pXG59IDogdm9pZCAwO1xuR3Jvdy5tdWlTdXBwb3J0QXV0byA9IHRydWU7XG5leHBvcnQgZGVmYXVsdCBHcm93OyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgY2hhaW5Qcm9wVHlwZXMsIGVsZW1lbnRUeXBlQWNjZXB0aW5nUmVmLCByZWZUeXBlLCBIVE1MRWxlbWVudFR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJy4uL3V0aWxzL2RlYm91bmNlJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IG93bmVyRG9jdW1lbnQgZnJvbSAnLi4vdXRpbHMvb3duZXJEb2N1bWVudCc7XG5pbXBvcnQgb3duZXJXaW5kb3cgZnJvbSAnLi4vdXRpbHMvb3duZXJXaW5kb3cnO1xuaW1wb3J0IGNyZWF0ZUNoYWluZWRGdW5jdGlvbiBmcm9tICcuLi91dGlscy9jcmVhdGVDaGFpbmVkRnVuY3Rpb24nO1xuaW1wb3J0IGRlcHJlY2F0ZWRQcm9wVHlwZSBmcm9tICcuLi91dGlscy9kZXByZWNhdGVkUHJvcFR5cGUnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IE1vZGFsIGZyb20gJy4uL01vZGFsJztcbmltcG9ydCBHcm93IGZyb20gJy4uL0dyb3cnO1xuaW1wb3J0IFBhcGVyIGZyb20gJy4uL1BhcGVyJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRPZmZzZXRUb3AocmVjdCwgdmVydGljYWwpIHtcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgaWYgKHR5cGVvZiB2ZXJ0aWNhbCA9PT0gJ251bWJlcicpIHtcbiAgICBvZmZzZXQgPSB2ZXJ0aWNhbDtcbiAgfSBlbHNlIGlmICh2ZXJ0aWNhbCA9PT0gJ2NlbnRlcicpIHtcbiAgICBvZmZzZXQgPSByZWN0LmhlaWdodCAvIDI7XG4gIH0gZWxzZSBpZiAodmVydGljYWwgPT09ICdib3R0b20nKSB7XG4gICAgb2Zmc2V0ID0gcmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE9mZnNldExlZnQocmVjdCwgaG9yaXpvbnRhbCkge1xuICB2YXIgb2Zmc2V0ID0gMDtcblxuICBpZiAodHlwZW9mIGhvcml6b250YWwgPT09ICdudW1iZXInKSB7XG4gICAgb2Zmc2V0ID0gaG9yaXpvbnRhbDtcbiAgfSBlbHNlIGlmIChob3Jpem9udGFsID09PSAnY2VudGVyJykge1xuICAgIG9mZnNldCA9IHJlY3Qud2lkdGggLyAyO1xuICB9IGVsc2UgaWYgKGhvcml6b250YWwgPT09ICdyaWdodCcpIHtcbiAgICBvZmZzZXQgPSByZWN0LndpZHRoO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtT3JpZ2luVmFsdWUodHJhbnNmb3JtT3JpZ2luKSB7XG4gIHJldHVybiBbdHJhbnNmb3JtT3JpZ2luLmhvcml6b250YWwsIHRyYW5zZm9ybU9yaWdpbi52ZXJ0aWNhbF0ubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuID09PSAnbnVtYmVyJyA/IFwiXCIuY29uY2F0KG4sIFwicHhcIikgOiBuO1xuICB9KS5qb2luKCcgJyk7XG59IC8vIFN1bSB0aGUgc2Nyb2xsVG9wIGJldHdlZW4gdHdvIGVsZW1lbnRzLlxuXG5cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChwYXJlbnQsIGNoaWxkKSB7XG4gIHZhciBlbGVtZW50ID0gY2hpbGQ7XG4gIHZhciBzY3JvbGxUb3AgPSAwO1xuXG4gIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQgIT09IHBhcmVudCkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgc2Nyb2xsVG9wICs9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICB9XG5cbiAgcmV0dXJuIHNjcm9sbFRvcDtcbn1cblxuZnVuY3Rpb24gZ2V0QW5jaG9yRWwoYW5jaG9yRWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBhbmNob3JFbCA9PT0gJ2Z1bmN0aW9uJyA/IGFuY2hvckVsKCkgOiBhbmNob3JFbDtcbn1cblxuZXhwb3J0IHZhciBzdHlsZXMgPSB7XG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gIHJvb3Q6IHt9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgUGFwZXJgIGNvbXBvbmVudC4gKi9cbiAgcGFwZXI6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBvdmVyZmxvd1k6ICdhdXRvJyxcbiAgICBvdmVyZmxvd1g6ICdoaWRkZW4nLFxuICAgIC8vIFNvIHdlIHNlZSB0aGUgcG9wb3ZlciB3aGVuIGl0J3MgZW1wdHkuXG4gICAgLy8gSXQncyBtb3N0IGxpa2VseSBvbiBpc3N1ZSBvbiB1c2VybGFuZC5cbiAgICBtaW5XaWR0aDogMTYsXG4gICAgbWluSGVpZ2h0OiAxNixcbiAgICBtYXhXaWR0aDogJ2NhbGMoMTAwJSAtIDMycHgpJyxcbiAgICBtYXhIZWlnaHQ6ICdjYWxjKDEwMCUgLSAzMnB4KScsXG4gICAgLy8gV2UgZGlzYWJsZSB0aGUgZm9jdXMgcmluZyBmb3IgbW91c2UsIHRvdWNoIGFuZCBrZXlib2FyZCB1c2Vycy5cbiAgICBvdXRsaW5lOiAwXG4gIH1cbn07XG52YXIgUG9wb3ZlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFBvcG92ZXIocHJvcHMsIHJlZikge1xuICB2YXIgYWN0aW9uID0gcHJvcHMuYWN0aW9uLFxuICAgICAgYW5jaG9yRWwgPSBwcm9wcy5hbmNob3JFbCxcbiAgICAgIF9wcm9wcyRhbmNob3JPcmlnaW4gPSBwcm9wcy5hbmNob3JPcmlnaW4sXG4gICAgICBhbmNob3JPcmlnaW4gPSBfcHJvcHMkYW5jaG9yT3JpZ2luID09PSB2b2lkIDAgPyB7XG4gICAgdmVydGljYWw6ICd0b3AnLFxuICAgIGhvcml6b250YWw6ICdsZWZ0J1xuICB9IDogX3Byb3BzJGFuY2hvck9yaWdpbixcbiAgICAgIGFuY2hvclBvc2l0aW9uID0gcHJvcHMuYW5jaG9yUG9zaXRpb24sXG4gICAgICBfcHJvcHMkYW5jaG9yUmVmZXJlbmMgPSBwcm9wcy5hbmNob3JSZWZlcmVuY2UsXG4gICAgICBhbmNob3JSZWZlcmVuY2UgPSBfcHJvcHMkYW5jaG9yUmVmZXJlbmMgPT09IHZvaWQgMCA/ICdhbmNob3JFbCcgOiBfcHJvcHMkYW5jaG9yUmVmZXJlbmMsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjb250YWluZXJQcm9wID0gcHJvcHMuY29udGFpbmVyLFxuICAgICAgX3Byb3BzJGVsZXZhdGlvbiA9IHByb3BzLmVsZXZhdGlvbixcbiAgICAgIGVsZXZhdGlvbiA9IF9wcm9wcyRlbGV2YXRpb24gPT09IHZvaWQgMCA/IDggOiBfcHJvcHMkZWxldmF0aW9uLFxuICAgICAgZ2V0Q29udGVudEFuY2hvckVsID0gcHJvcHMuZ2V0Q29udGVudEFuY2hvckVsLFxuICAgICAgX3Byb3BzJG1hcmdpblRocmVzaG9sID0gcHJvcHMubWFyZ2luVGhyZXNob2xkLFxuICAgICAgbWFyZ2luVGhyZXNob2xkID0gX3Byb3BzJG1hcmdpblRocmVzaG9sID09PSB2b2lkIDAgPyAxNiA6IF9wcm9wcyRtYXJnaW5UaHJlc2hvbCxcbiAgICAgIG9uRW50ZXIgPSBwcm9wcy5vbkVudGVyLFxuICAgICAgb25FbnRlcmVkID0gcHJvcHMub25FbnRlcmVkLFxuICAgICAgb25FbnRlcmluZyA9IHByb3BzLm9uRW50ZXJpbmcsXG4gICAgICBvbkV4aXQgPSBwcm9wcy5vbkV4aXQsXG4gICAgICBvbkV4aXRlZCA9IHByb3BzLm9uRXhpdGVkLFxuICAgICAgb25FeGl0aW5nID0gcHJvcHMub25FeGl0aW5nLFxuICAgICAgb3BlbiA9IHByb3BzLm9wZW4sXG4gICAgICBfcHJvcHMkUGFwZXJQcm9wcyA9IHByb3BzLlBhcGVyUHJvcHMsXG4gICAgICBQYXBlclByb3BzID0gX3Byb3BzJFBhcGVyUHJvcHMgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJFBhcGVyUHJvcHMsXG4gICAgICBfcHJvcHMkdHJhbnNmb3JtT3JpZ2kgPSBwcm9wcy50cmFuc2Zvcm1PcmlnaW4sXG4gICAgICB0cmFuc2Zvcm1PcmlnaW4gPSBfcHJvcHMkdHJhbnNmb3JtT3JpZ2kgPT09IHZvaWQgMCA/IHtcbiAgICB2ZXJ0aWNhbDogJ3RvcCcsXG4gICAgaG9yaXpvbnRhbDogJ2xlZnQnXG4gIH0gOiBfcHJvcHMkdHJhbnNmb3JtT3JpZ2ksXG4gICAgICBfcHJvcHMkVHJhbnNpdGlvbkNvbXAgPSBwcm9wcy5UcmFuc2l0aW9uQ29tcG9uZW50LFxuICAgICAgVHJhbnNpdGlvbkNvbXBvbmVudCA9IF9wcm9wcyRUcmFuc2l0aW9uQ29tcCA9PT0gdm9pZCAwID8gR3JvdyA6IF9wcm9wcyRUcmFuc2l0aW9uQ29tcCxcbiAgICAgIF9wcm9wcyR0cmFuc2l0aW9uRHVyYSA9IHByb3BzLnRyYW5zaXRpb25EdXJhdGlvbixcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvblByb3AgPSBfcHJvcHMkdHJhbnNpdGlvbkR1cmEgPT09IHZvaWQgMCA/ICdhdXRvJyA6IF9wcm9wcyR0cmFuc2l0aW9uRHVyYSxcbiAgICAgIF9wcm9wcyRUcmFuc2l0aW9uUHJvcCA9IHByb3BzLlRyYW5zaXRpb25Qcm9wcyxcbiAgICAgIFRyYW5zaXRpb25Qcm9wcyA9IF9wcm9wcyRUcmFuc2l0aW9uUHJvcCA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkVHJhbnNpdGlvblByb3AsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYWN0aW9uXCIsIFwiYW5jaG9yRWxcIiwgXCJhbmNob3JPcmlnaW5cIiwgXCJhbmNob3JQb3NpdGlvblwiLCBcImFuY2hvclJlZmVyZW5jZVwiLCBcImNoaWxkcmVuXCIsIFwiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcImNvbnRhaW5lclwiLCBcImVsZXZhdGlvblwiLCBcImdldENvbnRlbnRBbmNob3JFbFwiLCBcIm1hcmdpblRocmVzaG9sZFwiLCBcIm9uRW50ZXJcIiwgXCJvbkVudGVyZWRcIiwgXCJvbkVudGVyaW5nXCIsIFwib25FeGl0XCIsIFwib25FeGl0ZWRcIiwgXCJvbkV4aXRpbmdcIiwgXCJvcGVuXCIsIFwiUGFwZXJQcm9wc1wiLCBcInRyYW5zZm9ybU9yaWdpblwiLCBcIlRyYW5zaXRpb25Db21wb25lbnRcIiwgXCJ0cmFuc2l0aW9uRHVyYXRpb25cIiwgXCJUcmFuc2l0aW9uUHJvcHNcIl0pO1xuXG4gIHZhciBwYXBlclJlZiA9IFJlYWN0LnVzZVJlZigpOyAvLyBSZXR1cm5zIHRoZSB0b3AvbGVmdCBvZmZzZXQgb2YgdGhlIHBvc2l0aW9uXG4gIC8vIHRvIGF0dGFjaCB0byBvbiB0aGUgYW5jaG9yIGVsZW1lbnQgKG9yIGJvZHkgaWYgbm9uZSBpcyBwcm92aWRlZClcblxuICB2YXIgZ2V0QW5jaG9yT2Zmc2V0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbnRlbnRBbmNob3JPZmZzZXQpIHtcbiAgICBpZiAoYW5jaG9yUmVmZXJlbmNlID09PSAnYW5jaG9yUG9zaXRpb24nKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoIWFuY2hvclBvc2l0aW9uKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignTWF0ZXJpYWwtVUk6IFlvdSBuZWVkIHRvIHByb3ZpZGUgYSBgYW5jaG9yUG9zaXRpb25gIHByb3Agd2hlbiB1c2luZyAnICsgJzxQb3BvdmVyIGFuY2hvclJlZmVyZW5jZT1cImFuY2hvclBvc2l0aW9uXCIgLz4uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFuY2hvclBvc2l0aW9uO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlZEFuY2hvckVsID0gZ2V0QW5jaG9yRWwoYW5jaG9yRWwpOyAvLyBJZiBhbiBhbmNob3IgZWxlbWVudCB3YXNuJ3QgcHJvdmlkZWQsIGp1c3QgdXNlIHRoZSBwYXJlbnQgYm9keSBlbGVtZW50IG9mIHRoaXMgUG9wb3ZlclxuXG4gICAgdmFyIGFuY2hvckVsZW1lbnQgPSByZXNvbHZlZEFuY2hvckVsICYmIHJlc29sdmVkQW5jaG9yRWwubm9kZVR5cGUgPT09IDEgPyByZXNvbHZlZEFuY2hvckVsIDogb3duZXJEb2N1bWVudChwYXBlclJlZi5jdXJyZW50KS5ib2R5O1xuICAgIHZhciBhbmNob3JSZWN0ID0gYW5jaG9yRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgYm94ID0gYW5jaG9yRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiYgYm94LnRvcCA9PT0gMCAmJiBib3gubGVmdCA9PT0gMCAmJiBib3gucmlnaHQgPT09IDAgJiYgYm94LmJvdHRvbSA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oWydNYXRlcmlhbC1VSTogVGhlIGBhbmNob3JFbGAgcHJvcCBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50IGlzIGludmFsaWQuJywgJ1RoZSBhbmNob3IgZWxlbWVudCBzaG91bGQgYmUgcGFydCBvZiB0aGUgZG9jdW1lbnQgbGF5b3V0LicsIFwiTWFrZSBzdXJlIHRoZSBlbGVtZW50IGlzIHByZXNlbnQgaW4gdGhlIGRvY3VtZW50IG9yIHRoYXQgaXQncyBub3QgZGlzcGxheSBub25lLlwiXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFuY2hvclZlcnRpY2FsID0gY29udGVudEFuY2hvck9mZnNldCA9PT0gMCA/IGFuY2hvck9yaWdpbi52ZXJ0aWNhbCA6ICdjZW50ZXInO1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IGFuY2hvclJlY3QudG9wICsgZ2V0T2Zmc2V0VG9wKGFuY2hvclJlY3QsIGFuY2hvclZlcnRpY2FsKSxcbiAgICAgIGxlZnQ6IGFuY2hvclJlY3QubGVmdCArIGdldE9mZnNldExlZnQoYW5jaG9yUmVjdCwgYW5jaG9yT3JpZ2luLmhvcml6b250YWwpXG4gICAgfTtcbiAgfSwgW2FuY2hvckVsLCBhbmNob3JPcmlnaW4uaG9yaXpvbnRhbCwgYW5jaG9yT3JpZ2luLnZlcnRpY2FsLCBhbmNob3JQb3NpdGlvbiwgYW5jaG9yUmVmZXJlbmNlXSk7IC8vIFJldHVybnMgdGhlIHZlcnRpY2FsIG9mZnNldCBvZiBpbm5lciBjb250ZW50IHRvIGFuY2hvciB0aGUgdHJhbnNmb3JtIG9uIGlmIHByb3ZpZGVkXG5cbiAgdmFyIGdldENvbnRlbnRBbmNob3JPZmZzZXQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBjb250ZW50QW5jaG9yT2Zmc2V0ID0gMDtcblxuICAgIGlmIChnZXRDb250ZW50QW5jaG9yRWwgJiYgYW5jaG9yUmVmZXJlbmNlID09PSAnYW5jaG9yRWwnKSB7XG4gICAgICB2YXIgY29udGVudEFuY2hvckVsID0gZ2V0Q29udGVudEFuY2hvckVsKGVsZW1lbnQpO1xuXG4gICAgICBpZiAoY29udGVudEFuY2hvckVsICYmIGVsZW1lbnQuY29udGFpbnMoY29udGVudEFuY2hvckVsKSkge1xuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQsIGNvbnRlbnRBbmNob3JFbCk7XG4gICAgICAgIGNvbnRlbnRBbmNob3JPZmZzZXQgPSBjb250ZW50QW5jaG9yRWwub2Zmc2V0VG9wICsgY29udGVudEFuY2hvckVsLmNsaWVudEhlaWdodCAvIDIgLSBzY3JvbGxUb3AgfHwgMDtcbiAgICAgIH0gLy8gIT0gdGhlIGRlZmF1bHQgdmFsdWVcblxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoYW5jaG9yT3JpZ2luLnZlcnRpY2FsICE9PSAndG9wJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoWydNYXRlcmlhbC1VSTogWW91IGNhbiBub3QgY2hhbmdlIHRoZSBkZWZhdWx0IGBhbmNob3JPcmlnaW4udmVydGljYWxgIHZhbHVlICcsICd3aGVuIGFsc28gcHJvdmlkaW5nIHRoZSBgZ2V0Q29udGVudEFuY2hvckVsYCBwcm9wIHRvIHRoZSBwb3BvdmVyIGNvbXBvbmVudC4nLCAnT25seSB1c2Ugb25lIG9mIHRoZSB0d28gcHJvcHMuJywgJ1NldCBgZ2V0Q29udGVudEFuY2hvckVsYCB0byBgbnVsbCB8IHVuZGVmaW5lZGAnICsgJyBvciBsZWF2ZSBgYW5jaG9yT3JpZ2luLnZlcnRpY2FsYCB1bmNoYW5nZWQuJ10uam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRlbnRBbmNob3JPZmZzZXQ7XG4gIH0sIFthbmNob3JPcmlnaW4udmVydGljYWwsIGFuY2hvclJlZmVyZW5jZSwgZ2V0Q29udGVudEFuY2hvckVsXSk7IC8vIFJldHVybiB0aGUgYmFzZSB0cmFuc2Zvcm0gb3JpZ2luIHVzaW5nIHRoZSBlbGVtZW50XG4gIC8vIGFuZCB0YWtpbmcgdGhlIGNvbnRlbnQgYW5jaG9yIG9mZnNldCBpbnRvIGFjY291bnQgaWYgaW4gdXNlXG5cbiAgdmFyIGdldFRyYW5zZm9ybU9yaWdpbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlbGVtUmVjdCkge1xuICAgIHZhciBjb250ZW50QW5jaG9yT2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJ0aWNhbDogZ2V0T2Zmc2V0VG9wKGVsZW1SZWN0LCB0cmFuc2Zvcm1PcmlnaW4udmVydGljYWwpICsgY29udGVudEFuY2hvck9mZnNldCxcbiAgICAgIGhvcml6b250YWw6IGdldE9mZnNldExlZnQoZWxlbVJlY3QsIHRyYW5zZm9ybU9yaWdpbi5ob3Jpem9udGFsKVxuICAgIH07XG4gIH0sIFt0cmFuc2Zvcm1PcmlnaW4uaG9yaXpvbnRhbCwgdHJhbnNmb3JtT3JpZ2luLnZlcnRpY2FsXSk7XG4gIHZhciBnZXRQb3NpdGlvbmluZ1N0eWxlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgcGFyZW50IGhhcyByZXF1ZXN0ZWQgYW5jaG9yaW5nIG9uIGFuIGlubmVyIGNvbnRlbnQgbm9kZVxuICAgIHZhciBjb250ZW50QW5jaG9yT2Zmc2V0ID0gZ2V0Q29udGVudEFuY2hvck9mZnNldChlbGVtZW50KTtcbiAgICB2YXIgZWxlbVJlY3QgPSB7XG4gICAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgICB9OyAvLyBHZXQgdGhlIHRyYW5zZm9ybSBvcmlnaW4gcG9pbnQgb24gdGhlIGVsZW1lbnQgaXRzZWxmXG5cbiAgICB2YXIgZWxlbVRyYW5zZm9ybU9yaWdpbiA9IGdldFRyYW5zZm9ybU9yaWdpbihlbGVtUmVjdCwgY29udGVudEFuY2hvck9mZnNldCk7XG5cbiAgICBpZiAoYW5jaG9yUmVmZXJlbmNlID09PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogbnVsbCxcbiAgICAgICAgbGVmdDogbnVsbCxcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBnZXRUcmFuc2Zvcm1PcmlnaW5WYWx1ZShlbGVtVHJhbnNmb3JtT3JpZ2luKVxuICAgICAgfTtcbiAgICB9IC8vIEdldCB0aGUgb2Zmc2V0IG9mIG9mIHRoZSBhbmNob3JpbmcgZWxlbWVudFxuXG5cbiAgICB2YXIgYW5jaG9yT2Zmc2V0ID0gZ2V0QW5jaG9yT2Zmc2V0KGNvbnRlbnRBbmNob3JPZmZzZXQpOyAvLyBDYWxjdWxhdGUgZWxlbWVudCBwb3NpdGlvbmluZ1xuXG4gICAgdmFyIHRvcCA9IGFuY2hvck9mZnNldC50b3AgLSBlbGVtVHJhbnNmb3JtT3JpZ2luLnZlcnRpY2FsO1xuICAgIHZhciBsZWZ0ID0gYW5jaG9yT2Zmc2V0LmxlZnQgLSBlbGVtVHJhbnNmb3JtT3JpZ2luLmhvcml6b250YWw7XG4gICAgdmFyIGJvdHRvbSA9IHRvcCArIGVsZW1SZWN0LmhlaWdodDtcbiAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgZWxlbVJlY3Qud2lkdGg7IC8vIFVzZSB0aGUgcGFyZW50IHdpbmRvdyBvZiB0aGUgYW5jaG9yRWwgaWYgcHJvdmlkZWRcblxuICAgIHZhciBjb250YWluZXJXaW5kb3cgPSBvd25lcldpbmRvdyhnZXRBbmNob3JFbChhbmNob3JFbCkpOyAvLyBXaW5kb3cgdGhyZXNob2xkcyB0YWtpbmcgcmVxdWlyZWQgbWFyZ2luIGludG8gYWNjb3VudFxuXG4gICAgdmFyIGhlaWdodFRocmVzaG9sZCA9IGNvbnRhaW5lcldpbmRvdy5pbm5lckhlaWdodCAtIG1hcmdpblRocmVzaG9sZDtcbiAgICB2YXIgd2lkdGhUaHJlc2hvbGQgPSBjb250YWluZXJXaW5kb3cuaW5uZXJXaWR0aCAtIG1hcmdpblRocmVzaG9sZDsgLy8gQ2hlY2sgaWYgdGhlIHZlcnRpY2FsIGF4aXMgbmVlZHMgc2hpZnRpbmdcblxuICAgIGlmICh0b3AgPCBtYXJnaW5UaHJlc2hvbGQpIHtcbiAgICAgIHZhciBkaWZmID0gdG9wIC0gbWFyZ2luVGhyZXNob2xkO1xuICAgICAgdG9wIC09IGRpZmY7XG4gICAgICBlbGVtVHJhbnNmb3JtT3JpZ2luLnZlcnRpY2FsICs9IGRpZmY7XG4gICAgfSBlbHNlIGlmIChib3R0b20gPiBoZWlnaHRUaHJlc2hvbGQpIHtcbiAgICAgIHZhciBfZGlmZiA9IGJvdHRvbSAtIGhlaWdodFRocmVzaG9sZDtcblxuICAgICAgdG9wIC09IF9kaWZmO1xuICAgICAgZWxlbVRyYW5zZm9ybU9yaWdpbi52ZXJ0aWNhbCArPSBfZGlmZjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGVsZW1SZWN0LmhlaWdodCA+IGhlaWdodFRocmVzaG9sZCAmJiBlbGVtUmVjdC5oZWlnaHQgJiYgaGVpZ2h0VGhyZXNob2xkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoWydNYXRlcmlhbC1VSTogVGhlIHBvcG92ZXIgY29tcG9uZW50IGlzIHRvbyB0YWxsLicsIFwiU29tZSBwYXJ0IG9mIGl0IGNhbiBub3QgYmUgc2VlbiBvbiB0aGUgc2NyZWVuIChcIi5jb25jYXQoZWxlbVJlY3QuaGVpZ2h0IC0gaGVpZ2h0VGhyZXNob2xkLCBcInB4KS5cIiksICdQbGVhc2UgY29uc2lkZXIgYWRkaW5nIGEgYG1heC1oZWlnaHRgIHRvIGltcHJvdmUgdGhlIHVzZXItZXhwZXJpZW5jZS4nXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfSAvLyBDaGVjayBpZiB0aGUgaG9yaXpvbnRhbCBheGlzIG5lZWRzIHNoaWZ0aW5nXG5cblxuICAgIGlmIChsZWZ0IDwgbWFyZ2luVGhyZXNob2xkKSB7XG4gICAgICB2YXIgX2RpZmYyID0gbGVmdCAtIG1hcmdpblRocmVzaG9sZDtcblxuICAgICAgbGVmdCAtPSBfZGlmZjI7XG4gICAgICBlbGVtVHJhbnNmb3JtT3JpZ2luLmhvcml6b250YWwgKz0gX2RpZmYyO1xuICAgIH0gZWxzZSBpZiAocmlnaHQgPiB3aWR0aFRocmVzaG9sZCkge1xuICAgICAgdmFyIF9kaWZmMyA9IHJpZ2h0IC0gd2lkdGhUaHJlc2hvbGQ7XG5cbiAgICAgIGxlZnQgLT0gX2RpZmYzO1xuICAgICAgZWxlbVRyYW5zZm9ybU9yaWdpbi5ob3Jpem9udGFsICs9IF9kaWZmMztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBcIlwiLmNvbmNhdChNYXRoLnJvdW5kKHRvcCksIFwicHhcIiksXG4gICAgICBsZWZ0OiBcIlwiLmNvbmNhdChNYXRoLnJvdW5kKGxlZnQpLCBcInB4XCIpLFxuICAgICAgdHJhbnNmb3JtT3JpZ2luOiBnZXRUcmFuc2Zvcm1PcmlnaW5WYWx1ZShlbGVtVHJhbnNmb3JtT3JpZ2luKVxuICAgIH07XG4gIH0sIFthbmNob3JFbCwgYW5jaG9yUmVmZXJlbmNlLCBnZXRBbmNob3JPZmZzZXQsIGdldENvbnRlbnRBbmNob3JPZmZzZXQsIGdldFRyYW5zZm9ybU9yaWdpbiwgbWFyZ2luVGhyZXNob2xkXSk7XG4gIHZhciBzZXRQb3NpdGlvbmluZ1N0eWxlcyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbWVudCA9IHBhcGVyUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb25pbmcgPSBnZXRQb3NpdGlvbmluZ1N0eWxlKGVsZW1lbnQpO1xuXG4gICAgaWYgKHBvc2l0aW9uaW5nLnRvcCAhPT0gbnVsbCkge1xuICAgICAgZWxlbWVudC5zdHlsZS50b3AgPSBwb3NpdGlvbmluZy50b3A7XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uaW5nLmxlZnQgIT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IHBvc2l0aW9uaW5nLmxlZnQ7XG4gICAgfVxuXG4gICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBwb3NpdGlvbmluZy50cmFuc2Zvcm1PcmlnaW47XG4gIH0sIFtnZXRQb3NpdGlvbmluZ1N0eWxlXSk7XG5cbiAgdmFyIGhhbmRsZUVudGVyaW5nID0gZnVuY3Rpb24gaGFuZGxlRW50ZXJpbmcoZWxlbWVudCwgaXNBcHBlYXJpbmcpIHtcbiAgICBpZiAob25FbnRlcmluZykge1xuICAgICAgb25FbnRlcmluZyhlbGVtZW50LCBpc0FwcGVhcmluZyk7XG4gICAgfVxuXG4gICAgc2V0UG9zaXRpb25pbmdTdHlsZXMoKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUGFwZXJSZWYgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAvLyAjU3RyaWN0TW9kZSByZWFkeVxuICAgIHBhcGVyUmVmLmN1cnJlbnQgPSBSZWFjdERPTS5maW5kRE9NTm9kZShpbnN0YW5jZSk7XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAob3Blbikge1xuICAgICAgc2V0UG9zaXRpb25pbmdTdHlsZXMoKTtcbiAgICB9XG4gIH0pO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGFjdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBvcGVuID8ge1xuICAgICAgdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKCkge1xuICAgICAgICBzZXRQb3NpdGlvbmluZ1N0eWxlcygpO1xuICAgICAgfVxuICAgIH0gOiBudWxsO1xuICB9LCBbb3Blbiwgc2V0UG9zaXRpb25pbmdTdHlsZXNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZVJlc2l6ZSA9IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFBvc2l0aW9uaW5nU3R5bGVzKCk7XG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGhhbmRsZVJlc2l6ZS5jbGVhcigpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgfTtcbiAgfSwgW29wZW4sIHNldFBvc2l0aW9uaW5nU3R5bGVzXSk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb25Qcm9wO1xuXG4gIGlmICh0cmFuc2l0aW9uRHVyYXRpb25Qcm9wID09PSAnYXV0bycgJiYgIVRyYW5zaXRpb25Db21wb25lbnQubXVpU3VwcG9ydEF1dG8pIHtcbiAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSB1bmRlZmluZWQ7XG4gIH0gLy8gSWYgdGhlIGNvbnRhaW5lciBwcm9wIGlzIHByb3ZpZGVkLCB1c2UgdGhhdFxuICAvLyBJZiB0aGUgYW5jaG9yRWwgcHJvcCBpcyBwcm92aWRlZCwgdXNlIGl0cyBwYXJlbnQgYm9keSBlbGVtZW50IGFzIHRoZSBjb250YWluZXJcbiAgLy8gSWYgbmVpdGhlciBhcmUgcHJvdmlkZWQgbGV0IHRoZSBNb2RhbCB0YWtlIGNhcmUgb2YgY2hvb3NpbmcgdGhlIGNvbnRhaW5lclxuXG5cbiAgdmFyIGNvbnRhaW5lciA9IGNvbnRhaW5lclByb3AgfHwgKGFuY2hvckVsID8gb3duZXJEb2N1bWVudChnZXRBbmNob3JFbChhbmNob3JFbCkpLmJvZHkgOiB1bmRlZmluZWQpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTW9kYWwsIF9leHRlbmRzKHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBvcGVuOiBvcGVuLFxuICAgIHJlZjogcmVmLFxuICAgIEJhY2tkcm9wUHJvcHM6IHtcbiAgICAgIGludmlzaWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lKVxuICB9LCBvdGhlciksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRyYW5zaXRpb25Db21wb25lbnQsIF9leHRlbmRzKHtcbiAgICBhcHBlYXI6IHRydWUsXG4gICAgaW46IG9wZW4sXG4gICAgb25FbnRlcjogb25FbnRlcixcbiAgICBvbkVudGVyZWQ6IG9uRW50ZXJlZCxcbiAgICBvbkV4aXQ6IG9uRXhpdCxcbiAgICBvbkV4aXRlZDogb25FeGl0ZWQsXG4gICAgb25FeGl0aW5nOiBvbkV4aXRpbmcsXG4gICAgdGltZW91dDogdHJhbnNpdGlvbkR1cmF0aW9uXG4gIH0sIFRyYW5zaXRpb25Qcm9wcywge1xuICAgIG9uRW50ZXJpbmc6IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihoYW5kbGVFbnRlcmluZywgVHJhbnNpdGlvblByb3BzLm9uRW50ZXJpbmcpXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQYXBlciwgX2V4dGVuZHMoe1xuICAgIGVsZXZhdGlvbjogZWxldmF0aW9uLFxuICAgIHJlZjogaGFuZGxlUGFwZXJSZWZcbiAgfSwgUGFwZXJQcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnBhcGVyLCBQYXBlclByb3BzLmNsYXNzTmFtZSlcbiAgfSksIGNoaWxkcmVuKSkpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBQb3BvdmVyLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIEEgcmVmIGZvciBpbXBlcmF0aXZlIGFjdGlvbnMuXG4gICAqIEl0IGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHVwZGF0ZVBvc2l0aW9uKCkgYWN0aW9uLlxuICAgKi9cbiAgYWN0aW9uOiByZWZUeXBlLFxuXG4gIC8qKlxuICAgKiBBIEhUTUwgZWxlbWVudCwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgaXQuXG4gICAqIEl0J3MgdXNlZCB0byBzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyLlxuICAgKi9cbiAgYW5jaG9yRWw6IGNoYWluUHJvcFR5cGVzKFByb3BUeXBlcy5vbmVPZlR5cGUoW0hUTUxFbGVtZW50VHlwZSwgUHJvcFR5cGVzLmZ1bmNdKSwgZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgaWYgKHByb3BzLm9wZW4gJiYgKCFwcm9wcy5hbmNob3JSZWZlcmVuY2UgfHwgcHJvcHMuYW5jaG9yUmVmZXJlbmNlID09PSAnYW5jaG9yRWwnKSkge1xuICAgICAgdmFyIHJlc29sdmVkQW5jaG9yRWwgPSBnZXRBbmNob3JFbChwcm9wcy5hbmNob3JFbCk7XG5cbiAgICAgIGlmIChyZXNvbHZlZEFuY2hvckVsICYmIHJlc29sdmVkQW5jaG9yRWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgdmFyIGJveCA9IHJlc29sdmVkQW5jaG9yRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiYgYm94LnRvcCA9PT0gMCAmJiBib3gubGVmdCA9PT0gMCAmJiBib3gucmlnaHQgPT09IDAgJiYgYm94LmJvdHRvbSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoWydNYXRlcmlhbC1VSTogVGhlIGBhbmNob3JFbGAgcHJvcCBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50IGlzIGludmFsaWQuJywgJ1RoZSBhbmNob3IgZWxlbWVudCBzaG91bGQgYmUgcGFydCBvZiB0aGUgZG9jdW1lbnQgbGF5b3V0LicsIFwiTWFrZSBzdXJlIHRoZSBlbGVtZW50IGlzIHByZXNlbnQgaW4gdGhlIGRvY3VtZW50IG9yIHRoYXQgaXQncyBub3QgZGlzcGxheSBub25lLlwiXS5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoWydNYXRlcmlhbC1VSTogVGhlIGBhbmNob3JFbGAgcHJvcCBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50IGlzIGludmFsaWQuJywgXCJJdCBzaG91bGQgYmUgYW4gRWxlbWVudCBpbnN0YW5jZSBidXQgaXQncyBgXCIuY29uY2F0KHJlc29sdmVkQW5jaG9yRWwsIFwiYCBpbnN0ZWFkLlwiKV0uam9pbignXFxuJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9KSxcblxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgcG9pbnQgb24gdGhlIGFuY2hvciB3aGVyZSB0aGUgcG9wb3ZlcidzXG4gICAqIGBhbmNob3JFbGAgd2lsbCBhdHRhY2ggdG8uIFRoaXMgaXMgbm90IHVzZWQgd2hlbiB0aGVcbiAgICogYW5jaG9yUmVmZXJlbmNlIGlzICdhbmNob3JQb3NpdGlvbicuXG4gICAqXG4gICAqIE9wdGlvbnM6XG4gICAqIHZlcnRpY2FsOiBbdG9wLCBjZW50ZXIsIGJvdHRvbV07XG4gICAqIGhvcml6b250YWw6IFtsZWZ0LCBjZW50ZXIsIHJpZ2h0XS5cbiAgICovXG4gIGFuY2hvck9yaWdpbjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBob3Jpem9udGFsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub25lT2YoWydjZW50ZXInLCAnbGVmdCcsICdyaWdodCddKSwgUHJvcFR5cGVzLm51bWJlcl0pLmlzUmVxdWlyZWQsXG4gICAgdmVydGljYWw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbJ2JvdHRvbScsICdjZW50ZXInLCAndG9wJ10pLCBQcm9wVHlwZXMubnVtYmVyXSkuaXNSZXF1aXJlZFxuICB9KSxcblxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgcG9zaXRpb24gdGhhdCBtYXkgYmUgdXNlZFxuICAgKiB0byBzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyLlxuICAgKiBUaGUgY29vcmRpbmF0ZXMgYXJlIHJlbGF0aXZlIHRvXG4gICAqIHRoZSBhcHBsaWNhdGlvbidzIGNsaWVudCBhcmVhLlxuICAgKi9cbiAgYW5jaG9yUG9zaXRpb246IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgbGVmdDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIHRvcDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gIH0pLFxuXG4gIC8qKlxuICAgKiBUaGlzIGRldGVybWluZXMgd2hpY2ggYW5jaG9yIHByb3AgdG8gcmVmZXIgdG8gdG8gc2V0XG4gICAqIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wb3Zlci5cbiAgICovXG4gIGFuY2hvclJlZmVyZW5jZTogUHJvcFR5cGVzLm9uZU9mKFsnYW5jaG9yRWwnLCAnYW5jaG9yUG9zaXRpb24nLCAnbm9uZSddKSxcblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIEEgSFRNTCBlbGVtZW50LCBjb21wb25lbnQgaW5zdGFuY2UsIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBlaXRoZXIuXG4gICAqIFRoZSBgY29udGFpbmVyYCB3aWxsIHBhc3NlZCB0byB0aGUgTW9kYWwgY29tcG9uZW50LlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBpdCB1c2VzIHRoZSBib2R5IG9mIHRoZSBhbmNob3JFbCdzIHRvcC1sZXZlbCBkb2N1bWVudCBvYmplY3QsXG4gICAqIHNvIGl0J3Mgc2ltcGx5IGBkb2N1bWVudC5ib2R5YCBtb3N0IG9mIHRoZSB0aW1lLlxuICAgKi9cbiAgY29udGFpbmVyOiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAub25lT2ZUeXBlKFtIVE1MRWxlbWVudFR5cGUsIFByb3BUeXBlcy5pbnN0YW5jZU9mKFJlYWN0LkNvbXBvbmVudCksIFByb3BUeXBlcy5mdW5jXSksXG5cbiAgLyoqXG4gICAqIFRoZSBlbGV2YXRpb24gb2YgdGhlIHBvcG92ZXIuXG4gICAqL1xuICBlbGV2YXRpb246IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGluIG9yZGVyIHRvIHJldHJpZXZlIHRoZSBjb250ZW50IGFuY2hvciBlbGVtZW50LlxuICAgKiBJdCdzIHRoZSBvcHBvc2l0ZSBvZiB0aGUgYGFuY2hvckVsYCBwcm9wLlxuICAgKiBUaGUgY29udGVudCBhbmNob3IgZWxlbWVudCBzaG91bGQgYmUgYW4gZWxlbWVudCBpbnNpZGUgdGhlIHBvcG92ZXIuXG4gICAqIEl0J3MgdXNlZCB0byBjb3JyZWN0bHkgc2Nyb2xsIGFuZCBzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyLlxuICAgKiBUaGUgcG9zaXRpb25pbmcgc3RyYXRlZ3kgdHJpZXMgdG8gbWFrZSB0aGUgY29udGVudCBhbmNob3IgZWxlbWVudCBqdXN0IGFib3ZlIHRoZVxuICAgKiBhbmNob3IgZWxlbWVudC5cbiAgICovXG4gIGdldENvbnRlbnRBbmNob3JFbDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyBob3cgY2xvc2UgdG8gdGhlIGVkZ2Ugb2YgdGhlIHdpbmRvdyB0aGUgcG9wb3ZlciBjYW4gYXBwZWFyLlxuICAgKi9cbiAgbWFyZ2luVGhyZXNob2xkOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBjb21wb25lbnQgcmVxdWVzdHMgdG8gYmUgY2xvc2VkLlxuICAgKi9cbiAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIGVudGVyaW5nLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBUcmFuc2l0aW9uUHJvcHNgIHByb3AgaW5zdGVhZC5cbiAgICovXG4gIG9uRW50ZXI6IGRlcHJlY2F0ZWRQcm9wVHlwZShQcm9wVHlwZXMuZnVuYywgJ1VzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLicpLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGVudGVyZWQuXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLlxuICAgKi9cbiAgb25FbnRlcmVkOiBkZXByZWNhdGVkUHJvcFR5cGUoUHJvcFR5cGVzLmZ1bmMsICdVc2UgdGhlIGBUcmFuc2l0aW9uUHJvcHNgIHByb3AgaW5zdGVhZC4nKSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGVudGVyaW5nLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBUcmFuc2l0aW9uUHJvcHNgIHByb3AgaW5zdGVhZC5cbiAgICovXG4gIG9uRW50ZXJpbmc6IGRlcHJlY2F0ZWRQcm9wVHlwZShQcm9wVHlwZXMuZnVuYywgJ1VzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLicpLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBleGl0aW5nLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBUcmFuc2l0aW9uUHJvcHNgIHByb3AgaW5zdGVhZC5cbiAgICovXG4gIG9uRXhpdDogZGVwcmVjYXRlZFByb3BUeXBlKFByb3BUeXBlcy5mdW5jLCAnVXNlIHRoZSBgVHJhbnNpdGlvblByb3BzYCBwcm9wIGluc3RlYWQuJyksXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgZXhpdGVkLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBUcmFuc2l0aW9uUHJvcHNgIHByb3AgaW5zdGVhZC5cbiAgICovXG4gIG9uRXhpdGVkOiBkZXByZWNhdGVkUHJvcFR5cGUoUHJvcFR5cGVzLmZ1bmMsICdVc2UgdGhlIGBUcmFuc2l0aW9uUHJvcHNgIHByb3AgaW5zdGVhZC4nKSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGV4aXRpbmcuXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLlxuICAgKi9cbiAgb25FeGl0aW5nOiBkZXByZWNhdGVkUHJvcFR5cGUoUHJvcFR5cGVzLmZ1bmMsICdVc2UgdGhlIGBUcmFuc2l0aW9uUHJvcHNgIHByb3AgaW5zdGVhZC4nKSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgcG9wb3ZlciBpcyB2aXNpYmxlLlxuICAgKi9cbiAgb3BlbjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogUHJvcHMgYXBwbGllZCB0byB0aGUgW2BQYXBlcmBdKC9hcGkvcGFwZXIvKSBlbGVtZW50LlxuICAgKi9cbiAgUGFwZXJQcm9wczogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLnNoYXBlKHtcbiAgICBjb21wb25lbnQ6IGVsZW1lbnRUeXBlQWNjZXB0aW5nUmVmXG4gIH0pLFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBwb2ludCBvbiB0aGUgcG9wb3ZlciB3aGljaFxuICAgKiB3aWxsIGF0dGFjaCB0byB0aGUgYW5jaG9yJ3Mgb3JpZ2luLlxuICAgKlxuICAgKiBPcHRpb25zOlxuICAgKiB2ZXJ0aWNhbDogW3RvcCwgY2VudGVyLCBib3R0b20sIHgocHgpXTtcbiAgICogaG9yaXpvbnRhbDogW2xlZnQsIGNlbnRlciwgcmlnaHQsIHgocHgpXS5cbiAgICovXG4gIHRyYW5zZm9ybU9yaWdpbjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBob3Jpem9udGFsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub25lT2YoWydjZW50ZXInLCAnbGVmdCcsICdyaWdodCddKSwgUHJvcFR5cGVzLm51bWJlcl0pLmlzUmVxdWlyZWQsXG4gICAgdmVydGljYWw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbJ2JvdHRvbScsICdjZW50ZXInLCAndG9wJ10pLCBQcm9wVHlwZXMubnVtYmVyXSkuaXNSZXF1aXJlZFxuICB9KSxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgdHJhbnNpdGlvbi5cbiAgICogW0ZvbGxvdyB0aGlzIGd1aWRlXSgvY29tcG9uZW50cy90cmFuc2l0aW9ucy8jdHJhbnNpdGlvbmNvbXBvbmVudC1wcm9wKSB0byBsZWFybiBtb3JlIGFib3V0IHRoZSByZXF1aXJlbWVudHMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgVHJhbnNpdGlvbkNvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gJ2F1dG8nIHRvIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlIHRyYW5zaXRpb24gdGltZSBiYXNlZCBvbiBoZWlnaHQuXG4gICAqL1xuICB0cmFuc2l0aW9uRHVyYXRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbJ2F1dG8nXSksIFByb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgYXBwZWFyOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGVudGVyOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGV4aXQ6IFByb3BUeXBlcy5udW1iZXJcbiAgfSldKSxcblxuICAvKipcbiAgICogUHJvcHMgYXBwbGllZCB0byB0aGUgW2BUcmFuc2l0aW9uYF0oaHR0cDovL3JlYWN0Y29tbXVuaXR5Lm9yZy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL3RyYW5zaXRpb24jVHJhbnNpdGlvbi1wcm9wcykgZWxlbWVudC5cbiAgICovXG4gIFRyYW5zaXRpb25Qcm9wczogUHJvcFR5cGVzLm9iamVjdFxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlQb3BvdmVyJ1xufSkoUG9wb3Zlcik7IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuLyoqXG4gKiBAaWdub3JlIC0gaW50ZXJuYWwgY29tcG9uZW50LlxuICovXG5cbnZhciBMaXN0Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBMaXN0Q29udGV4dC5kaXNwbGF5TmFtZSA9ICdMaXN0Q29udGV4dCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpc3RDb250ZXh0OyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCBMaXN0Q29udGV4dCBmcm9tICcuL0xpc3RDb250ZXh0JztcbmV4cG9ydCB2YXIgc3R5bGVzID0ge1xuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICByb290OiB7XG4gICAgbGlzdFN0eWxlOiAnbm9uZScsXG4gICAgbWFyZ2luOiAwLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgfSxcblxuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBkaXNhYmxlUGFkZGluZz17ZmFsc2V9YC4gKi9cbiAgcGFkZGluZzoge1xuICAgIHBhZGRpbmdUb3A6IDgsXG4gICAgcGFkZGluZ0JvdHRvbTogOFxuICB9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgZGVuc2UuICovXG4gIGRlbnNlOiB7fSxcblxuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGEgYHN1YmhlYWRlcmAgaXMgcHJvdmlkZWQuICovXG4gIHN1YmhlYWRlcjoge1xuICAgIHBhZGRpbmdUb3A6IDBcbiAgfVxufTtcbnZhciBMaXN0ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gTGlzdChwcm9wcywgcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkY29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50LFxuICAgICAgQ29tcG9uZW50ID0gX3Byb3BzJGNvbXBvbmVudCA9PT0gdm9pZCAwID8gJ3VsJyA6IF9wcm9wcyRjb21wb25lbnQsXG4gICAgICBfcHJvcHMkZGVuc2UgPSBwcm9wcy5kZW5zZSxcbiAgICAgIGRlbnNlID0gX3Byb3BzJGRlbnNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkZW5zZSxcbiAgICAgIF9wcm9wcyRkaXNhYmxlUGFkZGluZyA9IHByb3BzLmRpc2FibGVQYWRkaW5nLFxuICAgICAgZGlzYWJsZVBhZGRpbmcgPSBfcHJvcHMkZGlzYWJsZVBhZGRpbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVQYWRkaW5nLFxuICAgICAgc3ViaGVhZGVyID0gcHJvcHMuc3ViaGVhZGVyLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcImNvbXBvbmVudFwiLCBcImRlbnNlXCIsIFwiZGlzYWJsZVBhZGRpbmdcIiwgXCJzdWJoZWFkZXJcIl0pO1xuXG4gIHZhciBjb250ZXh0ID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlbnNlOiBkZW5zZVxuICAgIH07XG4gIH0sIFtkZW5zZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGlzdENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUsIGRlbnNlICYmIGNsYXNzZXMuZGVuc2UsICFkaXNhYmxlUGFkZGluZyAmJiBjbGFzc2VzLnBhZGRpbmcsIHN1YmhlYWRlciAmJiBjbGFzc2VzLnN1YmhlYWRlciksXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpLCBzdWJoZWFkZXIsIGNoaWxkcmVuKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IExpc3QucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgcm9vdCBub2RlLlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgY29tcG9uZW50OiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAuZWxlbWVudFR5cGUsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgY29tcGFjdCB2ZXJ0aWNhbCBwYWRkaW5nIGRlc2lnbmVkIGZvciBrZXlib2FyZCBhbmQgbW91c2UgaW5wdXQgd2lsbCBiZSB1c2VkIGZvclxuICAgKiB0aGUgbGlzdCBhbmQgbGlzdCBpdGVtcy5cbiAgICogVGhlIHByb3AgaXMgYXZhaWxhYmxlIHRvIGRlc2NlbmRhbnQgY29tcG9uZW50cyBhcyB0aGUgYGRlbnNlYCBjb250ZXh0LlxuICAgKi9cbiAgZGVuc2U6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHZlcnRpY2FsIHBhZGRpbmcgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGxpc3QuXG4gICAqL1xuICBkaXNhYmxlUGFkZGluZzogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBzdWJoZWFkZXIsIG5vcm1hbGx5IGBMaXN0U3ViaGVhZGVyYC5cbiAgICovXG4gIHN1YmhlYWRlcjogUHJvcFR5cGVzLm5vZGVcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpTGlzdCdcbn0pKExpc3QpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzRnJhZ21lbnQgfSBmcm9tICdyZWFjdC1pcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBvd25lckRvY3VtZW50IGZyb20gJy4uL3V0aWxzL293bmVyRG9jdW1lbnQnO1xuaW1wb3J0IExpc3QgZnJvbSAnLi4vTGlzdCc7XG5pbXBvcnQgZ2V0U2Nyb2xsYmFyU2l6ZSBmcm9tICcuLi91dGlscy9nZXRTY3JvbGxiYXJTaXplJztcbmltcG9ydCB1c2VGb3JrUmVmIGZyb20gJy4uL3V0aWxzL3VzZUZvcmtSZWYnO1xuXG5mdW5jdGlvbiBuZXh0SXRlbShsaXN0LCBpdGVtLCBkaXNhYmxlTGlzdFdyYXApIHtcbiAgaWYgKGxpc3QgPT09IGl0ZW0pIHtcbiAgICByZXR1cm4gbGlzdC5maXJzdENoaWxkO1xuICB9XG5cbiAgaWYgKGl0ZW0gJiYgaXRlbS5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICByZXR1cm4gaXRlbS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gZGlzYWJsZUxpc3RXcmFwID8gbnVsbCA6IGxpc3QuZmlyc3RDaGlsZDtcbn1cblxuZnVuY3Rpb24gcHJldmlvdXNJdGVtKGxpc3QsIGl0ZW0sIGRpc2FibGVMaXN0V3JhcCkge1xuICBpZiAobGlzdCA9PT0gaXRlbSkge1xuICAgIHJldHVybiBkaXNhYmxlTGlzdFdyYXAgPyBsaXN0LmZpcnN0Q2hpbGQgOiBsaXN0Lmxhc3RDaGlsZDtcbiAgfVxuXG4gIGlmIChpdGVtICYmIGl0ZW0ucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgIHJldHVybiBpdGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gZGlzYWJsZUxpc3RXcmFwID8gbnVsbCA6IGxpc3QubGFzdENoaWxkO1xufVxuXG5mdW5jdGlvbiB0ZXh0Q3JpdGVyaWFNYXRjaGVzKG5leHRGb2N1cywgdGV4dENyaXRlcmlhKSB7XG4gIGlmICh0ZXh0Q3JpdGVyaWEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHRleHQgPSBuZXh0Rm9jdXMuaW5uZXJUZXh0O1xuXG4gIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBqc2RvbSBkb2Vzbid0IHN1cHBvcnQgaW5uZXJUZXh0XG4gICAgdGV4dCA9IG5leHRGb2N1cy50ZXh0Q29udGVudDtcbiAgfVxuXG4gIHRleHQgPSB0ZXh0LnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0ZXh0Q3JpdGVyaWEucmVwZWF0aW5nKSB7XG4gICAgcmV0dXJuIHRleHRbMF0gPT09IHRleHRDcml0ZXJpYS5rZXlzWzBdO1xuICB9XG5cbiAgcmV0dXJuIHRleHQuaW5kZXhPZih0ZXh0Q3JpdGVyaWEua2V5cy5qb2luKCcnKSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIG1vdmVGb2N1cyhsaXN0LCBjdXJyZW50Rm9jdXMsIGRpc2FibGVMaXN0V3JhcCwgZGlzYWJsZWRJdGVtc0ZvY3VzYWJsZSwgdHJhdmVyc2FsRnVuY3Rpb24sIHRleHRDcml0ZXJpYSkge1xuICB2YXIgd3JhcHBlZE9uY2UgPSBmYWxzZTtcbiAgdmFyIG5leHRGb2N1cyA9IHRyYXZlcnNhbEZ1bmN0aW9uKGxpc3QsIGN1cnJlbnRGb2N1cywgY3VycmVudEZvY3VzID8gZGlzYWJsZUxpc3RXcmFwIDogZmFsc2UpO1xuXG4gIHdoaWxlIChuZXh0Rm9jdXMpIHtcbiAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AuXG4gICAgaWYgKG5leHRGb2N1cyA9PT0gbGlzdC5maXJzdENoaWxkKSB7XG4gICAgICBpZiAod3JhcHBlZE9uY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3cmFwcGVkT25jZSA9IHRydWU7XG4gICAgfSAvLyBTYW1lIGxvZ2ljIGFzIHVzZUF1dG9jb21wbGV0ZS5qc1xuXG5cbiAgICB2YXIgbmV4dEZvY3VzRGlzYWJsZWQgPSBkaXNhYmxlZEl0ZW1zRm9jdXNhYmxlID8gZmFsc2UgOiBuZXh0Rm9jdXMuZGlzYWJsZWQgfHwgbmV4dEZvY3VzLmdldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcpID09PSAndHJ1ZSc7XG5cbiAgICBpZiAoIW5leHRGb2N1cy5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykgfHwgIXRleHRDcml0ZXJpYU1hdGNoZXMobmV4dEZvY3VzLCB0ZXh0Q3JpdGVyaWEpIHx8IG5leHRGb2N1c0Rpc2FibGVkKSB7XG4gICAgICAvLyBNb3ZlIHRvIHRoZSBuZXh0IGVsZW1lbnQuXG4gICAgICBuZXh0Rm9jdXMgPSB0cmF2ZXJzYWxGdW5jdGlvbihsaXN0LCBuZXh0Rm9jdXMsIGRpc2FibGVMaXN0V3JhcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRGb2N1cy5mb2N1cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdXNlRW5oYW5jZWRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IFJlYWN0LnVzZUVmZmVjdCA6IFJlYWN0LnVzZUxheW91dEVmZmVjdDtcbi8qKlxuICogQSBwZXJtYW5lbnRseSBkaXNwbGF5ZWQgbWVudSBmb2xsb3dpbmcgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhLXByYWN0aWNlcy8jbWVudWJ1dHRvbi5cbiAqIEl0J3MgZXhwb3NlZCB0byBoZWxwIGN1c3RvbWl6YXRpb24gb2YgdGhlIFtgTWVudWBdKC9hcGkvbWVudS8pIGNvbXBvbmVudC4gSWYgeW91XG4gKiB1c2UgaXQgc2VwYXJhdGVseSB5b3UgbmVlZCB0byBtb3ZlIGZvY3VzIGludG8gdGhlIGNvbXBvbmVudCBtYW51YWxseS4gT25jZVxuICogdGhlIGZvY3VzIGlzIHBsYWNlZCBpbnNpZGUgdGhlIGNvbXBvbmVudCBpdCBpcyBmdWxseSBrZXlib2FyZCBhY2Nlc3NpYmxlLlxuICovXG5cbnZhciBNZW51TGlzdCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIE1lbnVMaXN0KHByb3BzLCByZWYpIHtcbiAgdmFyIGFjdGlvbnMgPSBwcm9wcy5hY3Rpb25zLFxuICAgICAgX3Byb3BzJGF1dG9Gb2N1cyA9IHByb3BzLmF1dG9Gb2N1cyxcbiAgICAgIGF1dG9Gb2N1cyA9IF9wcm9wcyRhdXRvRm9jdXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGF1dG9Gb2N1cyxcbiAgICAgIF9wcm9wcyRhdXRvRm9jdXNJdGVtID0gcHJvcHMuYXV0b0ZvY3VzSXRlbSxcbiAgICAgIGF1dG9Gb2N1c0l0ZW0gPSBfcHJvcHMkYXV0b0ZvY3VzSXRlbSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkYXV0b0ZvY3VzSXRlbSxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkZGlzYWJsZWRJdGVtc0YgPSBwcm9wcy5kaXNhYmxlZEl0ZW1zRm9jdXNhYmxlLFxuICAgICAgZGlzYWJsZWRJdGVtc0ZvY3VzYWJsZSA9IF9wcm9wcyRkaXNhYmxlZEl0ZW1zRiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZWRJdGVtc0YsXG4gICAgICBfcHJvcHMkZGlzYWJsZUxpc3RXcmEgPSBwcm9wcy5kaXNhYmxlTGlzdFdyYXAsXG4gICAgICBkaXNhYmxlTGlzdFdyYXAgPSBfcHJvcHMkZGlzYWJsZUxpc3RXcmEgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVMaXN0V3JhLFxuICAgICAgb25LZXlEb3duID0gcHJvcHMub25LZXlEb3duLFxuICAgICAgX3Byb3BzJHZhcmlhbnQgPSBwcm9wcy52YXJpYW50LFxuICAgICAgdmFyaWFudCA9IF9wcm9wcyR2YXJpYW50ID09PSB2b2lkIDAgPyAnc2VsZWN0ZWRNZW51JyA6IF9wcm9wcyR2YXJpYW50LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImFjdGlvbnNcIiwgXCJhdXRvRm9jdXNcIiwgXCJhdXRvRm9jdXNJdGVtXCIsIFwiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJkaXNhYmxlZEl0ZW1zRm9jdXNhYmxlXCIsIFwiZGlzYWJsZUxpc3RXcmFwXCIsIFwib25LZXlEb3duXCIsIFwidmFyaWFudFwiXSk7XG5cbiAgdmFyIGxpc3RSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciB0ZXh0Q3JpdGVyaWFSZWYgPSBSZWFjdC51c2VSZWYoe1xuICAgIGtleXM6IFtdLFxuICAgIHJlcGVhdGluZzogdHJ1ZSxcbiAgICBwcmV2aW91c0tleU1hdGNoZWQ6IHRydWUsXG4gICAgbGFzdFRpbWU6IG51bGxcbiAgfSk7XG4gIHVzZUVuaGFuY2VkRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXV0b0ZvY3VzKSB7XG4gICAgICBsaXN0UmVmLmN1cnJlbnQuZm9jdXMoKTtcbiAgICB9XG4gIH0sIFthdXRvRm9jdXNdKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShhY3Rpb25zLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkanVzdFN0eWxlRm9yU2Nyb2xsYmFyOiBmdW5jdGlvbiBhZGp1c3RTdHlsZUZvclNjcm9sbGJhcihjb250YWluZXJFbGVtZW50LCB0aGVtZSkge1xuICAgICAgICAvLyBMZXQncyBpZ25vcmUgdGhhdCBwaWVjZSBvZiBsb2dpYyBpZiB1c2VycyBhcmUgYWxyZWFkeSBvdmVycmlkaW5nIHRoZSB3aWR0aFxuICAgICAgICAvLyBvZiB0aGUgbWVudS5cbiAgICAgICAgdmFyIG5vRXhwbGljaXRXaWR0aCA9ICFsaXN0UmVmLmN1cnJlbnQuc3R5bGUud2lkdGg7XG5cbiAgICAgICAgaWYgKGNvbnRhaW5lckVsZW1lbnQuY2xpZW50SGVpZ2h0IDwgbGlzdFJlZi5jdXJyZW50LmNsaWVudEhlaWdodCAmJiBub0V4cGxpY2l0V2lkdGgpIHtcbiAgICAgICAgICB2YXIgc2Nyb2xsYmFyU2l6ZSA9IFwiXCIuY29uY2F0KGdldFNjcm9sbGJhclNpemUodHJ1ZSksIFwicHhcIik7XG4gICAgICAgICAgbGlzdFJlZi5jdXJyZW50LnN0eWxlW3RoZW1lLmRpcmVjdGlvbiA9PT0gJ3J0bCcgPyAncGFkZGluZ0xlZnQnIDogJ3BhZGRpbmdSaWdodCddID0gc2Nyb2xsYmFyU2l6ZTtcbiAgICAgICAgICBsaXN0UmVmLmN1cnJlbnQuc3R5bGUud2lkdGggPSBcImNhbGMoMTAwJSArIFwiLmNvbmNhdChzY3JvbGxiYXJTaXplLCBcIilcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdFJlZi5jdXJyZW50O1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcblxuICB2YXIgaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICB2YXIgbGlzdCA9IGxpc3RSZWYuY3VycmVudDtcbiAgICB2YXIga2V5ID0gZXZlbnQua2V5O1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtFbGVtZW50fSAtIHdpbGwgYWx3YXlzIGJlIGRlZmluZWQgc2luY2Ugd2UgYXJlIGluIGEga2V5ZG93biBoYW5kbGVyXG4gICAgICogYXR0YWNoZWQgdG8gYW4gZWxlbWVudC4gQSBrZXlkb3duIGV2ZW50IGlzIGVpdGhlciBkaXNwYXRjaGVkIHRvIHRoZSBhY3RpdmVFbGVtZW50XG4gICAgICogb3IgZG9jdW1lbnQuYm9keSBvciBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuIE9ubHkgdGhlIGZpcnN0IGNhc2Ugd2lsbFxuICAgICAqIHRyaWdnZXIgdGhpcyBzcGVjaWZpYyBoYW5kbGVyLlxuICAgICAqL1xuXG4gICAgdmFyIGN1cnJlbnRGb2N1cyA9IG93bmVyRG9jdW1lbnQobGlzdCkuYWN0aXZlRWxlbWVudDtcblxuICAgIGlmIChrZXkgPT09ICdBcnJvd0Rvd24nKSB7XG4gICAgICAvLyBQcmV2ZW50IHNjcm9sbCBvZiB0aGUgcGFnZVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG1vdmVGb2N1cyhsaXN0LCBjdXJyZW50Rm9jdXMsIGRpc2FibGVMaXN0V3JhcCwgZGlzYWJsZWRJdGVtc0ZvY3VzYWJsZSwgbmV4dEl0ZW0pO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnQXJyb3dVcCcpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBtb3ZlRm9jdXMobGlzdCwgY3VycmVudEZvY3VzLCBkaXNhYmxlTGlzdFdyYXAsIGRpc2FibGVkSXRlbXNGb2N1c2FibGUsIHByZXZpb3VzSXRlbSk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdIb21lJykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG1vdmVGb2N1cyhsaXN0LCBudWxsLCBkaXNhYmxlTGlzdFdyYXAsIGRpc2FibGVkSXRlbXNGb2N1c2FibGUsIG5leHRJdGVtKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ0VuZCcpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBtb3ZlRm9jdXMobGlzdCwgbnVsbCwgZGlzYWJsZUxpc3RXcmFwLCBkaXNhYmxlZEl0ZW1zRm9jdXNhYmxlLCBwcmV2aW91c0l0ZW0pO1xuICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNyaXRlcmlhID0gdGV4dENyaXRlcmlhUmVmLmN1cnJlbnQ7XG4gICAgICB2YXIgbG93ZXJLZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBjdXJyVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICBpZiAoY3JpdGVyaWEua2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFJlc2V0XG4gICAgICAgIGlmIChjdXJyVGltZSAtIGNyaXRlcmlhLmxhc3RUaW1lID4gNTAwKSB7XG4gICAgICAgICAgY3JpdGVyaWEua2V5cyA9IFtdO1xuICAgICAgICAgIGNyaXRlcmlhLnJlcGVhdGluZyA9IHRydWU7XG4gICAgICAgICAgY3JpdGVyaWEucHJldmlvdXNLZXlNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjcml0ZXJpYS5yZXBlYXRpbmcgJiYgbG93ZXJLZXkgIT09IGNyaXRlcmlhLmtleXNbMF0pIHtcbiAgICAgICAgICBjcml0ZXJpYS5yZXBlYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjcml0ZXJpYS5sYXN0VGltZSA9IGN1cnJUaW1lO1xuICAgICAgY3JpdGVyaWEua2V5cy5wdXNoKGxvd2VyS2V5KTtcbiAgICAgIHZhciBrZWVwRm9jdXNPbkN1cnJlbnQgPSBjdXJyZW50Rm9jdXMgJiYgIWNyaXRlcmlhLnJlcGVhdGluZyAmJiB0ZXh0Q3JpdGVyaWFNYXRjaGVzKGN1cnJlbnRGb2N1cywgY3JpdGVyaWEpO1xuXG4gICAgICBpZiAoY3JpdGVyaWEucHJldmlvdXNLZXlNYXRjaGVkICYmIChrZWVwRm9jdXNPbkN1cnJlbnQgfHwgbW92ZUZvY3VzKGxpc3QsIGN1cnJlbnRGb2N1cywgZmFsc2UsIGRpc2FibGVkSXRlbXNGb2N1c2FibGUsIG5leHRJdGVtLCBjcml0ZXJpYSkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcml0ZXJpYS5wcmV2aW91c0tleU1hdGNoZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob25LZXlEb3duKSB7XG4gICAgICBvbktleURvd24oZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlT3duUmVmID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgLy8gI1N0cmljdE1vZGUgcmVhZHlcbiAgICBsaXN0UmVmLmN1cnJlbnQgPSBSZWFjdERPTS5maW5kRE9NTm9kZShpbnN0YW5jZSk7XG4gIH0sIFtdKTtcbiAgdmFyIGhhbmRsZVJlZiA9IHVzZUZvcmtSZWYoaGFuZGxlT3duUmVmLCByZWYpO1xuICAvKipcbiAgICogdGhlIGluZGV4IG9mIHRoZSBpdGVtIHNob3VsZCByZWNlaXZlIGZvY3VzXG4gICAqIGluIGEgYHZhcmlhbnQ9XCJzZWxlY3RlZE1lbnVcImAgaXQncyB0aGUgZmlyc3QgYHNlbGVjdGVkYCBpdGVtXG4gICAqIG90aGVyd2lzZSBpdCdzIHRoZSB2ZXJ5IGZpcnN0IGl0ZW0uXG4gICAqL1xuXG4gIHZhciBhY3RpdmVJdGVtSW5kZXggPSAtMTsgLy8gc2luY2Ugd2UgaW5qZWN0IGZvY3VzIHJlbGF0ZWQgcHJvcHMgaW50byBjaGlsZHJlbiB3ZSBoYXZlIHRvIGRvIGEgbG9va2FoZWFkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZXJlIGlzIGEgYHNlbGVjdGVkYCBpdGVtLiBXZSdyZSBsb29raW5nIGZvciB0aGUgbGFzdCBgc2VsZWN0ZWRgXG4gIC8vIGl0ZW0gYW5kIHVzZSB0aGUgZmlyc3QgdmFsaWQgaXRlbSBhcyBhIGZhbGxiYWNrXG5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgIGlmICghIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzRnJhZ21lbnQoY2hpbGQpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoW1wiTWF0ZXJpYWwtVUk6IFRoZSBNZW51IGNvbXBvbmVudCBkb2Vzbid0IGFjY2VwdCBhIEZyYWdtZW50IGFzIGEgY2hpbGQuXCIsICdDb25zaWRlciBwcm92aWRpbmcgYW4gYXJyYXkgaW5zdGVhZC4nXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZC5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgaWYgKHZhcmlhbnQgPT09ICdzZWxlY3RlZE1lbnUnICYmIGNoaWxkLnByb3BzLnNlbGVjdGVkKSB7XG4gICAgICAgIGFjdGl2ZUl0ZW1JbmRleCA9IGluZGV4O1xuICAgICAgfSBlbHNlIGlmIChhY3RpdmVJdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICAgIGFjdGl2ZUl0ZW1JbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBpdGVtcyA9IFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gYWN0aXZlSXRlbUluZGV4KSB7XG4gICAgICB2YXIgbmV3Q2hpbGRQcm9wcyA9IHt9O1xuXG4gICAgICBpZiAoYXV0b0ZvY3VzSXRlbSkge1xuICAgICAgICBuZXdDaGlsZFByb3BzLmF1dG9Gb2N1cyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZC5wcm9wcy50YWJJbmRleCA9PT0gdW5kZWZpbmVkICYmIHZhcmlhbnQgPT09ICdzZWxlY3RlZE1lbnUnKSB7XG4gICAgICAgIG5ld0NoaWxkUHJvcHMudGFiSW5kZXggPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgbmV3Q2hpbGRQcm9wcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExpc3QsIF9leHRlbmRzKHtcbiAgICByb2xlOiBcIm1lbnVcIixcbiAgICByZWY6IGhhbmRsZVJlZixcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICBvbktleURvd246IGhhbmRsZUtleURvd24sXG4gICAgdGFiSW5kZXg6IGF1dG9Gb2N1cyA/IDAgOiAtMVxuICB9LCBvdGhlciksIGl0ZW1zKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gTWVudUxpc3QucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogSWYgYHRydWVgLCB3aWxsIGZvY3VzIHRoZSBgW3JvbGU9XCJtZW51XCJdYCBjb250YWluZXIgYW5kIG1vdmUgaW50byB0YWIgb3JkZXIuXG4gICAqL1xuICBhdXRvRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHdpbGwgZm9jdXMgdGhlIGZpcnN0IG1lbnVpdGVtIGlmIGB2YXJpYW50PVwibWVudVwiYCBvciBzZWxlY3RlZCBpdGVtXG4gICAqIGlmIGB2YXJpYW50PVwic2VsZWN0ZWRNZW51XCJgLlxuICAgKi9cbiAgYXV0b0ZvY3VzSXRlbTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE1lbnVMaXN0IGNvbnRlbnRzLCBub3JtYWxseSBgTWVudUl0ZW1gcy5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHdpbGwgYWxsb3cgZm9jdXMgb24gZGlzYWJsZWQgaXRlbXMuXG4gICAqL1xuICBkaXNhYmxlZEl0ZW1zRm9jdXNhYmxlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbWVudSBpdGVtcyB3aWxsIG5vdCB3cmFwIGZvY3VzLlxuICAgKi9cbiAgZGlzYWJsZUxpc3RXcmFwOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25LZXlEb3duOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogVGhlIHZhcmlhbnQgdG8gdXNlLiBVc2UgYG1lbnVgIHRvIHByZXZlbnQgc2VsZWN0ZWQgaXRlbXMgZnJvbSBpbXBhY3RpbmcgdGhlIGluaXRpYWwgZm9jdXNcbiAgICogYW5kIHRoZSB2ZXJ0aWNhbCBhbGlnbm1lbnQgcmVsYXRpdmUgdG8gdGhlIGFuY2hvciBlbGVtZW50LlxuICAgKi9cbiAgdmFyaWFudDogUHJvcFR5cGVzLm9uZU9mKFsnbWVudScsICdzZWxlY3RlZE1lbnUnXSlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCBNZW51TGlzdDsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc0ZyYWdtZW50IH0gZnJvbSAncmVhY3QtaXMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHsgSFRNTEVsZW1lbnRUeXBlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCBQb3BvdmVyIGZyb20gJy4uL1BvcG92ZXInO1xuaW1wb3J0IE1lbnVMaXN0IGZyb20gJy4uL01lbnVMaXN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgc2V0UmVmIGZyb20gJy4uL3V0aWxzL3NldFJlZic7XG5pbXBvcnQgdXNlVGhlbWUgZnJvbSAnLi4vc3R5bGVzL3VzZVRoZW1lJztcbmltcG9ydCBkZXByZWNhdGVkUHJvcFR5cGUgZnJvbSAnLi4vdXRpbHMvZGVwcmVjYXRlZFByb3BUeXBlJztcbnZhciBSVExfT1JJR0lOID0ge1xuICB2ZXJ0aWNhbDogJ3RvcCcsXG4gIGhvcml6b250YWw6ICdyaWdodCdcbn07XG52YXIgTFRSX09SSUdJTiA9IHtcbiAgdmVydGljYWw6ICd0b3AnLFxuICBob3Jpem9udGFsOiAnbGVmdCdcbn07XG5leHBvcnQgdmFyIHN0eWxlcyA9IHtcbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBQYXBlcmAgY29tcG9uZW50LiAqL1xuICBwYXBlcjoge1xuICAgIC8vIHNwZWNaOiBUaGUgbWF4aW11bSBoZWlnaHQgb2YgYSBzaW1wbGUgbWVudSBzaG91bGQgYmUgb25lIG9yIG1vcmUgcm93cyBsZXNzIHRoYW4gdGhlIHZpZXdcbiAgICAvLyBoZWlnaHQuIFRoaXMgZW5zdXJlcyBhIHRhcGFibGUgYXJlYSBvdXRzaWRlIG9mIHRoZSBzaW1wbGUgbWVudSB3aXRoIHdoaWNoIHRvIGRpc21pc3NcbiAgICAvLyB0aGUgbWVudS5cbiAgICBtYXhIZWlnaHQ6ICdjYWxjKDEwMCUgLSA5NnB4KScsXG4gICAgLy8gQWRkIGlPUyBtb21lbnR1bSBzY3JvbGxpbmcuXG4gICAgV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6ICd0b3VjaCdcbiAgfSxcblxuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYExpc3RgIGNvbXBvbmVudCB2aWEgYE1lbnVMaXN0YC4gKi9cbiAgbGlzdDoge1xuICAgIC8vIFdlIGRpc2FibGUgdGhlIGZvY3VzIHJpbmcgZm9yIG1vdXNlLCB0b3VjaCBhbmQga2V5Ym9hcmQgdXNlcnMuXG4gICAgb3V0bGluZTogMFxuICB9XG59O1xudmFyIE1lbnUgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBNZW51KHByb3BzLCByZWYpIHtcbiAgdmFyIF9wcm9wcyRhdXRvRm9jdXMgPSBwcm9wcy5hdXRvRm9jdXMsXG4gICAgICBhdXRvRm9jdXMgPSBfcHJvcHMkYXV0b0ZvY3VzID09PSB2b2lkIDAgPyB0cnVlIDogX3Byb3BzJGF1dG9Gb2N1cyxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIF9wcm9wcyRkaXNhYmxlQXV0b0ZvYyA9IHByb3BzLmRpc2FibGVBdXRvRm9jdXNJdGVtLFxuICAgICAgZGlzYWJsZUF1dG9Gb2N1c0l0ZW0gPSBfcHJvcHMkZGlzYWJsZUF1dG9Gb2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVBdXRvRm9jLFxuICAgICAgX3Byb3BzJE1lbnVMaXN0UHJvcHMgPSBwcm9wcy5NZW51TGlzdFByb3BzLFxuICAgICAgTWVudUxpc3RQcm9wcyA9IF9wcm9wcyRNZW51TGlzdFByb3BzID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRNZW51TGlzdFByb3BzLFxuICAgICAgb25DbG9zZSA9IHByb3BzLm9uQ2xvc2UsXG4gICAgICBvbkVudGVyaW5nUHJvcCA9IHByb3BzLm9uRW50ZXJpbmcsXG4gICAgICBvcGVuID0gcHJvcHMub3BlbixcbiAgICAgIF9wcm9wcyRQYXBlclByb3BzID0gcHJvcHMuUGFwZXJQcm9wcyxcbiAgICAgIFBhcGVyUHJvcHMgPSBfcHJvcHMkUGFwZXJQcm9wcyA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkUGFwZXJQcm9wcyxcbiAgICAgIFBvcG92ZXJDbGFzc2VzID0gcHJvcHMuUG9wb3ZlckNsYXNzZXMsXG4gICAgICBfcHJvcHMkdHJhbnNpdGlvbkR1cmEgPSBwcm9wcy50cmFuc2l0aW9uRHVyYXRpb24sXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSBfcHJvcHMkdHJhbnNpdGlvbkR1cmEgPT09IHZvaWQgMCA/ICdhdXRvJyA6IF9wcm9wcyR0cmFuc2l0aW9uRHVyYSxcbiAgICAgIF9wcm9wcyRUcmFuc2l0aW9uUHJvcCA9IHByb3BzLlRyYW5zaXRpb25Qcm9wcztcbiAgX3Byb3BzJFRyYW5zaXRpb25Qcm9wID0gX3Byb3BzJFRyYW5zaXRpb25Qcm9wID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRUcmFuc2l0aW9uUHJvcDtcblxuICB2YXIgb25FbnRlcmluZyA9IF9wcm9wcyRUcmFuc2l0aW9uUHJvcC5vbkVudGVyaW5nLFxuICAgICAgVHJhbnNpdGlvblByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcyRUcmFuc2l0aW9uUHJvcCwgW1wib25FbnRlcmluZ1wiXSksXG4gICAgICBfcHJvcHMkdmFyaWFudCA9IHByb3BzLnZhcmlhbnQsXG4gICAgICB2YXJpYW50ID0gX3Byb3BzJHZhcmlhbnQgPT09IHZvaWQgMCA/ICdzZWxlY3RlZE1lbnUnIDogX3Byb3BzJHZhcmlhbnQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYXV0b0ZvY3VzXCIsIFwiY2hpbGRyZW5cIiwgXCJjbGFzc2VzXCIsIFwiZGlzYWJsZUF1dG9Gb2N1c0l0ZW1cIiwgXCJNZW51TGlzdFByb3BzXCIsIFwib25DbG9zZVwiLCBcIm9uRW50ZXJpbmdcIiwgXCJvcGVuXCIsIFwiUGFwZXJQcm9wc1wiLCBcIlBvcG92ZXJDbGFzc2VzXCIsIFwidHJhbnNpdGlvbkR1cmF0aW9uXCIsIFwiVHJhbnNpdGlvblByb3BzXCIsIFwidmFyaWFudFwiXSk7XG5cbiAgdmFyIHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgdmFyIGF1dG9Gb2N1c0l0ZW0gPSBhdXRvRm9jdXMgJiYgIWRpc2FibGVBdXRvRm9jdXNJdGVtICYmIG9wZW47XG4gIHZhciBtZW51TGlzdEFjdGlvbnNSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBjb250ZW50QW5jaG9yUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuXG4gIHZhciBnZXRDb250ZW50QW5jaG9yRWwgPSBmdW5jdGlvbiBnZXRDb250ZW50QW5jaG9yRWwoKSB7XG4gICAgcmV0dXJuIGNvbnRlbnRBbmNob3JSZWYuY3VycmVudDtcbiAgfTtcblxuICB2YXIgaGFuZGxlRW50ZXJpbmcgPSBmdW5jdGlvbiBoYW5kbGVFbnRlcmluZyhlbGVtZW50LCBpc0FwcGVhcmluZykge1xuICAgIGlmIChtZW51TGlzdEFjdGlvbnNSZWYuY3VycmVudCkge1xuICAgICAgbWVudUxpc3RBY3Rpb25zUmVmLmN1cnJlbnQuYWRqdXN0U3R5bGVGb3JTY3JvbGxiYXIoZWxlbWVudCwgdGhlbWUpO1xuICAgIH1cblxuICAgIGlmIChvbkVudGVyaW5nUHJvcCkge1xuICAgICAgb25FbnRlcmluZ1Byb3AoZWxlbWVudCwgaXNBcHBlYXJpbmcpO1xuICAgIH1cblxuICAgIGlmIChvbkVudGVyaW5nKSB7XG4gICAgICBvbkVudGVyaW5nKGVsZW1lbnQsIGlzQXBwZWFyaW5nKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUxpc3RLZXlEb3duID0gZnVuY3Rpb24gaGFuZGxlTGlzdEtleURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKG9uQ2xvc2UpIHtcbiAgICAgICAgb25DbG9zZShldmVudCwgJ3RhYktleURvd24nKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gc2hvdWxkIHJlY2VpdmUgZm9jdXNcbiAgICogaW4gYSBgdmFyaWFudD1cInNlbGVjdGVkTWVudVwiYCBpdCdzIHRoZSBmaXJzdCBgc2VsZWN0ZWRgIGl0ZW1cbiAgICogb3RoZXJ3aXNlIGl0J3MgdGhlIHZlcnkgZmlyc3QgaXRlbS5cbiAgICovXG5cblxuICB2YXIgYWN0aXZlSXRlbUluZGV4ID0gLTE7IC8vIHNpbmNlIHdlIGluamVjdCBmb2N1cyByZWxhdGVkIHByb3BzIGludG8gY2hpbGRyZW4gd2UgaGF2ZSB0byBkbyBhIGxvb2thaGVhZFxuICAvLyB0byBjaGVjayBpZiB0aGVyZSBpcyBhIGBzZWxlY3RlZGAgaXRlbS4gV2UncmUgbG9va2luZyBmb3IgdGhlIGxhc3QgYHNlbGVjdGVkYFxuICAvLyBpdGVtIGFuZCB1c2UgdGhlIGZpcnN0IHZhbGlkIGl0ZW0gYXMgYSBmYWxsYmFja1xuXG4gIFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgIGlmICghIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzRnJhZ21lbnQoY2hpbGQpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoW1wiTWF0ZXJpYWwtVUk6IFRoZSBNZW51IGNvbXBvbmVudCBkb2Vzbid0IGFjY2VwdCBhIEZyYWdtZW50IGFzIGEgY2hpbGQuXCIsICdDb25zaWRlciBwcm92aWRpbmcgYW4gYXJyYXkgaW5zdGVhZC4nXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZC5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgaWYgKHZhcmlhbnQgIT09IFwibWVudVwiICYmIGNoaWxkLnByb3BzLnNlbGVjdGVkKSB7XG4gICAgICAgIGFjdGl2ZUl0ZW1JbmRleCA9IGluZGV4O1xuICAgICAgfSBlbHNlIGlmIChhY3RpdmVJdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICAgIGFjdGl2ZUl0ZW1JbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBpdGVtcyA9IFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gYWN0aXZlSXRlbUluZGV4KSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihpbnN0YW5jZSkge1xuICAgICAgICAgIC8vICNTdHJpY3RNb2RlIHJlYWR5XG4gICAgICAgICAgY29udGVudEFuY2hvclJlZi5jdXJyZW50ID0gUmVhY3RET00uZmluZERPTU5vZGUoaW5zdGFuY2UpO1xuICAgICAgICAgIHNldFJlZihjaGlsZC5yZWYsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvcG92ZXIsIF9leHRlbmRzKHtcbiAgICBnZXRDb250ZW50QW5jaG9yRWw6IGdldENvbnRlbnRBbmNob3JFbCxcbiAgICBjbGFzc2VzOiBQb3BvdmVyQ2xhc3NlcyxcbiAgICBvbkNsb3NlOiBvbkNsb3NlLFxuICAgIFRyYW5zaXRpb25Qcm9wczogX2V4dGVuZHMoe1xuICAgICAgb25FbnRlcmluZzogaGFuZGxlRW50ZXJpbmdcbiAgICB9LCBUcmFuc2l0aW9uUHJvcHMpLFxuICAgIGFuY2hvck9yaWdpbjogdGhlbWUuZGlyZWN0aW9uID09PSAncnRsJyA/IFJUTF9PUklHSU4gOiBMVFJfT1JJR0lOLFxuICAgIHRyYW5zZm9ybU9yaWdpbjogdGhlbWUuZGlyZWN0aW9uID09PSAncnRsJyA/IFJUTF9PUklHSU4gOiBMVFJfT1JJR0lOLFxuICAgIFBhcGVyUHJvcHM6IF9leHRlbmRzKHt9LCBQYXBlclByb3BzLCB7XG4gICAgICBjbGFzc2VzOiBfZXh0ZW5kcyh7fSwgUGFwZXJQcm9wcy5jbGFzc2VzLCB7XG4gICAgICAgIHJvb3Q6IGNsYXNzZXMucGFwZXJcbiAgICAgIH0pXG4gICAgfSksXG4gICAgb3Blbjogb3BlbixcbiAgICByZWY6IHJlZixcbiAgICB0cmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25EdXJhdGlvblxuICB9LCBvdGhlciksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lbnVMaXN0LCBfZXh0ZW5kcyh7XG4gICAgb25LZXlEb3duOiBoYW5kbGVMaXN0S2V5RG93bixcbiAgICBhY3Rpb25zOiBtZW51TGlzdEFjdGlvbnNSZWYsXG4gICAgYXV0b0ZvY3VzOiBhdXRvRm9jdXMgJiYgKGFjdGl2ZUl0ZW1JbmRleCA9PT0gLTEgfHwgZGlzYWJsZUF1dG9Gb2N1c0l0ZW0pLFxuICAgIGF1dG9Gb2N1c0l0ZW06IGF1dG9Gb2N1c0l0ZW0sXG4gICAgdmFyaWFudDogdmFyaWFudFxuICB9LCBNZW51TGlzdFByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMubGlzdCwgTWVudUxpc3RQcm9wcy5jbGFzc05hbWUpXG4gIH0pLCBpdGVtcykpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBNZW51LnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIEEgSFRNTCBlbGVtZW50LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBpdC5cbiAgICogSXQncyB1c2VkIHRvIHNldCB0aGUgcG9zaXRpb24gb2YgdGhlIG1lbnUuXG4gICAqL1xuICBhbmNob3JFbDogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLm9uZU9mVHlwZShbSFRNTEVsZW1lbnRUeXBlLCBQcm9wVHlwZXMuZnVuY10pLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAgKERlZmF1bHQpIHdpbGwgZm9jdXMgdGhlIGBbcm9sZT1cIm1lbnVcIl1gIGlmIG5vIGZvY3VzYWJsZSBjaGlsZCBpcyBmb3VuZC4gRGlzYWJsZWRcbiAgICogY2hpbGRyZW4gYXJlIG5vdCBmb2N1c2FibGUuIElmIHlvdSBzZXQgdGhpcyBwcm9wIHRvIGBmYWxzZWAgZm9jdXMgd2lsbCBiZSBwbGFjZWRcbiAgICogb24gdGhlIHBhcmVudCBtb2RhbCBjb250YWluZXIuIFRoaXMgaGFzIHNldmVyZSBhY2Nlc3NpYmlsaXR5IGltcGxpY2F0aW9uc1xuICAgKiBhbmQgc2hvdWxkIG9ubHkgYmUgY29uc2lkZXJlZCBpZiB5b3UgbWFuYWdlIGZvY3VzIG90aGVyd2lzZS5cbiAgICovXG4gIGF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE1lbnUgY29udGVudHMsIG5vcm1hbGx5IGBNZW51SXRlbWBzLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFdoZW4gb3BlbmluZyB0aGUgbWVudSB3aWxsIG5vdCBmb2N1cyB0aGUgYWN0aXZlIGl0ZW0gYnV0IHRoZSBgW3JvbGU9XCJtZW51XCJdYFxuICAgKiB1bmxlc3MgYGF1dG9Gb2N1c2AgaXMgYWxzbyBzZXQgdG8gYGZhbHNlYC4gTm90IHVzaW5nIHRoZSBkZWZhdWx0IG1lYW5zIG5vdFxuICAgKiBmb2xsb3dpbmcgV0FJLUFSSUEgYXV0aG9yaW5nIHByYWN0aWNlcy4gUGxlYXNlIGJlIGNvbnNpZGVyYXRlIGFib3V0IHBvc3NpYmxlXG4gICAqIGFjY2Vzc2liaWxpdHkgaW1wbGljYXRpb25zLlxuICAgKi9cbiAgZGlzYWJsZUF1dG9Gb2N1c0l0ZW06IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBbYE1lbnVMaXN0YF0oL2FwaS9tZW51LWxpc3QvKSBlbGVtZW50LlxuICAgKi9cbiAgTWVudUxpc3RQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IHJlcXVlc3RzIHRvIGJlIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIENhbiBiZTogYFwiZXNjYXBlS2V5RG93blwiYCwgYFwiYmFja2Ryb3BDbGlja1wiYCwgYFwidGFiS2V5RG93blwiYC5cbiAgICovXG4gIG9uQ2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBiZWZvcmUgdGhlIE1lbnUgZW50ZXJzLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBUcmFuc2l0aW9uUHJvcHNgIHByb3AgaW5zdGVhZC5cbiAgICovXG4gIG9uRW50ZXI6IGRlcHJlY2F0ZWRQcm9wVHlwZShQcm9wVHlwZXMuZnVuYywgJ1VzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLicpLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBNZW51IGhhcyBlbnRlcmVkLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBUcmFuc2l0aW9uUHJvcHNgIHByb3AgaW5zdGVhZC5cbiAgICovXG4gIG9uRW50ZXJlZDogZGVwcmVjYXRlZFByb3BUeXBlKFByb3BUeXBlcy5mdW5jLCAnVXNlIHRoZSBgVHJhbnNpdGlvblByb3BzYCBwcm9wIGluc3RlYWQuJyksXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIE1lbnUgaXMgZW50ZXJpbmcuXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLlxuICAgKi9cbiAgb25FbnRlcmluZzogZGVwcmVjYXRlZFByb3BUeXBlKFByb3BUeXBlcy5mdW5jLCAnVXNlIHRoZSBgVHJhbnNpdGlvblByb3BzYCBwcm9wIGluc3RlYWQuJyksXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgTWVudSBleGl0cy5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgVHJhbnNpdGlvblByb3BzYCBwcm9wIGluc3RlYWQuXG4gICAqL1xuICBvbkV4aXQ6IGRlcHJlY2F0ZWRQcm9wVHlwZShQcm9wVHlwZXMuZnVuYywgJ1VzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLicpLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBNZW51IGhhcyBleGl0ZWQuXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLlxuICAgKi9cbiAgb25FeGl0ZWQ6IGRlcHJlY2F0ZWRQcm9wVHlwZShQcm9wVHlwZXMuZnVuYywgJ1VzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLicpLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBNZW51IGlzIGV4aXRpbmcuXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLlxuICAgKi9cbiAgb25FeGl0aW5nOiBkZXByZWNhdGVkUHJvcFR5cGUoUHJvcFR5cGVzLmZ1bmMsICdVc2UgdGhlIGBUcmFuc2l0aW9uUHJvcHNgIHByb3AgaW5zdGVhZC4nKSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbWVudSBpcyB2aXNpYmxlLlxuICAgKi9cbiAgb3BlbjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgUGFwZXJQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogYGNsYXNzZXNgIHByb3AgYXBwbGllZCB0byB0aGUgW2BQb3BvdmVyYF0oL2FwaS9wb3BvdmVyLykgZWxlbWVudC5cbiAgICovXG4gIFBvcG92ZXJDbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSB0cmFuc2l0aW9uIGluIGBtc2AsIG9yICdhdXRvJ1xuICAgKi9cbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub25lT2YoWydhdXRvJ10pLCBQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGFwcGVhcjogUHJvcFR5cGVzLm51bWJlcixcbiAgICBlbnRlcjogUHJvcFR5cGVzLm51bWJlcixcbiAgICBleGl0OiBQcm9wVHlwZXMubnVtYmVyXG4gIH0pXSksXG5cbiAgLyoqXG4gICAqIFByb3BzIGFwcGxpZWQgdG8gdGhlIHRyYW5zaXRpb24gZWxlbWVudC5cbiAgICogQnkgZGVmYXVsdCwgdGhlIGVsZW1lbnQgaXMgYmFzZWQgb24gdGhpcyBbYFRyYW5zaXRpb25gXShodHRwOi8vcmVhY3Rjb21tdW5pdHkub3JnL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvdHJhbnNpdGlvbikgY29tcG9uZW50LlxuICAgKi9cbiAgVHJhbnNpdGlvblByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBUaGUgdmFyaWFudCB0byB1c2UuIFVzZSBgbWVudWAgdG8gcHJldmVudCBzZWxlY3RlZCBpdGVtcyBmcm9tIGltcGFjdGluZyB0aGUgaW5pdGlhbCBmb2N1c1xuICAgKiBhbmQgdGhlIHZlcnRpY2FsIGFsaWdubWVudCByZWxhdGl2ZSB0byB0aGUgYW5jaG9yIGVsZW1lbnQuXG4gICAqL1xuICB2YXJpYW50OiBQcm9wVHlwZXMub25lT2YoWydtZW51JywgJ3NlbGVjdGVkTWVudSddKVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlNZW51J1xufSkoTWVudSk7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgX3R5cGVvZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mXCI7XG5pbXBvcnQgeyBmb3JtYXRNdWlFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdE11aUVycm9yTWVzc2FnZSB9IGZyb20gXCJAbWF0ZXJpYWwtdWkvdXRpbHNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzRnJhZ21lbnQgfSBmcm9tICdyZWFjdC1pcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgb3duZXJEb2N1bWVudCBmcm9tICcuLi91dGlscy9vd25lckRvY3VtZW50JztcbmltcG9ydCBjYXBpdGFsaXplIGZyb20gJy4uL3V0aWxzL2NhcGl0YWxpemUnO1xuaW1wb3J0IHsgcmVmVHlwZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgTWVudSBmcm9tICcuLi9NZW51L01lbnUnO1xuaW1wb3J0IHsgaXNGaWxsZWQgfSBmcm9tICcuLi9JbnB1dEJhc2UvdXRpbHMnO1xuaW1wb3J0IHVzZUZvcmtSZWYgZnJvbSAnLi4vdXRpbHMvdXNlRm9ya1JlZic7XG5pbXBvcnQgdXNlQ29udHJvbGxlZCBmcm9tICcuLi91dGlscy91c2VDb250cm9sbGVkJztcblxuZnVuY3Rpb24gYXJlRXF1YWxWYWx1ZXMoYSwgYikge1xuICBpZiAoX3R5cGVvZihiKSA9PT0gJ29iamVjdCcgJiYgYiAhPT0gbnVsbCkge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG5cbiAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5KGRpc3BsYXkpIHtcbiAgcmV0dXJuIGRpc3BsYXkgPT0gbnVsbCB8fCB0eXBlb2YgZGlzcGxheSA9PT0gJ3N0cmluZycgJiYgIWRpc3BsYXkudHJpbSgpO1xufVxuLyoqXG4gKiBAaWdub3JlIC0gaW50ZXJuYWwgY29tcG9uZW50LlxuICovXG5cblxudmFyIFNlbGVjdElucHV0ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gU2VsZWN0SW5wdXQocHJvcHMsIHJlZikge1xuICB2YXIgYXJpYUxhYmVsID0gcHJvcHNbJ2FyaWEtbGFiZWwnXSxcbiAgICAgIGF1dG9Gb2N1cyA9IHByb3BzLmF1dG9Gb2N1cyxcbiAgICAgIGF1dG9XaWR0aCA9IHByb3BzLmF1dG9XaWR0aCxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQsXG4gICAgICBkaXNwbGF5RW1wdHkgPSBwcm9wcy5kaXNwbGF5RW1wdHksXG4gICAgICBJY29uQ29tcG9uZW50ID0gcHJvcHMuSWNvbkNvbXBvbmVudCxcbiAgICAgIGlucHV0UmVmUHJvcCA9IHByb3BzLmlucHV0UmVmLFxuICAgICAgbGFiZWxJZCA9IHByb3BzLmxhYmVsSWQsXG4gICAgICBfcHJvcHMkTWVudVByb3BzID0gcHJvcHMuTWVudVByb3BzLFxuICAgICAgTWVudVByb3BzID0gX3Byb3BzJE1lbnVQcm9wcyA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkTWVudVByb3BzLFxuICAgICAgbXVsdGlwbGUgPSBwcm9wcy5tdWx0aXBsZSxcbiAgICAgIG5hbWUgPSBwcm9wcy5uYW1lLFxuICAgICAgb25CbHVyID0gcHJvcHMub25CbHVyLFxuICAgICAgb25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZSxcbiAgICAgIG9uQ2xvc2UgPSBwcm9wcy5vbkNsb3NlLFxuICAgICAgb25Gb2N1cyA9IHByb3BzLm9uRm9jdXMsXG4gICAgICBvbk9wZW4gPSBwcm9wcy5vbk9wZW4sXG4gICAgICBvcGVuUHJvcCA9IHByb3BzLm9wZW4sXG4gICAgICByZWFkT25seSA9IHByb3BzLnJlYWRPbmx5LFxuICAgICAgcmVuZGVyVmFsdWUgPSBwcm9wcy5yZW5kZXJWYWx1ZSxcbiAgICAgIF9wcm9wcyRTZWxlY3REaXNwbGF5UCA9IHByb3BzLlNlbGVjdERpc3BsYXlQcm9wcyxcbiAgICAgIFNlbGVjdERpc3BsYXlQcm9wcyA9IF9wcm9wcyRTZWxlY3REaXNwbGF5UCA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkU2VsZWN0RGlzcGxheVAsXG4gICAgICB0YWJJbmRleFByb3AgPSBwcm9wcy50YWJJbmRleCxcbiAgICAgIHR5cGUgPSBwcm9wcy50eXBlLFxuICAgICAgdmFsdWVQcm9wID0gcHJvcHMudmFsdWUsXG4gICAgICBfcHJvcHMkdmFyaWFudCA9IHByb3BzLnZhcmlhbnQsXG4gICAgICB2YXJpYW50ID0gX3Byb3BzJHZhcmlhbnQgPT09IHZvaWQgMCA/ICdzdGFuZGFyZCcgOiBfcHJvcHMkdmFyaWFudCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJhcmlhLWxhYmVsXCIsIFwiYXV0b0ZvY3VzXCIsIFwiYXV0b1dpZHRoXCIsIFwiY2hpbGRyZW5cIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiZGVmYXVsdFZhbHVlXCIsIFwiZGlzYWJsZWRcIiwgXCJkaXNwbGF5RW1wdHlcIiwgXCJJY29uQ29tcG9uZW50XCIsIFwiaW5wdXRSZWZcIiwgXCJsYWJlbElkXCIsIFwiTWVudVByb3BzXCIsIFwibXVsdGlwbGVcIiwgXCJuYW1lXCIsIFwib25CbHVyXCIsIFwib25DaGFuZ2VcIiwgXCJvbkNsb3NlXCIsIFwib25Gb2N1c1wiLCBcIm9uT3BlblwiLCBcIm9wZW5cIiwgXCJyZWFkT25seVwiLCBcInJlbmRlclZhbHVlXCIsIFwiU2VsZWN0RGlzcGxheVByb3BzXCIsIFwidGFiSW5kZXhcIiwgXCJ0eXBlXCIsIFwidmFsdWVcIiwgXCJ2YXJpYW50XCJdKTtcblxuICB2YXIgX3VzZUNvbnRyb2xsZWQgPSB1c2VDb250cm9sbGVkKHtcbiAgICBjb250cm9sbGVkOiB2YWx1ZVByb3AsXG4gICAgZGVmYXVsdDogZGVmYXVsdFZhbHVlLFxuICAgIG5hbWU6ICdTZWxlY3QnXG4gIH0pLFxuICAgICAgX3VzZUNvbnRyb2xsZWQyID0gX3NsaWNlZFRvQXJyYXkoX3VzZUNvbnRyb2xsZWQsIDIpLFxuICAgICAgdmFsdWUgPSBfdXNlQ29udHJvbGxlZDJbMF0sXG4gICAgICBzZXRWYWx1ZSA9IF91c2VDb250cm9sbGVkMlsxXTtcblxuICB2YXIgaW5wdXRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpLFxuICAgICAgZGlzcGxheU5vZGUgPSBfUmVhY3QkdXNlU3RhdGVbMF0sXG4gICAgICBzZXREaXNwbGF5Tm9kZSA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICB2YXIgX1JlYWN0JHVzZVJlZiA9IFJlYWN0LnVzZVJlZihvcGVuUHJvcCAhPSBudWxsKSxcbiAgICAgIGlzT3BlbkNvbnRyb2xsZWQgPSBfUmVhY3QkdXNlUmVmLmN1cnJlbnQ7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTIgPSBSZWFjdC51c2VTdGF0ZSgpLFxuICAgICAgbWVudU1pbldpZHRoU3RhdGUgPSBfUmVhY3QkdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0TWVudU1pbldpZHRoU3RhdGUgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgb3BlblN0YXRlID0gX1JlYWN0JHVzZVN0YXRlM1swXSxcbiAgICAgIHNldE9wZW5TdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZTNbMV07XG5cbiAgdmFyIGhhbmRsZVJlZiA9IHVzZUZvcmtSZWYocmVmLCBpbnB1dFJlZlByb3ApO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGhhbmRsZVJlZiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgICAgIGRpc3BsYXlOb2RlLmZvY3VzKCk7XG4gICAgICB9LFxuICAgICAgbm9kZTogaW5wdXRSZWYuY3VycmVudCxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH07XG4gIH0sIFtkaXNwbGF5Tm9kZSwgdmFsdWVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXV0b0ZvY3VzICYmIGRpc3BsYXlOb2RlKSB7XG4gICAgICBkaXNwbGF5Tm9kZS5mb2N1cygpO1xuICAgIH1cbiAgfSwgW2F1dG9Gb2N1cywgZGlzcGxheU5vZGVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZGlzcGxheU5vZGUpIHtcbiAgICAgIHZhciBsYWJlbCA9IG93bmVyRG9jdW1lbnQoZGlzcGxheU5vZGUpLmdldEVsZW1lbnRCeUlkKGxhYmVsSWQpO1xuXG4gICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICAgIGlmIChnZXRTZWxlY3Rpb24oKS5pc0NvbGxhcHNlZCkge1xuICAgICAgICAgICAgZGlzcGxheU5vZGUuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgbGFiZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBsYWJlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sIFtsYWJlbElkLCBkaXNwbGF5Tm9kZV0pO1xuXG4gIHZhciB1cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUob3BlbiwgZXZlbnQpIHtcbiAgICBpZiAob3Blbikge1xuICAgICAgaWYgKG9uT3Blbikge1xuICAgICAgICBvbk9wZW4oZXZlbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob25DbG9zZSkge1xuICAgICAgb25DbG9zZShldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKCFpc09wZW5Db250cm9sbGVkKSB7XG4gICAgICBzZXRNZW51TWluV2lkdGhTdGF0ZShhdXRvV2lkdGggPyBudWxsIDogZGlzcGxheU5vZGUuY2xpZW50V2lkdGgpO1xuICAgICAgc2V0T3BlblN0YXRlKG9wZW4pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG4gICAgLy8gSWdub3JlIGV2ZXJ5dGhpbmcgYnV0IGxlZnQtY2xpY2tcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBIaWphY2sgdGhlIGRlZmF1bHQgZm9jdXMgYmVoYXZpb3IuXG5cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGxheU5vZGUuZm9jdXMoKTtcbiAgICB1cGRhdGUodHJ1ZSwgZXZlbnQpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVDbG9zZSA9IGZ1bmN0aW9uIGhhbmRsZUNsb3NlKGV2ZW50KSB7XG4gICAgdXBkYXRlKGZhbHNlLCBldmVudCk7XG4gIH07XG5cbiAgdmFyIGNoaWxkcmVuQXJyYXkgPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKTsgLy8gU3VwcG9ydCBhdXRvZmlsbC5cblxuICB2YXIgaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gICAgdmFyIGluZGV4ID0gY2hpbGRyZW5BcnJheS5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQucHJvcHMudmFsdWU7XG4gICAgfSkuaW5kZXhPZihldmVudC50YXJnZXQudmFsdWUpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuQXJyYXlbaW5kZXhdO1xuICAgIHNldFZhbHVlKGNoaWxkLnByb3BzLnZhbHVlKTtcblxuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgb25DaGFuZ2UoZXZlbnQsIGNoaWxkKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUl0ZW1DbGljayA9IGZ1bmN0aW9uIGhhbmRsZUl0ZW1DbGljayhjaGlsZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghbXVsdGlwbGUpIHtcbiAgICAgICAgdXBkYXRlKGZhbHNlLCBldmVudCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdWYWx1ZTtcblxuICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5zbGljZSgpIDogW107XG4gICAgICAgIHZhciBpdGVtSW5kZXggPSB2YWx1ZS5pbmRleE9mKGNoaWxkLnByb3BzLnZhbHVlKTtcblxuICAgICAgICBpZiAoaXRlbUluZGV4ID09PSAtMSkge1xuICAgICAgICAgIG5ld1ZhbHVlLnB1c2goY2hpbGQucHJvcHMudmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1ZhbHVlLnNwbGljZShpdGVtSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IGNoaWxkLnByb3BzLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGQucHJvcHMub25DbGljaykge1xuICAgICAgICBjaGlsZC5wcm9wcy5vbkNsaWNrKGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID09PSBuZXdWYWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNldFZhbHVlKG5ld1ZhbHVlKTtcblxuICAgICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICAgIGV2ZW50LnBlcnNpc3QoKTsgLy8gUHJlYWN0IHN1cHBvcnQsIHRhcmdldCBpcyByZWFkIG9ubHkgcHJvcGVydHkgb24gYSBuYXRpdmUgZXZlbnQuXG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2ZW50LCAndGFyZ2V0Jywge1xuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb25DaGFuZ2UoZXZlbnQsIGNoaWxkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBoYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIGlmICghcmVhZE9ubHkpIHtcbiAgICAgIHZhciB2YWxpZEtleXMgPSBbJyAnLCAnQXJyb3dVcCcsICdBcnJvd0Rvd24nLCAvLyBUaGUgbmF0aXZlIHNlbGVjdCBkb2Vzbid0IHJlc3BvbmQgdG8gZW50ZXIgb24gTWFjT1MsIGJ1dCBpdCdzIHJlY29tbWVuZGVkIGJ5XG4gICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEtcHJhY3RpY2VzL2V4YW1wbGVzL2xpc3Rib3gvbGlzdGJveC1jb2xsYXBzaWJsZS5odG1sXG4gICAgICAnRW50ZXInXTtcblxuICAgICAgaWYgKHZhbGlkS2V5cy5pbmRleE9mKGV2ZW50LmtleSkgIT09IC0xKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHVwZGF0ZSh0cnVlLCBldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBvcGVuID0gZGlzcGxheU5vZGUgIT09IG51bGwgJiYgKGlzT3BlbkNvbnRyb2xsZWQgPyBvcGVuUHJvcCA6IG9wZW5TdGF0ZSk7XG5cbiAgdmFyIGhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKGV2ZW50KSB7XG4gICAgLy8gaWYgb3BlbiBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cbiAgICBpZiAoIW9wZW4gJiYgb25CbHVyKSB7XG4gICAgICBldmVudC5wZXJzaXN0KCk7IC8vIFByZWFjdCBzdXBwb3J0LCB0YXJnZXQgaXMgcmVhZCBvbmx5IHByb3BlcnR5IG9uIGEgbmF0aXZlIGV2ZW50LlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsICd0YXJnZXQnLCB7XG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb25CbHVyKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgZGVsZXRlIG90aGVyWydhcmlhLWludmFsaWQnXTtcbiAgdmFyIGRpc3BsYXk7XG4gIHZhciBkaXNwbGF5U2luZ2xlO1xuICB2YXIgZGlzcGxheU11bHRpcGxlID0gW107XG4gIHZhciBjb21wdXRlRGlzcGxheSA9IGZhbHNlO1xuICB2YXIgZm91bmRNYXRjaCA9IGZhbHNlOyAvLyBObyBuZWVkIHRvIGRpc3BsYXkgYW55IHZhbHVlIGlmIHRoZSBmaWVsZCBpcyBlbXB0eS5cblxuICBpZiAoaXNGaWxsZWQoe1xuICAgIHZhbHVlOiB2YWx1ZVxuICB9KSB8fCBkaXNwbGF5RW1wdHkpIHtcbiAgICBpZiAocmVuZGVyVmFsdWUpIHtcbiAgICAgIGRpc3BsYXkgPSByZW5kZXJWYWx1ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXB1dGVEaXNwbGF5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgaXRlbXMgPSBjaGlsZHJlbkFycmF5Lm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoISAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzRnJhZ21lbnQoY2hpbGQpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoW1wiTWF0ZXJpYWwtVUk6IFRoZSBTZWxlY3QgY29tcG9uZW50IGRvZXNuJ3QgYWNjZXB0IGEgRnJhZ21lbnQgYXMgYSBjaGlsZC5cIiwgJ0NvbnNpZGVyIHByb3ZpZGluZyBhbiBhcnJheSBpbnN0ZWFkLiddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0ZWQ7XG5cbiAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiTWF0ZXJpYWwtVUk6IFRoZSBgdmFsdWVgIHByb3AgbXVzdCBiZSBhbiBhcnJheSB3aGVuIHVzaW5nIHRoZSBgU2VsZWN0YCBjb21wb25lbnQgd2l0aCBgbXVsdGlwbGVgLlwiIDogX2Zvcm1hdE11aUVycm9yTWVzc2FnZSgyKSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdGVkID0gdmFsdWUuc29tZShmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gYXJlRXF1YWxWYWx1ZXModiwgY2hpbGQucHJvcHMudmFsdWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZWxlY3RlZCAmJiBjb21wdXRlRGlzcGxheSkge1xuICAgICAgICBkaXNwbGF5TXVsdGlwbGUucHVzaChjaGlsZC5wcm9wcy5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGVkID0gYXJlRXF1YWxWYWx1ZXModmFsdWUsIGNoaWxkLnByb3BzLnZhbHVlKTtcblxuICAgICAgaWYgKHNlbGVjdGVkICYmIGNvbXB1dGVEaXNwbGF5KSB7XG4gICAgICAgIGRpc3BsYXlTaW5nbGUgPSBjaGlsZC5wcm9wcy5jaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgIGZvdW5kTWF0Y2ggPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAnYXJpYS1zZWxlY3RlZCc6IHNlbGVjdGVkID8gJ3RydWUnIDogdW5kZWZpbmVkLFxuICAgICAgb25DbGljazogaGFuZGxlSXRlbUNsaWNrKGNoaWxkKSxcbiAgICAgIG9uS2V5VXA6IGZ1bmN0aW9uIG9uS2V5VXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJyAnKSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIG91ciBNZW51SXRlbXMgZGlzcGF0Y2hlcyBhIGNsaWNrIGV2ZW50XG4gICAgICAgICAgLy8gaXQncyBub3QgYmVoYXZpb3Igb2YgdGhlIG5hdGl2ZSA8b3B0aW9uPiBhbmQgY2F1c2VzXG4gICAgICAgICAgLy8gdGhlIHNlbGVjdCB0byBjbG9zZSBpbW1lZGlhdGVseSBzaW5jZSB3ZSBvcGVuIG9uIHNwYWNlIGtleWRvd25cbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkLnByb3BzLm9uS2V5VXApIHtcbiAgICAgICAgICBjaGlsZC5wcm9wcy5vbktleVVwKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJvbGU6ICdvcHRpb24nLFxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIC8vIFRoZSB2YWx1ZSBpcyBtb3N0IGxpa2VseSBub3QgYSB2YWxpZCBIVE1MIGF0dHJpYnV0ZS5cbiAgICAgICdkYXRhLXZhbHVlJzogY2hpbGQucHJvcHMudmFsdWUgLy8gSW5zdGVhZCwgd2UgcHJvdmlkZSBpdCBhcyBhIGRhdGEgYXR0cmlidXRlLlxuXG4gICAgfSk7XG4gIH0pO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghZm91bmRNYXRjaCAmJiAhbXVsdGlwbGUgJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBjaGlsZHJlbkFycmF5Lm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGQucHJvcHMudmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLndhcm4oW1wiTWF0ZXJpYWwtVUk6IFlvdSBoYXZlIHByb3ZpZGVkIGFuIG91dC1vZi1yYW5nZSB2YWx1ZSBgXCIuY29uY2F0KHZhbHVlLCBcImAgZm9yIHRoZSBzZWxlY3QgXCIpLmNvbmNhdChuYW1lID8gXCIobmFtZT1cXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIikgXCIpIDogJycsIFwiY29tcG9uZW50LlwiKSwgXCJDb25zaWRlciBwcm92aWRpbmcgYSB2YWx1ZSB0aGF0IG1hdGNoZXMgb25lIG9mIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBvciAnJy5cIiwgXCJUaGUgYXZhaWxhYmxlIHZhbHVlcyBhcmUgXCIuY29uY2F0KHZhbHVlcy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geCAhPSBudWxsO1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4gXCJgXCIuY29uY2F0KHgsIFwiYFwiKTtcbiAgICAgICAgfSkuam9pbignLCAnKSB8fCAnXCJcIicsIFwiLlwiKV0uam9pbignXFxuJykpO1xuICAgICAgfVxuICAgIH0sIFtmb3VuZE1hdGNoLCBjaGlsZHJlbkFycmF5LCBtdWx0aXBsZSwgbmFtZSwgdmFsdWVdKTtcbiAgfVxuXG4gIGlmIChjb21wdXRlRGlzcGxheSkge1xuICAgIGRpc3BsYXkgPSBtdWx0aXBsZSA/IGRpc3BsYXlNdWx0aXBsZS5qb2luKCcsICcpIDogZGlzcGxheVNpbmdsZTtcbiAgfSAvLyBBdm9pZCBwZXJmb3JtaW5nIGEgbGF5b3V0IGNvbXB1dGF0aW9uIGluIHRoZSByZW5kZXIgbWV0aG9kLlxuXG5cbiAgdmFyIG1lbnVNaW5XaWR0aCA9IG1lbnVNaW5XaWR0aFN0YXRlO1xuXG4gIGlmICghYXV0b1dpZHRoICYmIGlzT3BlbkNvbnRyb2xsZWQgJiYgZGlzcGxheU5vZGUpIHtcbiAgICBtZW51TWluV2lkdGggPSBkaXNwbGF5Tm9kZS5jbGllbnRXaWR0aDtcbiAgfVxuXG4gIHZhciB0YWJJbmRleDtcblxuICBpZiAodHlwZW9mIHRhYkluZGV4UHJvcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0YWJJbmRleCA9IHRhYkluZGV4UHJvcDtcbiAgfSBlbHNlIHtcbiAgICB0YWJJbmRleCA9IGRpc2FibGVkID8gbnVsbCA6IDA7XG4gIH1cblxuICB2YXIgYnV0dG9uSWQgPSBTZWxlY3REaXNwbGF5UHJvcHMuaWQgfHwgKG5hbWUgPyBcIm11aS1jb21wb25lbnQtc2VsZWN0LVwiLmNvbmNhdChuYW1lKSA6IHVuZGVmaW5lZCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIC8vIFRPRE8gdjU6IG1lcmdlIHJvb3QgYW5kIHNlbGVjdFxuICAgIGNsYXNzZXMuc2VsZWN0LCBjbGFzc2VzLnNlbGVjdE1lbnUsIGNsYXNzZXNbdmFyaWFudF0sIGNsYXNzTmFtZSwgZGlzYWJsZWQgJiYgY2xhc3Nlcy5kaXNhYmxlZCksXG4gICAgcmVmOiBzZXREaXNwbGF5Tm9kZSxcbiAgICB0YWJJbmRleDogdGFiSW5kZXgsXG4gICAgcm9sZTogXCJidXR0b25cIixcbiAgICBcImFyaWEtZGlzYWJsZWRcIjogZGlzYWJsZWQgPyAndHJ1ZScgOiB1bmRlZmluZWQsXG4gICAgXCJhcmlhLWV4cGFuZGVkXCI6IG9wZW4gPyAndHJ1ZScgOiB1bmRlZmluZWQsXG4gICAgXCJhcmlhLWhhc3BvcHVwXCI6IFwibGlzdGJveFwiLFxuICAgIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsXG4gICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogW2xhYmVsSWQsIGJ1dHRvbklkXS5maWx0ZXIoQm9vbGVhbikuam9pbignICcpIHx8IHVuZGVmaW5lZCxcbiAgICBvbktleURvd246IGhhbmRsZUtleURvd24sXG4gICAgb25Nb3VzZURvd246IGRpc2FibGVkIHx8IHJlYWRPbmx5ID8gbnVsbCA6IGhhbmRsZU1vdXNlRG93bixcbiAgICBvbkJsdXI6IGhhbmRsZUJsdXIsXG4gICAgb25Gb2N1czogb25Gb2N1c1xuICB9LCBTZWxlY3REaXNwbGF5UHJvcHMsIHtcbiAgICAvLyBUaGUgaWQgaXMgcmVxdWlyZWQgZm9yIHByb3BlciBhMTF5XG4gICAgaWQ6IGJ1dHRvbklkXG4gIH0pLCBpc0VtcHR5KGRpc3BsYXkpID9cbiAgLyojX19QVVJFX18qL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZGFuZ2VyXG4gIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgX19odG1sOiAnJiM4MjAzOydcbiAgICB9XG4gIH0pIDogZGlzcGxheSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgX2V4dGVuZHMoe1xuICAgIHZhbHVlOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywnKSA6IHZhbHVlLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcmVmOiBpbnB1dFJlZixcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgb25DaGFuZ2U6IGhhbmRsZUNoYW5nZSxcbiAgICB0YWJJbmRleDogLTEsXG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzLm5hdGl2ZUlucHV0LFxuICAgIGF1dG9Gb2N1czogYXV0b0ZvY3VzXG4gIH0sIG90aGVyKSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEljb25Db21wb25lbnQsIHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5pY29uLCBjbGFzc2VzW1wiaWNvblwiLmNvbmNhdChjYXBpdGFsaXplKHZhcmlhbnQpKV0sIG9wZW4gJiYgY2xhc3Nlcy5pY29uT3BlbiwgZGlzYWJsZWQgJiYgY2xhc3Nlcy5kaXNhYmxlZClcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lbnUsIF9leHRlbmRzKHtcbiAgICBpZDogXCJtZW51LVwiLmNvbmNhdChuYW1lIHx8ICcnKSxcbiAgICBhbmNob3JFbDogZGlzcGxheU5vZGUsXG4gICAgb3Blbjogb3BlbixcbiAgICBvbkNsb3NlOiBoYW5kbGVDbG9zZVxuICB9LCBNZW51UHJvcHMsIHtcbiAgICBNZW51TGlzdFByb3BzOiBfZXh0ZW5kcyh7XG4gICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogbGFiZWxJZCxcbiAgICAgIHJvbGU6ICdsaXN0Ym94JyxcbiAgICAgIGRpc2FibGVMaXN0V3JhcDogdHJ1ZVxuICAgIH0sIE1lbnVQcm9wcy5NZW51TGlzdFByb3BzKSxcbiAgICBQYXBlclByb3BzOiBfZXh0ZW5kcyh7fSwgTWVudVByb3BzLlBhcGVyUHJvcHMsIHtcbiAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7XG4gICAgICAgIG1pbldpZHRoOiBtZW51TWluV2lkdGhcbiAgICAgIH0sIE1lbnVQcm9wcy5QYXBlclByb3BzICE9IG51bGwgPyBNZW51UHJvcHMuUGFwZXJQcm9wcy5zdHlsZSA6IG51bGwpXG4gICAgfSlcbiAgfSksIGl0ZW1zKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFNlbGVjdElucHV0LnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gICdhcmlhLWxhYmVsJzogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgYXV0b0ZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgd2lkdGggb2YgdGhlIHBvcG92ZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHNldCBhY2NvcmRpbmcgdG8gdGhlIGl0ZW1zIGluc2lkZSB0aGVcbiAgICogbWVudSwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgYXQgbGVhc3QgdGhlIHdpZHRoIG9mIHRoZSBzZWxlY3QgaW5wdXQuXG4gICAqL1xuICBhdXRvV2lkdGg6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgb3B0aW9uIGVsZW1lbnRzIHRvIHBvcHVsYXRlIHRoZSBzZWxlY3Qgd2l0aC5cbiAgICogQ2FuIGJlIHNvbWUgYDxNZW51SXRlbT5gIGVsZW1lbnRzLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogVGhlIENTUyBjbGFzcyBuYW1lIG9mIHRoZSBzZWxlY3QgZWxlbWVudC5cbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgZWxlbWVudCB2YWx1ZS4gVXNlIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBub3QgY29udHJvbGxlZC5cbiAgICovXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLmFueSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgc2VsZWN0IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHNlbGVjdGVkIGl0ZW0gaXMgZGlzcGxheWVkIGV2ZW4gaWYgaXRzIHZhbHVlIGlzIGVtcHR5LlxuICAgKi9cbiAgZGlzcGxheUVtcHR5OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGljb24gdGhhdCBkaXNwbGF5cyB0aGUgYXJyb3cuXG4gICAqL1xuICBJY29uQ29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudFR5cGUuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogSW1wZXJhdGl2ZSBoYW5kbGUgaW1wbGVtZW50aW5nIGB7IHZhbHVlOiBULCBub2RlOiBIVE1MRWxlbWVudCwgZm9jdXMoKTogdm9pZCB9YFxuICAgKiBFcXVpdmFsZW50IHRvIGByZWZgXG4gICAqL1xuICBpbnB1dFJlZjogcmVmVHlwZSxcblxuICAvKipcbiAgICogVGhlIElEIG9mIGFuIGVsZW1lbnQgdGhhdCBhY3RzIGFzIGFuIGFkZGl0aW9uYWwgbGFiZWwuIFRoZSBTZWxlY3Qgd2lsbFxuICAgKiBiZSBsYWJlbGxlZCBieSB0aGUgYWRkaXRpb25hbCBsYWJlbCBhbmQgdGhlIHNlbGVjdGVkIHZhbHVlLlxuICAgKi9cbiAgbGFiZWxJZDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogUHJvcHMgYXBwbGllZCB0byB0aGUgW2BNZW51YF0oL2FwaS9tZW51LykgZWxlbWVudC5cbiAgICovXG4gIE1lbnVQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBgdmFsdWVgIG11c3QgYmUgYW4gYXJyYXkgYW5kIHRoZSBtZW51IHdpbGwgc3VwcG9ydCBtdWx0aXBsZSBzZWxlY3Rpb25zLlxuICAgKi9cbiAgbXVsdGlwbGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBOYW1lIGF0dHJpYnV0ZSBvZiB0aGUgYHNlbGVjdGAgb3IgaGlkZGVuIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uQmx1cjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIGZpcmVkIHdoZW4gYSBtZW51IGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cbiAgICogWW91IGNhbiBwdWxsIG91dCB0aGUgbmV3IHZhbHVlIGJ5IGFjY2Vzc2luZyBgZXZlbnQudGFyZ2V0LnZhbHVlYCAoYW55KS5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtjaGlsZF0gVGhlIHJlYWN0IGVsZW1lbnQgdGhhdCB3YXMgc2VsZWN0ZWQuXG4gICAqL1xuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGNvbXBvbmVudCByZXF1ZXN0cyB0byBiZSBjbG9zZWQuXG4gICAqIFVzZSBpbiBjb250cm9sbGVkIG1vZGUgKHNlZSBvcGVuKS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKi9cbiAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBjb21wb25lbnQgcmVxdWVzdHMgdG8gYmUgb3BlbmVkLlxuICAgKiBVc2UgaW4gY29udHJvbGxlZCBtb2RlIChzZWUgb3BlbikuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cbiAgICovXG4gIG9uT3BlbjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENvbnRyb2wgYHNlbGVjdGAgb3BlbiBzdGF0ZS5cbiAgICovXG4gIG9wZW46IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICByZWFkT25seTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgc2VsZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgYHZhbHVlYCBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBAcmV0dXJucyB7UmVhY3ROb2RlfVxuICAgKi9cbiAgcmVuZGVyVmFsdWU6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBjbGlja2FibGUgZGl2IGVsZW1lbnQuXG4gICAqL1xuICBTZWxlY3REaXNwbGF5UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHRhYkluZGV4OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHR5cGU6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCB2YWx1ZS5cbiAgICovXG4gIHZhbHVlOiBQcm9wVHlwZXMuYW55LFxuXG4gIC8qKlxuICAgKiBUaGUgdmFyaWFudCB0byB1c2UuXG4gICAqL1xuICB2YXJpYW50OiBQcm9wVHlwZXMub25lT2YoWydzdGFuZGFyZCcsICdvdXRsaW5lZCcsICdmaWxsZWQnXSlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCBTZWxlY3RJbnB1dDsiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3JlYXRlU3ZnSWNvbiBmcm9tICcuLi8uLi91dGlscy9jcmVhdGVTdmdJY29uJztcbi8qKlxuICogQGlnbm9yZSAtIGludGVybmFsIGNvbXBvbmVudC5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTdmdJY29uKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICBkOiBcIk03IDEwbDUgNSA1LTV6XCJcbn0pLCAnQXJyb3dEcm9wRG93bicpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IHJlZlR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IGNhcGl0YWxpemUgZnJvbSAnLi4vdXRpbHMvY2FwaXRhbGl6ZSc7XG4vKipcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXG4gKi9cblxudmFyIE5hdGl2ZVNlbGVjdElucHV0ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gTmF0aXZlU2VsZWN0SW5wdXQocHJvcHMsIHJlZikge1xuICB2YXIgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkLFxuICAgICAgSWNvbkNvbXBvbmVudCA9IHByb3BzLkljb25Db21wb25lbnQsXG4gICAgICBpbnB1dFJlZiA9IHByb3BzLmlucHV0UmVmLFxuICAgICAgX3Byb3BzJHZhcmlhbnQgPSBwcm9wcy52YXJpYW50LFxuICAgICAgdmFyaWFudCA9IF9wcm9wcyR2YXJpYW50ID09PSB2b2lkIDAgPyAnc3RhbmRhcmQnIDogX3Byb3BzJHZhcmlhbnQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcImRpc2FibGVkXCIsIFwiSWNvbkNvbXBvbmVudFwiLCBcImlucHV0UmVmXCIsIFwidmFyaWFudFwiXSk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgLy8gVE9ETyB2NTogbWVyZ2Ugcm9vdCBhbmQgc2VsZWN0XG4gICAgY2xhc3Nlcy5zZWxlY3QsIGNsYXNzZXNbdmFyaWFudF0sIGNsYXNzTmFtZSwgZGlzYWJsZWQgJiYgY2xhc3Nlcy5kaXNhYmxlZCksXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgIHJlZjogaW5wdXRSZWYgfHwgcmVmXG4gIH0sIG90aGVyKSksIHByb3BzLm11bHRpcGxlID8gbnVsbCA6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEljb25Db21wb25lbnQsIHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5pY29uLCBjbGFzc2VzW1wiaWNvblwiLmNvbmNhdChjYXBpdGFsaXplKHZhcmlhbnQpKV0sIGRpc2FibGVkICYmIGNsYXNzZXMuZGlzYWJsZWQpXG4gIH0pKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gTmF0aXZlU2VsZWN0SW5wdXQucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogVGhlIG9wdGlvbiBlbGVtZW50cyB0byBwb3B1bGF0ZSB0aGUgc2VsZWN0IHdpdGguXG4gICAqIENhbiBiZSBzb21lIGA8b3B0aW9uPmAgZWxlbWVudHMuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBUaGUgQ1NTIGNsYXNzIG5hbWUgb2YgdGhlIHNlbGVjdCBlbGVtZW50LlxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBzZWxlY3Qgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGljb24gdGhhdCBkaXNwbGF5cyB0aGUgYXJyb3cuXG4gICAqL1xuICBJY29uQ29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudFR5cGUuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogVXNlIHRoYXQgcHJvcCB0byBwYXNzIGEgcmVmIHRvIHRoZSBuYXRpdmUgc2VsZWN0IGVsZW1lbnQuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBpbnB1dFJlZjogcmVmVHlwZSxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgbXVsdGlwbGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBOYW1lIGF0dHJpYnV0ZSBvZiB0aGUgYHNlbGVjdGAgb3IgaGlkZGVuIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIGZpcmVkIHdoZW4gYSBtZW51IGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cbiAgICogWW91IGNhbiBwdWxsIG91dCB0aGUgbmV3IHZhbHVlIGJ5IGFjY2Vzc2luZyBgZXZlbnQudGFyZ2V0LnZhbHVlYCAoc3RyaW5nKS5cbiAgICovXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogVGhlIGlucHV0IHZhbHVlLlxuICAgKi9cbiAgdmFsdWU6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXG4gICAqIFRoZSB2YXJpYW50IHRvIHVzZS5cbiAgICovXG4gIHZhcmlhbnQ6IFByb3BUeXBlcy5vbmVPZihbJ3N0YW5kYXJkJywgJ291dGxpbmVkJywgJ2ZpbGxlZCddKVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IE5hdGl2ZVNlbGVjdElucHV0OyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgTmF0aXZlU2VsZWN0SW5wdXQgZnJvbSAnLi9OYXRpdmVTZWxlY3RJbnB1dCc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5pbXBvcnQgZm9ybUNvbnRyb2xTdGF0ZSBmcm9tICcuLi9Gb3JtQ29udHJvbC9mb3JtQ29udHJvbFN0YXRlJztcbmltcG9ydCB1c2VGb3JtQ29udHJvbCBmcm9tICcuLi9Gb3JtQ29udHJvbC91c2VGb3JtQ29udHJvbCc7XG5pbXBvcnQgQXJyb3dEcm9wRG93bkljb24gZnJvbSAnLi4vaW50ZXJuYWwvc3ZnLWljb25zL0Fycm93RHJvcERvd24nO1xuaW1wb3J0IElucHV0IGZyb20gJy4uL0lucHV0JztcbmV4cG9ydCB2YXIgc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKHRoZW1lKSB7XG4gIHJldHVybiB7XG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHNlbGVjdCBjb21wb25lbnQgYHJvb3RgIGNsYXNzLiAqL1xuICAgIHJvb3Q6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHNlbGVjdCBjb21wb25lbnQgYHNlbGVjdGAgY2xhc3MuICovXG4gICAgc2VsZWN0OiB7XG4gICAgICAnLW1vei1hcHBlYXJhbmNlJzogJ25vbmUnLFxuICAgICAgLy8gUmVzZXRcbiAgICAgICctd2Via2l0LWFwcGVhcmFuY2UnOiAnbm9uZScsXG4gICAgICAvLyBSZXNldFxuICAgICAgLy8gV2hlbiBpbnRlcmFjdGluZyBxdWlja2x5LCB0aGUgdGV4dCBjYW4gZW5kIHVwIHNlbGVjdGVkLlxuICAgICAgLy8gTmF0aXZlIHNlbGVjdCBjYW4ndCBiZSBzZWxlY3RlZCBlaXRoZXIuXG4gICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAvLyBSZXNldFxuICAgICAgbWluV2lkdGg6IDE2LFxuICAgICAgLy8gU28gaXQgZG9lc24ndCBjb2xsYXBzZS5cbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgJyY6Zm9jdXMnOiB7XG4gICAgICAgIC8vIFNob3cgdGhhdCBpdCdzIG5vdCBhbiB0ZXh0IGlucHV0XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS50eXBlID09PSAnbGlnaHQnID8gJ3JnYmEoMCwgMCwgMCwgMC4wNSknIDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4wNSknLFxuICAgICAgICBib3JkZXJSYWRpdXM6IDAgLy8gUmVzZXQgQ2hyb21lIHN0eWxlXG5cbiAgICAgIH0sXG4gICAgICAvLyBSZW1vdmUgSUUgMTEgYXJyb3dcbiAgICAgICcmOjotbXMtZXhwYW5kJzoge1xuICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgIH0sXG4gICAgICAnJiRkaXNhYmxlZCc6IHtcbiAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCdcbiAgICAgIH0sXG4gICAgICAnJlttdWx0aXBsZV0nOiB7XG4gICAgICAgIGhlaWdodDogJ2F1dG8nXG4gICAgICB9LFxuICAgICAgJyY6bm90KFttdWx0aXBsZV0pIG9wdGlvbiwgJjpub3QoW211bHRpcGxlXSkgb3B0Z3JvdXAnOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5iYWNrZ3JvdW5kLnBhcGVyXG4gICAgICB9LFxuICAgICAgJyYmJzoge1xuICAgICAgICBwYWRkaW5nUmlnaHQ6IDI0XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBzZWxlY3QgY29tcG9uZW50IGlmIGB2YXJpYW50PVwiZmlsbGVkXCJgLiAqL1xuICAgIGZpbGxlZDoge1xuICAgICAgJyYmJzoge1xuICAgICAgICBwYWRkaW5nUmlnaHQ6IDMyXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBzZWxlY3QgY29tcG9uZW50IGlmIGB2YXJpYW50PVwib3V0bGluZWRcImAuICovXG4gICAgb3V0bGluZWQ6IHtcbiAgICAgIGJvcmRlclJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzLFxuICAgICAgJyYmJzoge1xuICAgICAgICBwYWRkaW5nUmlnaHQ6IDMyXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBzZWxlY3QgY29tcG9uZW50IGBzZWxlY3RNZW51YCBjbGFzcy4gKi9cbiAgICBzZWxlY3RNZW51OiB7XG4gICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgIC8vIFJlc2V0cyBmb3IgbXVsdHBpbGUgc2VsZWN0IHdpdGggY2hpcHNcbiAgICAgIG1pbkhlaWdodDogJzEuMTg3NmVtJyxcbiAgICAgIC8vIFJlcXVpcmVkIGZvciBzZWxlY3RcXHRleHQtZmllbGQgaGVpZ2h0IGNvbnNpc3RlbmN5XG4gICAgICB0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcycsXG4gICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgIH0sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgc2VsZWN0IGNvbXBvbmVudCBgZGlzYWJsZWRgIGNsYXNzLiAqL1xuICAgIGRpc2FibGVkOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBpY29uIGNvbXBvbmVudC4gKi9cbiAgICBpY29uOiB7XG4gICAgICAvLyBXZSB1c2UgYSBwb3NpdGlvbiBhYnNvbHV0ZSBvdmVyIGEgZmxleGJveCBpbiBvcmRlciB0byBmb3J3YXJkIHRoZSBwb2ludGVyIGV2ZW50c1xuICAgICAgLy8gdG8gdGhlIGlucHV0IGFuZCB0byBzdXBwb3J0IHdyYXBwaW5nIHRhZ3MuLlxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogJ2NhbGMoNTAlIC0gMTJweCknLFxuICAgICAgLy8gQ2VudGVyIHZlcnRpY2FsbHlcbiAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgIC8vIERvbid0IGJsb2NrIHBvaW50ZXIgZXZlbnRzIG9uIHRoZSBzZWxlY3QgdW5kZXIgdGhlIGljb24uXG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5hY3Rpb24uYWN0aXZlLFxuICAgICAgJyYkZGlzYWJsZWQnOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmFjdGlvbi5kaXNhYmxlZFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaWNvbiBjb21wb25lbnQgaWYgdGhlIHBvcHVwIGlzIG9wZW4uICovXG4gICAgaWNvbk9wZW46IHtcbiAgICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgxODBkZWcpJ1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaWNvbiBjb21wb25lbnQgaWYgYHZhcmlhbnQ9XCJmaWxsZWRcImAuICovXG4gICAgaWNvbkZpbGxlZDoge1xuICAgICAgcmlnaHQ6IDdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGljb24gY29tcG9uZW50IGlmIGB2YXJpYW50PVwib3V0bGluZWRcImAuICovXG4gICAgaWNvbk91dGxpbmVkOiB7XG4gICAgICByaWdodDogN1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgdW5kZXJseWluZyBuYXRpdmUgaW5wdXQgY29tcG9uZW50LiAqL1xuICAgIG5hdGl2ZUlucHV0OiB7XG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgIH1cbiAgfTtcbn07XG52YXIgZGVmYXVsdElucHV0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXQsIG51bGwpO1xuLyoqXG4gKiBBbiBhbHRlcm5hdGl2ZSB0byBgPFNlbGVjdCBuYXRpdmUgLz5gIHdpdGggYSBtdWNoIHNtYWxsZXIgYnVuZGxlIHNpemUgZm9vdHByaW50LlxuICovXG5cbnZhciBOYXRpdmVTZWxlY3QgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBOYXRpdmVTZWxlY3QocHJvcHMsIHJlZikge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgX3Byb3BzJEljb25Db21wb25lbnQgPSBwcm9wcy5JY29uQ29tcG9uZW50LFxuICAgICAgSWNvbkNvbXBvbmVudCA9IF9wcm9wcyRJY29uQ29tcG9uZW50ID09PSB2b2lkIDAgPyBBcnJvd0Ryb3BEb3duSWNvbiA6IF9wcm9wcyRJY29uQ29tcG9uZW50LFxuICAgICAgX3Byb3BzJGlucHV0ID0gcHJvcHMuaW5wdXQsXG4gICAgICBpbnB1dCA9IF9wcm9wcyRpbnB1dCA9PT0gdm9pZCAwID8gZGVmYXVsdElucHV0IDogX3Byb3BzJGlucHV0LFxuICAgICAgaW5wdXRQcm9wcyA9IHByb3BzLmlucHV0UHJvcHMsXG4gICAgICB2YXJpYW50ID0gcHJvcHMudmFyaWFudCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJJY29uQ29tcG9uZW50XCIsIFwiaW5wdXRcIiwgXCJpbnB1dFByb3BzXCIsIFwidmFyaWFudFwiXSk7XG5cbiAgdmFyIG11aUZvcm1Db250cm9sID0gdXNlRm9ybUNvbnRyb2woKTtcbiAgdmFyIGZjcyA9IGZvcm1Db250cm9sU3RhdGUoe1xuICAgIHByb3BzOiBwcm9wcyxcbiAgICBtdWlGb3JtQ29udHJvbDogbXVpRm9ybUNvbnRyb2wsXG4gICAgc3RhdGVzOiBbJ3ZhcmlhbnQnXVxuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoaW5wdXQsIF9leHRlbmRzKHtcbiAgICAvLyBNb3N0IG9mIHRoZSBsb2dpYyBpcyBpbXBsZW1lbnRlZCBpbiBgTmF0aXZlU2VsZWN0SW5wdXRgLlxuICAgIC8vIFRoZSBgU2VsZWN0YCBjb21wb25lbnQgaXMgYSBzaW1wbGUgQVBJIHdyYXBwZXIgdG8gZXhwb3NlIHNvbWV0aGluZyBiZXR0ZXIgdG8gcGxheSB3aXRoLlxuICAgIGlucHV0Q29tcG9uZW50OiBOYXRpdmVTZWxlY3RJbnB1dCxcbiAgICBpbnB1dFByb3BzOiBfZXh0ZW5kcyh7XG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzOiBjbGFzc2VzLFxuICAgICAgSWNvbkNvbXBvbmVudDogSWNvbkNvbXBvbmVudCxcbiAgICAgIHZhcmlhbnQ6IGZjcy52YXJpYW50LFxuICAgICAgdHlwZTogdW5kZWZpbmVkXG4gICAgfSwgaW5wdXRQcm9wcywgaW5wdXQgPyBpbnB1dC5wcm9wcy5pbnB1dFByb3BzIDoge30pLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IE5hdGl2ZVNlbGVjdC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBUaGUgb3B0aW9uIGVsZW1lbnRzIHRvIHBvcHVsYXRlIHRoZSBzZWxlY3Qgd2l0aC5cbiAgICogQ2FuIGJlIHNvbWUgYDxvcHRpb24+YCBlbGVtZW50cy5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBUaGUgaWNvbiB0aGF0IGRpc3BsYXlzIHRoZSBhcnJvdy5cbiAgICovXG4gIEljb25Db21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogQW4gYElucHV0YCBlbGVtZW50OyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgbWF0ZXJpYWwtdWkgc3BlY2lmaWMgYElucHV0YC5cbiAgICovXG4gIGlucHV0OiBQcm9wVHlwZXMuZWxlbWVudCxcblxuICAvKipcbiAgICogQXR0cmlidXRlcyBhcHBsaWVkIHRvIHRoZSBgc2VsZWN0YCBlbGVtZW50LlxuICAgKi9cbiAgaW5wdXRQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gZmlyZWQgd2hlbiBhIG1lbnUgaXRlbSBpcyBzZWxlY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBZb3UgY2FuIHB1bGwgb3V0IHRoZSBuZXcgdmFsdWUgYnkgYWNjZXNzaW5nIGBldmVudC50YXJnZXQudmFsdWVgIChzdHJpbmcpLlxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgdmFsdWUuIFRoZSBET00gQVBJIGNhc3RzIHRoaXMgdG8gYSBzdHJpbmcuXG4gICAqL1xuICB2YWx1ZTogUHJvcFR5cGVzLmFueSxcblxuICAvKipcbiAgICogVGhlIHZhcmlhbnQgdG8gdXNlLlxuICAgKi9cbiAgdmFyaWFudDogUHJvcFR5cGVzLm9uZU9mKFsnZmlsbGVkJywgJ291dGxpbmVkJywgJ3N0YW5kYXJkJ10pXG59IDogdm9pZCAwO1xuTmF0aXZlU2VsZWN0Lm11aU5hbWUgPSAnU2VsZWN0JztcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlOYXRpdmVTZWxlY3QnXG59KShOYXRpdmVTZWxlY3QpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBtZXJnZUNsYXNzZXMgfSBmcm9tICdAbWF0ZXJpYWwtdWkvc3R5bGVzJztcbmltcG9ydCBTZWxlY3RJbnB1dCBmcm9tICcuL1NlbGVjdElucHV0JztcbmltcG9ydCBmb3JtQ29udHJvbFN0YXRlIGZyb20gJy4uL0Zvcm1Db250cm9sL2Zvcm1Db250cm9sU3RhdGUnO1xuaW1wb3J0IHVzZUZvcm1Db250cm9sIGZyb20gJy4uL0Zvcm1Db250cm9sL3VzZUZvcm1Db250cm9sJztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCBBcnJvd0Ryb3BEb3duSWNvbiBmcm9tICcuLi9pbnRlcm5hbC9zdmctaWNvbnMvQXJyb3dEcm9wRG93bic7XG5pbXBvcnQgSW5wdXQgZnJvbSAnLi4vSW5wdXQnO1xuaW1wb3J0IHsgc3R5bGVzIGFzIG5hdGl2ZVNlbGVjdFN0eWxlcyB9IGZyb20gJy4uL05hdGl2ZVNlbGVjdC9OYXRpdmVTZWxlY3QnO1xuaW1wb3J0IE5hdGl2ZVNlbGVjdElucHV0IGZyb20gJy4uL05hdGl2ZVNlbGVjdC9OYXRpdmVTZWxlY3RJbnB1dCc7XG5pbXBvcnQgRmlsbGVkSW5wdXQgZnJvbSAnLi4vRmlsbGVkSW5wdXQnO1xuaW1wb3J0IE91dGxpbmVkSW5wdXQgZnJvbSAnLi4vT3V0bGluZWRJbnB1dCc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IG5hdGl2ZVNlbGVjdFN0eWxlcztcblxudmFyIF9yZWYgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJbnB1dCwgbnVsbCk7XG5cbnZhciBfcmVmMiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZpbGxlZElucHV0LCBudWxsKTtcblxudmFyIFNlbGVjdCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFNlbGVjdChwcm9wcywgcmVmKSB7XG4gIHZhciBfcHJvcHMkYXV0b1dpZHRoID0gcHJvcHMuYXV0b1dpZHRoLFxuICAgICAgYXV0b1dpZHRoID0gX3Byb3BzJGF1dG9XaWR0aCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkYXV0b1dpZHRoLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgX3Byb3BzJGRpc3BsYXlFbXB0eSA9IHByb3BzLmRpc3BsYXlFbXB0eSxcbiAgICAgIGRpc3BsYXlFbXB0eSA9IF9wcm9wcyRkaXNwbGF5RW1wdHkgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc3BsYXlFbXB0eSxcbiAgICAgIF9wcm9wcyRJY29uQ29tcG9uZW50ID0gcHJvcHMuSWNvbkNvbXBvbmVudCxcbiAgICAgIEljb25Db21wb25lbnQgPSBfcHJvcHMkSWNvbkNvbXBvbmVudCA9PT0gdm9pZCAwID8gQXJyb3dEcm9wRG93bkljb24gOiBfcHJvcHMkSWNvbkNvbXBvbmVudCxcbiAgICAgIGlkID0gcHJvcHMuaWQsXG4gICAgICBpbnB1dCA9IHByb3BzLmlucHV0LFxuICAgICAgaW5wdXRQcm9wcyA9IHByb3BzLmlucHV0UHJvcHMsXG4gICAgICBsYWJlbCA9IHByb3BzLmxhYmVsLFxuICAgICAgbGFiZWxJZCA9IHByb3BzLmxhYmVsSWQsXG4gICAgICBfcHJvcHMkbGFiZWxXaWR0aCA9IHByb3BzLmxhYmVsV2lkdGgsXG4gICAgICBsYWJlbFdpZHRoID0gX3Byb3BzJGxhYmVsV2lkdGggPT09IHZvaWQgMCA/IDAgOiBfcHJvcHMkbGFiZWxXaWR0aCxcbiAgICAgIE1lbnVQcm9wcyA9IHByb3BzLk1lbnVQcm9wcyxcbiAgICAgIF9wcm9wcyRtdWx0aXBsZSA9IHByb3BzLm11bHRpcGxlLFxuICAgICAgbXVsdGlwbGUgPSBfcHJvcHMkbXVsdGlwbGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJG11bHRpcGxlLFxuICAgICAgX3Byb3BzJG5hdGl2ZSA9IHByb3BzLm5hdGl2ZSxcbiAgICAgIG5hdGl2ZSA9IF9wcm9wcyRuYXRpdmUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJG5hdGl2ZSxcbiAgICAgIG9uQ2xvc2UgPSBwcm9wcy5vbkNsb3NlLFxuICAgICAgb25PcGVuID0gcHJvcHMub25PcGVuLFxuICAgICAgb3BlbiA9IHByb3BzLm9wZW4sXG4gICAgICByZW5kZXJWYWx1ZSA9IHByb3BzLnJlbmRlclZhbHVlLFxuICAgICAgU2VsZWN0RGlzcGxheVByb3BzID0gcHJvcHMuU2VsZWN0RGlzcGxheVByb3BzLFxuICAgICAgX3Byb3BzJHZhcmlhbnQgPSBwcm9wcy52YXJpYW50LFxuICAgICAgdmFyaWFudFByb3BzID0gX3Byb3BzJHZhcmlhbnQgPT09IHZvaWQgMCA/ICdzdGFuZGFyZCcgOiBfcHJvcHMkdmFyaWFudCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJhdXRvV2lkdGhcIiwgXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJkaXNwbGF5RW1wdHlcIiwgXCJJY29uQ29tcG9uZW50XCIsIFwiaWRcIiwgXCJpbnB1dFwiLCBcImlucHV0UHJvcHNcIiwgXCJsYWJlbFwiLCBcImxhYmVsSWRcIiwgXCJsYWJlbFdpZHRoXCIsIFwiTWVudVByb3BzXCIsIFwibXVsdGlwbGVcIiwgXCJuYXRpdmVcIiwgXCJvbkNsb3NlXCIsIFwib25PcGVuXCIsIFwib3BlblwiLCBcInJlbmRlclZhbHVlXCIsIFwiU2VsZWN0RGlzcGxheVByb3BzXCIsIFwidmFyaWFudFwiXSk7XG5cbiAgdmFyIGlucHV0Q29tcG9uZW50ID0gbmF0aXZlID8gTmF0aXZlU2VsZWN0SW5wdXQgOiBTZWxlY3RJbnB1dDtcbiAgdmFyIG11aUZvcm1Db250cm9sID0gdXNlRm9ybUNvbnRyb2woKTtcbiAgdmFyIGZjcyA9IGZvcm1Db250cm9sU3RhdGUoe1xuICAgIHByb3BzOiBwcm9wcyxcbiAgICBtdWlGb3JtQ29udHJvbDogbXVpRm9ybUNvbnRyb2wsXG4gICAgc3RhdGVzOiBbJ3ZhcmlhbnQnXVxuICB9KTtcbiAgdmFyIHZhcmlhbnQgPSBmY3MudmFyaWFudCB8fCB2YXJpYW50UHJvcHM7XG4gIHZhciBJbnB1dENvbXBvbmVudCA9IGlucHV0IHx8IHtcbiAgICBzdGFuZGFyZDogX3JlZixcbiAgICBvdXRsaW5lZDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoT3V0bGluZWRJbnB1dCwge1xuICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgbGFiZWxXaWR0aDogbGFiZWxXaWR0aFxuICAgIH0pLFxuICAgIGZpbGxlZDogX3JlZjJcbiAgfVt2YXJpYW50XTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoSW5wdXRDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICAvLyBNb3N0IG9mIHRoZSBsb2dpYyBpcyBpbXBsZW1lbnRlZCBpbiBgU2VsZWN0SW5wdXRgLlxuICAgIC8vIFRoZSBgU2VsZWN0YCBjb21wb25lbnQgaXMgYSBzaW1wbGUgQVBJIHdyYXBwZXIgdG8gZXhwb3NlIHNvbWV0aGluZyBiZXR0ZXIgdG8gcGxheSB3aXRoLlxuICAgIGlucHV0Q29tcG9uZW50OiBpbnB1dENvbXBvbmVudCxcbiAgICBpbnB1dFByb3BzOiBfZXh0ZW5kcyh7XG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICBJY29uQ29tcG9uZW50OiBJY29uQ29tcG9uZW50LFxuICAgICAgdmFyaWFudDogdmFyaWFudCxcbiAgICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAgIC8vIFdlIHJlbmRlciBhIHNlbGVjdC4gV2UgY2FuIGlnbm9yZSB0aGUgdHlwZSBwcm92aWRlZCBieSB0aGUgYElucHV0YC5cbiAgICAgIG11bHRpcGxlOiBtdWx0aXBsZVxuICAgIH0sIG5hdGl2ZSA/IHtcbiAgICAgIGlkOiBpZFxuICAgIH0gOiB7XG4gICAgICBhdXRvV2lkdGg6IGF1dG9XaWR0aCxcbiAgICAgIGRpc3BsYXlFbXB0eTogZGlzcGxheUVtcHR5LFxuICAgICAgbGFiZWxJZDogbGFiZWxJZCxcbiAgICAgIE1lbnVQcm9wczogTWVudVByb3BzLFxuICAgICAgb25DbG9zZTogb25DbG9zZSxcbiAgICAgIG9uT3Blbjogb25PcGVuLFxuICAgICAgb3Blbjogb3BlbixcbiAgICAgIHJlbmRlclZhbHVlOiByZW5kZXJWYWx1ZSxcbiAgICAgIFNlbGVjdERpc3BsYXlQcm9wczogX2V4dGVuZHMoe1xuICAgICAgICBpZDogaWRcbiAgICAgIH0sIFNlbGVjdERpc3BsYXlQcm9wcylcbiAgICB9LCBpbnB1dFByb3BzLCB7XG4gICAgICBjbGFzc2VzOiBpbnB1dFByb3BzID8gbWVyZ2VDbGFzc2VzKHtcbiAgICAgICAgYmFzZUNsYXNzZXM6IGNsYXNzZXMsXG4gICAgICAgIG5ld0NsYXNzZXM6IGlucHV0UHJvcHMuY2xhc3NlcyxcbiAgICAgICAgQ29tcG9uZW50OiBTZWxlY3RcbiAgICAgIH0pIDogY2xhc3Nlc1xuICAgIH0sIGlucHV0ID8gaW5wdXQucHJvcHMuaW5wdXRQcm9wcyA6IHt9KSxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlcikpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBTZWxlY3QucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgd2lkdGggb2YgdGhlIHBvcG92ZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHNldCBhY2NvcmRpbmcgdG8gdGhlIGl0ZW1zIGluc2lkZSB0aGVcbiAgICogbWVudSwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgYXQgbGVhc3QgdGhlIHdpZHRoIG9mIHRoZSBzZWxlY3QgaW5wdXQuXG4gICAqL1xuICBhdXRvV2lkdGg6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgb3B0aW9uIGVsZW1lbnRzIHRvIHBvcHVsYXRlIHRoZSBzZWxlY3Qgd2l0aC5cbiAgICogQ2FuIGJlIHNvbWUgYE1lbnVJdGVtYCB3aGVuIGBuYXRpdmVgIGlzIGZhbHNlIGFuZCBgb3B0aW9uYCB3aGVuIGBuYXRpdmVgIGlzIHRydWUuXG4gICAqXG4gICAqIOKaoO+4j1RoZSBgTWVudUl0ZW1gIGVsZW1lbnRzICoqbXVzdCoqIGJlIGRpcmVjdCBkZXNjZW5kYW50cyB3aGVuIGBuYXRpdmVgIGlzIGZhbHNlLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGVsZW1lbnQgdmFsdWUuIFVzZSB3aGVuIHRoZSBjb21wb25lbnQgaXMgbm90IGNvbnRyb2xsZWQuXG4gICAqL1xuICBkZWZhdWx0VmFsdWU6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgYSB2YWx1ZSBpcyBkaXNwbGF5ZWQgZXZlbiBpZiBubyBpdGVtcyBhcmUgc2VsZWN0ZWQuXG4gICAqXG4gICAqIEluIG9yZGVyIHRvIGRpc3BsYXkgYSBtZWFuaW5nZnVsIHZhbHVlLCBhIGZ1bmN0aW9uIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIGByZW5kZXJWYWx1ZWAgcHJvcCB3aGljaCByZXR1cm5zIHRoZSB2YWx1ZSB0byBiZSBkaXNwbGF5ZWQgd2hlbiBubyBpdGVtcyBhcmUgc2VsZWN0ZWQuXG4gICAqIFlvdSBjYW4gb25seSB1c2UgaXQgd2hlbiB0aGUgYG5hdGl2ZWAgcHJvcCBpcyBgZmFsc2VgIChkZWZhdWx0KS5cbiAgICovXG4gIGRpc3BsYXlFbXB0eTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBpY29uIHRoYXQgZGlzcGxheXMgdGhlIGFycm93LlxuICAgKi9cbiAgSWNvbkNvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBUaGUgYGlkYCBvZiB0aGUgd3JhcHBlciBlbGVtZW50IG9yIHRoZSBgc2VsZWN0YCBlbGVtZW50IHdoZW4gYG5hdGl2ZWAuXG4gICAqL1xuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQW4gYElucHV0YCBlbGVtZW50OyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgbWF0ZXJpYWwtdWkgc3BlY2lmaWMgYElucHV0YC5cbiAgICovXG4gIGlucHV0OiBQcm9wVHlwZXMuZWxlbWVudCxcblxuICAvKipcbiAgICogW0F0dHJpYnV0ZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNBdHRyaWJ1dGVzKSBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqIFdoZW4gYG5hdGl2ZWAgaXMgYHRydWVgLCB0aGUgYXR0cmlidXRlcyBhcmUgYXBwbGllZCBvbiB0aGUgYHNlbGVjdGAgZWxlbWVudC5cbiAgICovXG4gIGlucHV0UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFNlZSBbT3V0bGluZWRJbnB1dCNsYWJlbF0oL2FwaS9vdXRsaW5lZC1pbnB1dC8jcHJvcHMpXG4gICAqL1xuICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiBhbiBlbGVtZW50IHRoYXQgYWN0cyBhcyBhbiBhZGRpdGlvbmFsIGxhYmVsLiBUaGUgU2VsZWN0IHdpbGxcbiAgICogYmUgbGFiZWxsZWQgYnkgdGhlIGFkZGl0aW9uYWwgbGFiZWwgYW5kIHRoZSBzZWxlY3RlZCB2YWx1ZS5cbiAgICovXG4gIGxhYmVsSWQ6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFNlZSBbT3V0bGluZWRJbnB1dCNsYWJlbF0oL2FwaS9vdXRsaW5lZC1pbnB1dC8jcHJvcHMpXG4gICAqL1xuICBsYWJlbFdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBbYE1lbnVgXSgvYXBpL21lbnUvKSBlbGVtZW50LlxuICAgKi9cbiAgTWVudVByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGB2YWx1ZWAgbXVzdCBiZSBhbiBhcnJheSBhbmQgdGhlIG1lbnUgd2lsbCBzdXBwb3J0IG11bHRpcGxlIHNlbGVjdGlvbnMuXG4gICAqL1xuICBtdWx0aXBsZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNvbXBvbmVudCB3aWxsIGJlIHVzaW5nIGEgbmF0aXZlIGBzZWxlY3RgIGVsZW1lbnQuXG4gICAqL1xuICBuYXRpdmU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBmaXJlZCB3aGVuIGEgbWVudSBpdGVtIGlzIHNlbGVjdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqIFlvdSBjYW4gcHVsbCBvdXQgdGhlIG5ldyB2YWx1ZSBieSBhY2Nlc3NpbmcgYGV2ZW50LnRhcmdldC52YWx1ZWAgKGFueSkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY2hpbGRdIFRoZSByZWFjdCBlbGVtZW50IHRoYXQgd2FzIHNlbGVjdGVkIHdoZW4gYG5hdGl2ZWAgaXMgYGZhbHNlYCAoZGVmYXVsdCkuXG4gICAqL1xuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGNvbXBvbmVudCByZXF1ZXN0cyB0byBiZSBjbG9zZWQuXG4gICAqIFVzZSBpbiBjb250cm9sbGVkIG1vZGUgKHNlZSBvcGVuKS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKi9cbiAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGNvbXBvbmVudCByZXF1ZXN0cyB0byBiZSBvcGVuZWQuXG4gICAqIFVzZSBpbiBjb250cm9sbGVkIG1vZGUgKHNlZSBvcGVuKS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKi9cbiAgb25PcGVuOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ29udHJvbCBgc2VsZWN0YCBvcGVuIHN0YXRlLlxuICAgKiBZb3UgY2FuIG9ubHkgdXNlIGl0IHdoZW4gdGhlIGBuYXRpdmVgIHByb3AgaXMgYGZhbHNlYCAoZGVmYXVsdCkuXG4gICAqL1xuICBvcGVuOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBzZWxlY3RlZCB2YWx1ZS5cbiAgICogWW91IGNhbiBvbmx5IHVzZSBpdCB3aGVuIHRoZSBgbmF0aXZlYCBwcm9wIGlzIGBmYWxzZWAgKGRlZmF1bHQpLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIGB2YWx1ZWAgcHJvdmlkZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogQHJldHVybnMge1JlYWN0Tm9kZX1cbiAgICovXG4gIHJlbmRlclZhbHVlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogUHJvcHMgYXBwbGllZCB0byB0aGUgY2xpY2thYmxlIGRpdiBlbGVtZW50LlxuICAgKi9cbiAgU2VsZWN0RGlzcGxheVByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgdmFsdWUuIFByb3ZpZGluZyBhbiBlbXB0eSBzdHJpbmcgd2lsbCBzZWxlY3Qgbm8gb3B0aW9ucy5cbiAgICogVGhpcyBwcm9wIGlzIHJlcXVpcmVkIHdoZW4gdGhlIGBuYXRpdmVgIHByb3AgaXMgYGZhbHNlYCAoZGVmYXVsdCkuXG4gICAqIFNldCB0byBhbiBlbXB0eSBzdHJpbmcgYCcnYCBpZiB5b3UgZG9uJ3Qgd2FudCBhbnkgb2YgdGhlIGF2YWlsYWJsZSBvcHRpb25zIHRvIGJlIHNlbGVjdGVkLlxuICAgKlxuICAgKiBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IGl0IG11c3QgaGF2ZSByZWZlcmVuY2UgZXF1YWxpdHkgd2l0aCB0aGUgb3B0aW9uIGluIG9yZGVyIHRvIGJlIHNlbGVjdGVkLlxuICAgKiBJZiB0aGUgdmFsdWUgaXMgbm90IGFuIG9iamVjdCwgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBtdXN0IG1hdGNoIHdpdGggdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb3B0aW9uIGluIG9yZGVyIHRvIGJlIHNlbGVjdGVkLlxuICAgKi9cbiAgdmFsdWU6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXG4gICAqIFRoZSB2YXJpYW50IHRvIHVzZS5cbiAgICovXG4gIHZhcmlhbnQ6IFByb3BUeXBlcy5vbmVPZihbJ2ZpbGxlZCcsICdvdXRsaW5lZCcsICdzdGFuZGFyZCddKVxufSA6IHZvaWQgMDtcblNlbGVjdC5tdWlOYW1lID0gJ1NlbGVjdCc7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpU2VsZWN0J1xufSkoU2VsZWN0KTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyByZWZUeXBlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCBJbnB1dCBmcm9tICcuLi9JbnB1dCc7XG5pbXBvcnQgRmlsbGVkSW5wdXQgZnJvbSAnLi4vRmlsbGVkSW5wdXQnO1xuaW1wb3J0IE91dGxpbmVkSW5wdXQgZnJvbSAnLi4vT3V0bGluZWRJbnB1dCc7XG5pbXBvcnQgSW5wdXRMYWJlbCBmcm9tICcuLi9JbnB1dExhYmVsJztcbmltcG9ydCBGb3JtQ29udHJvbCBmcm9tICcuLi9Gb3JtQ29udHJvbCc7XG5pbXBvcnQgRm9ybUhlbHBlclRleHQgZnJvbSAnLi4vRm9ybUhlbHBlclRleHQnO1xuaW1wb3J0IFNlbGVjdCBmcm9tICcuLi9TZWxlY3QnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xudmFyIHZhcmlhbnRDb21wb25lbnQgPSB7XG4gIHN0YW5kYXJkOiBJbnB1dCxcbiAgZmlsbGVkOiBGaWxsZWRJbnB1dCxcbiAgb3V0bGluZWQ6IE91dGxpbmVkSW5wdXRcbn07XG5leHBvcnQgdmFyIHN0eWxlcyA9IHtcbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgcm9vdDoge31cbn07XG4vKipcbiAqIFRoZSBgVGV4dEZpZWxkYCBpcyBhIGNvbnZlbmllbmNlIHdyYXBwZXIgZm9yIHRoZSBtb3N0IGNvbW1vbiBjYXNlcyAoODAlKS5cbiAqIEl0IGNhbm5vdCBiZSBhbGwgdGhpbmdzIHRvIGFsbCBwZW9wbGUsIG90aGVyd2lzZSB0aGUgQVBJIHdvdWxkIGdyb3cgb3V0IG9mIGNvbnRyb2wuXG4gKlxuICogIyMgQWR2YW5jZWQgQ29uZmlndXJhdGlvblxuICpcbiAqIEl0J3MgaW1wb3J0YW50IHRvIHVuZGVyc3RhbmQgdGhhdCB0aGUgdGV4dCBmaWVsZCBpcyBhIHNpbXBsZSBhYnN0cmFjdGlvblxuICogb24gdG9wIG9mIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czpcbiAqXG4gKiAtIFtGb3JtQ29udHJvbF0oL2FwaS9mb3JtLWNvbnRyb2wvKVxuICogLSBbSW5wdXRMYWJlbF0oL2FwaS9pbnB1dC1sYWJlbC8pXG4gKiAtIFtGaWxsZWRJbnB1dF0oL2FwaS9maWxsZWQtaW5wdXQvKVxuICogLSBbT3V0bGluZWRJbnB1dF0oL2FwaS9vdXRsaW5lZC1pbnB1dC8pXG4gKiAtIFtJbnB1dF0oL2FwaS9pbnB1dC8pXG4gKiAtIFtGb3JtSGVscGVyVGV4dF0oL2FwaS9mb3JtLWhlbHBlci10ZXh0LylcbiAqXG4gKiBJZiB5b3Ugd2lzaCB0byBhbHRlciB0aGUgcHJvcHMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50LCB5b3UgY2FuIGRvIHNvIGFzIGZvbGxvd3M6XG4gKlxuICogYGBganN4XG4gKiBjb25zdCBpbnB1dFByb3BzID0ge1xuICogICBzdGVwOiAzMDAsXG4gKiB9O1xuICpcbiAqIHJldHVybiA8VGV4dEZpZWxkIGlkPVwidGltZVwiIHR5cGU9XCJ0aW1lXCIgaW5wdXRQcm9wcz17aW5wdXRQcm9wc30gLz47XG4gKiBgYGBcbiAqXG4gKiBGb3IgYWR2YW5jZWQgY2FzZXMsIHBsZWFzZSBsb29rIGF0IHRoZSBzb3VyY2Ugb2YgVGV4dEZpZWxkIGJ5IGNsaWNraW5nIG9uIHRoZVxuICogXCJFZGl0IHRoaXMgcGFnZVwiIGJ1dHRvbiBhYm92ZS4gQ29uc2lkZXIgZWl0aGVyOlxuICpcbiAqIC0gdXNpbmcgdGhlIHVwcGVyIGNhc2UgcHJvcHMgZm9yIHBhc3NpbmcgdmFsdWVzIGRpcmVjdGx5IHRvIHRoZSBjb21wb25lbnRzXG4gKiAtIHVzaW5nIHRoZSB1bmRlcmx5aW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgYXMgc2hvd24gaW4gdGhlIGRlbW9zXG4gKi9cblxudmFyIFRleHRGaWVsZCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFRleHRGaWVsZChwcm9wcywgcmVmKSB7XG4gIHZhciBhdXRvQ29tcGxldGUgPSBwcm9wcy5hdXRvQ29tcGxldGUsXG4gICAgICBfcHJvcHMkYXV0b0ZvY3VzID0gcHJvcHMuYXV0b0ZvY3VzLFxuICAgICAgYXV0b0ZvY3VzID0gX3Byb3BzJGF1dG9Gb2N1cyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkYXV0b0ZvY3VzLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgX3Byb3BzJGNvbG9yID0gcHJvcHMuY29sb3IsXG4gICAgICBjb2xvciA9IF9wcm9wcyRjb2xvciA9PT0gdm9pZCAwID8gJ3ByaW1hcnknIDogX3Byb3BzJGNvbG9yLFxuICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgX3Byb3BzJGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQsXG4gICAgICBkaXNhYmxlZCA9IF9wcm9wcyRkaXNhYmxlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZWQsXG4gICAgICBfcHJvcHMkZXJyb3IgPSBwcm9wcy5lcnJvcixcbiAgICAgIGVycm9yID0gX3Byb3BzJGVycm9yID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRlcnJvcixcbiAgICAgIEZvcm1IZWxwZXJUZXh0UHJvcHMgPSBwcm9wcy5Gb3JtSGVscGVyVGV4dFByb3BzLFxuICAgICAgX3Byb3BzJGZ1bGxXaWR0aCA9IHByb3BzLmZ1bGxXaWR0aCxcbiAgICAgIGZ1bGxXaWR0aCA9IF9wcm9wcyRmdWxsV2lkdGggPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGZ1bGxXaWR0aCxcbiAgICAgIGhlbHBlclRleHQgPSBwcm9wcy5oZWxwZXJUZXh0LFxuICAgICAgaGlkZGVuTGFiZWwgPSBwcm9wcy5oaWRkZW5MYWJlbCxcbiAgICAgIGlkID0gcHJvcHMuaWQsXG4gICAgICBJbnB1dExhYmVsUHJvcHMgPSBwcm9wcy5JbnB1dExhYmVsUHJvcHMsXG4gICAgICBpbnB1dFByb3BzID0gcHJvcHMuaW5wdXRQcm9wcyxcbiAgICAgIElucHV0UHJvcHMgPSBwcm9wcy5JbnB1dFByb3BzLFxuICAgICAgaW5wdXRSZWYgPSBwcm9wcy5pbnB1dFJlZixcbiAgICAgIGxhYmVsID0gcHJvcHMubGFiZWwsXG4gICAgICBfcHJvcHMkbXVsdGlsaW5lID0gcHJvcHMubXVsdGlsaW5lLFxuICAgICAgbXVsdGlsaW5lID0gX3Byb3BzJG11bHRpbGluZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkbXVsdGlsaW5lLFxuICAgICAgbmFtZSA9IHByb3BzLm5hbWUsXG4gICAgICBvbkJsdXIgPSBwcm9wcy5vbkJsdXIsXG4gICAgICBvbkNoYW5nZSA9IHByb3BzLm9uQ2hhbmdlLFxuICAgICAgb25Gb2N1cyA9IHByb3BzLm9uRm9jdXMsXG4gICAgICBwbGFjZWhvbGRlciA9IHByb3BzLnBsYWNlaG9sZGVyLFxuICAgICAgX3Byb3BzJHJlcXVpcmVkID0gcHJvcHMucmVxdWlyZWQsXG4gICAgICByZXF1aXJlZCA9IF9wcm9wcyRyZXF1aXJlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkcmVxdWlyZWQsXG4gICAgICByb3dzID0gcHJvcHMucm93cyxcbiAgICAgIHJvd3NNYXggPSBwcm9wcy5yb3dzTWF4LFxuICAgICAgbWF4Um93cyA9IHByb3BzLm1heFJvd3MsXG4gICAgICBtaW5Sb3dzID0gcHJvcHMubWluUm93cyxcbiAgICAgIF9wcm9wcyRzZWxlY3QgPSBwcm9wcy5zZWxlY3QsXG4gICAgICBzZWxlY3QgPSBfcHJvcHMkc2VsZWN0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRzZWxlY3QsXG4gICAgICBTZWxlY3RQcm9wcyA9IHByb3BzLlNlbGVjdFByb3BzLFxuICAgICAgdHlwZSA9IHByb3BzLnR5cGUsXG4gICAgICB2YWx1ZSA9IHByb3BzLnZhbHVlLFxuICAgICAgX3Byb3BzJHZhcmlhbnQgPSBwcm9wcy52YXJpYW50LFxuICAgICAgdmFyaWFudCA9IF9wcm9wcyR2YXJpYW50ID09PSB2b2lkIDAgPyAnc3RhbmRhcmQnIDogX3Byb3BzJHZhcmlhbnQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYXV0b0NvbXBsZXRlXCIsIFwiYXV0b0ZvY3VzXCIsIFwiY2hpbGRyZW5cIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29sb3JcIiwgXCJkZWZhdWx0VmFsdWVcIiwgXCJkaXNhYmxlZFwiLCBcImVycm9yXCIsIFwiRm9ybUhlbHBlclRleHRQcm9wc1wiLCBcImZ1bGxXaWR0aFwiLCBcImhlbHBlclRleHRcIiwgXCJoaWRkZW5MYWJlbFwiLCBcImlkXCIsIFwiSW5wdXRMYWJlbFByb3BzXCIsIFwiaW5wdXRQcm9wc1wiLCBcIklucHV0UHJvcHNcIiwgXCJpbnB1dFJlZlwiLCBcImxhYmVsXCIsIFwibXVsdGlsaW5lXCIsIFwibmFtZVwiLCBcIm9uQmx1clwiLCBcIm9uQ2hhbmdlXCIsIFwib25Gb2N1c1wiLCBcInBsYWNlaG9sZGVyXCIsIFwicmVxdWlyZWRcIiwgXCJyb3dzXCIsIFwicm93c01heFwiLCBcIm1heFJvd3NcIiwgXCJtaW5Sb3dzXCIsIFwic2VsZWN0XCIsIFwiU2VsZWN0UHJvcHNcIiwgXCJ0eXBlXCIsIFwidmFsdWVcIiwgXCJ2YXJpYW50XCJdKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChzZWxlY3QgJiYgIWNoaWxkcmVuKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNYXRlcmlhbC1VSTogYGNoaWxkcmVuYCBtdXN0IGJlIHBhc3NlZCB3aGVuIHVzaW5nIHRoZSBgVGV4dEZpZWxkYCBjb21wb25lbnQgd2l0aCBgc2VsZWN0YC4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgSW5wdXRNb3JlID0ge307XG5cbiAgaWYgKHZhcmlhbnQgPT09ICdvdXRsaW5lZCcpIHtcbiAgICBpZiAoSW5wdXRMYWJlbFByb3BzICYmIHR5cGVvZiBJbnB1dExhYmVsUHJvcHMuc2hyaW5rICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgSW5wdXRNb3JlLm5vdGNoZWQgPSBJbnB1dExhYmVsUHJvcHMuc2hyaW5rO1xuICAgIH1cblxuICAgIGlmIChsYWJlbCkge1xuICAgICAgdmFyIF9JbnB1dExhYmVsUHJvcHMkcmVxdTtcblxuICAgICAgdmFyIGRpc3BsYXlSZXF1aXJlZCA9IChfSW5wdXRMYWJlbFByb3BzJHJlcXUgPSBJbnB1dExhYmVsUHJvcHMgPT09IG51bGwgfHwgSW5wdXRMYWJlbFByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBJbnB1dExhYmVsUHJvcHMucmVxdWlyZWQpICE9PSBudWxsICYmIF9JbnB1dExhYmVsUHJvcHMkcmVxdSAhPT0gdm9pZCAwID8gX0lucHV0TGFiZWxQcm9wcyRyZXF1IDogcmVxdWlyZWQ7XG4gICAgICBJbnB1dE1vcmUubGFiZWwgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgbGFiZWwsIGRpc3BsYXlSZXF1aXJlZCAmJiBcIlxceEEwKlwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZWN0KSB7XG4gICAgLy8gdW5zZXQgZGVmYXVsdHMgZnJvbSB0ZXh0Ym94IGlucHV0c1xuICAgIGlmICghU2VsZWN0UHJvcHMgfHwgIVNlbGVjdFByb3BzLm5hdGl2ZSkge1xuICAgICAgSW5wdXRNb3JlLmlkID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIElucHV0TW9yZVsnYXJpYS1kZXNjcmliZWRieSddID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIGhlbHBlclRleHRJZCA9IGhlbHBlclRleHQgJiYgaWQgPyBcIlwiLmNvbmNhdChpZCwgXCItaGVscGVyLXRleHRcIikgOiB1bmRlZmluZWQ7XG4gIHZhciBpbnB1dExhYmVsSWQgPSBsYWJlbCAmJiBpZCA/IFwiXCIuY29uY2F0KGlkLCBcIi1sYWJlbFwiKSA6IHVuZGVmaW5lZDtcbiAgdmFyIElucHV0Q29tcG9uZW50ID0gdmFyaWFudENvbXBvbmVudFt2YXJpYW50XTtcbiAgdmFyIElucHV0RWxlbWVudCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KElucHV0Q29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGhlbHBlclRleHRJZCxcbiAgICBhdXRvQ29tcGxldGU6IGF1dG9Db21wbGV0ZSxcbiAgICBhdXRvRm9jdXM6IGF1dG9Gb2N1cyxcbiAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBmdWxsV2lkdGg6IGZ1bGxXaWR0aCxcbiAgICBtdWx0aWxpbmU6IG11bHRpbGluZSxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHJvd3M6IHJvd3MsXG4gICAgcm93c01heDogcm93c01heCxcbiAgICBtYXhSb3dzOiBtYXhSb3dzLFxuICAgIG1pblJvd3M6IG1pblJvd3MsXG4gICAgdHlwZTogdHlwZSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgaWQ6IGlkLFxuICAgIGlucHV0UmVmOiBpbnB1dFJlZixcbiAgICBvbkJsdXI6IG9uQmx1cixcbiAgICBvbkNoYW5nZTogb25DaGFuZ2UsXG4gICAgb25Gb2N1czogb25Gb2N1cyxcbiAgICBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsXG4gICAgaW5wdXRQcm9wczogaW5wdXRQcm9wc1xuICB9LCBJbnB1dE1vcmUsIElucHV0UHJvcHMpKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1Db250cm9sLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lKSxcbiAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgZXJyb3I6IGVycm9yLFxuICAgIGZ1bGxXaWR0aDogZnVsbFdpZHRoLFxuICAgIGhpZGRlbkxhYmVsOiBoaWRkZW5MYWJlbCxcbiAgICByZWY6IHJlZixcbiAgICByZXF1aXJlZDogcmVxdWlyZWQsXG4gICAgY29sb3I6IGNvbG9yLFxuICAgIHZhcmlhbnQ6IHZhcmlhbnRcbiAgfSwgb3RoZXIpLCBsYWJlbCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJbnB1dExhYmVsLCBfZXh0ZW5kcyh7XG4gICAgaHRtbEZvcjogaWQsXG4gICAgaWQ6IGlucHV0TGFiZWxJZFxuICB9LCBJbnB1dExhYmVsUHJvcHMpLCBsYWJlbCksIHNlbGVjdCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFNlbGVjdCwgX2V4dGVuZHMoe1xuICAgIFwiYXJpYS1kZXNjcmliZWRieVwiOiBoZWxwZXJUZXh0SWQsXG4gICAgaWQ6IGlkLFxuICAgIGxhYmVsSWQ6IGlucHV0TGFiZWxJZCxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgaW5wdXQ6IElucHV0RWxlbWVudFxuICB9LCBTZWxlY3RQcm9wcyksIGNoaWxkcmVuKSA6IElucHV0RWxlbWVudCwgaGVscGVyVGV4dCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtSGVscGVyVGV4dCwgX2V4dGVuZHMoe1xuICAgIGlkOiBoZWxwZXJUZXh0SWRcbiAgfSwgRm9ybUhlbHBlclRleHRQcm9wcyksIGhlbHBlclRleHQpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVGV4dEZpZWxkLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoaXMgcHJvcCBoZWxwcyB1c2VycyB0byBmaWxsIGZvcm1zIGZhc3RlciwgZXNwZWNpYWxseSBvbiBtb2JpbGUgZGV2aWNlcy5cbiAgICogVGhlIG5hbWUgY2FuIGJlIGNvbmZ1c2luZywgYXMgaXQncyBtb3JlIGxpa2UgYW4gYXV0b2ZpbGwuXG4gICAqIFlvdSBjYW4gbGVhcm4gbW9yZSBhYm91dCBpdCBbZm9sbG93aW5nIHRoZSBzcGVjaWZpY2F0aW9uXShodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNhdXRvZmlsbCkuXG4gICAqL1xuICBhdXRvQ29tcGxldGU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIGZvY3VzZWQgZHVyaW5nIHRoZSBmaXJzdCBtb3VudC5cbiAgICovXG4gIGF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29tcG9uZW50LiBJdCBzdXBwb3J0cyB0aG9zZSB0aGVtZSBjb2xvcnMgdGhhdCBtYWtlIHNlbnNlIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoWydwcmltYXJ5JywgJ3NlY29uZGFyeSddKSxcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLmFueSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYGlucHV0YCBlbGVtZW50IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxhYmVsIHdpbGwgYmUgZGlzcGxheWVkIGluIGFuIGVycm9yIHN0YXRlLlxuICAgKi9cbiAgZXJyb3I6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBbYEZvcm1IZWxwZXJUZXh0YF0oL2FwaS9mb3JtLWhlbHBlci10ZXh0LykgZWxlbWVudC5cbiAgICovXG4gIEZvcm1IZWxwZXJUZXh0UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IHdpbGwgdGFrZSB1cCB0aGUgZnVsbCB3aWR0aCBvZiBpdHMgY29udGFpbmVyLlxuICAgKi9cbiAgZnVsbFdpZHRoOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGhlbHBlciB0ZXh0IGNvbnRlbnQuXG4gICAqL1xuICBoZWxwZXJUZXh0OiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgaGlkZGVuTGFiZWw6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgaWQgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICogVXNlIHRoaXMgcHJvcCB0byBtYWtlIGBsYWJlbGAgYW5kIGBoZWxwZXJUZXh0YCBhY2Nlc3NpYmxlIGZvciBzY3JlZW4gcmVhZGVycy5cbiAgICovXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBbYElucHV0TGFiZWxgXSgvYXBpL2lucHV0LWxhYmVsLykgZWxlbWVudC5cbiAgICovXG4gIElucHV0TGFiZWxQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogW0F0dHJpYnV0ZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNBdHRyaWJ1dGVzKSBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBJbnB1dCBlbGVtZW50LlxuICAgKiBJdCB3aWxsIGJlIGEgW2BGaWxsZWRJbnB1dGBdKC9hcGkvZmlsbGVkLWlucHV0LyksXG4gICAqIFtgT3V0bGluZWRJbnB1dGBdKC9hcGkvb3V0bGluZWQtaW5wdXQvKSBvciBbYElucHV0YF0oL2FwaS9pbnB1dC8pXG4gICAqIGNvbXBvbmVudCBkZXBlbmRpbmcgb24gdGhlIGB2YXJpYW50YCBwcm9wIHZhbHVlLlxuICAgKi9cbiAgSW5wdXRQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogUGFzcyBhIHJlZiB0byB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgaW5wdXRSZWY6IHJlZlR5cGUsXG5cbiAgLyoqXG4gICAqIFRoZSBsYWJlbCBjb250ZW50LlxuICAgKi9cbiAgbGFiZWw6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBJZiBgZGVuc2VgIG9yIGBub3JtYWxgLCB3aWxsIGFkanVzdCB2ZXJ0aWNhbCBzcGFjaW5nIG9mIHRoaXMgYW5kIGNvbnRhaW5lZCBjb21wb25lbnRzLlxuICAgKi9cbiAgbWFyZ2luOiBQcm9wVHlwZXMub25lT2YoWydkZW5zZScsICdub25lJywgJ25vcm1hbCddKSxcblxuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IHdoZW4gbXVsdGlsaW5lIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICovXG4gIG1heFJvd3M6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5LlxuICAgKi9cbiAgbWluUm93czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGEgdGV4dGFyZWEgZWxlbWVudCB3aWxsIGJlIHJlbmRlcmVkIGluc3RlYWQgb2YgYW4gaW5wdXQuXG4gICAqL1xuICBtdWx0aWxpbmU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBOYW1lIGF0dHJpYnV0ZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgdmFsdWUgaXMgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBZb3UgY2FuIHB1bGwgb3V0IHRoZSBuZXcgdmFsdWUgYnkgYWNjZXNzaW5nIGBldmVudC50YXJnZXQudmFsdWVgIChzdHJpbmcpLlxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkZvY3VzOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogVGhlIHNob3J0IGhpbnQgZGlzcGxheWVkIGluIHRoZSBpbnB1dCBiZWZvcmUgdGhlIHVzZXIgZW50ZXJzIGEgdmFsdWUuXG4gICAqL1xuICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbGFiZWwgaXMgZGlzcGxheWVkIGFzIHJlcXVpcmVkIGFuZCB0aGUgYGlucHV0YCBlbGVtZW50YCB3aWxsIGJlIHJlcXVpcmVkLlxuICAgKi9cbiAgcmVxdWlyZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IHdoZW4gbXVsdGlsaW5lIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBtaW5Sb3dzYCBpbnN0ZWFkLlxuICAgKi9cbiAgcm93czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgbWF4Um93c2AgaW5zdGVhZC5cbiAgICovXG4gIHJvd3NNYXg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogUmVuZGVyIGEgW2BTZWxlY3RgXSgvYXBpL3NlbGVjdC8pIGVsZW1lbnQgd2hpbGUgcGFzc2luZyB0aGUgSW5wdXQgZWxlbWVudCB0byBgU2VsZWN0YCBhcyBgaW5wdXRgIHBhcmFtZXRlci5cbiAgICogSWYgdGhpcyBvcHRpb24gaXMgc2V0IHlvdSBtdXN0IHBhc3MgdGhlIG9wdGlvbnMgb2YgdGhlIHNlbGVjdCBhcyBjaGlsZHJlbi5cbiAgICovXG4gIHNlbGVjdDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFByb3BzIGFwcGxpZWQgdG8gdGhlIFtgU2VsZWN0YF0oL2FwaS9zZWxlY3QvKSBlbGVtZW50LlxuICAgKi9cbiAgU2VsZWN0UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSB0ZXh0IGZpZWxkLlxuICAgKi9cbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnbWVkaXVtJywgJ3NtYWxsJ10pLFxuXG4gIC8qKlxuICAgKiBUeXBlIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuIEl0IHNob3VsZCBiZSBbYSB2YWxpZCBIVE1MNSBpbnB1dCB0eXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQjRm9ybV8lM0NpbnB1dCUzRV90eXBlcykuXG4gICAqL1xuICB0eXBlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudCwgcmVxdWlyZWQgZm9yIGEgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAqL1xuICB2YWx1ZTogUHJvcFR5cGVzLmFueSxcblxuICAvKipcbiAgICogVGhlIHZhcmlhbnQgdG8gdXNlLlxuICAgKi9cbiAgdmFyaWFudDogUHJvcFR5cGVzLm9uZU9mKFsnZmlsbGVkJywgJ291dGxpbmVkJywgJ3N0YW5kYXJkJ10pXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aVRleHRGaWVsZCdcbn0pKFRleHRGaWVsZCk7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyByZWZUeXBlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCB1c2VDb250cm9sbGVkIGZyb20gJy4uL3V0aWxzL3VzZUNvbnRyb2xsZWQnO1xuaW1wb3J0IHVzZUZvcm1Db250cm9sIGZyb20gJy4uL0Zvcm1Db250cm9sL3VzZUZvcm1Db250cm9sJztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCBJY29uQnV0dG9uIGZyb20gJy4uL0ljb25CdXR0b24nO1xuZXhwb3J0IHZhciBzdHlsZXMgPSB7XG4gIHJvb3Q6IHtcbiAgICBwYWRkaW5nOiA5XG4gIH0sXG4gIGNoZWNrZWQ6IHt9LFxuICBkaXNhYmxlZDoge30sXG4gIGlucHV0OiB7XG4gICAgY3Vyc29yOiAnaW5oZXJpdCcsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgb3BhY2l0eTogMCxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxuICAgIG1hcmdpbjogMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHpJbmRleDogMVxuICB9XG59O1xuLyoqXG4gKiBAaWdub3JlIC0gaW50ZXJuYWwgY29tcG9uZW50LlxuICovXG5cbnZhciBTd2l0Y2hCYXNlID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gU3dpdGNoQmFzZShwcm9wcywgcmVmKSB7XG4gIHZhciBhdXRvRm9jdXMgPSBwcm9wcy5hdXRvRm9jdXMsXG4gICAgICBjaGVja2VkUHJvcCA9IHByb3BzLmNoZWNrZWQsXG4gICAgICBjaGVja2VkSWNvbiA9IHByb3BzLmNoZWNrZWRJY29uLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBkZWZhdWx0Q2hlY2tlZCA9IHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgICAgZGlzYWJsZWRQcm9wID0gcHJvcHMuZGlzYWJsZWQsXG4gICAgICBpY29uID0gcHJvcHMuaWNvbixcbiAgICAgIGlkID0gcHJvcHMuaWQsXG4gICAgICBpbnB1dFByb3BzID0gcHJvcHMuaW5wdXRQcm9wcyxcbiAgICAgIGlucHV0UmVmID0gcHJvcHMuaW5wdXRSZWYsXG4gICAgICBuYW1lID0gcHJvcHMubmFtZSxcbiAgICAgIG9uQmx1ciA9IHByb3BzLm9uQmx1cixcbiAgICAgIG9uQ2hhbmdlID0gcHJvcHMub25DaGFuZ2UsXG4gICAgICBvbkZvY3VzID0gcHJvcHMub25Gb2N1cyxcbiAgICAgIHJlYWRPbmx5ID0gcHJvcHMucmVhZE9ubHksXG4gICAgICByZXF1aXJlZCA9IHByb3BzLnJlcXVpcmVkLFxuICAgICAgdGFiSW5kZXggPSBwcm9wcy50YWJJbmRleCxcbiAgICAgIHR5cGUgPSBwcm9wcy50eXBlLFxuICAgICAgdmFsdWUgPSBwcm9wcy52YWx1ZSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJhdXRvRm9jdXNcIiwgXCJjaGVja2VkXCIsIFwiY2hlY2tlZEljb25cIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiZGVmYXVsdENoZWNrZWRcIiwgXCJkaXNhYmxlZFwiLCBcImljb25cIiwgXCJpZFwiLCBcImlucHV0UHJvcHNcIiwgXCJpbnB1dFJlZlwiLCBcIm5hbWVcIiwgXCJvbkJsdXJcIiwgXCJvbkNoYW5nZVwiLCBcIm9uRm9jdXNcIiwgXCJyZWFkT25seVwiLCBcInJlcXVpcmVkXCIsIFwidGFiSW5kZXhcIiwgXCJ0eXBlXCIsIFwidmFsdWVcIl0pO1xuXG4gIHZhciBfdXNlQ29udHJvbGxlZCA9IHVzZUNvbnRyb2xsZWQoe1xuICAgIGNvbnRyb2xsZWQ6IGNoZWNrZWRQcm9wLFxuICAgIGRlZmF1bHQ6IEJvb2xlYW4oZGVmYXVsdENoZWNrZWQpLFxuICAgIG5hbWU6ICdTd2l0Y2hCYXNlJyxcbiAgICBzdGF0ZTogJ2NoZWNrZWQnXG4gIH0pLFxuICAgICAgX3VzZUNvbnRyb2xsZWQyID0gX3NsaWNlZFRvQXJyYXkoX3VzZUNvbnRyb2xsZWQsIDIpLFxuICAgICAgY2hlY2tlZCA9IF91c2VDb250cm9sbGVkMlswXSxcbiAgICAgIHNldENoZWNrZWRTdGF0ZSA9IF91c2VDb250cm9sbGVkMlsxXTtcblxuICB2YXIgbXVpRm9ybUNvbnRyb2wgPSB1c2VGb3JtQ29udHJvbCgpO1xuXG4gIHZhciBoYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIGhhbmRsZUZvY3VzKGV2ZW50KSB7XG4gICAgaWYgKG9uRm9jdXMpIHtcbiAgICAgIG9uRm9jdXMoZXZlbnQpO1xuICAgIH1cblxuICAgIGlmIChtdWlGb3JtQ29udHJvbCAmJiBtdWlGb3JtQ29udHJvbC5vbkZvY3VzKSB7XG4gICAgICBtdWlGb3JtQ29udHJvbC5vbkZvY3VzKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKGV2ZW50KSB7XG4gICAgaWYgKG9uQmx1cikge1xuICAgICAgb25CbHVyKGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAobXVpRm9ybUNvbnRyb2wgJiYgbXVpRm9ybUNvbnRyb2wub25CbHVyKSB7XG4gICAgICBtdWlGb3JtQ29udHJvbC5vbkJsdXIoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlSW5wdXRDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVJbnB1dENoYW5nZShldmVudCkge1xuICAgIHZhciBuZXdDaGVja2VkID0gZXZlbnQudGFyZ2V0LmNoZWNrZWQ7XG4gICAgc2V0Q2hlY2tlZFN0YXRlKG5ld0NoZWNrZWQpO1xuXG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICAvLyBUT0RPIHY1OiByZW1vdmUgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgICAgIG9uQ2hhbmdlKGV2ZW50LCBuZXdDaGVja2VkKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGRpc2FibGVkID0gZGlzYWJsZWRQcm9wO1xuXG4gIGlmIChtdWlGb3JtQ29udHJvbCkge1xuICAgIGlmICh0eXBlb2YgZGlzYWJsZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkaXNhYmxlZCA9IG11aUZvcm1Db250cm9sLmRpc2FibGVkO1xuICAgIH1cbiAgfVxuXG4gIHZhciBoYXNMYWJlbEZvciA9IHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEljb25CdXR0b24sIF9leHRlbmRzKHtcbiAgICBjb21wb25lbnQ6IFwic3BhblwiLFxuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSwgY2hlY2tlZCAmJiBjbGFzc2VzLmNoZWNrZWQsIGRpc2FibGVkICYmIGNsYXNzZXMuZGlzYWJsZWQpLFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICB0YWJJbmRleDogbnVsbCxcbiAgICByb2xlOiB1bmRlZmluZWQsXG4gICAgb25Gb2N1czogaGFuZGxlRm9jdXMsXG4gICAgb25CbHVyOiBoYW5kbGVCbHVyLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBfZXh0ZW5kcyh7XG4gICAgYXV0b0ZvY3VzOiBhdXRvRm9jdXMsXG4gICAgY2hlY2tlZDogY2hlY2tlZFByb3AsXG4gICAgZGVmYXVsdENoZWNrZWQ6IGRlZmF1bHRDaGVja2VkLFxuICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5pbnB1dCxcbiAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgaWQ6IGhhc0xhYmVsRm9yICYmIGlkLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgb25DaGFuZ2U6IGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgIHJlYWRPbmx5OiByZWFkT25seSxcbiAgICByZWY6IGlucHV0UmVmLFxuICAgIHJlcXVpcmVkOiByZXF1aXJlZCxcbiAgICB0YWJJbmRleDogdGFiSW5kZXgsXG4gICAgdHlwZTogdHlwZSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSwgaW5wdXRQcm9wcykpLCBjaGVja2VkID8gY2hlY2tlZEljb24gOiBpY29uKTtcbn0pOyAvLyBOQjogSWYgY2hhbmdlZCwgcGxlYXNlIHVwZGF0ZSBDaGVja2JveCwgU3dpdGNoIGFuZCBSYWRpb1xuLy8gc28gdGhhdCB0aGUgQVBJIGRvY3VtZW50YXRpb24gaXMgdXBkYXRlZC5cblxucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gU3dpdGNoQmFzZS5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBgaW5wdXRgIGVsZW1lbnQgd2lsbCBiZSBmb2N1c2VkIGR1cmluZyB0aGUgZmlyc3QgbW91bnQuXG4gICAqL1xuICBhdXRvRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjb21wb25lbnQgaXMgY2hlY2tlZC5cbiAgICovXG4gIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgaWNvbiB0byBkaXNwbGF5IHdoZW4gdGhlIGNvbXBvbmVudCBpcyBjaGVja2VkLlxuICAgKi9cbiAgY2hlY2tlZEljb246IFByb3BUeXBlcy5ub2RlLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGRlZmF1bHRDaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgc3dpdGNoIHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBpY29uIHRvIGRpc3BsYXkgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVuY2hlY2tlZC5cbiAgICovXG4gIGljb246IFByb3BUeXBlcy5ub2RlLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIFRoZSBpZCBvZiB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFtBdHRyaWJ1dGVzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQjQXR0cmlidXRlcykgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgaW5wdXRQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogUGFzcyBhIHJlZiB0byB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgaW5wdXRSZWY6IHJlZlR5cGUsXG5cbiAgLypcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgc3RhdGUgaXMgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBZb3UgY2FuIHB1bGwgb3V0IHRoZSBuZXcgY2hlY2tlZCBzdGF0ZSBieSBhY2Nlc3NpbmcgYGV2ZW50LnRhcmdldC5jaGVja2VkYCAoYm9vbGVhbikuXG4gICAqL1xuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBJdCBwcmV2ZW50cyB0aGUgdXNlciBmcm9tIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiB0aGUgZmllbGRcbiAgICogKG5vdCBmcm9tIGludGVyYWN0aW5nIHdpdGggdGhlIGZpZWxkKS5cbiAgICovXG4gIHJlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYGlucHV0YCBlbGVtZW50IHdpbGwgYmUgcmVxdWlyZWQuXG4gICAqL1xuICByZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHRhYkluZGV4OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBjb21wb25lbnQgcHJvcCBgdHlwZWAuXG4gICAqL1xuICB0eXBlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgdmFsdWU6IFByb3BUeXBlcy5hbnlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnUHJpdmF0ZVN3aXRjaEJhc2UnXG59KShTd2l0Y2hCYXNlKTsiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3JlYXRlU3ZnSWNvbiBmcm9tICcuLi8uLi91dGlscy9jcmVhdGVTdmdJY29uJztcbi8qKlxuICogQGlnbm9yZSAtIGludGVybmFsIGNvbXBvbmVudC5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTdmdJY29uKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICBkOiBcIk0xOSA1djE0SDVWNWgxNG0wLTJINWMtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yelwiXG59KSwgJ0NoZWNrQm94T3V0bGluZUJsYW5rJyk7IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNyZWF0ZVN2Z0ljb24gZnJvbSAnLi4vLi4vdXRpbHMvY3JlYXRlU3ZnSWNvbic7XG4vKipcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlU3ZnSWNvbiggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgZDogXCJNMTkgM0g1Yy0xLjExIDAtMiAuOS0yIDJ2MTRjMCAxLjEuODkgMiAyIDJoMTRjMS4xMSAwIDItLjkgMi0yVjVjMC0xLjEtLjg5LTItMi0yem0tOSAxNGwtNS01IDEuNDEtMS40MUwxMCAxNC4xN2w3LjU5LTcuNTlMMTkgOGwtOSA5elwiXG59KSwgJ0NoZWNrQm94Jyk7IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNyZWF0ZVN2Z0ljb24gZnJvbSAnLi4vLi4vdXRpbHMvY3JlYXRlU3ZnSWNvbic7XG4vKipcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlU3ZnSWNvbiggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgZDogXCJNMTkgM0g1Yy0xLjEgMC0yIC45LTIgMnYxNGMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bS0yIDEwSDd2LTJoMTB2MnpcIlxufSksICdJbmRldGVybWluYXRlQ2hlY2tCb3gnKTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyByZWZUeXBlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCBTd2l0Y2hCYXNlIGZyb20gJy4uL2ludGVybmFsL1N3aXRjaEJhc2UnO1xuaW1wb3J0IENoZWNrQm94T3V0bGluZUJsYW5rSWNvbiBmcm9tICcuLi9pbnRlcm5hbC9zdmctaWNvbnMvQ2hlY2tCb3hPdXRsaW5lQmxhbmsnO1xuaW1wb3J0IENoZWNrQm94SWNvbiBmcm9tICcuLi9pbnRlcm5hbC9zdmctaWNvbnMvQ2hlY2tCb3gnO1xuaW1wb3J0IHsgYWxwaGEgfSBmcm9tICcuLi9zdHlsZXMvY29sb3JNYW5pcHVsYXRvcic7XG5pbXBvcnQgSW5kZXRlcm1pbmF0ZUNoZWNrQm94SWNvbiBmcm9tICcuLi9pbnRlcm5hbC9zdmctaWNvbnMvSW5kZXRlcm1pbmF0ZUNoZWNrQm94JztcbmltcG9ydCBjYXBpdGFsaXplIGZyb20gJy4uL3V0aWxzL2NhcGl0YWxpemUnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IHtcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnRleHQuc2Vjb25kYXJ5XG4gICAgfSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNoZWNrZWQ9e3RydWV9YC4gKi9cbiAgICBjaGVja2VkOiB7fSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVkPXt0cnVlfWAuICovXG4gICAgZGlzYWJsZWQ6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgaW5kZXRlcm1pbmF0ZT17dHJ1ZX1gLiAqL1xuICAgIGluZGV0ZXJtaW5hdGU6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgY29sb3I9XCJwcmltYXJ5XCJgLiAqL1xuICAgIGNvbG9yUHJpbWFyeToge1xuICAgICAgJyYkY2hlY2tlZCc6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluLFxuICAgICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGFscGhhKHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluLCB0aGVtZS5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHkpLFxuICAgICAgICAgIC8vIFJlc2V0IG9uIHRvdWNoIGRldmljZXMsIGl0IGRvZXNuJ3QgYWRkIHNwZWNpZmljaXR5XG4gICAgICAgICAgJ0BtZWRpYSAoaG92ZXI6IG5vbmUpJzoge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJyYkZGlzYWJsZWQnOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmFjdGlvbi5kaXNhYmxlZFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBjb2xvcj1cInNlY29uZGFyeVwiYC4gKi9cbiAgICBjb2xvclNlY29uZGFyeToge1xuICAgICAgJyYkY2hlY2tlZCc6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW4sXG4gICAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYWxwaGEodGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkubWFpbiwgdGhlbWUucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5KSxcbiAgICAgICAgICAvLyBSZXNldCBvbiB0b3VjaCBkZXZpY2VzLCBpdCBkb2Vzbid0IGFkZCBzcGVjaWZpY2l0eVxuICAgICAgICAgICdAbWVkaWEgKGhvdmVyOiBub25lKSc6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50J1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICcmJGRpc2FibGVkJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWRcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xudmFyIGRlZmF1bHRDaGVja2VkSWNvbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENoZWNrQm94SWNvbiwgbnVsbCk7XG52YXIgZGVmYXVsdEljb24gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDaGVja0JveE91dGxpbmVCbGFua0ljb24sIG51bGwpO1xudmFyIGRlZmF1bHRJbmRldGVybWluYXRlSWNvbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEluZGV0ZXJtaW5hdGVDaGVja0JveEljb24sIG51bGwpO1xudmFyIENoZWNrYm94ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQ2hlY2tib3gocHJvcHMsIHJlZikge1xuICB2YXIgX3Byb3BzJGNoZWNrZWRJY29uID0gcHJvcHMuY2hlY2tlZEljb24sXG4gICAgICBjaGVja2VkSWNvbiA9IF9wcm9wcyRjaGVja2VkSWNvbiA9PT0gdm9pZCAwID8gZGVmYXVsdENoZWNrZWRJY29uIDogX3Byb3BzJGNoZWNrZWRJY29uLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBfcHJvcHMkY29sb3IgPSBwcm9wcy5jb2xvcixcbiAgICAgIGNvbG9yID0gX3Byb3BzJGNvbG9yID09PSB2b2lkIDAgPyAnc2Vjb25kYXJ5JyA6IF9wcm9wcyRjb2xvcixcbiAgICAgIF9wcm9wcyRpY29uID0gcHJvcHMuaWNvbixcbiAgICAgIGljb25Qcm9wID0gX3Byb3BzJGljb24gPT09IHZvaWQgMCA/IGRlZmF1bHRJY29uIDogX3Byb3BzJGljb24sXG4gICAgICBfcHJvcHMkaW5kZXRlcm1pbmF0ZSA9IHByb3BzLmluZGV0ZXJtaW5hdGUsXG4gICAgICBpbmRldGVybWluYXRlID0gX3Byb3BzJGluZGV0ZXJtaW5hdGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGluZGV0ZXJtaW5hdGUsXG4gICAgICBfcHJvcHMkaW5kZXRlcm1pbmF0ZUkgPSBwcm9wcy5pbmRldGVybWluYXRlSWNvbixcbiAgICAgIGluZGV0ZXJtaW5hdGVJY29uUHJvcCA9IF9wcm9wcyRpbmRldGVybWluYXRlSSA9PT0gdm9pZCAwID8gZGVmYXVsdEluZGV0ZXJtaW5hdGVJY29uIDogX3Byb3BzJGluZGV0ZXJtaW5hdGVJLFxuICAgICAgaW5wdXRQcm9wcyA9IHByb3BzLmlucHV0UHJvcHMsXG4gICAgICBfcHJvcHMkc2l6ZSA9IHByb3BzLnNpemUsXG4gICAgICBzaXplID0gX3Byb3BzJHNpemUgPT09IHZvaWQgMCA/ICdtZWRpdW0nIDogX3Byb3BzJHNpemUsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2hlY2tlZEljb25cIiwgXCJjbGFzc2VzXCIsIFwiY29sb3JcIiwgXCJpY29uXCIsIFwiaW5kZXRlcm1pbmF0ZVwiLCBcImluZGV0ZXJtaW5hdGVJY29uXCIsIFwiaW5wdXRQcm9wc1wiLCBcInNpemVcIl0pO1xuXG4gIHZhciBpY29uID0gaW5kZXRlcm1pbmF0ZSA/IGluZGV0ZXJtaW5hdGVJY29uUHJvcCA6IGljb25Qcm9wO1xuICB2YXIgaW5kZXRlcm1pbmF0ZUljb24gPSBpbmRldGVybWluYXRlID8gaW5kZXRlcm1pbmF0ZUljb25Qcm9wIDogY2hlY2tlZEljb247XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTd2l0Y2hCYXNlLCBfZXh0ZW5kcyh7XG4gICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgIGNsYXNzZXM6IHtcbiAgICAgIHJvb3Q6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc2VzW1wiY29sb3JcIi5jb25jYXQoY2FwaXRhbGl6ZShjb2xvcikpXSwgaW5kZXRlcm1pbmF0ZSAmJiBjbGFzc2VzLmluZGV0ZXJtaW5hdGUpLFxuICAgICAgY2hlY2tlZDogY2xhc3Nlcy5jaGVja2VkLFxuICAgICAgZGlzYWJsZWQ6IGNsYXNzZXMuZGlzYWJsZWRcbiAgICB9LFxuICAgIGNvbG9yOiBjb2xvcixcbiAgICBpbnB1dFByb3BzOiBfZXh0ZW5kcyh7XG4gICAgICAnZGF0YS1pbmRldGVybWluYXRlJzogaW5kZXRlcm1pbmF0ZVxuICAgIH0sIGlucHV0UHJvcHMpLFxuICAgIGljb246IC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoaWNvbiwge1xuICAgICAgZm9udFNpemU6IGljb24ucHJvcHMuZm9udFNpemUgPT09IHVuZGVmaW5lZCAmJiBzaXplID09PSBcInNtYWxsXCIgPyBzaXplIDogaWNvbi5wcm9wcy5mb250U2l6ZVxuICAgIH0pLFxuICAgIGNoZWNrZWRJY29uOiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGluZGV0ZXJtaW5hdGVJY29uLCB7XG4gICAgICBmb250U2l6ZTogaW5kZXRlcm1pbmF0ZUljb24ucHJvcHMuZm9udFNpemUgPT09IHVuZGVmaW5lZCAmJiBzaXplID09PSBcInNtYWxsXCIgPyBzaXplIDogaW5kZXRlcm1pbmF0ZUljb24ucHJvcHMuZm9udFNpemVcbiAgICB9KSxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlcikpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBDaGVja2JveC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjb21wb25lbnQgaXMgY2hlY2tlZC5cbiAgICovXG4gIGNoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgaWNvbiB0byBkaXNwbGF5IHdoZW4gdGhlIGNvbXBvbmVudCBpcyBjaGVja2VkLlxuICAgKi9cbiAgY2hlY2tlZEljb246IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29tcG9uZW50LiBJdCBzdXBwb3J0cyB0aG9zZSB0aGVtZSBjb2xvcnMgdGhhdCBtYWtlIHNlbnNlIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoWydkZWZhdWx0JywgJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjaGVja2JveCB3aWxsIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSByaXBwbGUgZWZmZWN0IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlUmlwcGxlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGljb24gdG8gZGlzcGxheSB3aGVuIHRoZSBjb21wb25lbnQgaXMgdW5jaGVja2VkLlxuICAgKi9cbiAgaWNvbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIFRoZSBpZCBvZiB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNvbXBvbmVudCBhcHBlYXJzIGluZGV0ZXJtaW5hdGUuXG4gICAqIFRoaXMgZG9lcyBub3Qgc2V0IHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudCB0byBpbmRldGVybWluYXRlIGR1ZVxuICAgKiB0byBpbmNvbnNpc3RlbnQgYmVoYXZpb3IgYWNyb3NzIGJyb3dzZXJzLlxuICAgKiBIb3dldmVyLCB3ZSBzZXQgYSBgZGF0YS1pbmRldGVybWluYXRlYCBhdHRyaWJ1dGUgb24gdGhlIGlucHV0LlxuICAgKi9cbiAgaW5kZXRlcm1pbmF0ZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBpY29uIHRvIGRpc3BsYXkgd2hlbiB0aGUgY29tcG9uZW50IGlzIGluZGV0ZXJtaW5hdGUuXG4gICAqL1xuICBpbmRldGVybWluYXRlSWNvbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIFtBdHRyaWJ1dGVzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQjQXR0cmlidXRlcykgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgaW5wdXRQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogUGFzcyBhIHJlZiB0byB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgaW5wdXRSZWY6IHJlZlR5cGUsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIHN0YXRlIGlzIGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cbiAgICogWW91IGNhbiBwdWxsIG91dCB0aGUgbmV3IGNoZWNrZWQgc3RhdGUgYnkgYWNjZXNzaW5nIGBldmVudC50YXJnZXQuY2hlY2tlZGAgKGJvb2xlYW4pLlxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBgaW5wdXRgIGVsZW1lbnQgd2lsbCBiZSByZXF1aXJlZC5cbiAgICovXG4gIHJlcXVpcmVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIGNoZWNrYm94LlxuICAgKiBgc21hbGxgIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGRlbnNlIGNoZWNrYm94IHN0eWxpbmcuXG4gICAqL1xuICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydtZWRpdW0nLCAnc21hbGwnXSksXG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgY29tcG9uZW50LiBUaGUgRE9NIEFQSSBjYXN0cyB0aGlzIHRvIGEgc3RyaW5nLlxuICAgKiBUaGUgYnJvd3NlciB1c2VzIFwib25cIiBhcyB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICovXG4gIHZhbHVlOiBQcm9wVHlwZXMuYW55XG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUNoZWNrYm94J1xufSkoQ2hlY2tib3gpOyIsImltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tIFwicmVhY3RcIlxyXG5cclxuaW1wb3J0IEF1dG9jb21wbGV0ZSBmcm9tICdAbWF0ZXJpYWwtdWkvbGFiL0F1dG9jb21wbGV0ZSc7XHJcbmltcG9ydCBUZXh0RmllbGQgZnJvbSAnQG1hdGVyaWFsLXVpL2NvcmUvVGV4dEZpZWxkJztcclxuaW1wb3J0IENoZWNrYm94IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL0NoZWNrYm94JztcclxuXHJcbmV4cG9ydCBjbGFzcyBBdXRvY29tcGxldGVVSSBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgcmVuZGVyKCkge1xyXG4gICAgcmV0dXJuIDxBdXRvY29tcGxldGUgXHJcbiAgICAgICAga2V5ID0ge3RoaXMucHJvcHMua2V5fVxyXG4gICAgICAgIG11bHRpcGxlID0ge3RoaXMucHJvcHMubXVsdGlwbGV9XHJcbiAgICAgICAgc2l6ZT1cInNtYWxsXCJcclxuICAgICAgICBkaXNhYmxlZCA9IHt0aGlzLnByb3BzLmRpc2FibGVkfVxyXG4gICAgICAgIGZpbHRlclNlbGVjdGVkT3B0aW9ucyA9IHt0aGlzLnByb3BzLmZpbHRlclNlbGVjdGVkT3B0aW9uc31cclxuICAgICAgICBkaXNhYmxlQ2xvc2VPblNlbGVjdCA9IHt0aGlzLnByb3BzLmRpc2FibGVDbG9zZU9uU2VsZWN0fVxyXG4gICAgICAgIG9wdGlvbnMgPSB7dGhpcy5wcm9wcy5vcHRpb25zfVxyXG4gICAgICAgIHZhbHVlID0ge3RoaXMucHJvcHMudmFsdWV9XHJcbiAgICAgICAgZ2V0T3B0aW9uTGFiZWwgPSB7b3B0aW9uID0+IG9wdGlvbi50aXRsZX1cclxuICAgICAgICBvbkNoYW5nZSA9IHt0aGlzLnByb3BzLm9uQ2hhbmdlfVxyXG4gICAgICAgIG5vT3B0aW9uc1RleHQgPSB7dGhpcy5wcm9wcy5ub09wdGlvbnNUZXh0fVxyXG4gICAgICAgIGxpbWl0VGFncz17dGhpcy5wcm9wcy5saW1pdFRhZ3N9XHJcbiAgICAgICAgb25PcGVuID0ge3RoaXMucHJvcHMub25PcGVufVxyXG4gICAgICAgIGxvYWRpbmcgPSB7dGhpcy5wcm9wcy5sb2FkaW5nfVxyXG4gICAgICAgIGxvYWRpbmdUZXh0ID0ge3RoaXMucHJvcHMubG9hZGluZ1RleHR9XHJcbiAgICAgICAgb25JbnB1dENoYW5nZT17IHRoaXMucHJvcHMub25JbnB1dENoYW5nZX1cclxuICAgICAgICBnZXRPcHRpb25TZWxlY3RlZD17KG9wdGlvbiwgdmFsdWUpID0+IG9wdGlvbi50aXRsZSA9PT0gdmFsdWUudGl0bGUgJiYgb3B0aW9uLmtleSA9PT0gdmFsdWUua2V5fVxyXG4gICAgICAgIHJlbmRlck9wdGlvbj17KG9wdGlvbiwgeyBzZWxlY3RlZCB9KSA9PiAoXHJcbiAgICAgICAgICAgIDxGcmFnbWVudD5cclxuICAgICAgICAgICAge3RoaXMucHJvcHMuc2hvd0NoZWNrYm94ZXMgPyA8Q2hlY2tib3hcclxuICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3NlbGVjdGVkfVxyXG4gICAgICAgICAgICAvPiA6IG51bGwgfVxyXG4gICAgICAgICAgICB7b3B0aW9uLnRpdGxlfVxyXG4gICAgICAgICAgICA8L0ZyYWdtZW50PlxyXG4gICAgICAgICl9XHJcbiAgICAgICAgcmVuZGVySW5wdXQ9e3BhcmFtcyA9PiAoXHJcbiAgICAgICAgPFRleHRGaWVsZFxyXG4gICAgICAgICAgICB7Li4ucGFyYW1zfVxyXG4gICAgICAgICAgICB2YXJpYW50PXt0aGlzLnByb3BzLnZhcmlhbnR9XHJcbiAgICAgICAgICAgIGxhYmVsPXt0aGlzLnByb3BzLmxhYmVsfVxyXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj17dGhpcy5wcm9wcy5wbGFjZWhvbGRlcn1cclxuICAgICAgICAvPlxyXG4gICAgICAgICl9XHJcbiAgICAvPjtcclxuICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsImltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgXCIuL3VpL0F1dG9jb21wbGV0ZU11bHRpc2VsZWN0LmNzc1wiO1xuXG5pbXBvcnQgeyBBdXRvY29tcGxldGVVSSB9IGZyb20gXCIuL2NvbXBvbmVudHMvQXV0b2NvbXBsZXRlVUlcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0b2NvbXBsZXRlTXVsdGlzZWxlY3QgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHVwZGF0ZURhdGU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hdXRvQ29tcGxldGVLZXkgPSAwO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gdGhpcy5jaGFuZ2VWYWx1ZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk9wZW5Ecm9wZG93biA9IHRoaXMub3BlbkRyb3Bkb3duLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25JbnB1dENoYW5nZSA9IHRoaXMuaW5wdXRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gW107XG4gICAgICAgIHRoaXMub3B0aW9uc1NlbGVjdGVkID0gW107IC8vIEFycmF5IGZvciBtdWx0aXNlbGVjdCwgb3RoZXJ3aXNlIG9iamVjdFxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0byB0cnVlIHRvIG1ha2Ugc3VyZSBkYXRhIGlzIHJldHJpZXZlZCB3aGVuIGluaXRpYWxpemluZyB3aWRnZXRcbiAgICAgICAgdGhpcy5yZWZyZXNoRGF0YSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnNob3dUb0Zld0NoYXJzVGV4dCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMubGF0ZXN0SW5wdXRDaGFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBsZXQgcmVmcmVzaFN0YXRlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gUmVmcmVzaCB0aGUgZGF0YSBpZiB0aGUgcmVmcmVzaEF0dHJpYnV0ZSBoYXMgYmVlbiBzZXQgdG8gdHJ1ZVxuICAgICAgICBpZiAocHJldlByb3BzLnJlZnJlc2hBdHRyaWJ1dGUgJiYgdGhpcy5wcm9wcy5yZWZyZXNoQXR0cmlidXRlLnZhbHVlICYmICFwcmV2UHJvcHMucmVmcmVzaEF0dHJpYnV0ZS52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5yZWZyZXNoQXR0cmlidXRlLnNldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlS2V5Kys7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgZGF0YSBhbmQgc3RhdGUgd2lsbCBiZSByZWZyZXNoZWRcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaERhdGEgPSB0cnVlO1xuICAgICAgICAgICAgcmVmcmVzaFN0YXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGRhdGEgc291cnNlIG9yIGF0dHJpYnV0ZSBpcyB1c2VkXG4gICAgICAgIGlmICh0aGlzLnByb3BzLkpTT05BdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLkpTT05BdHRyaWJ1dGUuc3RhdHVzID09PSBcImF2YWlsYWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGl0ZW1zIGhhcyBiZWVuIGNoYW5nZWQgb3IgZGF0YSBuZWVkcyB0byBiZSByZWZyZXNoZWRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWZyZXNoRGF0YSB8fCB0aGlzLnByb3BzLkpTT05BdHRyaWJ1dGUgIT09IHByZXZQcm9wcy5KU09OQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhUGFyc2VkID0gW107XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIHRoZSBqc29uXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLkpTT05BdHRyaWJ1dGUudmFsdWUgJiYgdGhpcy5wcm9wcy5KU09OQXR0cmlidXRlLnZhbHVlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhUGFyc2VkID0gSlNPTi5wYXJzZSh0aGlzLnByb3BzLkpTT05BdHRyaWJ1dGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGRhdGEgbmVlZHMgdG8gYmUgcmVmcmVzaGVkLCByZXNldCBkZWZhdWx0c1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWZyZXNoRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZGF0YVBhcnNlZC5maWx0ZXIob3B0aW9uID0+IG9wdGlvbi5kZWZhdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zU2VsZWN0ZWQgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1NlbGVjdGVkID0gZGVmYXVsdFZhbHVlWzBdID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVmYXVsdFZhbHVlWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgY3VzdG9tIHNlYXJjaCBpcyB1c2VkLCBpdCBjYW4gYmUgdGhhdCBzb21lIG9wdGlvbnMgYXJlIG5vdCBpbiB0aGUgSlNPTlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZXNlIG9wdGlvbnMgdG8gbWFrZSBzdXJlIHRoZSBkZWZhdWx0cyBhcmUgaW4sIHRoZXkgd2lsbCBiZSBmaWx0ZXJlZCBvdXQgaWYgbm90IGFwcGxpY2FibGUgdG8gaW5wdXQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uSW5wdXRDaGFuZ2VBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zU2VsZWN0ZWROb3RJbkxpc3QgPSB0aGlzLm9wdGlvbnNTZWxlY3RlZC5maWx0ZXIoc2VsZWN0ZWRPcHRpb24gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVBhcnNlZC5maW5kKG9wdGlvbiA9PiBvcHRpb24udGl0bGUgPT09IHNlbGVjdGVkT3B0aW9uLnRpdGxlICYmIG9wdGlvbi5rZXkgPT09IHNlbGVjdGVkT3B0aW9uLmtleSkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUGFyc2VkID0gZGF0YVBhcnNlZC5jb25jYXQob3B0aW9uc1NlbGVjdGVkTm90SW5MaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSBjaGVjayBpZiBvcHRpb25TZWxlY3RlZCBhcmUgc3RpbGwgYXZhaWxhYmxlLiBUaGlzIGlzIGRvbmUgc2luY2UgaXQgY2FuIGJlIHRoZSBjYXNlIHRoYXQgdGhlIG9wdGlvbnMgaGF2ZSBiZWVuIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1NlbGVjdGVkID0gdGhpcy5vcHRpb25zU2VsZWN0ZWQuZmlsdGVyKHNlbGVjdGVkT3B0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhUGFyc2VkLmZpbmQob3B0aW9uID0+IG9wdGlvbi50aXRsZSA9PT0gc2VsZWN0ZWRPcHRpb24udGl0bGUgJiYgb3B0aW9uLmtleSA9PT0gc2VsZWN0ZWRPcHRpb24ua2V5KSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9uc1NlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1NlbGVjdGVkID0gZGF0YVBhcnNlZC5maW5kKG9wdGlvbiA9PiBvcHRpb24udGl0bGUgPT09IHRoaXMub3B0aW9uc1NlbGVjdGVkLnRpdGxlICYmIG9wdGlvbi5rZXkgPT09IHRoaXMub3B0aW9uc1NlbGVjdGVkLmtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBpZiAodGhpcy5vcHRpb25zU2VsZWN0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNTZWxlY3RlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGRhdGFQYXJzZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaERhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgcmVzcG9uc2UgaW4gcmVzcG9uc2VBdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5yZXNwb25zZUF0dHJpYnV0ZS5zZXRWYWx1ZShKU09OLnN0cmluZ2lmeSh0aGlzLm9wdGlvbnNTZWxlY3RlZCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5kYXRhU291cmNlT3B0aW9ucyAhPT0gcHJldlByb3BzLmRhdGFTb3VyY2VPcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZGF0YXNvdXJjZSBoYXMgYmVlbiBsb2FkZWRcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmRhdGFTb3VyY2VPcHRpb25zLnN0YXR1cyA9PT0gJ2F2YWlsYWJsZScpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaXRlbXMgaGF2ZSBiZWVuIGNoYW5nZWQgb3IgaWYgZGF0ZSBuZWVkcyB0byBiZSByZWZyZXNoZWQsIGNoYW5nZSB0aGUgb3B0aW9uc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZnJlc2hEYXRhIHx8IHRoaXMucHJvcHMuZGF0YVNvdXJjZU9wdGlvbnMuaXRlbXMgIT09IHByZXZQcm9wcy5kYXRhU291cmNlT3B0aW9ucy5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2FybmluZ0dpdmVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG11bHRpU2VsZWN0ID0gdGhpcy5wcm9wcy5tdWx0aXBsZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9wdGlvbnNTZWxlY3RlZCA9IG11bHRpU2VsZWN0ID8gW10gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVmYXVsdFNlbGVjdGVkU3RyaW5nID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hcCB0aGUgb3B0aW9ucyBhbmQgZ2V0IHRoZSBzZWxlY3RlZCBvbmVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMucHJvcHMuZGF0YVNvdXJjZU9wdGlvbnMuaXRlbXMubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uVGl0bGUgPSB0aGlzLnByb3BzLnRpdGxlQXR0ci5nZXQoaXRlbSkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb24gPSB7dGl0bGU6IG9wdGlvblRpdGxlfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYga2V5IGlzIHVzZWQsIGFkZCBrZXkgdG8gdGhlIG9wdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMua2V5QXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5rZXkgPSB0aGlzLnByb3BzLmtleUF0dHIuZ2V0KGl0ZW0pLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGF0YSBuZWVkcyB0byBiZSByZWZyZXNoZWQsIGdldCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZnJlc2hEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgc3RyaW5nIGlzIG5vdCB5ZXQgZmlsbGVkLCBmaWxsIHdpdGggZWl0aGVyIHRoZSBqc29uIG9yIHdpdGggbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0U2VsZWN0ZWRTdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5kZWZhdWx0U2VsZWN0ZWRTdHJpbmdBdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFNlbGVjdGVkU3RyaW5nID0gSlNPTi5wYXJzZSh0aGlzLnByb3BzLmRlZmF1bHRTZWxlY3RlZFN0cmluZ0F0dHIudmFsdWUpOztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U2VsZWN0ZWRTdHJpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCB0byBudWxsIHRvIG5vdCBjaGVjayB0aGlzIGZvciBldmVyeSBpdGVtIGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U2VsZWN0ZWRTdHJpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc0l0ZW1EZWZhdWx0U2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJdGVtcyBjYW4gYmUgc2V0IHRvIGRlZmF1bHQgc2VsZWN0ZWQgaW4gdHdvIHdheXM6IGRlZmF1bHRTZWxlY3RlZFN0cmluZ0F0dHIgcHJvcCBvciBkZWZhdWx0U2VsZWN0ZWRBdHRyIHByb3Agb24gYW4gaXRlbS4gSWYgdGhlIGZpcnN0IG9wdGlvbiBpcyBjaG9zZW4sIHRoZSBwcm9wIG9uIHRoZSBpdGVtIGlzIGlnbm9yZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRTZWxlY3RlZFN0cmluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0l0ZW1EZWZhdWx0U2VsZWN0ZWQgPSBkZWZhdWx0U2VsZWN0ZWRTdHJpbmcuaW5kZXhPZihvcHRpb25UaXRsZSkgIT09IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSXRlbURlZmF1bHRTZWxlY3RlZCA9IHRoaXMucHJvcHMuZGVmYXVsdFNlbGVjdGVkQXR0ciAmJiB0aGlzLnByb3BzLmRlZmF1bHRTZWxlY3RlZEF0dHIuZ2V0KGl0ZW0pLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJdGVtRGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aVNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1NlbGVjdGVkLnB1c2gob3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zU2VsZWN0ZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zU2VsZWN0ZWQgPSBvcHRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2FybmluZ0dpdmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkF1dG9jb21wbGV0ZSBNdWx0aXNlbGVjdDogTXVsdGlwbGUgb3B0aW9ucyBhcmUgc2V0IGFzIGRlZmF1bHQgZm9yIGEgc2luZ2xlIHNlbGVjdC4gRmlyc3Qgb3B0aW9uIGlzIHNldCBhcyB0aGUgc2VsZWN0ZWQgb25lLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ0dpdmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVsc2UgY2hlY2sgaWYgb3B0aW9uIGlzIHNlbGVjdGVkIChiYXNlZCBvbiB0aGUgdGl0bGUpLiBUaGlzIGlzIGRvbmUgc2luY2UgaXQgY2FuIGJlIHRoZSBjYXNlIHRoYXQgdGhlIG9wdGlvbnMgaGF2ZSBiZWVuIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNTZWxlY3RlZC5maW5kKG9wdGlvbiA9PiBvcHRpb24udGl0bGUgPT09IG9wdGlvblRpdGxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1NlbGVjdGVkLnB1c2gob3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zU2VsZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1NlbGVjdGVkLnRpdGxlID09PSBvcHRpb25UaXRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1NlbGVjdGVkID0gb3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaERhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zU2VsZWN0ZWQgPSBvcHRpb25zU2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHJlc3BvbnNlIGluIHJlc3BvbnNlQXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMucmVzcG9uc2VBdHRyaWJ1dGUuc2V0VmFsdWUoSlNPTi5zdHJpbmdpZnkob3B0aW9uc1NlbGVjdGVkKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWZyZXNoU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe3VwZGF0ZURhdGU6IG5ldyBEYXRlKCl9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIGEgbmV3IHZhbHVlIGlzIHNlbGVjdGVkIG9yIHZhbHVlKHMpIGFyZSBkZXNlbGVjdGVkLiBcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0geyp9IGV2ZW50IC0gdGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgYWN0aW9uXG4gICAgICogQHBhcmFtIHsqfSBuZXdWYWx1ZSAtIHRoZSBuZXcgdmFsdWUgb2YgdGhlIGRyb3Bkb3duXG4gICAgICogQHBhcmFtIHsqfSByZWFzb24gLSB0aGUgcmVhc29uIHRoYXQgdGhpcyBhY3Rpb24gaXMgdHJpZ2dlcmVkLCBlaXRoZXIgc2VsZWN0LW9wdGlvbiwgcmVtb3ZlLW9wdGlvbiwgY3JlYXRlLW9wdGlvbiwgYmx1ciBvciBjbGVhclxuICAgICAqIEBwYXJhbSB7Kn0gZGV0YWlscyAtIG1vcmUgZGV0YWlscyBhYm91dCB0aGUgb3B0aW9uIGZvciB3aGljaCB0aGlzIGV2ZW50IGlzIHRyaWdnZXJlZFxuICAgICAqL1xuICAgIGNoYW5nZVZhbHVlcyhldmVudCwgbmV3VmFsdWUsIHJlYXNvbiwgZGV0YWlscykge1xuICAgICAgICAvLyBTdG9yZSByZXNwb25zZSBpbiByZXNwb25zZUF0dHJpYnV0ZSBhbmQgY2FsbCBvbiBjaGFuZ2UgYWN0aW9uXG4gICAgICAgIHRoaXMucHJvcHMucmVzcG9uc2VBdHRyaWJ1dGUuc2V0VmFsdWUoSlNPTi5zdHJpbmdpZnkobmV3VmFsdWUpKTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ2hhbmdlQWN0aW9uICYmIHRoaXMucHJvcHMub25DaGFuZ2VBY3Rpb24uY2FuRXhlY3V0ZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZUFjdGlvbi5leGVjdXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB3aWRnZXQgd2l0aCB0aGUgbmV3IHZhbHVlcyBzZWxlY3RlZFxuICAgICAgICB0aGlzLm9wdGlvbnNTZWxlY3RlZCA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHt1cGRhdGVEYXRlOiBuZXcgRGF0ZSgpfSk7IFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNhbGxlcyB3aGVuIGRyb3Bkb3duIGlzIG9wZW5lZFxuICAgICAqL1xuICAgIG9wZW5Ecm9wZG93bigpIHtcbiAgICAgICAgbGV0IHNldExvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIGNoZWNrIGlmIGVub3VnaCBjaGFycyBhcmUgZmlsbGVkXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uSW5wdXRDaGFuZ2VBY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnNlYXJjaEFmdGVyWENoYXJzLnZhbHVlICYmIHRoaXMucHJvcHMuc2VhcmNoQWZ0ZXJYQ2hhcnMudmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93VG9GZXdDaGFyc1RleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNldExvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uT3BlbkFjdGlvbiAmJiB0aGlzLnByb3BzLm9uT3BlbkFjdGlvbi5jYW5FeGVjdXRlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uT3BlbkFjdGlvbi5leGVjdXRlKCk7XG4gICAgICAgICAgICBzZXRMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgfSBcbiAgICAgICAgaWYgKHNldExvYWRpbmcpIHtcbiAgICAgICAgICAgIC8vIFJlcmVuZGVyIHdpZGdldFxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe3VwZGF0ZURhdGU6IG5ldyBEYXRlKCl9KTsgXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBjYWxsZWQgd2hlbiBhIHRoZSBpbnB1dCB2YWx1ZSBjaGFuZ2VzXG4gICAgICogXG4gICAgICogQHBhcmFtIHsqfSBldmVudCAtIHRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGFjdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSB0aGUgbmV3IHZhbHVlIG9mIHRoZSBpbnB1dFxuICAgICAqIEBwYXJhbSB7Kn0gcmVhc29uIC0gdGhlIHJlYXNvbiB0aGF0IHRoaXMgYWN0aW9uIGlzIHRyaWdnZXJlZCwgZWl0aGVyIGlucHV0LCBjbGVhciBvciByZXNldFxuICAgICAqL1xuICAgIGlucHV0Q2hhbmdlID0gKGV2ZW50LCB2YWx1ZSwgcmVhc29uKSAgPT4ge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5zZWFyY2hBZnRlclhDaGFycy52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlLmxlbmd0aCA+PSB0aGlzLnByb3BzLnNlYXJjaEFmdGVyWENoYXJzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dUb0Zld0NoYXJzVGV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgdGltZVN0YW1wID0gZXZlbnQudGltZVN0YW1wXG4gICAgICAgICAgICB0aGlzLmxhdGVzdElucHV0Q2hhbmdlID0gdGltZVN0YW1wO1xuICAgICAgICAgICAgLy9DaGVjayBpZiBubyBvdGhlciBpbnB1dGNoYW5nZSB3aWxsIGJlIGRvbmVcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKHRpbWVTdGFtcCwgdmFsdWUsIHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdElucHV0Q2hhbmdlID09PSB0aW1lU3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuc2VhcmNoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc2VhcmNoVmFsdWUuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uSW5wdXRDaGFuZ2VBY3Rpb24gJiYgdGhpcy5wcm9wcy5vbklucHV0Q2hhbmdlQWN0aW9uLmNhbkV4ZWN1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25JbnB1dENoYW5nZUFjdGlvbi5leGVjdXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzLnByb3BzLm9uSW5wdXRDaGFuZ2VEZWxheS52YWx1ZSwgdGltZVN0YW1wLCB2YWx1ZSwgcmVhc29uKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93VG9GZXdDaGFyc1RleHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byByZXJlbmRlciB0aGUgd2lkZ2V0XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe3VwZGF0ZURhdGU6IG5ldyBEYXRlKCl9KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8vIERvIG5vdCByZW5kZXIgdGhlIHdpZGdldCBpZiBpdCBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0XG4gICAgICAgIGlmKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eSBpcyBub3QgZmlsbGVkLCB0aGUgd2lkZ2V0IHdpbGwgYmUgZWRpdGFibGVcbiAgICAgICAgbGV0IGRpc2FibGVkID0gdGhpcy5wcm9wcy5lZGl0YWJsZSA/ICF0aGlzLnByb3BzLmVkaXRhYmxlLnZhbHVlIDogZmFsc2U7XG4gICAgICAgIC8vIENoZWNrIGlmIHVzZXIgaGFzIHJpZ2h0cyBvbiByZXNwb25zZSBhdHRyaWJ1dGVcbiAgICAgICAgaWYoIWRpc2FibGVkICYmIHRoaXMucHJvcHMucmVzcG9uc2VBdHRyaWJ1dGUucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQXV0b2NvbXBsZXRlIE11bHRpc2VsZWN0OiBVc2VyIGhhcyBubyByaWdodHMgdG8gY2hhbmdlIHRoZSByZXNwb25zZSBhdHRyaWJ1dGUuJylcbiAgICAgICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3Qgbm9PcHRpb25zVGV4dCA9IHRoaXMucHJvcHMubm9PcHRpb25zVGV4dCA/IHRoaXMucHJvcHMubm9PcHRpb25zVGV4dC52YWx1ZSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRoaXMucHJvcHMucGxhY2Vob2xkZXIgPyB0aGlzLnByb3BzLnBsYWNlaG9sZGVyLnZhbHVlIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGNvbnN0IGxpbWl0VGFncyA9IHRoaXMucHJvcHMubGltaXRUYWdzID4gMCA/IHRoaXMucHJvcHMubGltaXRUYWdzIDogdW5kZWZpbmVkO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLnByb3BzLmxhYmVsID8gdGhpcy5wcm9wcy5sYWJlbC52YWx1ZSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBGb2xsb3dpbmcgb3B0aW9ucyBvbmx5IHVzZWQgd2hlbiBqc29uIGF0dHJpYnV0ZSBpcyB1c2VkXG4gICAgICAgIGxldCBvbk9wZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBvbklucHV0Q2hhbmdlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgbG9hZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGxvYWRpbmdUZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuSlNPTkF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgb25PcGVuID0gdGhpcy5vbk9wZW5Ecm9wZG93bjtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uSW5wdXRDaGFuZ2VBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBvbklucHV0Q2hhbmdlID0gdGhpcy5vbklucHV0Q2hhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9hZGluZyA9IHRoaXMubG9hZGluZztcblxuICAgICAgICAgICAgLy8gc2V0IGxvYWRpbmcgdGV4dCwgaWYgdG8gZmV3IGNoYXJzIGFyZSBmaWxsZWQgdXNlIHRoaXMgdGV4dC5cbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dUb0Zld0NoYXJzVGV4dCkge1xuICAgICAgICAgICAgICAgIGxvYWRpbmdUZXh0ID0gdGhpcy5wcm9wcy5zZWFyY2hBZnRlclhDaGFyc1RleHQgPyB0aGlzLnByb3BzLnNlYXJjaEFmdGVyWENoYXJzVGV4dC52YWx1ZSA6IFwiRW50ZXIgYXQgbGVhc3QgXCIgKyB0aGlzLnByb3BzLnNlYXJjaEFmdGVyWENoYXJzLnZhbHVlICsgXCIgY2hhcmFjdGVyc1wiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nVGV4dCA9IHRoaXMucHJvcHMubG9hZGluZ1RleHQgPyB0aGlzLnByb3BzLmxvYWRpbmdUZXh0LnZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgY29tcG9uZW50IGlzIGxvYWRpbmcsIGhpZGUgb3B0aW9uc1xuICAgICAgICAgICAgaWYgKHRoaXMubG9hZGluZykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBbXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDxBdXRvY29tcGxldGVVSSBcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ge3RoaXMuYXV0b0NvbXBsZXRlS2V5fVxuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZSA9IHt0aGlzLnByb3BzLm11bHRpcGxlfVxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCA9IHtkaXNhYmxlZH1cbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZUNsb3NlT25TZWxlY3QgPSB7dGhpcy5wcm9wcy5kaXNhYmxlQ2xvc2VPblNlbGVjdH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtvcHRpb25zfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHt0aGlzLm9wdGlvbnNTZWxlY3RlZH1cbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UgPSB7dGhpcy5vbkNoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAgbm9PcHRpb25zVGV4dCA9IHtub09wdGlvbnNUZXh0fVxuICAgICAgICAgICAgICAgICAgICBsaW1pdFRhZ3M9e2xpbWl0VGFnc31cbiAgICAgICAgICAgICAgICAgICAgc2hvd0NoZWNrYm94ZXMgPSB7dGhpcy5wcm9wcy5zaG93Q2hlY2tib3hlc31cbiAgICAgICAgICAgICAgICAgICAgdmFyaWFudD17dGhpcy5wcm9wcy52YXJpYW50fVxuICAgICAgICAgICAgICAgICAgICBsYWJlbD17bGFiZWx9XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPXtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyU2VsZWN0ZWRPcHRpb25zPXt0aGlzLnByb3BzLmZpbHRlclNlbGVjdGVkT3B0aW9uc31cbiAgICAgICAgICAgICAgICAgICAgb25PcGVuID0ge29uT3Blbn1cbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZyA9IHtsb2FkaW5nfVxuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nVGV4dCA9IHtsb2FkaW5nVGV4dH1cbiAgICAgICAgICAgICAgICAgICAgb25JbnB1dENoYW5nZT17b25JbnB1dENoYW5nZX1cbiAgICAgICAgICAgIC8+O1xuICAgIH1cbn1cblxuXG5cbiJdLCJuYW1lcyI6WyJzdHlsZUluamVjdCIsImNzcyIsInJlZiIsImluc2VydEF0IiwiZG9jdW1lbnQiLCJoZWFkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzdHlsZSIsImNyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwiZmlyc3RDaGlsZCIsImluc2VydEJlZm9yZSIsImFwcGVuZENoaWxkIiwic3R5bGVTaGVldCIsImNzc1RleHQiLCJjcmVhdGVUZXh0Tm9kZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlIiwiZXhjbHVkZWQiLCJ0YXJnZXQiLCJzb3VyY2VLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImtleSIsImkiLCJsZW5ndGgiLCJpbmRleE9mIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwib2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJwcm90b3R5cGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImNhbGwiLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJ2YWx1ZSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJhcmd1bWVudHMiLCJoYXNPd25Qcm9wZXJ0eSIsImFwcGx5IiwiaGFzU3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfQVNZTkNfTU9ERV9UWVBFIiwiUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX0JMT0NLX1RZUEUiLCJSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIiwiUkVBQ1RfUkVTUE9OREVSX1RZUEUiLCJSRUFDVF9TQ09QRV9UWVBFIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiJCR0eXBlb2YiLCJ0eXBlT2YiLCJvYmplY3QiLCIkJHR5cGVvZlR5cGUiLCJ1bmRlZmluZWQiLCJBc3luY01vZGUiLCJDb25jdXJyZW50TW9kZSIsIkNvbnRleHRDb25zdW1lciIsIkNvbnRleHRQcm92aWRlciIsIkVsZW1lbnQiLCJGb3J3YXJkUmVmIiwiRnJhZ21lbnQiLCJMYXp5IiwiTWVtbyIsIlBvcnRhbCIsIlByb2ZpbGVyIiwiU3RyaWN0TW9kZSIsIlN1c3BlbnNlIiwiaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUiLCJpc0FzeW5jTW9kZSIsImNvbnNvbGUiLCJpc0NvbmN1cnJlbnRNb2RlIiwiaXNDb250ZXh0Q29uc3VtZXIiLCJpc0NvbnRleHRQcm92aWRlciIsImlzRWxlbWVudCIsImlzRm9yd2FyZFJlZiIsImlzRnJhZ21lbnQiLCJpc0xhenkiLCJpc01lbW8iLCJpc1BvcnRhbCIsImlzUHJvZmlsZXIiLCJpc1N0cmljdE1vZGUiLCJpc1N1c3BlbnNlIiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJwcm9wSXNFbnVtZXJhYmxlIiwidG9PYmplY3QiLCJ2YWwiLCJUeXBlRXJyb3IiLCJzaG91bGRVc2VOYXRpdmUiLCJ0ZXN0MSIsIlN0cmluZyIsImdldE93blByb3BlcnR5TmFtZXMiLCJ0ZXN0MiIsImZyb21DaGFyQ29kZSIsIm9yZGVyMiIsIm1hcCIsIm4iLCJqb2luIiwidGVzdDMiLCJzcGxpdCIsImZvckVhY2giLCJsZXR0ZXIiLCJlcnIiLCJmcm9tIiwidG8iLCJzeW1ib2xzIiwicyIsIlJlYWN0UHJvcFR5cGVzU2VjcmV0IiwicHJpbnRXYXJuaW5nIiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwiaGFzIiwiRnVuY3Rpb24iLCJiaW5kIiwidGV4dCIsIm1lc3NhZ2UiLCJlcnJvciIsIkVycm9yIiwieCIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJuYW1lIiwiZXgiLCJzdGFjayIsInJlc2V0V2FybmluZ0NhY2hlIiwiUmVhY3RJcyIsImVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwiLCJpc1ZhbGlkRWxlbWVudCIsInRocm93T25EaXJlY3RBY2Nlc3MiLCJJVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJpdGVyYXRvckZuIiwiQU5PTllNT1VTIiwiUmVhY3RQcm9wVHlwZXMiLCJhcnJheSIsImNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyIiwiYm9vbCIsImZ1bmMiLCJudW1iZXIiLCJzdHJpbmciLCJzeW1ib2wiLCJhbnkiLCJjcmVhdGVBbnlUeXBlQ2hlY2tlciIsImFycmF5T2YiLCJjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIiLCJlbGVtZW50IiwiY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyIiwiZWxlbWVudFR5cGUiLCJjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyIiwiaW5zdGFuY2VPZiIsImNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIiLCJub2RlIiwiY3JlYXRlTm9kZUNoZWNrZXIiLCJvYmplY3RPZiIsImNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIiLCJvbmVPZiIsImNyZWF0ZUVudW1UeXBlQ2hlY2tlciIsIm9uZU9mVHlwZSIsImNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIiLCJzaGFwZSIsImNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIiLCJleGFjdCIsImNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIiLCJpcyIsInkiLCJQcm9wVHlwZUVycm9yIiwiY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIiLCJ2YWxpZGF0ZSIsIm1hbnVhbFByb3BUeXBlQ2FsbENhY2hlIiwibWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQiLCJjaGVja1R5cGUiLCJpc1JlcXVpcmVkIiwicHJvcHMiLCJwcm9wTmFtZSIsInByb3BGdWxsTmFtZSIsInNlY3JldCIsImNhY2hlS2V5IiwiY2hhaW5lZENoZWNrVHlwZSIsImV4cGVjdGVkVHlwZSIsInByb3BWYWx1ZSIsInByb3BUeXBlIiwiZ2V0UHJvcFR5cGUiLCJwcmVjaXNlVHlwZSIsImdldFByZWNpc2VUeXBlIiwidHlwZUNoZWNrZXIiLCJBcnJheSIsImlzQXJyYXkiLCJleHBlY3RlZENsYXNzIiwiZXhwZWN0ZWRDbGFzc05hbWUiLCJhY3R1YWxDbGFzc05hbWUiLCJnZXRDbGFzc05hbWUiLCJleHBlY3RlZFZhbHVlcyIsInZhbHVlc1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXBsYWNlciIsImFycmF5T2ZUeXBlQ2hlY2tlcnMiLCJwcm9jZXNzIiwiY2hlY2tlciIsImdldFBvc3RmaXhGb3JUeXBlV2FybmluZyIsImlzTm9kZSIsInNoYXBlVHlwZXMiLCJhbGxLZXlzIiwiZXZlcnkiLCJzdGVwIiwiZW50cmllcyIsIm5leHQiLCJkb25lIiwiZW50cnkiLCJpc1N5bWJvbCIsIlJlZ0V4cCIsIkRhdGUiLCJjb25zdHJ1Y3RvciIsIlByb3BUeXBlcyIsInRvVmFsIiwibWl4IiwiayIsInN0ciIsInRtcCIsImNoYWluUHJvcFR5cGVzIiwicHJvcFR5cGUxIiwicHJvcFR5cGUyIiwiX3R5cGVvZiIsImlzUGxhaW5PYmplY3QiLCJpdGVtIiwiZGVlcG1lcmdlIiwib3B0aW9ucyIsImNsb25lIiwib3V0cHV0IiwiaXNDbGFzc0NvbXBvbmVudCIsIl9lbGVtZW50VHlwZSRwcm90b3R5cCIsIkJvb2xlYW4iLCJpc1JlYWN0Q29tcG9uZW50IiwiYWNjZXB0aW5nUmVmIiwic2FmZVByb3BOYW1lIiwid2FybmluZ0hpbnQiLCJjb25jYXQiLCJlbGVtZW50QWNjZXB0aW5nUmVmIiwiZWxlbWVudFR5cGVBY2NlcHRpbmdSZWYiLCJzcGVjaWFsUHJvcGVydHkiLCJleGFjdFByb3AiLCJwcm9wVHlwZXMiLCJ1bnN1cHBvcnRlZFByb3BzIiwiZmlsdGVyIiwicHJvcCIsImZuTmFtZU1hdGNoUmVnZXgiLCJnZXRGdW5jdGlvbk5hbWUiLCJmbiIsIm1hdGNoIiwiZ2V0RnVuY3Rpb25Db21wb25lbnROYW1lIiwiQ29tcG9uZW50IiwiZmFsbGJhY2siLCJkaXNwbGF5TmFtZSIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJmdW5jdGlvbk5hbWUiLCJnZXREaXNwbGF5TmFtZSIsInJlbmRlciIsIkhUTUxFbGVtZW50VHlwZSIsIm5vZGVUeXBlIiwicmVmVHlwZSIsImNsYW1wIiwibWluIiwibWF4IiwiTWF0aCIsImhleFRvUmdiIiwiY29sb3IiLCJzdWJzdHIiLCJyZSIsImNvbG9ycyIsImluZGV4IiwicGFyc2VJbnQiLCJyb3VuZCIsImhzbFRvUmdiIiwiZGVjb21wb3NlQ29sb3IiLCJfY29sb3IiLCJoIiwibCIsImEiLCJmIiwicmdiIiwicHVzaCIsInJlY29tcG9zZUNvbG9yIiwiY2hhckF0IiwibWFya2VyIiwic3Vic3RyaW5nIiwicGFyc2VGbG9hdCIsImdldENvbnRyYXN0UmF0aW8iLCJmb3JlZ3JvdW5kIiwiYmFja2dyb3VuZCIsImx1bUEiLCJnZXRMdW1pbmFuY2UiLCJsdW1CIiwicG93IiwiTnVtYmVyIiwidG9GaXhlZCIsImVtcGhhc2l6ZSIsImNvZWZmaWNpZW50IiwiZGFya2VuIiwibGlnaHRlbiIsImFscGhhIiwiY3JlYXRlQnJlYWtwb2ludHMiLCJicmVha3BvaW50cyIsIl9icmVha3BvaW50cyR2YWx1ZXMiLCJ4cyIsInNtIiwibWQiLCJsZyIsInhsIiwiX2JyZWFrcG9pbnRzJHVuaXQiLCJ1bml0IiwiX2JyZWFrcG9pbnRzJHN0ZXAiLCJvdGhlciIsInVwIiwiZG93biIsImVuZEluZGV4IiwidXBwZXJib3VuZCIsImJldHdlZW4iLCJzdGFydCIsImVuZCIsIm9ubHkiLCJ3YXJuZWRPbmNlIiwid2lkdGgiLCJ3YXJuIiwiY3JlYXRlTWl4aW5zIiwic3BhY2luZyIsIm1peGlucyIsIl90b29sYmFyIiwiZ3V0dGVycyIsInN0eWxlcyIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwidG9vbGJhciIsIm1pbkhlaWdodCIsImNvbW1vbiIsImJsYWNrIiwid2hpdGUiLCJncmV5IiwiQTEwMCIsIkEyMDAiLCJBNDAwIiwiQTcwMCIsImluZGlnbyIsInBpbmsiLCJyZWQiLCJvcmFuZ2UiLCJibHVlIiwiZ3JlZW4iLCJsaWdodCIsInByaW1hcnkiLCJzZWNvbmRhcnkiLCJkaXNhYmxlZCIsImhpbnQiLCJkaXZpZGVyIiwicGFwZXIiLCJkZWZhdWx0IiwiYWN0aW9uIiwiYWN0aXZlIiwiaG92ZXIiLCJob3Zlck9wYWNpdHkiLCJzZWxlY3RlZCIsInNlbGVjdGVkT3BhY2l0eSIsImRpc2FibGVkQmFja2dyb3VuZCIsImRpc2FibGVkT3BhY2l0eSIsImZvY3VzIiwiZm9jdXNPcGFjaXR5IiwiYWN0aXZhdGVkT3BhY2l0eSIsImRhcmsiLCJpY29uIiwiYWRkTGlnaHRPckRhcmsiLCJpbnRlbnQiLCJkaXJlY3Rpb24iLCJzaGFkZSIsInRvbmFsT2Zmc2V0IiwidG9uYWxPZmZzZXRMaWdodCIsInRvbmFsT2Zmc2V0RGFyayIsIm1haW4iLCJjcmVhdGVQYWxldHRlIiwicGFsZXR0ZSIsIl9wYWxldHRlJHByaW1hcnkiLCJfcGFsZXR0ZSRzZWNvbmRhcnkiLCJfcGFsZXR0ZSRlcnJvciIsIl9wYWxldHRlJHdhcm5pbmciLCJ3YXJuaW5nIiwiX3BhbGV0dGUkaW5mbyIsImluZm8iLCJfcGFsZXR0ZSRzdWNjZXNzIiwic3VjY2VzcyIsIl9wYWxldHRlJHR5cGUiLCJfcGFsZXR0ZSRjb250cmFzdFRocmUiLCJjb250cmFzdFRocmVzaG9sZCIsIl9wYWxldHRlJHRvbmFsT2Zmc2V0IiwiZ2V0Q29udHJhc3RUZXh0IiwiY29udHJhc3RUZXh0IiwiY29udHJhc3QiLCJhdWdtZW50Q29sb3IiLCJtYWluU2hhZGUiLCJsaWdodFNoYWRlIiwiZGFya1NoYWRlIiwidHlwZXMiLCJwYWxldHRlT3V0cHV0Iiwicm91bmRXaXRoRGVwcmVjYXRpb25XYXJuaW5nIiwiY2FzZUFsbENhcHMiLCJ0ZXh0VHJhbnNmb3JtIiwiZGVmYXVsdEZvbnRGYW1pbHkiLCJjcmVhdGVUeXBvZ3JhcGh5IiwidHlwb2dyYXBoeSIsIl9yZWYiLCJfcmVmJGZvbnRGYW1pbHkiLCJmb250RmFtaWx5IiwiX3JlZiRmb250U2l6ZSIsImZvbnRTaXplIiwiX3JlZiRmb250V2VpZ2h0TGlnaHQiLCJmb250V2VpZ2h0TGlnaHQiLCJfcmVmJGZvbnRXZWlnaHRSZWd1bGEiLCJmb250V2VpZ2h0UmVndWxhciIsIl9yZWYkZm9udFdlaWdodE1lZGl1bSIsImZvbnRXZWlnaHRNZWRpdW0iLCJfcmVmJGZvbnRXZWlnaHRCb2xkIiwiZm9udFdlaWdodEJvbGQiLCJfcmVmJGh0bWxGb250U2l6ZSIsImh0bWxGb250U2l6ZSIsImFsbFZhcmlhbnRzIiwicHhUb1JlbTIiLCJweFRvUmVtIiwiY29lZiIsInNpemUiLCJidWlsZFZhcmlhbnQiLCJmb250V2VpZ2h0IiwibGluZUhlaWdodCIsImxldHRlclNwYWNpbmciLCJjYXNpbmciLCJ2YXJpYW50cyIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsInN1YnRpdGxlMSIsInN1YnRpdGxlMiIsImJvZHkxIiwiYm9keTIiLCJidXR0b24iLCJjYXB0aW9uIiwib3ZlcmxpbmUiLCJzaGFkb3dLZXlVbWJyYU9wYWNpdHkiLCJzaGFkb3dLZXlQZW51bWJyYU9wYWNpdHkiLCJzaGFkb3dBbWJpZW50U2hhZG93T3BhY2l0eSIsImNyZWF0ZVNoYWRvdyIsInNoYWRvd3MiLCJib3JkZXJSYWRpdXMiLCJyZXNwb25zaXZlUHJvcFR5cGUiLCJfYXJyYXlMaWtlVG9BcnJheSIsImFyciIsImxlbiIsImFycjIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJhcnJheUxpa2VUb0FycmF5IiwiX2l0ZXJhYmxlVG9BcnJheSIsIml0ZXIiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJvIiwibWluTGVuIiwidG9TdHJpbmciLCJzbGljZSIsInRlc3QiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnJheVdpdGhvdXRIb2xlcyIsIml0ZXJhYmxlVG9BcnJheSIsInVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5Iiwibm9uSXRlcmFibGVTcHJlYWQiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfaSIsIl9hcnIiLCJfbiIsIl9kIiwiX3MiLCJfZSIsIl9ub25JdGVyYWJsZVJlc3QiLCJfc2xpY2VkVG9BcnJheSIsImFycmF5V2l0aEhvbGVzIiwiaXRlcmFibGVUb0FycmF5TGltaXQiLCJub25JdGVyYWJsZVJlc3QiLCJzcGFjaW5nS2V5cyIsImNyZWF0ZVVuYXJ5U3BhY2luZyIsInRoZW1lIiwidGhlbWVTcGFjaW5nIiwiYWJzIiwicmVkdWNlIiwid2Fybk9uY2UiLCJjcmVhdGVTcGFjaW5nIiwic3BhY2luZ0lucHV0IiwibXVpIiwidHJhbnNmb3JtIiwiX2xlbiIsImFyZ3MiLCJfa2V5IiwiYXJndW1lbnQiLCJnZXQiLCJlYXNpbmciLCJlYXNlSW5PdXQiLCJlYXNlT3V0IiwiZWFzZUluIiwic2hhcnAiLCJkdXJhdGlvbiIsInNob3J0ZXN0Iiwic2hvcnRlciIsInNob3J0Iiwic3RhbmRhcmQiLCJjb21wbGV4IiwiZW50ZXJpbmdTY3JlZW4iLCJsZWF2aW5nU2NyZWVuIiwiZm9ybWF0TXMiLCJtaWxsaXNlY29uZHMiLCJjcmVhdGUiLCJfb3B0aW9ucyRkdXJhdGlvbiIsImR1cmF0aW9uT3B0aW9uIiwiX29wdGlvbnMkZWFzaW5nIiwiZWFzaW5nT3B0aW9uIiwiX29wdGlvbnMkZGVsYXkiLCJkZWxheSIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc05hTiIsImFuaW1hdGVkUHJvcCIsImdldEF1dG9IZWlnaHREdXJhdGlvbiIsImhlaWdodCIsImNvbnN0YW50IiwiekluZGV4IiwibW9iaWxlU3RlcHBlciIsInNwZWVkRGlhbCIsImFwcEJhciIsImRyYXdlciIsIm1vZGFsIiwic25hY2tiYXIiLCJ0b29sdGlwIiwiY3JlYXRlVGhlbWUiLCJfb3B0aW9ucyRicmVha3BvaW50cyIsImJyZWFrcG9pbnRzSW5wdXQiLCJfb3B0aW9ucyRtaXhpbnMiLCJtaXhpbnNJbnB1dCIsIl9vcHRpb25zJHBhbGV0dGUiLCJwYWxldHRlSW5wdXQiLCJfb3B0aW9ucyR0eXBvZ3JhcGh5IiwidHlwb2dyYXBoeUlucHV0IiwibXVpVGhlbWUiLCJvdmVycmlkZXMiLCJ0cmFuc2l0aW9ucyIsImFjYyIsInBzZXVkb0NsYXNzZXMiLCJ0cmF2ZXJzZSIsInBhcmVudEtleSIsImRlcHRoIiwiY2hpbGQiLCJyb290IiwiY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUiLCJfb3B0aW9ucyRkaXNhYmxlR2xvYmEiLCJkaXNhYmxlR2xvYmFsIiwicHJvZHVjdGlvblByZWZpeCIsIl9vcHRpb25zJHNlZWQiLCJzZWVkIiwic2VlZFByZWZpeCIsInJ1bGVDb3VudGVyIiwiZ2V0TmV4dENvdW50ZXJJZCIsInJ1bGUiLCJsaW5rIiwicHJlZml4IiwibmVzdGVkIiwic3VmZml4IiwiY2xhc3NOYW1lUHJlZml4IiwiZ2V0VGhlbWVQcm9wcyIsInBhcmFtcyIsImRlZmF1bHRQcm9wcyIsImlzUHJvZHVjdGlvbiIsImNvbmRpdGlvbiIsImlzQnJvd3NlciIsIndpbmRvdyIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwiZGVzY3JpcHRvciIsIl9jcmVhdGVDbGFzcyIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX3NldFByb3RvdHlwZU9mIiwicCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2luaGVyaXRzTG9vc2UiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwic2VsZiIsIlJlZmVyZW5jZUVycm9yIiwicGxhaW5PYmplY3RDb25zdHJ1cmN0b3IiLCJjbG9uZVN0eWxlIiwibmV3U3R5bGUiLCJjcmVhdGVSdWxlIiwiZGVjbCIsImpzcyIsImRlY2xDb3B5IiwicGx1Z2lucyIsIm9uQ3JlYXRlUnVsZSIsImJ5IiwicmVzdWx0IiwidG9Dc3NWYWx1ZSIsImlnbm9yZUltcG9ydGFudCIsImNzc1ZhbHVlIiwiZ2V0V2hpdGVzcGFjZVN5bWJvbHMiLCJmb3JtYXQiLCJsaW5lYnJlYWsiLCJzcGFjZSIsImluZGVudFN0ciIsImluZGVudCIsInRvQ3NzIiwic2VsZWN0b3IiLCJfb3B0aW9ucyIsIl9vcHRpb25zJGluZGVudCIsImZhbGxiYWNrcyIsIkluZmluaXR5IiwiX2dldFdoaXRlc3BhY2VTeW1ib2xzIiwiX3Byb3AiLCJfdmFsdWUiLCJfcHJvcDIiLCJfdmFsdWUyIiwiYWxsb3dFbXB0eSIsImVzY2FwZVJlZ2V4IiwibmF0aXZlRXNjYXBlIiwiQ1NTIiwiZXNjYXBlIiwicmVwbGFjZSIsIkJhc2VTdHlsZVJ1bGUiLCJpc1Byb2Nlc3NlZCIsInNoZWV0IiwiUmVuZGVyZXIiLCJyZW5kZXJlciIsIl9wcm90byIsImZvcmNlIiwibmV3VmFsdWUiLCJvbkNoYW5nZVZhbHVlIiwiaXNFbXB0eSIsImlzRGVmaW5lZCIsInJlbW92ZSIsInJlbmRlcmFibGUiLCJyZW1vdmVQcm9wZXJ0eSIsInNldFByb3BlcnR5IiwiYXR0YWNoZWQiLCJTdHlsZVJ1bGUiLCJfQmFzZVN0eWxlUnVsZSIsIl90aGlzIiwic2NvcGVkIiwiZ2VuZXJhdGVJZCIsInNlbGVjdG9yVGV4dCIsImlkIiwiX3Byb3RvMiIsImFwcGx5VG8iLCJqc29uIiwidG9KU09OIiwib3B0cyIsInNldCIsImhhc0NoYW5nZWQiLCJzZXRTZWxlY3RvciIsInJlcGxhY2VSdWxlIiwicGx1Z2luU3R5bGVSdWxlIiwicGFyZW50IiwiZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyIsImNoaWxkcmVuIiwiYXRSZWdFeHAiLCJDb25kaXRpb25hbFJ1bGUiLCJhdE1hdGNoIiwiYXQiLCJxdWVyeSIsInJ1bGVzIiwiUnVsZUxpc3QiLCJhZGQiLCJnZXRSdWxlIiwiYWRkUnVsZSIsIm9uUHJvY2Vzc1J1bGUiLCJrZXlSZWdFeHAiLCJwbHVnaW5Db25kaXRpb25hbFJ1bGUiLCJkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDEiLCJuYW1lUmVnRXhwIiwiS2V5ZnJhbWVzUnVsZSIsImZyYW1lcyIsIm5hbWVNYXRjaCIsImtleVJlZ0V4cCQxIiwicmVmUmVnRXhwIiwiZmluZFJlZmVyZW5jZWRLZXlmcmFtZSIsImtleWZyYW1lcyIsInJlcGxhY2VSZWYiLCJyZWZLZXlmcmFtZSIsInBsdWdpbktleWZyYW1lc1J1bGUiLCJvblByb2Nlc3NTdHlsZSIsIktleWZyYW1lUnVsZSIsInBsdWdpbktleWZyYW1lUnVsZSIsIkZvbnRGYWNlUnVsZSIsImtleVJlZ0V4cCQyIiwicGx1Z2luRm9udEZhY2VSdWxlIiwiVmlld3BvcnRSdWxlIiwicGx1Z2luVmlld3BvcnRSdWxlIiwiU2ltcGxlUnVsZSIsImtleXNNYXAiLCJwbHVnaW5TaW1wbGVSdWxlIiwiZGVmYXVsdFVwZGF0ZU9wdGlvbnMiLCJmb3JjZVVwZGF0ZU9wdGlvbnMiLCJyYXciLCJjb3VudGVyIiwiY2xhc3NlcyIsInJ1bGVPcHRpb25zIiwiX3RoaXMkb3B0aW9ucyIsInJlZ2lzdGVyIiwic3BsaWNlIiwidW5yZWdpc3RlciIsInVwZGF0ZSIsImRhdGEiLCJ1cGRhdGVPbmUiLCJfdGhpcyRvcHRpb25zMiIsIm9uVXBkYXRlIiwibmV4dFZhbHVlIiwicHJldlZhbHVlIiwiX25leHRWYWx1ZSIsIl9wcmV2VmFsdWUiLCJTdHlsZVNoZWV0IiwiZGVwbG95ZWQiLCJhdHRhY2giLCJkZXBsb3kiLCJkZXRhY2giLCJxdWV1ZSIsImluc2VydFJ1bGUiLCJhZGRSdWxlcyIsImFkZGVkIiwiZGVsZXRlUnVsZSIsIl90aGlzJHJ1bGVzIiwiUGx1Z2luc1JlZ2lzdHJ5IiwiaW50ZXJuYWwiLCJleHRlcm5hbCIsInJlZ2lzdHJ5Iiwib25Qcm9jZXNzU2hlZXQiLCJwcm9jZXNzZWRWYWx1ZSIsInVzZSIsIm5ld1BsdWdpbiIsInBsdWdpbiIsIlNoZWV0c1JlZ2lzdHJ5IiwicmVzZXQiLCJfdGVtcCIsInNoZWV0cyIsImdsb2JhbFRoaXMkMSIsImdsb2JhbFRoaXMiLCJucyIsIm1vZHVsZUlkIiwibWF4UnVsZXMiLCJjcmVhdGVHZW5lcmF0ZUlkIiwianNzSWQiLCJtaW5pZnkiLCJtZW1vaXplIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImNzc1J1bGUiLCJhdHRyaWJ1dGVTdHlsZU1hcCIsImRlbGV0ZSIsImdldEhlYWQiLCJxdWVyeVNlbGVjdG9yIiwiZmluZEhpZ2hlclNoZWV0IiwiaW5zZXJ0aW9uUG9pbnQiLCJmaW5kSGlnaGVzdFNoZWV0IiwiZmluZENvbW1lbnROb2RlIiwiY2hpbGROb2RlcyIsIm5vZGVWYWx1ZSIsInRyaW0iLCJmaW5kUHJldk5vZGUiLCJwYXJlbnROb2RlIiwibmV4dFNpYmxpbmciLCJjb21tZW50IiwiaW5zZXJ0U3R5bGUiLCJuZXh0Tm9kZSIsImluc2VydGlvblBvaW50RWxlbWVudCIsImdldE5vbmNlIiwiZ2V0QXR0cmlidXRlIiwiX2luc2VydFJ1bGUiLCJjb250YWluZXIiLCJhcHBlbmRSdWxlIiwiY3NzUnVsZXMiLCJnZXRWYWxpZFJ1bGVJbnNlcnRpb25JbmRleCIsIm1heEluZGV4IiwiY3JlYXRlU3R5bGUiLCJlbCIsInRleHRDb250ZW50IiwiRG9tUmVuZGVyZXIiLCJoYXNJbnNlcnRlZFJ1bGVzIiwibWVkaWEiLCJtZXRhIiwic2V0QXR0cmlidXRlIiwibm9uY2UiLCJyZW1vdmVDaGlsZCIsImluc2VydFJ1bGVzIiwibmF0aXZlUGFyZW50IiwibGF0ZXN0TmF0aXZlUGFyZW50IiwiX2luc2VydGlvbkluZGV4IiwicmVmQ3NzUnVsZSIsInJ1bGVTdHIiLCJpbnNlcnRpb25JbmRleCIsIm5hdGl2ZVJ1bGUiLCJnZXRSdWxlcyIsImluc3RhbmNlQ291bnRlciIsIkpzcyIsInZlcnNpb24iLCJpc0luQnJvd3NlciIsInNldHVwIiwiY3JlYXRlU3R5bGVTaGVldCIsInJlbW92ZVN0eWxlU2hlZXQiLCJjcmVhdGVSdWxlJDEiLCJjcmVhdGVKc3MiLCJoYXNDU1NUT01TdXBwb3J0IiwiZ2V0RHluYW1pY1N0eWxlcyIsImV4dHJhY3RlZCIsIm5vdyIsImZuVmFsdWVzTnMiLCJmblJ1bGVOcyIsImZ1bmN0aW9uUGx1Z2luIiwiZm5WYWx1ZXMiLCJzdHlsZVJ1bGUiLCJmblJ1bGUiLCJhdFByZWZpeCIsIkdsb2JhbENvbnRhaW5lclJ1bGUiLCJHbG9iYWxQcmVmaXhlZFJ1bGUiLCJzZXBhcmF0b3JSZWdFeHAiLCJhZGRTY29wZSIsInNjb3BlIiwicGFydHMiLCJoYW5kbGVOZXN0ZWRHbG9iYWxDb250YWluZXJSdWxlIiwiaGFuZGxlUHJlZml4ZWRHbG9iYWxSdWxlIiwianNzR2xvYmFsIiwicGFyZW50UmVnRXhwIiwianNzTmVzdGVkIiwiZ2V0UmVwbGFjZVJlZiIsInJlcGxhY2VQYXJlbnRSZWZzIiwibmVzdGVkUHJvcCIsInBhcmVudFByb3AiLCJwYXJlbnRTZWxlY3RvcnMiLCJuZXN0ZWRTZWxlY3RvcnMiLCJqIiwiZ2V0T3B0aW9ucyIsInByZXZPcHRpb25zIiwibmVzdGluZ0xldmVsIiwiaXNOZXN0ZWQiLCJpc05lc3RlZENvbmRpdGlvbmFsIiwidXBwZXJjYXNlUGF0dGVybiIsIm1zUGF0dGVybiIsImNhY2hlIiwidG9IeXBoZW5Mb3dlciIsInRvTG93ZXJDYXNlIiwiaHlwaGVuYXRlU3R5bGVOYW1lIiwiaE5hbWUiLCJjb252ZXJ0Q2FzZSIsImNvbnZlcnRlZCIsImh5cGhlbmF0ZSIsImNhbWVsQ2FzZSIsImh5cGhlbmF0ZWRQcm9wIiwicHgiLCJtcyIsInBlcmNlbnQiLCJkZWZhdWx0VW5pdHMiLCJib3JkZXIiLCJtYXJnaW4iLCJwYWRkaW5nIiwiYm90dG9tIiwibGVmdCIsInRvcCIsInJpZ2h0IiwiaW5zZXQiLCJtb3Rpb24iLCJvdXRsaW5lIiwicGVyc3BlY3RpdmUiLCJnYXAiLCJncmlkIiwiYWRkQ2FtZWxDYXNlZFZlcnNpb24iLCJyZWdFeHAiLCJ0b1VwcGVyQ2FzZSIsIm5ld09iaiIsInVuaXRzIiwiaXRlcmF0ZSIsImlubmVyUHJvcCIsIl9pbm5lclByb3AiLCJkZWZhdWx0VW5pdCIsImNhbWVsQ2FzZWRPcHRpb25zIiwianMiLCJ2ZW5kb3IiLCJicm93c2VyIiwiaXNUb3VjaCIsImRvY3VtZW50RWxlbWVudCIsImpzQ3NzTWFwIiwiTW96IiwiTyIsIldlYmtpdCIsIl9kb2N1bWVudCRjcmVhdGVFbGVtZSIsInRlc3RQcm9wIiwic3VwcG9ydGVkS2V5ZnJhbWVzIiwiYXBwZWFyZW5jZSIsIm5vUHJlZmlsbCIsInN1cHBvcnRlZFByb3BlcnR5IiwiY29sb3JBZGp1c3QiLCJ0b1VwcGVyIiwiYyIsImNhbWVsaXplIiwicGFzY2FsaXplIiwibWFzayIsImxvbmdoYW5kIiwidGV4dE9yaWVudGF0aW9uIiwidHJhbnNpdGlvbiIsIndyaXRpbmdNb2RlIiwidXNlclNlbGVjdCIsImJyZWFrUHJvcHNPbGQiLCJqc1Byb3AiLCJfanNQcm9wIiwiaW5saW5lTG9naWNhbE9sZCIsIm5ld1Byb3AiLCJ1bnByZWZpeGVkIiwicHJlZml4ZWQiLCJwYXNjYWxpemVkIiwic2Nyb2xsU25hcCIsIm92ZXJzY3JvbGxCZWhhdmlvciIsInByb3BNYXAiLCJvcmRlciIsImZsZXgyMDEyIiwicHJvcE1hcCQxIiwiZmxleCIsInByb3BLZXlzIiwicHJlZml4Q3NzIiwiZmxleDIwMDkiLCJtdWx0aXBsZSIsInByb3BlcnR5RGV0ZWN0b3JzIiwiY29tcHV0ZWQiLCJnZXRDb21wdXRlZFN0eWxlIiwia2V5JDEiLCJjYWNoZSQxIiwidHJhbnNpdGlvblByb3BlcnRpZXMiLCJ0cmFuc1Byb3BzUmVnRXhwIiwiZWwkMSIsInByZWZpeFRyYW5zaXRpb25DYWxsYmFjayIsInAxIiwicDIiLCJwcmVmaXhlZFZhbHVlIiwic3VwcG9ydGVkVmFsdWUiLCJwcm9wZXJ0eSIsImpzc1ZlbmRvclByZWZpeGVyIiwiYXRSdWxlIiwicHJlZml4U3R5bGUiLCJjaGFuZ2VQcm9wIiwic3VwcG9ydGVkUHJvcCIsImNoYW5nZVZhbHVlIiwic3VwcG9ydGVkVmFsdWUkMSIsImpzc1Byb3BzU29ydCIsInNvcnQiLCJwcm9wMCIsInByb3AxIiwianNzUHJlc2V0IiwiZnVuY3Rpb25zIiwiZ2xvYmFsIiwidmVuZG9yUHJlZml4ZXIiLCJwcm9wc1NvcnQiLCJtZXJnZUNsYXNzZXMiLCJiYXNlQ2xhc3NlcyIsIm5ld0NsYXNzZXMiLCJuZXh0Q2xhc3NlcyIsIm11bHRpS2V5U3RvcmUiLCJrZXkxIiwia2V5MiIsInN1YkNhY2hlIiwiTWFwIiwiX2RlbGV0ZSIsIlRoZW1lQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZVRoZW1lIiwidXNlQ29udGV4dCIsInVzZURlYnVnVmFsdWUiLCJnZW5lcmF0ZUNsYXNzTmFtZSIsInNoZWV0c01hbmFnZXIiLCJkZWZhdWx0T3B0aW9ucyIsImRpc2FibGVHZW5lcmF0aW9uIiwic2hlZXRzQ2FjaGUiLCJzaGVldHNSZWdpc3RyeSIsIlN0eWxlc0NvbnRleHQiLCJpbmplY3RGaXJzdE5vZGUiLCJTdHlsZXNQcm92aWRlciIsIl9wcm9wcyRpbmplY3RGaXJzdCIsImluamVjdEZpcnN0IiwiX3Byb3BzJGRpc2FibGVHZW5lcmF0IiwibG9jYWxPcHRpb25zIiwib3V0ZXJPcHRpb25zIiwiY29udGV4dCIsImNyZWF0ZUNvbW1lbnQiLCJQcm92aWRlciIsInNlcnZlckdlbmVyYXRlQ2xhc3NOYW1lIiwiaW5kZXhDb3VudGVyIiwiaW5jcmVtZW50Iiwibm9vcFRoZW1lIiwiZ2V0U3R5bGVzQ3JlYXRvciIsInN0eWxlc09yQ3JlYXRvciIsInRoZW1pbmdFbmFibGVkIiwic3R5bGVzV2l0aE92ZXJyaWRlcyIsImdldENsYXNzZXMiLCJzdGF0ZSIsInN0eWxlc09wdGlvbnMiLCJjYWNoZUNsYXNzZXMiLCJsYXN0UHJvcCIsImxhc3RKU1MiLCJnZW5lcmF0ZSIsIl9yZWYyIiwic3R5bGVzQ3JlYXRvciIsInNoZWV0TWFuYWdlciIsInJlZnMiLCJzdGF0aWNTaGVldCIsImR5bmFtaWNTdHlsZXMiLCJmbGlwIiwiZHluYW1pY1NoZWV0IiwiX3JlZjMiLCJfcmVmNCIsInVzZVN5bmNocm9ub3VzRWZmZWN0IiwidXNlUmVmIiwiY3VycmVudEtleSIsInVzZU1lbW8iLCJjdXJyZW50IiwidXNlRWZmZWN0IiwibWFrZVN0eWxlcyIsImNsYXNzTmFtZVByZWZpeE9wdGlvbiIsIl9vcHRpb25zJGRlZmF1bHRUaGVtZSIsImRlZmF1bHRUaGVtZSIsInN0eWxlc09wdGlvbnMyIiwidXNlU3R5bGVzIiwiaW5zdGFuY2UiLCJzaG91bGRVcGRhdGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJyZWFjdElzIiwiUkVBQ1RfU1RBVElDUyIsImNoaWxkQ29udGV4dFR5cGVzIiwiY29udGV4dFR5cGUiLCJjb250ZXh0VHlwZXMiLCJnZXREZWZhdWx0UHJvcHMiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJLTk9XTl9TVEFUSUNTIiwiY2FsbGVyIiwiY2FsbGVlIiwiYXJpdHkiLCJGT1JXQVJEX1JFRl9TVEFUSUNTIiwiTUVNT19TVEFUSUNTIiwiY29tcGFyZSIsIlRZUEVfU1RBVElDUyIsImdldFN0YXRpY3MiLCJjb21wb25lbnQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRQcm90b3R5cGVPZiIsIm9iamVjdFByb3RvdHlwZSIsImhvaXN0Tm9uUmVhY3RTdGF0aWNzIiwidGFyZ2V0Q29tcG9uZW50Iiwic291cmNlQ29tcG9uZW50IiwiYmxhY2tsaXN0IiwiaW5oZXJpdGVkQ29tcG9uZW50IiwidGFyZ2V0U3RhdGljcyIsInNvdXJjZVN0YXRpY3MiLCJlIiwid2l0aFN0eWxlcyIsIl9vcHRpb25zJHdpdGhUaGVtZSIsIndpdGhUaGVtZSIsIldpdGhTdHlsZXMiLCJmb3J3YXJkUmVmIiwiaW5uZXJSZWYiLCJtb3JlIiwiTmFrZWQiLCJ1c2VUaGVtZVdpdGhvdXREZWZhdWx0Iiwid2l0aFN0eWxlc1dpdGhvdXREZWZhdWx0IiwiZGVwcmVjYXRlZFByb3BUeXBlIiwidmFsaWRhdG9yIiwicmVhc29uIiwiY29tcG9uZW50TmFtZVNhZmUiLCJwcm9wRnVsbE5hbWVTYWZlIiwic2V0UmVmIiwidXNlRm9ya1JlZiIsInJlZkEiLCJyZWZCIiwicmVmVmFsdWUiLCJnZXRDb250YWluZXIiLCJSZWFjdERPTSIsImZpbmRET01Ob2RlIiwidXNlRW5oYW5jZWRFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJfcHJvcHMkZGlzYWJsZVBvcnRhbCIsImRpc2FibGVQb3J0YWwiLCJvblJlbmRlcmVkIiwiX1JlYWN0JHVzZVN0YXRlIiwidXNlU3RhdGUiLCJtb3VudE5vZGUiLCJzZXRNb3VudE5vZGUiLCJoYW5kbGVSZWYiLCJib2R5IiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlUG9ydGFsIiwiY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uIiwiZnVuY3MiLCJjaGFpbmVkRnVuY3Rpb24iLCJfbGVuMiIsIl9rZXkyIiwiZmxpcFBsYWNlbWVudCIsInBsYWNlbWVudCIsImdldEFuY2hvckVsIiwiYW5jaG9yRWwiLCJkZWZhdWx0UG9wcGVyT3B0aW9ucyIsIlBvcHBlciIsIl9wcm9wcyRrZWVwTW91bnRlZCIsImtlZXBNb3VudGVkIiwibW9kaWZpZXJzIiwib3BlbiIsIl9wcm9wcyRwbGFjZW1lbnQiLCJpbml0aWFsUGxhY2VtZW50IiwiX3Byb3BzJHBvcHBlck9wdGlvbnMiLCJwb3BwZXJPcHRpb25zIiwicG9wcGVyUmVmUHJvcCIsInBvcHBlclJlZiIsIl9wcm9wcyR0cmFuc2l0aW9uIiwidG9vbHRpcFJlZiIsIm93blJlZiIsImhhbmRsZVBvcHBlclJlZiIsImhhbmRsZVBvcHBlclJlZlJlZiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJleGl0ZWQiLCJzZXRFeGl0ZWQiLCJydGxQbGFjZW1lbnQiLCJfUmVhY3QkdXNlU3RhdGUyIiwic2V0UGxhY2VtZW50IiwiaGFuZGxlT3BlbiIsInVzZUNhbGxiYWNrIiwiZGVzdHJveSIsImhhbmRsZVBvcHBlclVwZGF0ZSIsInJlc29sdmVkQW5jaG9yRWwiLCJib3giLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwb3BwZXIiLCJQb3BwZXJKcyIsInByZXZlbnRPdmVyZmxvdyIsImJvdW5kYXJpZXNFbGVtZW50Iiwib25DcmVhdGUiLCJoYW5kbGVFbnRlciIsImhhbmRsZUNsb3NlIiwiaGFuZGxlRXhpdGVkIiwiY2hpbGRQcm9wcyIsIlRyYW5zaXRpb25Qcm9wcyIsImluIiwib25FbnRlciIsIm9uRXhpdGVkIiwicm9sZSIsInBvc2l0aW9uIiwiZGlzcGxheSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiY2FwaXRhbGl6ZSIsImJveFNpemluZyIsImxpc3RTdHlsZSIsImNvbG9yUHJpbWFyeSIsImNvbG9ySW5oZXJpdCIsInN0aWNreSIsImJhY2tncm91bmRDb2xvciIsIkxpc3RTdWJoZWFkZXIiLCJjbGFzc05hbWUiLCJfcHJvcHMkY29sb3IiLCJfcHJvcHMkY29tcG9uZW50IiwiX3Byb3BzJGRpc2FibGVHdXR0ZXJzIiwiZGlzYWJsZUd1dHRlcnMiLCJfcHJvcHMkZGlzYWJsZVN0aWNreSIsImRpc2FibGVTdGlja3kiLCJfcHJvcHMkaW5zZXQiLCJjbHN4IiwiZWxldmF0aW9ucyIsInNoYWRvdyIsImJveFNoYWRvdyIsInJvdW5kZWQiLCJvdXRsaW5lZCIsIlBhcGVyIiwiX3Byb3BzJHNxdWFyZSIsInNxdWFyZSIsIl9wcm9wcyRlbGV2YXRpb24iLCJlbGV2YXRpb24iLCJfcHJvcHMkdmFyaWFudCIsInZhcmlhbnQiLCJ1c2VFdmVudENhbGxiYWNrIiwiaGFkS2V5Ym9hcmRFdmVudCIsImhhZEZvY3VzVmlzaWJsZVJlY2VudGx5IiwiaGFkRm9jdXNWaXNpYmxlUmVjZW50bHlUaW1lb3V0IiwiaW5wdXRUeXBlc1doaXRlbGlzdCIsInNlYXJjaCIsInVybCIsInRlbCIsImVtYWlsIiwicGFzc3dvcmQiLCJkYXRlIiwibW9udGgiLCJ3ZWVrIiwidGltZSIsImRhdGV0aW1lIiwiZm9jdXNUcmlnZ2Vyc0tleWJvYXJkTW9kYWxpdHkiLCJ0YWdOYW1lIiwicmVhZE9ubHkiLCJpc0NvbnRlbnRFZGl0YWJsZSIsImhhbmRsZUtleURvd24iLCJldmVudCIsIm1ldGFLZXkiLCJhbHRLZXkiLCJjdHJsS2V5IiwiaGFuZGxlUG9pbnRlckRvd24iLCJoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlIiwidmlzaWJpbGl0eVN0YXRlIiwicHJlcGFyZSIsImRvYyIsImFkZEV2ZW50TGlzdGVuZXIiLCJpc0ZvY3VzVmlzaWJsZSIsIm1hdGNoZXMiLCJoYW5kbGVCbHVyVmlzaWJsZSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJ1c2VJc0ZvY3VzVmlzaWJsZSIsIm93bmVyRG9jdW1lbnQiLCJvbkJsdXJWaXNpYmxlIiwidGltZW91dHNTaGFwZSIsImVudGVyIiwiZXhpdCIsImFwcGVhciIsImVudGVyRG9uZSIsImVudGVyQWN0aXZlIiwiZXhpdERvbmUiLCJleGl0QWN0aXZlIiwiVU5NT1VOVEVEIiwiRVhJVEVEIiwiRU5URVJJTkciLCJFTlRFUkVEIiwiRVhJVElORyIsIlRyYW5zaXRpb24iLCJfUmVhY3QkQ29tcG9uZW50IiwicGFyZW50R3JvdXAiLCJpc01vdW50aW5nIiwiaW5pdGlhbFN0YXR1cyIsImFwcGVhclN0YXR1cyIsInVubW91bnRPbkV4aXQiLCJtb3VudE9uRW50ZXIiLCJzdGF0dXMiLCJuZXh0Q2FsbGJhY2siLCJwcmV2U3RhdGUiLCJuZXh0SW4iLCJjb21wb25lbnREaWRNb3VudCIsInVwZGF0ZVN0YXR1cyIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsIm5leHRTdGF0dXMiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImNhbmNlbE5leHRDYWxsYmFjayIsImdldFRpbWVvdXRzIiwidGltZW91dCIsIm1vdW50aW5nIiwicGVyZm9ybUVudGVyIiwicGVyZm9ybUV4aXQiLCJzZXRTdGF0ZSIsIl90aGlzMiIsImFwcGVhcmluZyIsIm5vZGVSZWYiLCJtYXliZU5vZGUiLCJtYXliZUFwcGVhcmluZyIsInRpbWVvdXRzIiwiZW50ZXJUaW1lb3V0IiwiY29uZmlnIiwic2FmZVNldFN0YXRlIiwib25FbnRlcmVkIiwib25FbnRlcmluZyIsIm9uVHJhbnNpdGlvbkVuZCIsIl90aGlzMyIsIm9uRXhpdCIsIm9uRXhpdGluZyIsImNhbmNlbCIsIm5leHRTdGF0ZSIsImNhbGxiYWNrIiwic2V0TmV4dENhbGxiYWNrIiwiX3RoaXM0IiwiaGFuZGxlciIsImRvZXNOb3RIYXZlVGltZW91dE9yTGlzdGVuZXIiLCJhZGRFbmRMaXN0ZW5lciIsIm1heWJlTmV4dENhbGxiYWNrIiwiX3RoaXMkcHJvcHMiLCJUcmFuc2l0aW9uR3JvdXBDb250ZXh0IiwiQ2hpbGRyZW4iLCJkZWZhdWx0VmlldyIsInB0Iiwibm9vcCIsImdldENoaWxkTWFwcGluZyIsIm1hcEZuIiwibWFwcGVyIiwibWVyZ2VDaGlsZE1hcHBpbmdzIiwicHJldiIsImdldFZhbHVlRm9yS2V5IiwibmV4dEtleXNQZW5kaW5nIiwicGVuZGluZ0tleXMiLCJwcmV2S2V5IiwiY2hpbGRNYXBwaW5nIiwibmV4dEtleSIsInBlbmRpbmdOZXh0S2V5IiwiZ2V0UHJvcCIsImdldEluaXRpYWxDaGlsZE1hcHBpbmciLCJnZXROZXh0Q2hpbGRNYXBwaW5nIiwibmV4dFByb3BzIiwicHJldkNoaWxkTWFwcGluZyIsIm5leHRDaGlsZE1hcHBpbmciLCJoYXNQcmV2IiwiaGFzTmV4dCIsInByZXZDaGlsZCIsImlzTGVhdmluZyIsImNoaWxkRmFjdG9yeSIsIlRyYW5zaXRpb25Hcm91cCIsImNvbnRleHRWYWx1ZSIsImZpcnN0UmVuZGVyIiwibW91bnRlZCIsImN1cnJlbnRDaGlsZE1hcHBpbmciLCJSaXBwbGUiLCJfcHJvcHMkcHVsc2F0ZSIsInB1bHNhdGUiLCJyaXBwbGVYIiwicmlwcGxlWSIsInJpcHBsZVNpemUiLCJpblByb3AiLCJfcHJvcHMkb25FeGl0ZWQiLCJsZWF2aW5nIiwic2V0TGVhdmluZyIsInJpcHBsZUNsYXNzTmFtZSIsInJpcHBsZSIsInJpcHBsZVZpc2libGUiLCJyaXBwbGVQdWxzYXRlIiwicmlwcGxlU3R5bGVzIiwiY2hpbGRDbGFzc05hbWUiLCJjaGlsZExlYXZpbmciLCJjaGlsZFB1bHNhdGUiLCJ0aW1lb3V0SWQiLCJEVVJBVElPTiIsIkRFTEFZX1JJUFBMRSIsIm92ZXJmbG93IiwicG9pbnRlckV2ZW50cyIsIm9wYWNpdHkiLCJhbmltYXRpb24iLCJhbmltYXRpb25EdXJhdGlvbiIsIlRvdWNoUmlwcGxlIiwiX3Byb3BzJGNlbnRlciIsImNlbnRlciIsImNlbnRlclByb3AiLCJyaXBwbGVzIiwic2V0UmlwcGxlcyIsInJpcHBsZUNhbGxiYWNrIiwiaWdub3JpbmdNb3VzZURvd24iLCJzdGFydFRpbWVyIiwic3RhcnRUaW1lckNvbW1pdCIsInN0YXJ0Q29tbWl0IiwiY2IiLCJvbGRSaXBwbGVzIiwiX29wdGlvbnMkcHVsc2F0ZSIsIl9vcHRpb25zJGNlbnRlciIsIl9vcHRpb25zJGZha2VFbGVtZW50IiwiZmFrZUVsZW1lbnQiLCJyZWN0IiwiY2xpZW50WCIsImNsaWVudFkiLCJ0b3VjaGVzIiwic3FydCIsInNpemVYIiwic2l6ZVkiLCJzdG9wIiwicGVyc2lzdCIsIm1lbW8iLCJhbGlnbkl0ZW1zIiwianVzdGlmeUNvbnRlbnQiLCJXZWJraXRUYXBIaWdobGlnaHRDb2xvciIsImN1cnNvciIsInZlcnRpY2FsQWxpZ24iLCJ0ZXh0RGVjb3JhdGlvbiIsImJvcmRlclN0eWxlIiwiZm9jdXNWaXNpYmxlIiwiQnV0dG9uQmFzZSIsImJ1dHRvblJlZlByb3AiLCJidXR0b25SZWYiLCJfcHJvcHMkY2VudGVyUmlwcGxlIiwiY2VudGVyUmlwcGxlIiwiX3Byb3BzJGRpc2FibGVkIiwiX3Byb3BzJGRpc2FibGVSaXBwbGUiLCJkaXNhYmxlUmlwcGxlIiwiX3Byb3BzJGRpc2FibGVUb3VjaFJpIiwiZGlzYWJsZVRvdWNoUmlwcGxlIiwiX3Byb3BzJGZvY3VzUmlwcGxlIiwiZm9jdXNSaXBwbGUiLCJmb2N1c1Zpc2libGVDbGFzc05hbWUiLCJvbkJsdXIiLCJvbkNsaWNrIiwib25Gb2N1cyIsIm9uRm9jdXNWaXNpYmxlIiwib25LZXlEb3duIiwib25LZXlVcCIsIm9uTW91c2VEb3duIiwib25Nb3VzZUxlYXZlIiwib25Nb3VzZVVwIiwib25Ub3VjaEVuZCIsIm9uVG91Y2hNb3ZlIiwib25Ub3VjaFN0YXJ0Iiwib25EcmFnTGVhdmUiLCJfcHJvcHMkdGFiSW5kZXgiLCJ0YWJJbmRleCIsIlRvdWNoUmlwcGxlUHJvcHMiLCJfcHJvcHMkdHlwZSIsImdldEJ1dHRvbk5vZGUiLCJyaXBwbGVSZWYiLCJzZXRGb2N1c1Zpc2libGUiLCJfdXNlSXNGb2N1c1Zpc2libGUiLCJmb2N1c1Zpc2libGVSZWYiLCJ1c2VSaXBwbGVIYW5kbGVyIiwicmlwcGxlQWN0aW9uIiwiZXZlbnRDYWxsYmFjayIsInNraXBSaXBwbGVBY3Rpb24iLCJpZ25vcmUiLCJoYW5kbGVNb3VzZURvd24iLCJoYW5kbGVEcmFnTGVhdmUiLCJoYW5kbGVNb3VzZVVwIiwiaGFuZGxlTW91c2VMZWF2ZSIsInByZXZlbnREZWZhdWx0IiwiaGFuZGxlVG91Y2hTdGFydCIsImhhbmRsZVRvdWNoRW5kIiwiaGFuZGxlVG91Y2hNb3ZlIiwiaGFuZGxlQmx1ciIsImhhbmRsZUZvY3VzIiwiY3VycmVudFRhcmdldCIsImlzTm9uTmF0aXZlQnV0dG9uIiwiaHJlZiIsImtleWRvd25SZWYiLCJoYW5kbGVLZXlVcCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJDb21wb25lbnRQcm9wIiwiYnV0dG9uUHJvcHMiLCJoYW5kbGVVc2VyUmVmIiwiaGFuZGxlT3duUmVmIiwibW91bnRlZFN0YXRlIiwic2V0TW91bnRlZFN0YXRlIiwiZW5hYmxlVG91Y2hSaXBwbGUiLCJ0ZXh0QWxpZ24iLCJlZGdlU3RhcnQiLCJtYXJnaW5MZWZ0IiwiZWRnZUVuZCIsIm1hcmdpblJpZ2h0IiwiY29sb3JTZWNvbmRhcnkiLCJzaXplU21hbGwiLCJsYWJlbCIsIkljb25CdXR0b24iLCJfcHJvcHMkZWRnZSIsImVkZ2UiLCJfcHJvcHMkZGlzYWJsZUZvY3VzUmkiLCJkaXNhYmxlRm9jdXNSaXBwbGUiLCJfcHJvcHMkc2l6ZSIsImZvdW5kIiwidG9BcnJheSIsInNvbWUiLCJmaWxsIiwiZmxleFNocmluayIsImNvbG9yQWN0aW9uIiwiY29sb3JFcnJvciIsImNvbG9yRGlzYWJsZWQiLCJmb250U2l6ZUluaGVyaXQiLCJmb250U2l6ZVNtYWxsIiwiZm9udFNpemVMYXJnZSIsIlN2Z0ljb24iLCJfcHJvcHMkZm9udFNpemUiLCJodG1sQ29sb3IiLCJ0aXRsZUFjY2VzcyIsIl9wcm9wcyR2aWV3Qm94Iiwidmlld0JveCIsImZvY3VzYWJsZSIsInNoYXBlUmVuZGVyaW5nIiwibXVpTmFtZSIsImNyZWF0ZVN2Z0ljb24iLCJwYXRoIiwiZCIsInVuc3VwcG9ydGVkUHJvcCIsImRlbGV0ZUljb25Db2xvciIsIndoaXRlU3BhY2UiLCJjbGlja2FibGUiLCJjbGlja2FibGVDb2xvclByaW1hcnkiLCJjbGlja2FibGVDb2xvclNlY29uZGFyeSIsImRlbGV0YWJsZSIsImRlbGV0YWJsZUNvbG9yUHJpbWFyeSIsImRlbGV0YWJsZUNvbG9yU2Vjb25kYXJ5Iiwib3V0bGluZWRQcmltYXJ5Iiwib3V0bGluZWRTZWNvbmRhcnkiLCJhdmF0YXIiLCJhdmF0YXJTbWFsbCIsImF2YXRhckNvbG9yUHJpbWFyeSIsImF2YXRhckNvbG9yU2Vjb25kYXJ5IiwiaWNvblNtYWxsIiwiaWNvbkNvbG9yUHJpbWFyeSIsImljb25Db2xvclNlY29uZGFyeSIsInRleHRPdmVyZmxvdyIsImxhYmVsU21hbGwiLCJkZWxldGVJY29uIiwiZGVsZXRlSWNvblNtYWxsIiwiZGVsZXRlSWNvbkNvbG9yUHJpbWFyeSIsImRlbGV0ZUljb25Db2xvclNlY29uZGFyeSIsImRlbGV0ZUljb25PdXRsaW5lZENvbG9yUHJpbWFyeSIsImRlbGV0ZUljb25PdXRsaW5lZENvbG9yU2Vjb25kYXJ5IiwiaXNEZWxldGVLZXlib2FyZEV2ZW50Iiwia2V5Ym9hcmRFdmVudCIsIkNoaXAiLCJhdmF0YXJQcm9wIiwiY2xpY2thYmxlUHJvcCIsImRlbGV0ZUljb25Qcm9wIiwiaWNvblByb3AiLCJvbkRlbGV0ZSIsImNoaXBSZWYiLCJoYW5kbGVEZWxldGVJY29uQ2xpY2siLCJzdG9wUHJvcGFnYXRpb24iLCJibHVyIiwic21hbGwiLCJtb3JlUHJvcHMiLCJjdXN0b21DbGFzc2VzIiwiQ2FuY2VsSWNvbiIsImRlYm91bmNlIiwid2FpdCIsImRlYm91bmNlZCIsInRoYXQiLCJsYXRlciIsImNsZWFyIiwiaXNNdWlFbGVtZW50IiwibXVpTmFtZXMiLCJvd25lcldpbmRvdyIsInVzZUNvbnRyb2xsZWQiLCJjb250cm9sbGVkIiwiZGVmYXVsdFByb3AiLCJfcmVmJHN0YXRlIiwiX1JlYWN0JHVzZVJlZiIsImlzQ29udHJvbGxlZCIsInZhbHVlU3RhdGUiLCJzZXRWYWx1ZSIsIl9SZWFjdCR1c2VSZWYyIiwiZGVmYXVsdFZhbHVlIiwic2V0VmFsdWVJZlVuY29udHJvbGxlZCIsInVzZUlkIiwiaWRPdmVycmlkZSIsImRlZmF1bHRJZCIsInNldERlZmF1bHRJZCIsInJhbmRvbSIsInN0cmlwRGlhY3JpdGljcyIsIm5vcm1hbGl6ZSIsImNyZWF0ZUZpbHRlck9wdGlvbnMiLCJfY29uZmlnJGlnbm9yZUFjY2VudHMiLCJpZ25vcmVBY2NlbnRzIiwiX2NvbmZpZyRpZ25vcmVDYXNlIiwiaWdub3JlQ2FzZSIsImxpbWl0IiwiX2NvbmZpZyRtYXRjaEZyb20iLCJtYXRjaEZyb20iLCJfY29uZmlnJHRyaW0iLCJpbnB1dFZhbHVlIiwiZ2V0T3B0aW9uTGFiZWwiLCJpbnB1dCIsImZpbHRlcmVkT3B0aW9ucyIsIm9wdGlvbiIsImNhbmRpZGF0ZSIsImZpbmRJbmRleCIsImNvbXAiLCJkZWZhdWx0RmlsdGVyT3B0aW9ucyIsInBhZ2VTaXplIiwidXNlQXV0b2NvbXBsZXRlIiwiX3Byb3BzJGF1dG9Db21wbGV0ZSIsImF1dG9Db21wbGV0ZSIsIl9wcm9wcyRhdXRvSGlnaGxpZ2h0IiwiYXV0b0hpZ2hsaWdodCIsIl9wcm9wcyRhdXRvU2VsZWN0IiwiYXV0b1NlbGVjdCIsIl9wcm9wcyRibHVyT25TZWxlY3QiLCJibHVyT25TZWxlY3QiLCJfcHJvcHMkY2xlYXJPbkJsdXIiLCJjbGVhck9uQmx1ciIsImZyZWVTb2xvIiwiX3Byb3BzJGNsZWFyT25Fc2NhcGUiLCJjbGVhck9uRXNjYXBlIiwiX3Byb3BzJGNvbXBvbmVudE5hbWUiLCJfcHJvcHMkZGVidWciLCJkZWJ1ZyIsIl9wcm9wcyRkZWZhdWx0VmFsdWUiLCJfcHJvcHMkZGlzYWJsZUNsZWFyYWIiLCJkaXNhYmxlQ2xlYXJhYmxlIiwiX3Byb3BzJGRpc2FibGVDbG9zZU9uIiwiZGlzYWJsZUNsb3NlT25TZWxlY3QiLCJfcHJvcHMkZGlzYWJsZWRJdGVtc0YiLCJkaXNhYmxlZEl0ZW1zRm9jdXNhYmxlIiwiX3Byb3BzJGRpc2FibGVMaXN0V3JhIiwiZGlzYWJsZUxpc3RXcmFwIiwiX3Byb3BzJGZpbHRlck9wdGlvbnMiLCJmaWx0ZXJPcHRpb25zIiwiX3Byb3BzJGZpbHRlclNlbGVjdGVkIiwiZmlsdGVyU2VsZWN0ZWRPcHRpb25zIiwiX3Byb3BzJGZyZWVTb2xvIiwiZ2V0T3B0aW9uRGlzYWJsZWQiLCJfcHJvcHMkZ2V0T3B0aW9uTGFiZWwiLCJnZXRPcHRpb25MYWJlbFByb3AiLCJfcHJvcHMkZ2V0T3B0aW9uU2VsZWMiLCJnZXRPcHRpb25TZWxlY3RlZCIsImdyb3VwQnkiLCJfcHJvcHMkaGFuZGxlSG9tZUVuZEsiLCJoYW5kbGVIb21lRW5kS2V5cyIsImlkUHJvcCIsIl9wcm9wcyRpbmNsdWRlSW5wdXRJbiIsImluY2x1ZGVJbnB1dEluTGlzdCIsImlucHV0VmFsdWVQcm9wIiwiX3Byb3BzJG11bHRpcGxlIiwib25DaGFuZ2UiLCJvbkNsb3NlIiwib25IaWdobGlnaHRDaGFuZ2UiLCJvbklucHV0Q2hhbmdlIiwib25PcGVuIiwib3BlblByb3AiLCJfcHJvcHMkb3Blbk9uRm9jdXMiLCJvcGVuT25Gb2N1cyIsIl9wcm9wcyRzZWxlY3RPbkZvY3VzIiwic2VsZWN0T25Gb2N1cyIsInZhbHVlUHJvcCIsIm9wdGlvbkxhYmVsIiwiZXJyb25lb3VzUmV0dXJuIiwiaWdub3JlRm9jdXMiLCJmaXJzdEZvY3VzIiwiaW5wdXRSZWYiLCJsaXN0Ym94UmVmIiwic2V0QW5jaG9yRWwiLCJmb2N1c2VkVGFnIiwic2V0Rm9jdXNlZFRhZyIsImRlZmF1bHRIaWdobGlnaHRlZCIsImhpZ2hsaWdodGVkSW5kZXhSZWYiLCJfdXNlQ29udHJvbGxlZCIsIl91c2VDb250cm9sbGVkMiIsIl91c2VDb250cm9sbGVkMyIsIl91c2VDb250cm9sbGVkNCIsInNldElucHV0VmFsdWUiLCJfUmVhY3QkdXNlU3RhdGUzIiwiZm9jdXNlZCIsInNldEZvY3VzZWQiLCJyZXNldElucHV0VmFsdWUiLCJuZXdJbnB1dFZhbHVlIiwiX3VzZUNvbnRyb2xsZWQ1IiwiX3VzZUNvbnRyb2xsZWQ2Iiwic2V0T3BlblN0YXRlIiwiaW5wdXRWYWx1ZUlzU2VsZWN0ZWRWYWx1ZSIsInBvcHVwT3BlbiIsInZhbHVlMiIsIm1pc3NpbmdWYWx1ZSIsImZvY3VzVGFnIiwidGFnVG9Gb2N1cyIsInZhbGlkT3B0aW9uSW5kZXgiLCJuZXh0Rm9jdXMiLCJuZXh0Rm9jdXNEaXNhYmxlZCIsImhhc0F0dHJpYnV0ZSIsInNldEhpZ2hsaWdodGVkSW5kZXgiLCJfcmVmMiRyZWFzb24iLCJyZW1vdmVBdHRyaWJ1dGUiLCJsaXN0Ym94Tm9kZSIsInBhcmVudEVsZW1lbnQiLCJzY3JvbGxUb3AiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxCb3R0b20iLCJlbGVtZW50Qm90dG9tIiwib2Zmc2V0VG9wIiwib2Zmc2V0SGVpZ2h0IiwiY2hhbmdlSGlnaGxpZ2h0ZWRJbmRleCIsImRpZmYiLCJfcmVmMyRkaXJlY3Rpb24iLCJfcmVmMyRyZWFzb24iLCJnZXROZXh0SW5kZXgiLCJuZXdJbmRleCIsIm5leHRJbmRleCIsInNldFNlbGVjdGlvblJhbmdlIiwic3luY0hpZ2hsaWdodGVkSW5kZXgiLCJ2YWx1ZUl0ZW0iLCJjdXJyZW50T3B0aW9uIiwiaXRlbUluZGV4Iiwib3B0aW9uSXRlbSIsImhhbmRsZUxpc3Rib3hSZWYiLCJoYW5kbGVWYWx1ZSIsImRldGFpbHMiLCJzZWxlY3ROZXdWYWx1ZSIsInJlYXNvblByb3AiLCJvcmlnaW4iLCJ2YWxpZFRhZ0luZGV4IiwiaGFuZGxlRm9jdXNUYWciLCJuZXh0VGFnIiwiaGFuZGxlQ2xlYXIiLCJ3aGljaCIsImFjdGl2ZUVsZW1lbnQiLCJoYW5kbGVJbnB1dENoYW5nZSIsImhhbmRsZU9wdGlvbk1vdXNlT3ZlciIsImhhbmRsZU9wdGlvblRvdWNoU3RhcnQiLCJoYW5kbGVPcHRpb25DbGljayIsImhhbmRsZVRhZ0RlbGV0ZSIsImhhbmRsZVBvcHVwSW5kaWNhdG9yIiwiaGFuZGxlQ2xpY2siLCJzZWxlY3Rpb25FbmQiLCJzZWxlY3Rpb25TdGFydCIsInNlbGVjdCIsImhhbmRsZUlucHV0TW91c2VEb3duIiwiZGlydHkiLCJncm91cGVkT3B0aW9ucyIsImluZGV4QnkiLCJncm91cCIsImdldFJvb3RQcm9wcyIsImdldElucHV0TGFiZWxQcm9wcyIsImh0bWxGb3IiLCJnZXRJbnB1dFByb3BzIiwiYXV0b0NhcGl0YWxpemUiLCJzcGVsbENoZWNrIiwiZ2V0Q2xlYXJQcm9wcyIsImdldFBvcHVwSW5kaWNhdG9yUHJvcHMiLCJnZXRUYWdQcm9wcyIsImdldExpc3Rib3hQcm9wcyIsImdldE9wdGlvblByb3BzIiwiX3JlZjUiLCJvbk1vdXNlT3ZlciIsIl9vcHRpb24iLCJ2aXNpYmlsaXR5IiwiZnVsbFdpZHRoIiwidGFnIiwibWF4V2lkdGgiLCJ0YWdTaXplU21hbGwiLCJoYXNQb3B1cEljb24iLCJoYXNDbGVhckljb24iLCJpbnB1dFJvb3QiLCJmbGV4V3JhcCIsIm1pbldpZHRoIiwicGFkZGluZ0JvdHRvbSIsInBhZGRpbmdUb3AiLCJmbGV4R3JvdyIsImlucHV0Rm9jdXNlZCIsImVuZEFkb3JubWVudCIsImNsZWFySW5kaWNhdG9yIiwiY2xlYXJJbmRpY2F0b3JEaXJ0eSIsInBvcHVwSW5kaWNhdG9yIiwicG9wdXBJbmRpY2F0b3JPcGVuIiwicG9wcGVyRGlzYWJsZVBvcnRhbCIsImxpc3Rib3giLCJtYXhIZWlnaHQiLCJsb2FkaW5nIiwibm9PcHRpb25zIiwiZ3JvdXBMYWJlbCIsImdyb3VwVWwiLCJEaXNhYmxlUG9ydGFsIiwiQ2xvc2VJY29uIiwiQXJyb3dEcm9wRG93bkljb24iLCJBdXRvY29tcGxldGUiLCJDaGlwUHJvcHMiLCJfcHJvcHMkY2xlYXJUZXh0IiwiY2xlYXJUZXh0IiwiX3Byb3BzJGNsb3NlSWNvbiIsImNsb3NlSWNvbiIsIl9wcm9wcyRjbG9zZVRleHQiLCJjbG9zZVRleHQiLCJfcHJvcHMkZm9yY2VQb3B1cEljb24iLCJmb3JjZVBvcHVwSWNvbiIsIl9wcm9wcyRmdWxsV2lkdGgiLCJfcHJvcHMkZ2V0TGltaXRUYWdzVGUiLCJnZXRMaW1pdFRhZ3NUZXh0IiwiX3Byb3BzJGxpbWl0VGFncyIsImxpbWl0VGFncyIsIl9wcm9wcyRMaXN0Ym94Q29tcG9uZSIsIkxpc3Rib3hDb21wb25lbnQiLCJMaXN0Ym94UHJvcHMiLCJfcHJvcHMkbG9hZGluZyIsIl9wcm9wcyRsb2FkaW5nVGV4dCIsImxvYWRpbmdUZXh0IiwiX3Byb3BzJG5vT3B0aW9uc1RleHQiLCJub09wdGlvbnNUZXh0IiwiX3Byb3BzJG9wZW5UZXh0Iiwib3BlblRleHQiLCJfcHJvcHMkUGFwZXJDb21wb25lbnQiLCJQYXBlckNvbXBvbmVudCIsIl9wcm9wcyRQb3BwZXJDb21wb25lbiIsIlBvcHBlckNvbXBvbmVudCIsIlBvcHBlckNvbXBvbmVudFByb3AiLCJfcHJvcHMkcG9wdXBJY29uIiwicG9wdXBJY29uIiwicmVuZGVyR3JvdXBQcm9wIiwicmVuZGVyR3JvdXAiLCJyZW5kZXJJbnB1dCIsInJlbmRlck9wdGlvblByb3AiLCJyZW5kZXJPcHRpb24iLCJyZW5kZXJUYWdzIiwiX3VzZUF1dG9jb21wbGV0ZSIsInN0YXJ0QWRvcm5tZW50IiwiZ2V0Q3VzdG9taXplZFRhZ1Byb3BzIiwiZGVmYXVsdFJlbmRlckdyb3VwIiwicmVuZGVyTGlzdE9wdGlvbiIsIm9wdGlvblByb3BzIiwiSW5wdXRMYWJlbFByb3BzIiwiSW5wdXRQcm9wcyIsInRpdGxlIiwiaW5wdXRQcm9wcyIsIm9wdGlvbjIiLCJpbmRleDIiLCJmb3JtQ29udHJvbFN0YXRlIiwic3RhdGVzIiwibXVpRm9ybUNvbnRyb2wiLCJGb3JtQ29udHJvbENvbnRleHQiLCJ1c2VGb3JtQ29udHJvbCIsImdldFN0eWxlVmFsdWUiLCJjb21wdXRlZFN0eWxlIiwiVGV4dGFyZWFBdXRvc2l6ZSIsInJvd3MiLCJyb3dzTWF4Iiwicm93c01pblByb3AiLCJyb3dzTWluIiwibWF4Um93c1Byb3AiLCJtYXhSb3dzIiwiX3Byb3BzJG1pblJvd3MiLCJtaW5Sb3dzIiwibWluUm93c1Byb3AiLCJzaGFkb3dSZWYiLCJyZW5kZXJzIiwic3luY0hlaWdodCIsImlucHV0U2hhbGxvdyIsInBsYWNlaG9sZGVyIiwiaW5uZXJIZWlnaHQiLCJzaW5nbGVSb3dIZWlnaHQiLCJvdXRlckhlaWdodCIsIm91dGVySGVpZ2h0U3R5bGUiLCJoYW5kbGVSZXNpemUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlQ2hhbmdlIiwiaGFzVmFsdWUiLCJpc0ZpbGxlZCIsIlNTUiIsImlzQWRvcm5lZFN0YXJ0IiwicGxhY2Vob2xkZXJIaWRkZW4iLCJwbGFjZWhvbGRlclZpc2libGUiLCJmb3JtQ29udHJvbCIsImFkb3JuZWRTdGFydCIsImFkb3JuZWRFbmQiLCJtYXJnaW5EZW5zZSIsIm11bHRpbGluZSIsImZvbnQiLCJhbmltYXRpb25OYW1lIiwiaW5wdXRNYXJnaW5EZW5zZSIsImlucHV0TXVsdGlsaW5lIiwicmVzaXplIiwiaW5wdXRUeXBlU2VhcmNoIiwiaW5wdXRBZG9ybmVkU3RhcnQiLCJpbnB1dEFkb3JuZWRFbmQiLCJpbnB1dEhpZGRlbkxhYmVsIiwiSW5wdXRCYXNlIiwiYXJpYURlc2NyaWJlZGJ5IiwiYXV0b0ZvY3VzIiwiX3Byb3BzJGlucHV0Q29tcG9uZW50IiwiaW5wdXRDb21wb25lbnQiLCJfcHJvcHMkaW5wdXRQcm9wcyIsImlucHV0UHJvcHNQcm9wIiwiaW5wdXRSZWZQcm9wIiwiX3Byb3BzJG11bHRpbGluZSIsInJlbmRlclN1ZmZpeCIsImhhbmRsZUlucHV0UmVmV2FybmluZyIsIm5vZGVOYW1lIiwiaGFuZGxlSW5wdXRQcm9wc1JlZlByb3AiLCJoYW5kbGVJbnB1dFJlZlByb3AiLCJoYW5kbGVJbnB1dFJlZiIsInJlZ2lzdGVyRWZmZWN0IiwiZmNzIiwib25GaWxsZWQiLCJvbkVtcHR5IiwiY2hlY2tEaXJ0eSIsIklucHV0Q29tcG9uZW50IiwiaGFuZGxlQXV0b0ZpbGwiLCJzZXRBZG9ybmVkU3RhcnQiLCJvbkFuaW1hdGlvblN0YXJ0IiwicmVxdWlyZWQiLCJoaWRkZW5MYWJlbCIsImJvdHRvbUxpbmVDb2xvciIsIm1hcmdpblRvcCIsImJvcmRlckJvdHRvbUNvbG9yIiwidW5kZXJsaW5lIiwiYm9yZGVyQm90dG9tIiwiY29udGVudCIsImJvcmRlckJvdHRvbVN0eWxlIiwiSW5wdXQiLCJkaXNhYmxlVW5kZXJsaW5lIiwiYm9yZGVyVG9wTGVmdFJhZGl1cyIsImJvcmRlclRvcFJpZ2h0UmFkaXVzIiwiV2Via2l0Qm94U2hhZG93IiwiV2Via2l0VGV4dEZpbGxDb2xvciIsImNhcmV0Q29sb3IiLCJGaWxsZWRJbnB1dCIsImJvcmRlcldpZHRoIiwibGVnZW5kIiwibGVnZW5kTGFiZWxsZWQiLCJsZWdlbmROb3RjaGVkIiwiTm90Y2hlZE91dGxpbmUiLCJsYWJlbFdpZHRoUHJvcCIsImxhYmVsV2lkdGgiLCJub3RjaGVkIiwiYWxpZ24iLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsImJvcmRlckNvbG9yIiwibm90Y2hlZE91dGxpbmUiLCJPdXRsaW5lZElucHV0IiwiX3Byb3BzJGxhYmVsV2lkdGgiLCJmaWxsZWQiLCJhc3RlcmlzayIsIkZvcm1MYWJlbCIsInRyYW5zZm9ybU9yaWdpbiIsInNocmluayIsImFuaW1hdGVkIiwiSW5wdXRMYWJlbCIsIl9wcm9wcyRkaXNhYmxlQW5pbWF0aSIsImRpc2FibGVBbmltYXRpb24iLCJzaHJpbmtQcm9wIiwiZmxleERpcmVjdGlvbiIsIm1hcmdpbk5vcm1hbCIsIm1hcmdpbkJvdHRvbSIsIkZvcm1Db250cm9sIiwiX3Byb3BzJGVycm9yIiwidmlzdWFsbHlGb2N1c2VkIiwiX3Byb3BzJGhpZGRlbkxhYmVsIiwiX3Byb3BzJG1hcmdpbiIsIl9wcm9wcyRyZXF1aXJlZCIsImluaXRpYWxBZG9ybmVkU3RhcnQiLCJpbml0aWFsRmlsbGVkIiwic2V0RmlsbGVkIiwiX2ZvY3VzZWQiLCJyZWdpc3RlcmVkSW5wdXQiLCJjaGlsZENvbnRleHQiLCJjb250YWluZWQiLCJGb3JtSGVscGVyVGV4dCIsImdldFNjcm9sbGJhclNpemUiLCJzY3JvbGxEaXYiLCJzY3JvbGxiYXJTaXplIiwib2Zmc2V0V2lkdGgiLCJpc092ZXJmbG93aW5nIiwiaW5uZXJXaWR0aCIsImFyaWFIaWRkZW4iLCJzaG93IiwiZ2V0UGFkZGluZ1JpZ2h0IiwiYXJpYUhpZGRlblNpYmxpbmdzIiwiY3VycmVudE5vZGUiLCJub2Rlc1RvRXhjbHVkZSIsImJsYWNrbGlzdFRhZ05hbWVzIiwiZmluZEluZGV4T2YiLCJjb250YWluZXJJbmZvIiwiaWR4IiwiaGFuZGxlQ29udGFpbmVyIiwicmVzdG9yZVN0eWxlIiwicmVzdG9yZVBhZGRpbmdzIiwiZml4ZWROb2RlcyIsImRpc2FibGVTY3JvbGxMb2NrIiwicXVlcnlTZWxlY3RvckFsbCIsInNjcm9sbENvbnRhaW5lciIsInJlc3RvcmUiLCJnZXRIaWRkZW5TaWJsaW5ncyIsImhpZGRlblNpYmxpbmdzIiwiTW9kYWxNYW5hZ2VyIiwibW9kYWxzIiwiY29udGFpbmVycyIsIm1vZGFsSW5kZXgiLCJtb2RhbFJlZiIsImhpZGRlblNpYmxpbmdOb2RlcyIsImNvbnRhaW5lckluZGV4IiwibW91bnQiLCJuZXh0VG9wIiwiaXNUb3BNb2RhbCIsIlVuc3RhYmxlX1RyYXBGb2N1cyIsIl9wcm9wcyRkaXNhYmxlQXV0b0ZvYyIsImRpc2FibGVBdXRvRm9jdXMiLCJfcHJvcHMkZGlzYWJsZUVuZm9yY2UiLCJkaXNhYmxlRW5mb3JjZUZvY3VzIiwiX3Byb3BzJGRpc2FibGVSZXN0b3JlIiwiZGlzYWJsZVJlc3RvcmVGb2N1cyIsImdldERvYyIsImlzRW5hYmxlZCIsImlnbm9yZU5leHRFbmZvcmNlRm9jdXMiLCJzZW50aW5lbFN0YXJ0Iiwic2VudGluZWxFbmQiLCJub2RlVG9SZXN0b3JlIiwicm9vdFJlZiIsInByZXZPcGVuUmVmIiwiY29udGFpbnMiLCJjb250YWluIiwicm9vdEVsZW1lbnQiLCJoYXNGb2N1cyIsImxvb3BGb2N1cyIsImtleUNvZGUiLCJzaGlmdEtleSIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiaW52aXNpYmxlIiwiU2ltcGxlQmFja2Ryb3AiLCJfcHJvcHMkaW52aXNpYmxlIiwiZ2V0SGFzVHJhbnNpdGlvbiIsImRlZmF1bHRNYW5hZ2VyIiwiaGlkZGVuIiwiTW9kYWwiLCJpblByb3BzIiwiX3Byb3BzJEJhY2tkcm9wQ29tcG9uIiwiQmFja2Ryb3BDb21wb25lbnQiLCJCYWNrZHJvcFByb3BzIiwiX3Byb3BzJGNsb3NlQWZ0ZXJUcmFuIiwiY2xvc2VBZnRlclRyYW5zaXRpb24iLCJfcHJvcHMkZGlzYWJsZUJhY2tkcm8iLCJkaXNhYmxlQmFja2Ryb3BDbGljayIsIl9wcm9wcyRkaXNhYmxlRXNjYXBlSyIsImRpc2FibGVFc2NhcGVLZXlEb3duIiwiX3Byb3BzJGRpc2FibGVTY3JvbGxMIiwiX3Byb3BzJGhpZGVCYWNrZHJvcCIsImhpZGVCYWNrZHJvcCIsIl9wcm9wcyRtYW5hZ2VyIiwibWFuYWdlciIsIm9uQmFja2Ryb3BDbGljayIsIm9uRXNjYXBlS2V5RG93biIsIm1vdW50Tm9kZVJlZiIsImhhc1RyYW5zaXRpb24iLCJnZXRNb2RhbCIsImhhbmRsZU1vdW50ZWQiLCJyZXNvbHZlZENvbnRhaW5lciIsImhhbmRsZVBvcnRhbFJlZiIsImhhbmRsZUJhY2tkcm9wQ2xpY2siLCJpbmxpbmVTdHlsZSIsIlRyYXBGb2N1cyIsInJlZmxvdyIsImdldFRyYW5zaXRpb25Qcm9wcyIsIl9wcm9wcyRzdHlsZSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIm1vZGUiLCJ0cmFuc2l0aW9uRGVsYXkiLCJnZXRTY2FsZSIsImVudGVyaW5nIiwiZW50ZXJlZCIsIkdyb3ciLCJfcHJvcHMkZGlzYWJsZVN0cmljdE0iLCJkaXNhYmxlU3RyaWN0TW9kZUNvbXBhdCIsIl9wcm9wcyR0aW1lb3V0IiwiX3Byb3BzJFRyYW5zaXRpb25Db21wIiwiVHJhbnNpdGlvbkNvbXBvbmVudCIsInRpbWVyIiwiYXV0b1RpbWVvdXQiLCJlbmFibGVTdHJpY3RNb2RlQ29tcGF0IiwidW5zdGFibGVfc3RyaWN0TW9kZSIsImZvcmVpZ25SZWYiLCJub3JtYWxpemVkVHJhbnNpdGlvbkNhbGxiYWNrIiwibm9kZU9yQXBwZWFyaW5nIiwiaXNBcHBlYXJpbmciLCJoYW5kbGVFbnRlcmluZyIsIl9nZXRUcmFuc2l0aW9uUHJvcHMiLCJoYW5kbGVFbnRlcmVkIiwiaGFuZGxlRXhpdGluZyIsImhhbmRsZUV4aXQiLCJfZ2V0VHJhbnNpdGlvblByb3BzMiIsIm5vZGVPck5leHQiLCJtYXliZU5leHQiLCJtdWlTdXBwb3J0QXV0byIsImdldE9mZnNldFRvcCIsInZlcnRpY2FsIiwib2Zmc2V0IiwiZ2V0T2Zmc2V0TGVmdCIsImhvcml6b250YWwiLCJnZXRUcmFuc2Zvcm1PcmlnaW5WYWx1ZSIsImdldFNjcm9sbFBhcmVudCIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsIlBvcG92ZXIiLCJfcHJvcHMkYW5jaG9yT3JpZ2luIiwiYW5jaG9yT3JpZ2luIiwiYW5jaG9yUG9zaXRpb24iLCJfcHJvcHMkYW5jaG9yUmVmZXJlbmMiLCJhbmNob3JSZWZlcmVuY2UiLCJjb250YWluZXJQcm9wIiwiZ2V0Q29udGVudEFuY2hvckVsIiwiX3Byb3BzJG1hcmdpblRocmVzaG9sIiwibWFyZ2luVGhyZXNob2xkIiwiX3Byb3BzJFBhcGVyUHJvcHMiLCJQYXBlclByb3BzIiwiX3Byb3BzJHRyYW5zZm9ybU9yaWdpIiwiX3Byb3BzJHRyYW5zaXRpb25EdXJhIiwidHJhbnNpdGlvbkR1cmF0aW9uUHJvcCIsIl9wcm9wcyRUcmFuc2l0aW9uUHJvcCIsInBhcGVyUmVmIiwiZ2V0QW5jaG9yT2Zmc2V0IiwiY29udGVudEFuY2hvck9mZnNldCIsImFuY2hvckVsZW1lbnQiLCJhbmNob3JSZWN0IiwiYW5jaG9yVmVydGljYWwiLCJnZXRDb250ZW50QW5jaG9yT2Zmc2V0IiwiY29udGVudEFuY2hvckVsIiwiZ2V0VHJhbnNmb3JtT3JpZ2luIiwiZWxlbVJlY3QiLCJnZXRQb3NpdGlvbmluZ1N0eWxlIiwiZWxlbVRyYW5zZm9ybU9yaWdpbiIsImFuY2hvck9mZnNldCIsImNvbnRhaW5lcldpbmRvdyIsImhlaWdodFRocmVzaG9sZCIsIndpZHRoVGhyZXNob2xkIiwiX2RpZmYiLCJfZGlmZjIiLCJfZGlmZjMiLCJzZXRQb3NpdGlvbmluZ1N0eWxlcyIsInBvc2l0aW9uaW5nIiwiaGFuZGxlUGFwZXJSZWYiLCJ1cGRhdGVQb3NpdGlvbiIsIkxpc3RDb250ZXh0IiwiZGVuc2UiLCJzdWJoZWFkZXIiLCJMaXN0IiwiX3Byb3BzJGRlbnNlIiwiX3Byb3BzJGRpc2FibGVQYWRkaW5nIiwiZGlzYWJsZVBhZGRpbmciLCJuZXh0SXRlbSIsImxpc3QiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJwcmV2aW91c0l0ZW0iLCJsYXN0Q2hpbGQiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwidGV4dENyaXRlcmlhTWF0Y2hlcyIsInRleHRDcml0ZXJpYSIsImlubmVyVGV4dCIsInJlcGVhdGluZyIsIm1vdmVGb2N1cyIsImN1cnJlbnRGb2N1cyIsInRyYXZlcnNhbEZ1bmN0aW9uIiwid3JhcHBlZE9uY2UiLCJNZW51TGlzdCIsImFjdGlvbnMiLCJfcHJvcHMkYXV0b0ZvY3VzIiwiX3Byb3BzJGF1dG9Gb2N1c0l0ZW0iLCJhdXRvRm9jdXNJdGVtIiwibGlzdFJlZiIsInRleHRDcml0ZXJpYVJlZiIsInByZXZpb3VzS2V5TWF0Y2hlZCIsImxhc3RUaW1lIiwiYWRqdXN0U3R5bGVGb3JTY3JvbGxiYXIiLCJjb250YWluZXJFbGVtZW50Iiwibm9FeHBsaWNpdFdpZHRoIiwiY3JpdGVyaWEiLCJsb3dlcktleSIsImN1cnJUaW1lIiwicGVyZm9ybWFuY2UiLCJrZWVwRm9jdXNPbkN1cnJlbnQiLCJhY3RpdmVJdGVtSW5kZXgiLCJpdGVtcyIsIm5ld0NoaWxkUHJvcHMiLCJSVExfT1JJR0lOIiwiTFRSX09SSUdJTiIsIldlYmtpdE92ZXJmbG93U2Nyb2xsaW5nIiwiTWVudSIsImRpc2FibGVBdXRvRm9jdXNJdGVtIiwiX3Byb3BzJE1lbnVMaXN0UHJvcHMiLCJNZW51TGlzdFByb3BzIiwib25FbnRlcmluZ1Byb3AiLCJQb3BvdmVyQ2xhc3NlcyIsIm1lbnVMaXN0QWN0aW9uc1JlZiIsImNvbnRlbnRBbmNob3JSZWYiLCJoYW5kbGVMaXN0S2V5RG93biIsImFyZUVxdWFsVmFsdWVzIiwiYiIsIlNlbGVjdElucHV0IiwiYXJpYUxhYmVsIiwiYXV0b1dpZHRoIiwiZGlzcGxheUVtcHR5IiwiSWNvbkNvbXBvbmVudCIsImxhYmVsSWQiLCJfcHJvcHMkTWVudVByb3BzIiwiTWVudVByb3BzIiwicmVuZGVyVmFsdWUiLCJfcHJvcHMkU2VsZWN0RGlzcGxheVAiLCJTZWxlY3REaXNwbGF5UHJvcHMiLCJ0YWJJbmRleFByb3AiLCJkaXNwbGF5Tm9kZSIsInNldERpc3BsYXlOb2RlIiwiaXNPcGVuQ29udHJvbGxlZCIsIm1lbnVNaW5XaWR0aFN0YXRlIiwic2V0TWVudU1pbldpZHRoU3RhdGUiLCJvcGVuU3RhdGUiLCJnZXRFbGVtZW50QnlJZCIsImdldFNlbGVjdGlvbiIsImlzQ29sbGFwc2VkIiwiY2hpbGRyZW5BcnJheSIsImhhbmRsZUl0ZW1DbGljayIsInZhbGlkS2V5cyIsImRpc3BsYXlTaW5nbGUiLCJkaXNwbGF5TXVsdGlwbGUiLCJjb21wdXRlRGlzcGxheSIsImZvdW5kTWF0Y2giLCJ2IiwibWVudU1pbldpZHRoIiwiYnV0dG9uSWQiLCJzZWxlY3RNZW51IiwibmF0aXZlSW5wdXQiLCJpY29uT3BlbiIsIk5hdGl2ZVNlbGVjdElucHV0IiwiaWNvbkZpbGxlZCIsImljb25PdXRsaW5lZCIsImRlZmF1bHRJbnB1dCIsIk5hdGl2ZVNlbGVjdCIsIl9wcm9wcyRJY29uQ29tcG9uZW50IiwiX3Byb3BzJGlucHV0IiwibmF0aXZlU2VsZWN0U3R5bGVzIiwiU2VsZWN0IiwiX3Byb3BzJGF1dG9XaWR0aCIsIl9wcm9wcyRkaXNwbGF5RW1wdHkiLCJfcHJvcHMkbmF0aXZlIiwibmF0aXZlIiwidmFyaWFudFByb3BzIiwidmFyaWFudENvbXBvbmVudCIsIlRleHRGaWVsZCIsIkZvcm1IZWxwZXJUZXh0UHJvcHMiLCJoZWxwZXJUZXh0IiwiX3Byb3BzJHNlbGVjdCIsIlNlbGVjdFByb3BzIiwiSW5wdXRNb3JlIiwiX0lucHV0TGFiZWxQcm9wcyRyZXF1IiwiZGlzcGxheVJlcXVpcmVkIiwiaGVscGVyVGV4dElkIiwiaW5wdXRMYWJlbElkIiwiSW5wdXRFbGVtZW50IiwiY2hlY2tlZCIsIlN3aXRjaEJhc2UiLCJjaGVja2VkUHJvcCIsImNoZWNrZWRJY29uIiwiZGVmYXVsdENoZWNrZWQiLCJkaXNhYmxlZFByb3AiLCJzZXRDaGVja2VkU3RhdGUiLCJuZXdDaGVja2VkIiwiaGFzTGFiZWxGb3IiLCJpbmRldGVybWluYXRlIiwiZGVmYXVsdENoZWNrZWRJY29uIiwiQ2hlY2tCb3hJY29uIiwiZGVmYXVsdEljb24iLCJDaGVja0JveE91dGxpbmVCbGFua0ljb24iLCJkZWZhdWx0SW5kZXRlcm1pbmF0ZUljb24iLCJJbmRldGVybWluYXRlQ2hlY2tCb3hJY29uIiwiQ2hlY2tib3giLCJfcHJvcHMkY2hlY2tlZEljb24iLCJfcHJvcHMkaWNvbiIsIl9wcm9wcyRpbmRldGVybWluYXRlIiwiX3Byb3BzJGluZGV0ZXJtaW5hdGVJIiwiaW5kZXRlcm1pbmF0ZUljb24iLCJpbmRldGVybWluYXRlSWNvblByb3AiLCJBdXRvY29tcGxldGVVSSIsInNob3dDaGVja2JveGVzIiwiQXV0b2NvbXBsZXRlTXVsdGlzZWxlY3QiLCJzZWFyY2hBZnRlclhDaGFycyIsInNob3dUb0Zld0NoYXJzVGV4dCIsInRpbWVTdGFtcCIsImxhdGVzdElucHV0Q2hhbmdlIiwic2VhcmNoVmFsdWUiLCJvbklucHV0Q2hhbmdlQWN0aW9uIiwiY2FuRXhlY3V0ZSIsImV4ZWN1dGUiLCJvbklucHV0Q2hhbmdlRGVsYXkiLCJ1cGRhdGVEYXRlIiwiYXV0b0NvbXBsZXRlS2V5IiwiY2hhbmdlVmFsdWVzIiwib25PcGVuRHJvcGRvd24iLCJvcGVuRHJvcGRvd24iLCJpbnB1dENoYW5nZSIsIm9wdGlvbnNTZWxlY3RlZCIsImluaXRpYWxpemVkIiwicmVmcmVzaERhdGEiLCJyZWZyZXNoU3RhdGUiLCJyZWZyZXNoQXR0cmlidXRlIiwiSlNPTkF0dHJpYnV0ZSIsImRhdGFQYXJzZWQiLCJwYXJzZSIsIm9wdGlvbnNTZWxlY3RlZE5vdEluTGlzdCIsInNlbGVjdGVkT3B0aW9uIiwiZmluZCIsInJlc3BvbnNlQXR0cmlidXRlIiwiZGF0YVNvdXJjZU9wdGlvbnMiLCJ3YXJuaW5nR2l2ZW4iLCJtdWx0aVNlbGVjdCIsImRlZmF1bHRTZWxlY3RlZFN0cmluZyIsIm9wdGlvblRpdGxlIiwidGl0bGVBdHRyIiwia2V5QXR0ciIsImRlZmF1bHRTZWxlY3RlZFN0cmluZ0F0dHIiLCJpc0l0ZW1EZWZhdWx0U2VsZWN0ZWQiLCJkZWZhdWx0U2VsZWN0ZWRBdHRyIiwib25DaGFuZ2VBY3Rpb24iLCJzZXRMb2FkaW5nIiwib25PcGVuQWN0aW9uIiwiZWRpdGFibGUiLCJzZWFyY2hBZnRlclhDaGFyc1RleHQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsU0FBU0EsV0FBVCxDQUFxQkMsR0FBckIsRUFBMEJDLEdBQTFCLEVBQStCO0FBQzdCLE1BQUtBLEdBQUcsS0FBSyxLQUFLLENBQWxCLEVBQXNCQSxHQUFHLEdBQUcsRUFBTjtBQUN0QixNQUFJQyxRQUFRLEdBQUdELEdBQUcsQ0FBQ0MsUUFBbkI7O0FBRUEsTUFBSSxDQUFDRixHQUFELElBQVEsT0FBT0csUUFBUCxLQUFvQixXQUFoQyxFQUE2QztBQUFFO0FBQVM7O0FBRXhELE1BQUlDLElBQUksR0FBR0QsUUFBUSxDQUFDQyxJQUFULElBQWlCRCxRQUFRLENBQUNFLG9CQUFULENBQThCLE1BQTlCLEVBQXNDLENBQXRDLENBQTVCO0FBQ0Es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TUFBZjs7QUNoQkEsSUFBSUMsSUFBSSxHQUFHO0FBQ1QsTUFBSSxTQURLO0FBRVQsT0FBSyxTQUZJO0FBR1QsT0FBSyxTQUhJO0FBSVQsT0FBSyxTQUpJO0FBS1QsT0FBSyxTQUxJO0FBTVQsT0FBSyxTQU5JO0FBT1QsT0FBSyxTQVBJO0FBUVQsT0FBSyxTQVJJO0FBU1QsT0FBSyxTQVRJO0FBVVQsT0FBSyxTQVZJO0FBV1RMLEVBQUFBLElBQUksRUFBRSxTQVhHO0FBWVRDLEVBQUFBLElBQUksRUFBRSxTQVpHO0FBYVRDLEVBQUFBLElBQUksRUFBRSxTQWJHO0FBY1RDLEVBQUFBLElBQUksRUFBRTtBQWRHLENBQVg7QUFnQkEsYUFBZUUsSUFBZjs7QUNoQkEsSUFBSUMsR0FBRyxHQUFHO0FBQ1IsTUFBSSxTQURJO0FBRVIsT0FBSyxTQUZHO0FBR1IsT0FBSyxTQUhHO0FBSVIsT0FBSyxTQUpHO0FBS1IsT0FBSyxTQUxHO0FBTVIsT0FBSyxTQU5HO0FBT1IsT0FBSyxTQVBHO0FBUVIsT0FBSyxTQVJHO0FBU1IsT0FBSyxTQVRHO0FBVVIsT0FBSyxTQVZHO0FBV1JOLEVBQUFBLElBQUksRUFBRSxTQVhFO0FBWVJDLEVBQUFBLElBQUksRUFBRSxTQVpFO0FBYVJDLEVBQUFBLElBQUksRUFBRSxTQWJFO0FBY1JDLEVBQUFBLElBQUksRUFBRTtBQWRFLENBQVY7QUFnQkEsWUFBZUcsR0FBZjs7QUNoQkEsSUFBSUMsTUFBTSxHQUFHO0FBQ1gsTUFBSSxTQURPO0FBRVgsT0FBSyxTQUZNO0FBR1gsT0FBSyxTQUhNO0FBSVgsT0FBSyxTQUpNO0FBS1gsT0FBSyxTQUxNO0FBTVgsT0FBSyxTQU5NO0FBT1gsT0FBSyxTQVBNO0FBUVgsT0FBSyxTQVJNO0FBU1gsT0FBSyxTQVRNO0FBVVgsT0FBSyxTQVZNO0FBV1hQLEVBQUFBLElBQUksRUFBRSxTQVhLO0FBWVhDLEVBQUFBLElBQUksRUFBRSxTQVpLO0FBYVhDLEVBQUFBLElBQUksRUFBRSxTQWJLO0FBY1hDLEVBQUFBLElBQUksRUFBRTtBQWRLLENBQWI7QUFn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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
