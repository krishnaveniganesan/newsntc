define(['react', 'react-dom'], (function (React, ReactDOM) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
  var React__namespace = /*#__PURE__*/_interopNamespace(React);
  var ReactDOM__namespace = /*#__PURE__*/_interopNamespace(ReactDOM);
  var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);

  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends$2() {
    _extends$2 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$2.apply(this, arguments);
  }

  function styleInject(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') {
      return;
    }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css_248z = ".MuiIconButton-label input[type=\"checkbox\"] {\n    cursor: pointer;\n    position: absolute !important;\n}\n\n.MuiAutocomplete-root {\n    width: 100%;\n}\n\n.MuiFormLabel-root.MuiInputLabel-root, .MuiFormControl-root .MuiInputBase-root{\n    font-size: 16px;\n}\n\n.MuiChip-root .MuiChip-label {\n    font-size: 12px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkF1dG9jb21wbGV0ZU11bHRpc2VsZWN0LmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtJQUNJLGVBQWU7SUFDZiw2QkFBNkI7QUFDakM7O0FBRUE7SUFDSSxXQUFXO0FBQ2Y7O0FBRUE7SUFDSSxlQUFlO0FBQ25COztBQUVBO0lBQ0ksZUFBZTtBQUNuQiIsImZpbGUiOiJBdXRvY29tcGxldGVNdWx0aXNlbGVjdC5jc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuTXVpSWNvbkJ1dHRvbi1sYWJlbCBpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0ge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGUgIWltcG9ydGFudDtcbn1cblxuLk11aUF1dG9jb21wbGV0ZS1yb290IHtcbiAgICB3aWR0aDogMTAwJTtcbn1cblxuLk11aUZvcm1MYWJlbC1yb290Lk11aUlucHV0TGFiZWwtcm9vdCwgLk11aUZvcm1Db250cm9sLXJvb3QgLk11aUlucHV0QmFzZS1yb290e1xuICAgIGZvbnQtc2l6ZTogMTZweDtcbn1cblxuLk11aUNoaXAtcm9vdCAuTXVpQ2hpcC1sYWJlbCB7XG4gICAgZm9udC1zaXplOiAxMnB4O1xufSJdfQ== */";
  styleInject(css_248z);

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends$1() {
    _extends$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$1.apply(this, arguments);
  }

  var propTypes = {exports: {}};

  var reactIs$1 = {exports: {}};

  var reactIs_development = {};

  /** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  {
    (function () {
      // nor polyfill, then a plain number is used for performance.

      var hasSymbol = typeof Symbol === 'function' && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
      var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
      var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
      // (unstable) APIs that have been removed. Can we remove the symbols?

      var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
      var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
      var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
      var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
      var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
      var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
      var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

      function isValidElementType(type) {
        return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
        type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
      }

      function typeOf(object) {
        if (typeof object === 'object' && object !== null) {
          var $$typeof = object.$$typeof;

          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;

              switch (type) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type;

                default:
                  var $$typeofType = type && type.$$typeof;

                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;

                    default:
                      return $$typeof;
                  }

              }

            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }

        return undefined;
      } // AsyncMode is deprecated along with isAsyncMode


      var AsyncMode = REACT_ASYNC_MODE_TYPE;
      var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

            console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
          }
        }
        return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
      }

      function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
      }

      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }

      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }

      function isElement(object) {
        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }

      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }

      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }

      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }

      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }

      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }

      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }

      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }

      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }

      reactIs_development.AsyncMode = AsyncMode;
      reactIs_development.ConcurrentMode = ConcurrentMode;
      reactIs_development.ContextConsumer = ContextConsumer;
      reactIs_development.ContextProvider = ContextProvider;
      reactIs_development.Element = Element;
      reactIs_development.ForwardRef = ForwardRef;
      reactIs_development.Fragment = Fragment;
      reactIs_development.Lazy = Lazy;
      reactIs_development.Memo = Memo;
      reactIs_development.Portal = Portal;
      reactIs_development.Profiler = Profiler;
      reactIs_development.StrictMode = StrictMode;
      reactIs_development.Suspense = Suspense;
      reactIs_development.isAsyncMode = isAsyncMode;
      reactIs_development.isConcurrentMode = isConcurrentMode;
      reactIs_development.isContextConsumer = isContextConsumer;
      reactIs_development.isContextProvider = isContextProvider;
      reactIs_development.isElement = isElement;
      reactIs_development.isForwardRef = isForwardRef;
      reactIs_development.isFragment = isFragment;
      reactIs_development.isLazy = isLazy;
      reactIs_development.isMemo = isMemo;
      reactIs_development.isPortal = isPortal;
      reactIs_development.isProfiler = isProfiler;
      reactIs_development.isStrictMode = isStrictMode;
      reactIs_development.isSuspense = isSuspense;
      reactIs_development.isValidElementType = isValidElementType;
      reactIs_development.typeOf = typeOf;
    })();
  }

  {
    reactIs$1.exports = reactIs_development;
  }

  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  /* eslint-disable no-unused-vars */

  var getOwnPropertySymbols$1 = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function toObject(val) {
    if (val === null || val === undefined) {
      throw new TypeError('Object.assign cannot be called with null or undefined');
    }

    return Object(val);
  }

  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      } // Detect buggy property enumeration order in older V8 versions.
      // https://bugs.chromium.org/p/v8/issues/detail?id=4118


      var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

      test1[5] = 'de';

      if (Object.getOwnPropertyNames(test1)[0] === '5') {
        return false;
      } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


      var test2 = {};

      for (var i = 0; i < 10; i++) {
        test2['_' + String.fromCharCode(i)] = i;
      }

      var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
        return test2[n];
      });

      if (order2.join('') !== '0123456789') {
        return false;
      } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


      var test3 = {};
      'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
        test3[letter] = letter;
      });

      if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
        return false;
      }

      return true;
    } catch (err) {
      // We don't expect any of the above to throw, but better to be safe.
      return false;
    }
  }

  var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
    var from;
    var to = toObject(target);
    var symbols;

    for (var s = 1; s < arguments.length; s++) {
      from = Object(arguments[s]);

      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }

      if (getOwnPropertySymbols$1) {
        symbols = getOwnPropertySymbols$1(from);

        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }

    return to;
  };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var ReactPropTypesSecret$2 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
  var ReactPropTypesSecret_1 = ReactPropTypesSecret$2;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var printWarning$1 = function () {};

  {
    var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;

    var loggedTypeFailures = {};
    var has$1 = Function.call.bind(Object.prototype.hasOwnProperty);

    printWarning$1 = function (text) {
      var message = 'Warning: ' + text;

      if (typeof console !== 'undefined') {
        console.error(message);
      }

      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };
  }
  /**
   * Assert that the values match with the type specs.
   * Error messages are memorized and will only be shown once.
   *
   * @param {object} typeSpecs Map of name to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @param {string} componentName Name of the component for error messages.
   * @param {?Function} getStack Returns the component stack.
   * @private
   */


  function checkPropTypes$1(typeSpecs, values, location, componentName, getStack) {
    {
      for (var typeSpecName in typeSpecs) {
        if (has$1(typeSpecs, typeSpecName)) {
          var error; // Prop type validation may throw. In case they do, we don't want to
          // fail the render phase where it didn't fail before. So we log it.
          // After these have been cleaned up, we'll let them throw.

          try {
            // This is intentionally an invariant that gets caught. It's the same
            // behavior as without this statement except with a better message.
            if (typeof typeSpecs[typeSpecName] !== 'function') {
              var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.');
              err.name = 'Invariant Violation';
              throw err;
            }

            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
          } catch (ex) {
            error = ex;
          }

          if (error && !(error instanceof Error)) {
            printWarning$1((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
          }

          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            // Only monitor this failure once because there tends to be a lot of the
            // same error.
            loggedTypeFailures[error.message] = true;
            var stack = getStack ? getStack() : '';
            printWarning$1('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
          }
        }
      }
    }
  }
  /**
   * Resets warning cache when testing.
   *
   * @private
   */


  checkPropTypes$1.resetWarningCache = function () {
    {
      loggedTypeFailures = {};
    }
  };

  var checkPropTypes_1 = checkPropTypes$1;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var ReactIs$1 = reactIs$1.exports;

  var assign = objectAssign;

  var ReactPropTypesSecret = ReactPropTypesSecret_1;

  var checkPropTypes = checkPropTypes_1;

  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  var printWarning = function () {};

  {
    printWarning = function (text) {
      var message = 'Warning: ' + text;

      if (typeof console !== 'undefined') {
        console.error(message);
      }

      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };
  }

  function emptyFunctionThatReturnsNull() {
    return null;
  }

  var factoryWithTypeCheckers = function (isValidElement, throwOnDirectAccess) {
    /* global Symbol */
    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

    /**
     * Returns the iterator method function contained on the iterable object.
     *
     * Be sure to invoke the function with the iterable as context:
     *
     *     var iteratorFn = getIteratorFn(myIterable);
     *     if (iteratorFn) {
     *       var iterator = iteratorFn.call(myIterable);
     *       ...
     *     }
     *
     * @param {?object} maybeIterable
     * @return {?function}
     */

    function getIteratorFn(maybeIterable) {
      var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);

      if (typeof iteratorFn === 'function') {
        return iteratorFn;
      }
    }
    /**
     * Collection of methods that allow declaration and validation of props that are
     * supplied to React components. Example usage:
     *
     *   var Props = require('ReactPropTypes');
     *   var MyArticle = React.createClass({
     *     propTypes: {
     *       // An optional string prop named "description".
     *       description: Props.string,
     *
     *       // A required enum prop named "category".
     *       category: Props.oneOf(['News','Photos']).isRequired,
     *
     *       // A prop named "dialog" that requires an instance of Dialog.
     *       dialog: Props.instanceOf(Dialog).isRequired
     *     },
     *     render: function() { ... }
     *   });
     *
     * A more formal specification of how these methods are used:
     *
     *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
     *   decl := ReactPropTypes.{type}(.isRequired)?
     *
     * Each and every declaration produces a function with the same signature. This
     * allows the creation of custom validation functions. For example:
     *
     *  var MyLink = React.createClass({
     *    propTypes: {
     *      // An optional string or URI prop named "href".
     *      href: function(props, propName, componentName) {
     *        var propValue = props[propName];
     *        if (propValue != null && typeof propValue !== 'string' &&
     *            !(propValue instanceof URI)) {
     *          return new Error(
     *            'Expected a string or an URI for ' + propName + ' in ' +
     *            componentName
     *          );
     *        }
     *      }
     *    },
     *    render: function() {...}
     *  });
     *
     * @internal
     */


    var ANONYMOUS = '<<anonymous>>'; // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.

    var ReactPropTypes = {
      array: createPrimitiveTypeChecker('array'),
      bool: createPrimitiveTypeChecker('boolean'),
      func: createPrimitiveTypeChecker('function'),
      number: createPrimitiveTypeChecker('number'),
      object: createPrimitiveTypeChecker('object'),
      string: createPrimitiveTypeChecker('string'),
      symbol: createPrimitiveTypeChecker('symbol'),
      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      elementType: createElementTypeTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker
    };
    /**
     * inlined Object.is polyfill to avoid requiring consumers ship their own
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
     */

    /*eslint-disable no-self-compare*/

    function is(x, y) {
      // SameValue algorithm
      if (x === y) {
        // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
      } else {
        // Step 6.a: NaN == NaN
        return x !== x && y !== y;
      }
    }
    /*eslint-enable no-self-compare*/

    /**
     * We use an Error-like object for backward compatibility as people may call
     * PropTypes directly and inspect their output. However, we don't use real
     * Errors anymore. We don't inspect their stack anyway, and creating them
     * is prohibitively expensive if they are created too often, such as what
     * happens in oneOfType() for any type before the one that matched.
     */


    function PropTypeError(message) {
      this.message = message;
      this.stack = '';
    } // Make `instanceof Error` still work for returned errors.


    PropTypeError.prototype = Error.prototype;

    function createChainableTypeChecker(validate) {
      {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }

      function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;

        if (secret !== ReactPropTypesSecret) {
          if (throwOnDirectAccess) {
            // New behavior only for users of `prop-types` package
            var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
            err.name = 'Invariant Violation';
            throw err;
          } else if (typeof console !== 'undefined') {
            // Old behavior for people using React.PropTypes
            var cacheKey = componentName + ':' + propName;

            if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3) {
              printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }

        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
            }

            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
          }

          return null;
        } else {
          return validate(props, propName, componentName, location, propFullName);
        }
      }

      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);
      return chainedCheckType;
    }

    function createPrimitiveTypeChecker(expectedType) {
      function validate(props, propName, componentName, location, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== expectedType) {
          // `propValue` being instance of, say, date/regexp, pass the 'object'
          // check, but we can offer a more precise error message here rather than
          // 'of type `object`'.
          var preciseType = getPreciseType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }

    function createArrayOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
        }

        var propValue = props[propName];

        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
        }

        for (var i = 0; i < propValue.length; i++) {
          var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);

          if (error instanceof Error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createElementTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];

        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createElementTypeTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];

        if (!ReactIs$1.isValidElementType(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createInstanceTypeChecker(expectedClass) {
      function validate(props, propName, componentName, location, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        {
          if (arguments.length > 1) {
            printWarning('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' + 'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');
          } else {
            printWarning('Invalid argument supplied to oneOf, expected an array.');
          }
        }

        return emptyFunctionThatReturnsNull;
      }

      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];

        for (var i = 0; i < expectedValues.length; i++) {
          if (is(propValue, expectedValues[i])) {
            return null;
          }
        }

        var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
          var type = getPreciseType(value);

          if (type === 'symbol') {
            return String(value);
          }

          return value;
        });
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
      }

      return createChainableTypeChecker(validate);
    }

    function createObjectOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
        }

        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
        }

        for (var key in propValue) {
          if (has(propValue, key)) {
            var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

            if (error instanceof Error) {
              return error;
            }
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') ;
        return emptyFunctionThatReturnsNull;
      }

      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];

        if (typeof checker !== 'function') {
          printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
          return emptyFunctionThatReturnsNull;
        }
      }

      function validate(props, propName, componentName, location, propFullName) {
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];

          if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
            return null;
          }
        }

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
      }

      return createChainableTypeChecker(validate);
    }

    function createNodeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        if (!isNode(props[propName])) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }

        for (var key in shapeTypes) {
          var checker = shapeTypes[key];

          if (!checker) {
            continue;
          }

          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

          if (error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);

        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        } // We need to check all keys in case some are required but missing from
        // props.


        var allKeys = assign({}, props[propName], shapeTypes);

        for (var key in allKeys) {
          var checker = shapeTypes[key];

          if (!checker) {
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
          }

          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);

          if (error) {
            return error;
          }
        }

        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function isNode(propValue) {
      switch (typeof propValue) {
        case 'number':
        case 'string':
        case 'undefined':
          return true;

        case 'boolean':
          return !propValue;

        case 'object':
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }

          if (propValue === null || isValidElement(propValue)) {
            return true;
          }

          var iteratorFn = getIteratorFn(propValue);

          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;

            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              // Iterator will provide entry [k,v] tuples rather than values.
              while (!(step = iterator.next()).done) {
                var entry = step.value;

                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }

          return true;

        default:
          return false;
      }
    }

    function isSymbol(propType, propValue) {
      // Native Symbol.
      if (propType === 'symbol') {
        return true;
      } // falsy value can't be a Symbol


      if (!propValue) {
        return false;
      } // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'


      if (propValue['@@toStringTag'] === 'Symbol') {
        return true;
      } // Fallback for non-spec compliant Symbols which are polyfilled.


      if (typeof Symbol === 'function' && propValue instanceof Symbol) {
        return true;
      }

      return false;
    } // Equivalent of `typeof` but with special handling for array and regexp.


    function getPropType(propValue) {
      var propType = typeof propValue;

      if (Array.isArray(propValue)) {
        return 'array';
      }

      if (propValue instanceof RegExp) {
        // Old webkits (at least until Android 4.0) return 'function' rather than
        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
        // passes PropTypes.object.
        return 'object';
      }

      if (isSymbol(propType, propValue)) {
        return 'symbol';
      }

      return propType;
    } // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.


    function getPreciseType(propValue) {
      if (typeof propValue === 'undefined' || propValue === null) {
        return '' + propValue;
      }

      var propType = getPropType(propValue);

      if (propType === 'object') {
        if (propValue instanceof Date) {
          return 'date';
        } else if (propValue instanceof RegExp) {
          return 'regexp';
        }
      }

      return propType;
    } // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"


    function getPostfixForTypeWarning(value) {
      var type = getPreciseType(value);

      switch (type) {
        case 'array':
        case 'object':
          return 'an ' + type;

        case 'boolean':
        case 'date':
        case 'regexp':
          return 'a ' + type;

        default:
          return type;
      }
    } // Returns class name of the object, if any.


    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }

      return propValue.constructor.name;
    }

    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  {
    var ReactIs = reactIs$1.exports; // By explicitly using `prop-types` you are opting into new development behavior.
    // http://fb.me/prop-types-in-prod


    var throwOnDirectAccess = true;
    propTypes.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
  }

  var PropTypes = propTypes.exports;

  function toVal(mix) {
    var k,
        y,
        str = '';

    if (typeof mix === 'string' || typeof mix === 'number') {
      str += mix;
    } else if (typeof mix === 'object') {
      if (Array.isArray(mix)) {
        for (k = 0; k < mix.length; k++) {
          if (mix[k]) {
            if (y = toVal(mix[k])) {
              str && (str += ' ');
              str += y;
            }
          }
        }
      } else {
        for (k in mix) {
          if (mix[k]) {
            str && (str += ' ');
            str += k;
          }
        }
      }
    }

    return str;
  }

  function clsx () {
    var i = 0,
        tmp,
        x,
        str = '';

    while (i < arguments.length) {
      if (tmp = arguments[i++]) {
        if (x = toVal(tmp)) {
          str && (str += ' ');
          str += x;
        }
      }
    }

    return str;
  }

  function chainPropTypes(propType1, propType2) {

    return function validate() {
      return propType1.apply(void 0, arguments) || propType2.apply(void 0, arguments);
    };
  }

  function _typeof$1(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$1 = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof$1 = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$1(obj);
  }

  function isPlainObject(item) {
    return item && _typeof$1(item) === 'object' && item.constructor === Object;
  }
  function deepmerge(target, source) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      clone: true
    };
    var output = options.clone ? _extends$1({}, target) : target;

    if (isPlainObject(target) && isPlainObject(source)) {
      Object.keys(source).forEach(function (key) {
        // Avoid prototype pollution
        if (key === '__proto__') {
          return;
        }

        if (isPlainObject(source[key]) && key in target) {
          output[key] = deepmerge(target[key], source[key], options);
        } else {
          output[key] = source[key];
        }
      });
    }

    return output;
  }

  function isClassComponent$1(elementType) {
    // elementType.prototype?.isReactComponent
    var _elementType$prototyp = elementType.prototype,
        prototype = _elementType$prototyp === void 0 ? {} : _elementType$prototyp;
    return Boolean(prototype.isReactComponent);
  }

  function acceptingRef(props, propName, componentName, location, propFullName) {
    var element = props[propName];
    var safePropName = propFullName || propName;

    if (element == null) {
      return null;
    }

    var warningHint;
    var elementType = element.type;
    /**
     * Blacklisting instead of whitelisting
     *
     * Blacklisting will miss some components, such as React.Fragment. Those will at least
     * trigger a warning in React.
     * We can't whitelist because there is no safe way to detect React.forwardRef
     * or class components. "Safe" means there's no public API.
     *
     */

    if (typeof elementType === 'function' && !isClassComponent$1(elementType)) {
      warningHint = 'Did you accidentally use a plain function component for an element instead?';
    }

    if (warningHint !== undefined) {
      return new Error("Invalid ".concat(location, " `").concat(safePropName, "` supplied to `").concat(componentName, "`. ") + "Expected an element that can hold a ref. ".concat(warningHint, " ") + 'For more information see https://material-ui.com/r/caveat-with-refs-guide');
    }

    return null;
  }

  var elementAcceptingRef = chainPropTypes(PropTypes.element, acceptingRef);
  elementAcceptingRef.isRequired = chainPropTypes(PropTypes.element.isRequired, acceptingRef);
  var elementAcceptingRef$1 = elementAcceptingRef;

  function isClassComponent(elementType) {
    // elementType.prototype?.isReactComponent
    var _elementType$prototyp = elementType.prototype,
        prototype = _elementType$prototyp === void 0 ? {} : _elementType$prototyp;
    return Boolean(prototype.isReactComponent);
  }

  function elementTypeAcceptingRef(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var safePropName = propFullName || propName;

    if (propValue == null) {
      return null;
    }

    var warningHint;
    /**
     * Blacklisting instead of whitelisting
     *
     * Blacklisting will miss some components, such as React.Fragment. Those will at least
     * trigger a warning in React.
     * We can't whitelist because there is no safe way to detect React.forwardRef
     * or class components. "Safe" means there's no public API.
     *
     */

    if (typeof propValue === 'function' && !isClassComponent(propValue)) {
      warningHint = 'Did you accidentally provide a plain function component instead?';
    }

    if (warningHint !== undefined) {
      return new Error("Invalid ".concat(location, " `").concat(safePropName, "` supplied to `").concat(componentName, "`. ") + "Expected an element type that can hold a ref. ".concat(warningHint, " ") + 'For more information see https://material-ui.com/r/caveat-with-refs-guide');
    }

    return null;
  }

  var elementTypeAcceptingRef$1 = chainPropTypes(propTypes.exports.elementType, elementTypeAcceptingRef);

  // However, in order to reduce the number of dependencies and to remove some extra safe checks
  // the module was forked.
  // Only exported for test purposes.

  var specialProperty = "exact-prop: \u200B";
  function exactProp(propTypes) {

    return _extends$1({}, propTypes, _defineProperty({}, specialProperty, function (props) {
      var unsupportedProps = Object.keys(props).filter(function (prop) {
        return !propTypes.hasOwnProperty(prop);
      });

      if (unsupportedProps.length > 0) {
        return new Error("The following props are not supported: ".concat(unsupportedProps.map(function (prop) {
          return "`".concat(prop, "`");
        }).join(', '), ". Please remove them."));
      }

      return null;
    }));
  }

  // https://github.com/JamesMGreene/Function.name/blob/58b314d4a983110c3682f1228f845d39ccca1817/Function.name.js#L3

  var fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
  function getFunctionName(fn) {
    var match = "".concat(fn).match(fnNameMatchRegex);
    var name = match && match[1];
    return name || '';
  }
  /**
   * @param {function} Component
   * @param {string} fallback
   * @returns {string | undefined}
   */

  function getFunctionComponentName(Component) {
    var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    return Component.displayName || Component.name || getFunctionName(Component) || fallback;
  }

  function getWrappedName(outerType, innerType, wrapperName) {
    var functionName = getFunctionComponentName(innerType);
    return outerType.displayName || (functionName !== '' ? "".concat(wrapperName, "(").concat(functionName, ")") : wrapperName);
  }
  /**
   * cherry-pick from
   * https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/getComponentName.js
   * originally forked from recompose/getDisplayName with added IE 11 support
   *
   * @param {React.ReactType} Component
   * @returns {string | undefined}
   */


  function getDisplayName(Component) {
    if (Component == null) {
      return undefined;
    }

    if (typeof Component === 'string') {
      return Component;
    }

    if (typeof Component === 'function') {
      return getFunctionComponentName(Component, 'Component');
    }

    if (_typeof$1(Component) === 'object') {
      switch (Component.$$typeof) {
        case reactIs$1.exports.ForwardRef:
          return getWrappedName(Component, Component.render, 'ForwardRef');

        case reactIs$1.exports.Memo:
          return getWrappedName(Component, Component.type, 'memo');

        default:
          return undefined;
      }
    }

    return undefined;
  }

  function HTMLElementType(props, propName, componentName, location, propFullName) {

    var propValue = props[propName];
    var safePropName = propFullName || propName;

    if (propValue == null) {
      return null;
    }

    if (propValue && propValue.nodeType !== 1) {
      return new Error("Invalid ".concat(location, " `").concat(safePropName, "` supplied to `").concat(componentName, "`. ") + "Expected an HTMLElement.");
    }

    return null;
  }

  var refType = PropTypes.oneOfType([PropTypes.func, PropTypes.object]);
  var refType$1 = refType;

  /* eslint-disable no-use-before-define */

  /**
   * Returns a number whose value is limited to the given range.
   *
   * @param {number} value The value to be clamped
   * @param {number} min The lower boundary of the output range
   * @param {number} max The upper boundary of the output range
   * @returns {number} A number in the range [min, max]
   */

  function clamp(value) {
    var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    {
      if (value < min || value > max) {
        console.error("Material-UI: The value provided ".concat(value, " is out of range [").concat(min, ", ").concat(max, "]."));
      }
    }

    return Math.min(Math.max(min, value), max);
  }
  /**
   * Converts a color from CSS hex format to CSS rgb format.
   *
   * @param {string} color - Hex color, i.e. #nnn or #nnnnnn
   * @returns {string} A CSS rgb color string
   */


  function hexToRgb(color) {
    color = color.substr(1);
    var re = new RegExp(".{1,".concat(color.length >= 6 ? 2 : 1, "}"), 'g');
    var colors = color.match(re);

    if (colors && colors[0].length === 1) {
      colors = colors.map(function (n) {
        return n + n;
      });
    }

    return colors ? "rgb".concat(colors.length === 4 ? 'a' : '', "(").concat(colors.map(function (n, index) {
      return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1000) / 1000;
    }).join(', '), ")") : '';
  }
  /**
   * Converts a color from hsl format to rgb format.
   *
   * @param {string} color - HSL color values
   * @returns {string} rgb color values
   */

  function hslToRgb(color) {
    color = decomposeColor(color);
    var _color = color,
        values = _color.values;
    var h = values[0];
    var s = values[1] / 100;
    var l = values[2] / 100;
    var a = s * Math.min(l, 1 - l);

    var f = function f(n) {
      var k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n + h / 30) % 12;
      return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    };

    var type = 'rgb';
    var rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];

    if (color.type === 'hsla') {
      type += 'a';
      rgb.push(values[3]);
    }

    return recomposeColor({
      type: type,
      values: rgb
    });
  }
  /**
   * Returns an object with the type and values of a color.
   *
   * Note: Does not support rgb % values.
   *
   * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @returns {object} - A MUI color object: {type: string, values: number[]}
   */

  function decomposeColor(color) {
    // Idempotent
    if (color.type) {
      return color;
    }

    if (color.charAt(0) === '#') {
      return decomposeColor(hexToRgb(color));
    }

    var marker = color.indexOf('(');
    var type = color.substring(0, marker);

    if (['rgb', 'rgba', 'hsl', 'hsla'].indexOf(type) === -1) {
      throw new Error("Material-UI: Unsupported `".concat(color, "` color.\nWe support the following formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla().") );
    }

    var values = color.substring(marker + 1, color.length - 1).split(',');
    values = values.map(function (value) {
      return parseFloat(value);
    });
    return {
      type: type,
      values: values
    };
  }
  /**
   * Converts a color object with type and values to a string.
   *
   * @param {object} color - Decomposed color
   * @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla'
   * @param {array} color.values - [n,n,n] or [n,n,n,n]
   * @returns {string} A CSS color string
   */

  function recomposeColor(color) {
    var type = color.type;
    var values = color.values;

    if (type.indexOf('rgb') !== -1) {
      // Only convert the first 3 values to int (i.e. not alpha)
      values = values.map(function (n, i) {
        return i < 3 ? parseInt(n, 10) : n;
      });
    } else if (type.indexOf('hsl') !== -1) {
      values[1] = "".concat(values[1], "%");
      values[2] = "".concat(values[2], "%");
    }

    return "".concat(type, "(").concat(values.join(', '), ")");
  }
  /**
   * Calculates the contrast ratio between two colors.
   *
   * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
   *
   * @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @returns {number} A contrast ratio value in the range 0 - 21.
   */

  function getContrastRatio(foreground, background) {
    var lumA = getLuminance(foreground);
    var lumB = getLuminance(background);
    return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
  }
  /**
   * The relative brightness of any point in a color space,
   * normalized to 0 for darkest black and 1 for lightest white.
   *
   * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
   *
   * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @returns {number} The relative brightness of the color in the range 0 - 1
   */

  function getLuminance(color) {
    color = decomposeColor(color);
    var rgb = color.type === 'hsl' ? decomposeColor(hslToRgb(color)).values : color.values;
    rgb = rgb.map(function (val) {
      val /= 255; // normalized

      return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
    }); // Truncate at 3 digits

    return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
  }
  /**
   * Darken or lighten a color, depending on its luminance.
   * Light colors are darkened, dark colors are lightened.
   *
   * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @param {number} coefficient=0.15 - multiplier in the range 0 - 1
   * @returns {string} A CSS color string. Hex input values are returned as rgb
   */

  function emphasize(color) {
    var coefficient = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.15;
    return getLuminance(color) > 0.5 ? darken(color, coefficient) : lighten(color, coefficient);
  }
  /**
   * Set the absolute transparency of a color.
   * Any existing alpha value is overwritten.
   *
   * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @param {number} value - value to set the alpha channel to in the range 0-1
   * @returns {string} A CSS color string. Hex input values are returned as rgb
   */

  function alpha(color, value) {
    color = decomposeColor(color);
    value = clamp(value);

    if (color.type === 'rgb' || color.type === 'hsl') {
      color.type += 'a';
    }

    color.values[3] = value;
    return recomposeColor(color);
  }
  /**
   * Darkens a color.
   *
   * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @param {number} coefficient - multiplier in the range 0 - 1
   * @returns {string} A CSS color string. Hex input values are returned as rgb
   */

  function darken(color, coefficient) {
    color = decomposeColor(color);
    coefficient = clamp(coefficient);

    if (color.type.indexOf('hsl') !== -1) {
      color.values[2] *= 1 - coefficient;
    } else if (color.type.indexOf('rgb') !== -1) {
      for (var i = 0; i < 3; i += 1) {
        color.values[i] *= 1 - coefficient;
      }
    }

    return recomposeColor(color);
  }
  /**
   * Lightens a color.
   *
   * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @param {number} coefficient - multiplier in the range 0 - 1
   * @returns {string} A CSS color string. Hex input values are returned as rgb
   */

  function lighten(color, coefficient) {
    color = decomposeColor(color);
    coefficient = clamp(coefficient);

    if (color.type.indexOf('hsl') !== -1) {
      color.values[2] += (100 - color.values[2]) * coefficient;
    } else if (color.type.indexOf('rgb') !== -1) {
      for (var i = 0; i < 3; i += 1) {
        color.values[i] += (255 - color.values[i]) * coefficient;
      }
    }

    return recomposeColor(color);
  }

  // It can't be configured as it's used statically for propTypes.

  var keys = ['xs', 'sm', 'md', 'lg', 'xl']; // Keep in mind that @media is inclusive by the CSS specification.

  function createBreakpoints(breakpoints) {
    var _breakpoints$values = breakpoints.values,
        values = _breakpoints$values === void 0 ? {
      xs: 0,
      sm: 600,
      md: 960,
      lg: 1280,
      xl: 1920
    } : _breakpoints$values,
        _breakpoints$unit = breakpoints.unit,
        unit = _breakpoints$unit === void 0 ? 'px' : _breakpoints$unit,
        _breakpoints$step = breakpoints.step,
        step = _breakpoints$step === void 0 ? 5 : _breakpoints$step,
        other = _objectWithoutProperties(breakpoints, ["values", "unit", "step"]);

    function up(key) {
      var value = typeof values[key] === 'number' ? values[key] : key;
      return "@media (min-width:".concat(value).concat(unit, ")");
    }

    function down(key) {
      var endIndex = keys.indexOf(key) + 1;
      var upperbound = values[keys[endIndex]];

      if (endIndex === keys.length) {
        // xl down applies to all sizes
        return up('xs');
      }

      var value = typeof upperbound === 'number' && endIndex > 0 ? upperbound : key;
      return "@media (max-width:".concat(value - step / 100).concat(unit, ")");
    }

    function between(start, end) {
      var endIndex = keys.indexOf(end);

      if (endIndex === keys.length - 1) {
        return up(start);
      }

      return "@media (min-width:".concat(typeof values[start] === 'number' ? values[start] : start).concat(unit, ") and ") + "(max-width:".concat((endIndex !== -1 && typeof values[keys[endIndex + 1]] === 'number' ? values[keys[endIndex + 1]] : end) - step / 100).concat(unit, ")");
    }

    function only(key) {
      return between(key, key);
    }

    var warnedOnce = false;

    function width(key) {
      {
        if (!warnedOnce) {
          warnedOnce = true;
          console.warn(["Material-UI: The `theme.breakpoints.width` utility is deprecated because it's redundant.", 'Use the `theme.breakpoints.values` instead.'].join('\n'));
        }
      }

      return values[key];
    }

    return _extends$1({
      keys: keys,
      values: values,
      up: up,
      down: down,
      between: between,
      only: only,
      width: width
    }, other);
  }

  function createMixins(breakpoints, spacing, mixins) {
    var _toolbar;

    return _extends$1({
      gutters: function gutters() {
        var styles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        console.warn(['Material-UI: theme.mixins.gutters() is deprecated.', 'You can use the source of the mixin directly:', "\n      paddingLeft: theme.spacing(2),\n      paddingRight: theme.spacing(2),\n      [theme.breakpoints.up('sm')]: {\n        paddingLeft: theme.spacing(3),\n        paddingRight: theme.spacing(3),\n      },\n      "].join('\n'));
        return _extends$1({
          paddingLeft: spacing(2),
          paddingRight: spacing(2)
        }, styles, _defineProperty({}, breakpoints.up('sm'), _extends$1({
          paddingLeft: spacing(3),
          paddingRight: spacing(3)
        }, styles[breakpoints.up('sm')])));
      },
      toolbar: (_toolbar = {
        minHeight: 56
      }, _defineProperty(_toolbar, "".concat(breakpoints.up('xs'), " and (orientation: landscape)"), {
        minHeight: 48
      }), _defineProperty(_toolbar, breakpoints.up('sm'), {
        minHeight: 64
      }), _toolbar)
    }, mixins);
  }

  var common = {
    black: '#000',
    white: '#fff'
  };
  var common$1 = common;

  var grey = {
    50: '#fafafa',
    100: '#f5f5f5',
    200: '#eeeeee',
    300: '#e0e0e0',
    400: '#bdbdbd',
    500: '#9e9e9e',
    600: '#757575',
    700: '#616161',
    800: '#424242',
    900: '#212121',
    A100: '#d5d5d5',
    A200: '#aaaaaa',
    A400: '#303030',
    A700: '#616161'
  };
  var grey$1 = grey;

  var indigo = {
    50: '#e8eaf6',
    100: '#c5cae9',
    200: '#9fa8da',
    300: '#7986cb',
    400: '#5c6bc0',
    500: '#3f51b5',
    600: '#3949ab',
    700: '#303f9f',
    800: '#283593',
    900: '#1a237e',
    A100: '#8c9eff',
    A200: '#536dfe',
    A400: '#3d5afe',
    A700: '#304ffe'
  };
  var indigo$1 = indigo;

  var pink = {
    50: '#fce4ec',
    100: '#f8bbd0',
    200: '#f48fb1',
    300: '#f06292',
    400: '#ec407a',
    500: '#e91e63',
    600: '#d81b60',
    700: '#c2185b',
    800: '#ad1457',
    900: '#880e4f',
    A100: '#ff80ab',
    A200: '#ff4081',
    A400: '#f50057',
    A700: '#c51162'
  };
  var pink$1 = pink;

  var red = {
    50: '#ffebee',
    100: '#ffcdd2',
    200: '#ef9a9a',
    300: '#e57373',
    400: '#ef5350',
    500: '#f44336',
    600: '#e53935',
    700: '#d32f2f',
    800: '#c62828',
    900: '#b71c1c',
    A100: '#ff8a80',
    A200: '#ff5252',
    A400: '#ff1744',
    A700: '#d50000'
  };
  var red$1 = red;

  var orange = {
    50: '#fff3e0',
    100: '#ffe0b2',
    200: '#ffcc80',
    300: '#ffb74d',
    400: '#ffa726',
    500: '#ff9800',
    600: '#fb8c00',
    700: '#f57c00',
    800: '#ef6c00',
    900: '#e65100',
    A100: '#ffd180',
    A200: '#ffab40',
    A400: '#ff9100',
    A700: '#ff6d00'
  };
  var orange$1 = orange;

  var blue = {
    50: '#e3f2fd',
    100: '#bbdefb',
    200: '#90caf9',
    300: '#64b5f6',
    400: '#42a5f5',
    500: '#2196f3',
    600: '#1e88e5',
    700: '#1976d2',
    800: '#1565c0',
    900: '#0d47a1',
    A100: '#82b1ff',
    A200: '#448aff',
    A400: '#2979ff',
    A700: '#2962ff'
  };
  var blue$1 = blue;

  var green = {
    50: '#e8f5e9',
    100: '#c8e6c9',
    200: '#a5d6a7',
    300: '#81c784',
    400: '#66bb6a',
    500: '#4caf50',
    600: '#43a047',
    700: '#388e3c',
    800: '#2e7d32',
    900: '#1b5e20',
    A100: '#b9f6ca',
    A200: '#69f0ae',
    A400: '#00e676',
    A700: '#00c853'
  };
  var green$1 = green;

  var light = {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: 'rgba(0, 0, 0, 0.87)',
      // Secondary text.
      secondary: 'rgba(0, 0, 0, 0.54)',
      // Disabled text have even lower visual prominence.
      disabled: 'rgba(0, 0, 0, 0.38)',
      // Text hints.
      hint: 'rgba(0, 0, 0, 0.38)'
    },
    // The color used to divide different elements.
    divider: 'rgba(0, 0, 0, 0.12)',
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: common$1.white,
      default: grey$1[50]
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: 'rgba(0, 0, 0, 0.54)',
      // The color of an hovered action.
      hover: 'rgba(0, 0, 0, 0.04)',
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: 'rgba(0, 0, 0, 0.08)',
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: 'rgba(0, 0, 0, 0.26)',
      // The background color of a disabled action.
      disabledBackground: 'rgba(0, 0, 0, 0.12)',
      disabledOpacity: 0.38,
      focus: 'rgba(0, 0, 0, 0.12)',
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
  var dark = {
    text: {
      primary: common$1.white,
      secondary: 'rgba(255, 255, 255, 0.7)',
      disabled: 'rgba(255, 255, 255, 0.5)',
      hint: 'rgba(255, 255, 255, 0.5)',
      icon: 'rgba(255, 255, 255, 0.5)'
    },
    divider: 'rgba(255, 255, 255, 0.12)',
    background: {
      paper: grey$1[800],
      default: '#303030'
    },
    action: {
      active: common$1.white,
      hover: 'rgba(255, 255, 255, 0.08)',
      hoverOpacity: 0.08,
      selected: 'rgba(255, 255, 255, 0.16)',
      selectedOpacity: 0.16,
      disabled: 'rgba(255, 255, 255, 0.3)',
      disabledBackground: 'rgba(255, 255, 255, 0.12)',
      disabledOpacity: 0.38,
      focus: 'rgba(255, 255, 255, 0.12)',
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };

  function addLightOrDark(intent, direction, shade, tonalOffset) {
    var tonalOffsetLight = tonalOffset.light || tonalOffset;
    var tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;

    if (!intent[direction]) {
      if (intent.hasOwnProperty(shade)) {
        intent[direction] = intent[shade];
      } else if (direction === 'light') {
        intent.light = lighten(intent.main, tonalOffsetLight);
      } else if (direction === 'dark') {
        intent.dark = darken(intent.main, tonalOffsetDark);
      }
    }
  }

  function createPalette(palette) {
    var _palette$primary = palette.primary,
        primary = _palette$primary === void 0 ? {
      light: indigo$1[300],
      main: indigo$1[500],
      dark: indigo$1[700]
    } : _palette$primary,
        _palette$secondary = palette.secondary,
        secondary = _palette$secondary === void 0 ? {
      light: pink$1.A200,
      main: pink$1.A400,
      dark: pink$1.A700
    } : _palette$secondary,
        _palette$error = palette.error,
        error = _palette$error === void 0 ? {
      light: red$1[300],
      main: red$1[500],
      dark: red$1[700]
    } : _palette$error,
        _palette$warning = palette.warning,
        warning = _palette$warning === void 0 ? {
      light: orange$1[300],
      main: orange$1[500],
      dark: orange$1[700]
    } : _palette$warning,
        _palette$info = palette.info,
        info = _palette$info === void 0 ? {
      light: blue$1[300],
      main: blue$1[500],
      dark: blue$1[700]
    } : _palette$info,
        _palette$success = palette.success,
        success = _palette$success === void 0 ? {
      light: green$1[300],
      main: green$1[500],
      dark: green$1[700]
    } : _palette$success,
        _palette$type = palette.type,
        type = _palette$type === void 0 ? 'light' : _palette$type,
        _palette$contrastThre = palette.contrastThreshold,
        contrastThreshold = _palette$contrastThre === void 0 ? 3 : _palette$contrastThre,
        _palette$tonalOffset = palette.tonalOffset,
        tonalOffset = _palette$tonalOffset === void 0 ? 0.2 : _palette$tonalOffset,
        other = _objectWithoutProperties(palette, ["primary", "secondary", "error", "warning", "info", "success", "type", "contrastThreshold", "tonalOffset"]); // Use the same logic as
    // Bootstrap: https://github.com/twbs/bootstrap/blob/1d6e3710dd447de1a200f29e8fa521f8a0908f70/scss/_functions.scss#L59
    // and material-components-web https://github.com/material-components/material-components-web/blob/ac46b8863c4dab9fc22c4c662dc6bd1b65dd652f/packages/mdc-theme/_functions.scss#L54


    function getContrastText(background) {
      var contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;

      {
        var contrast = getContrastRatio(background, contrastText);

        if (contrast < 3) {
          console.error(["Material-UI: The contrast ratio of ".concat(contrast, ":1 for ").concat(contrastText, " on ").concat(background), 'falls below the WCAG recommended absolute minimum contrast ratio of 3:1.', 'https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast'].join('\n'));
        }
      }

      return contrastText;
    }

    var augmentColor = function augmentColor(color) {
      var mainShade = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
      var lightShade = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;
      var darkShade = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 700;
      color = _extends$1({}, color);

      if (!color.main && color[mainShade]) {
        color.main = color[mainShade];
      }

      if (!color.main) {
        throw new Error("Material-UI: The color provided to augmentColor(color) is invalid.\nThe color object needs to have a `main` property or a `".concat(mainShade, "` property.") );
      }

      if (typeof color.main !== 'string') {
        throw new Error("Material-UI: The color provided to augmentColor(color) is invalid.\n`color.main` should be a string, but `".concat(JSON.stringify(color.main), "` was provided instead.\n\nDid you intend to use one of the following approaches?\n\nimport {\xA0green } from \"@material-ui/core/colors\";\n\nconst theme1 = createTheme({ palette: {\n  primary: green,\n} });\n\nconst theme2 = createTheme({ palette: {\n  primary: { main: green[500] },\n} });") );
      }

      addLightOrDark(color, 'light', lightShade, tonalOffset);
      addLightOrDark(color, 'dark', darkShade, tonalOffset);

      if (!color.contrastText) {
        color.contrastText = getContrastText(color.main);
      }

      return color;
    };

    var types = {
      dark: dark,
      light: light
    };

    {
      if (!types[type]) {
        console.error("Material-UI: The palette type `".concat(type, "` is not supported."));
      }
    }

    var paletteOutput = deepmerge(_extends$1({
      // A collection of common colors.
      common: common$1,
      // The palette type, can be light or dark.
      type: type,
      // The colors used to represent primary interface elements for a user.
      primary: augmentColor(primary),
      // The colors used to represent secondary interface elements for a user.
      secondary: augmentColor(secondary, 'A400', 'A200', 'A700'),
      // The colors used to represent interface elements that the user should be made aware of.
      error: augmentColor(error),
      // The colors used to represent potentially dangerous actions or important messages.
      warning: augmentColor(warning),
      // The colors used to present information to the user that is neutral and not necessarily important.
      info: augmentColor(info),
      // The colors used to indicate the successful completion of an action that user triggered.
      success: augmentColor(success),
      // The grey colors.
      grey: grey$1,
      // Used by `getContrastText()` to maximize the contrast between
      // the background and the text.
      contrastThreshold: contrastThreshold,
      // Takes a background color and returns the text color that maximizes the contrast.
      getContrastText: getContrastText,
      // Generate a rich color object.
      augmentColor: augmentColor,
      // Used by the functions below to shift a color's luminance by approximately
      // two indexes within its tonal palette.
      // E.g., shift from Red 500 to Red 300 or Red 700.
      tonalOffset: tonalOffset
    }, types[type]), other);
    return paletteOutput;
  }

  function round(value) {
    return Math.round(value * 1e5) / 1e5;
  }

  var warnedOnce = false;

  function roundWithDeprecationWarning(value) {
    {
      if (!warnedOnce) {
        console.warn(['Material-UI: The `theme.typography.round` helper is deprecated.', 'Head to https://material-ui.com/r/migration-v4/#theme for a migration path.'].join('\n'));
        warnedOnce = true;
      }
    }

    return round(value);
  }

  var caseAllCaps = {
    textTransform: 'uppercase'
  };
  var defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
  /**
   * @see @link{https://material.io/design/typography/the-type-system.html}
   * @see @link{https://material.io/design/typography/understanding-typography.html}
   */

  function createTypography(palette, typography) {
    var _ref = typeof typography === 'function' ? typography(palette) : typography,
        _ref$fontFamily = _ref.fontFamily,
        fontFamily = _ref$fontFamily === void 0 ? defaultFontFamily : _ref$fontFamily,
        _ref$fontSize = _ref.fontSize,
        fontSize = _ref$fontSize === void 0 ? 14 : _ref$fontSize,
        _ref$fontWeightLight = _ref.fontWeightLight,
        fontWeightLight = _ref$fontWeightLight === void 0 ? 300 : _ref$fontWeightLight,
        _ref$fontWeightRegula = _ref.fontWeightRegular,
        fontWeightRegular = _ref$fontWeightRegula === void 0 ? 400 : _ref$fontWeightRegula,
        _ref$fontWeightMedium = _ref.fontWeightMedium,
        fontWeightMedium = _ref$fontWeightMedium === void 0 ? 500 : _ref$fontWeightMedium,
        _ref$fontWeightBold = _ref.fontWeightBold,
        fontWeightBold = _ref$fontWeightBold === void 0 ? 700 : _ref$fontWeightBold,
        _ref$htmlFontSize = _ref.htmlFontSize,
        htmlFontSize = _ref$htmlFontSize === void 0 ? 16 : _ref$htmlFontSize,
        allVariants = _ref.allVariants,
        pxToRem2 = _ref.pxToRem,
        other = _objectWithoutProperties(_ref, ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"]);

    {
      if (typeof fontSize !== 'number') {
        console.error('Material-UI: `fontSize` is required to be a number.');
      }

      if (typeof htmlFontSize !== 'number') {
        console.error('Material-UI: `htmlFontSize` is required to be a number.');
      }
    }

    var coef = fontSize / 14;

    var pxToRem = pxToRem2 || function (size) {
      return "".concat(size / htmlFontSize * coef, "rem");
    };

    var buildVariant = function buildVariant(fontWeight, size, lineHeight, letterSpacing, casing) {
      return _extends$1({
        fontFamily: fontFamily,
        fontWeight: fontWeight,
        fontSize: pxToRem(size),
        // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
        lineHeight: lineHeight
      }, fontFamily === defaultFontFamily ? {
        letterSpacing: "".concat(round(letterSpacing / size), "em")
      } : {}, casing, allVariants);
    };

    var variants = {
      h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
      h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
      h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
      h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
      h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
      h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
      subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
      subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
      body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
      body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
      button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
      caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
      overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)
    };
    return deepmerge(_extends$1({
      htmlFontSize: htmlFontSize,
      pxToRem: pxToRem,
      round: roundWithDeprecationWarning,
      // TODO v5: remove
      fontFamily: fontFamily,
      fontSize: fontSize,
      fontWeightLight: fontWeightLight,
      fontWeightRegular: fontWeightRegular,
      fontWeightMedium: fontWeightMedium,
      fontWeightBold: fontWeightBold
    }, variants), other, {
      clone: false // No need to clone deep

    });
  }

  var shadowKeyUmbraOpacity = 0.2;
  var shadowKeyPenumbraOpacity = 0.14;
  var shadowAmbientShadowOpacity = 0.12;

  function createShadow() {
    return ["".concat(arguments.length <= 0 ? undefined : arguments[0], "px ").concat(arguments.length <= 1 ? undefined : arguments[1], "px ").concat(arguments.length <= 2 ? undefined : arguments[2], "px ").concat(arguments.length <= 3 ? undefined : arguments[3], "px rgba(0,0,0,").concat(shadowKeyUmbraOpacity, ")"), "".concat(arguments.length <= 4 ? undefined : arguments[4], "px ").concat(arguments.length <= 5 ? undefined : arguments[5], "px ").concat(arguments.length <= 6 ? undefined : arguments[6], "px ").concat(arguments.length <= 7 ? undefined : arguments[7], "px rgba(0,0,0,").concat(shadowKeyPenumbraOpacity, ")"), "".concat(arguments.length <= 8 ? undefined : arguments[8], "px ").concat(arguments.length <= 9 ? undefined : arguments[9], "px ").concat(arguments.length <= 10 ? undefined : arguments[10], "px ").concat(arguments.length <= 11 ? undefined : arguments[11], "px rgba(0,0,0,").concat(shadowAmbientShadowOpacity, ")")].join(',');
  } // Values from https://github.com/material-components/material-components-web/blob/be8747f94574669cb5e7add1a7c54fa41a89cec7/packages/mdc-elevation/_variables.scss


  var shadows = ['none', createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
  var shadows$1 = shadows;

  var shape = {
    borderRadius: 4
  };
  var shape$1 = shape;

  var responsivePropType = PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.object, PropTypes.array]) ;
  var responsivePropType$1 = responsivePropType;

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  var spacingKeys = ['m', 'mt', 'mr', 'mb', 'ml', 'mx', 'my', 'p', 'pt', 'pr', 'pb', 'pl', 'px', 'py', 'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'marginX', 'marginY', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'paddingX', 'paddingY'];
  function createUnarySpacing(theme) {
    var themeSpacing = theme.spacing || 8;

    if (typeof themeSpacing === 'number') {
      return function (abs) {
        {
          if (typeof abs !== 'number') {
            console.error("Material-UI: Expected spacing argument to be a number, got ".concat(abs, "."));
          }
        }

        return themeSpacing * abs;
      };
    }

    if (Array.isArray(themeSpacing)) {
      return function (abs) {
        {
          if (abs > themeSpacing.length - 1) {
            console.error(["Material-UI: The value provided (".concat(abs, ") overflows."), "The supported values are: ".concat(JSON.stringify(themeSpacing), "."), "".concat(abs, " > ").concat(themeSpacing.length - 1, ", you need to add the missing values.")].join('\n'));
          }
        }

        return themeSpacing[abs];
      };
    }

    if (typeof themeSpacing === 'function') {
      return themeSpacing;
    }

    {
      console.error(["Material-UI: The `theme.spacing` value (".concat(themeSpacing, ") is invalid."), 'It should be a number, an array or a function.'].join('\n'));
    }

    return function () {
      return undefined;
    };
  }

  spacingKeys.reduce(function (obj, key) {
    obj[key] = responsivePropType$1;
    return obj;
  }, {}) ;

  var warnOnce;
  function createSpacing() {
    var spacingInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8; // Already transformed.

    if (spacingInput.mui) {
      return spacingInput;
    } // Material Design layouts are visually balanced. Most measurements align to an 8dp grid applied, which aligns both spacing and the overall layout.
    // Smaller components, such as icons and type, can align to a 4dp grid.
    // https://material.io/design/layout/understanding-layout.html#usage


    var transform = createUnarySpacing({
      spacing: spacingInput
    });

    var spacing = function spacing() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      {
        if (!(args.length <= 4)) {
          console.error("Material-UI: Too many arguments provided, expected between 0 and 4, got ".concat(args.length));
        }
      }

      if (args.length === 0) {
        return transform(1);
      }

      if (args.length === 1) {
        return transform(args[0]);
      }

      return args.map(function (argument) {
        if (typeof argument === 'string') {
          return argument;
        }

        var output = transform(argument);
        return typeof output === 'number' ? "".concat(output, "px") : output;
      }).join(' ');
    }; // Backward compatibility, to remove in v5.


    Object.defineProperty(spacing, 'unit', {
      get: function get() {
        {
          if (!warnOnce || 'development' === 'test') {
            console.error(['Material-UI: theme.spacing.unit usage has been deprecated.', 'It will be removed in v5.', 'You can replace `theme.spacing.unit * y` with `theme.spacing(y)`.', '', 'You can use the `https://github.com/mui-org/material-ui/tree/master/packages/material-ui-codemod/README.md#theme-spacing-api` migration helper to make the process smoother.'].join('\n'));
          }

          warnOnce = true;
        }

        return spacingInput;
      }
    });
    spacing.mui = true;
    return spacing;
  }

  // to learn the context in which each easing should be used.

  var easing = {
    // This is the most common easing curve.
    easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'
  }; // Follow https://material.io/guidelines/motion/duration-easing.html#duration-easing-common-durations
  // to learn when use what timing

  var duration = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195
  };

  function formatMs(milliseconds) {
    return "".concat(Math.round(milliseconds), "ms");
  }
  /**
   * @param {string|Array} props
   * @param {object} param
   * @param {string} param.prop
   * @param {number} param.duration
   * @param {string} param.easing
   * @param {number} param.delay
   */


  var transitions = {
    easing: easing,
    duration: duration,
    create: function create() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['all'];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _options$duration = options.duration,
          durationOption = _options$duration === void 0 ? duration.standard : _options$duration,
          _options$easing = options.easing,
          easingOption = _options$easing === void 0 ? easing.easeInOut : _options$easing,
          _options$delay = options.delay,
          delay = _options$delay === void 0 ? 0 : _options$delay,
          other = _objectWithoutProperties(options, ["duration", "easing", "delay"]);

      {
        var isString = function isString(value) {
          return typeof value === 'string';
        };

        var isNumber = function isNumber(value) {
          return !isNaN(parseFloat(value));
        };

        if (!isString(props) && !Array.isArray(props)) {
          console.error('Material-UI: Argument "props" must be a string or Array.');
        }

        if (!isNumber(durationOption) && !isString(durationOption)) {
          console.error("Material-UI: Argument \"duration\" must be a number or a string but found ".concat(durationOption, "."));
        }

        if (!isString(easingOption)) {
          console.error('Material-UI: Argument "easing" must be a string.');
        }

        if (!isNumber(delay) && !isString(delay)) {
          console.error('Material-UI: Argument "delay" must be a number or a string.');
        }

        if (Object.keys(other).length !== 0) {
          console.error("Material-UI: Unrecognized argument(s) [".concat(Object.keys(other).join(','), "]."));
        }
      }

      return (Array.isArray(props) ? props : [props]).map(function (animatedProp) {
        return "".concat(animatedProp, " ").concat(typeof durationOption === 'string' ? durationOption : formatMs(durationOption), " ").concat(easingOption, " ").concat(typeof delay === 'string' ? delay : formatMs(delay));
      }).join(',');
    },
    getAutoHeightDuration: function getAutoHeightDuration(height) {
      if (!height) {
        return 0;
      }

      var constant = height / 36; // https://www.wolframalpha.com/input/?i=(4+%2B+15+*+(x+%2F+36+)+**+0.25+%2B+(x+%2F+36)+%2F+5)+*+10

      return Math.round((4 + 15 * Math.pow(constant, 0.25) + constant / 5) * 10);
    }
  };

  // We need to centralize the zIndex definitions as they work
  // like global values in the browser.
  var zIndex = {
    mobileStepper: 1000,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
  };
  var zIndex$1 = zIndex;

  function createTheme() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _options$breakpoints = options.breakpoints,
        breakpointsInput = _options$breakpoints === void 0 ? {} : _options$breakpoints,
        _options$mixins = options.mixins,
        mixinsInput = _options$mixins === void 0 ? {} : _options$mixins,
        _options$palette = options.palette,
        paletteInput = _options$palette === void 0 ? {} : _options$palette,
        spacingInput = options.spacing,
        _options$typography = options.typography,
        typographyInput = _options$typography === void 0 ? {} : _options$typography,
        other = _objectWithoutProperties(options, ["breakpoints", "mixins", "palette", "spacing", "typography"]);

    var palette = createPalette(paletteInput);
    var breakpoints = createBreakpoints(breakpointsInput);
    var spacing = createSpacing(spacingInput);
    var muiTheme = deepmerge({
      breakpoints: breakpoints,
      direction: 'ltr',
      mixins: createMixins(breakpoints, spacing, mixinsInput),
      overrides: {},
      // Inject custom styles
      palette: palette,
      props: {},
      // Provide default props
      shadows: shadows$1,
      typography: createTypography(palette, typographyInput),
      spacing: spacing,
      shape: shape$1,
      transitions: transitions,
      zIndex: zIndex$1
    }, other);

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    muiTheme = args.reduce(function (acc, argument) {
      return deepmerge(acc, argument);
    }, muiTheme);

    {
      var pseudoClasses = ['checked', 'disabled', 'error', 'focused', 'focusVisible', 'required', 'expanded', 'selected'];

      var traverse = function traverse(node, parentKey) {
        var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        var key; // eslint-disable-next-line guard-for-in, no-restricted-syntax

        for (key in node) {
          var child = node[key];

          if (depth === 1) {
            if (key.indexOf('Mui') === 0 && child) {
              traverse(child, key, depth + 1);
            }
          } else if (pseudoClasses.indexOf(key) !== -1 && Object.keys(child).length > 0) {
            {
              console.error(["Material-UI: The `".concat(parentKey, "` component increases ") + "the CSS specificity of the `".concat(key, "` internal state."), 'You can not override it like this: ', JSON.stringify(node, null, 2), '', 'Instead, you need to use the $ruleName syntax:', JSON.stringify({
                root: _defineProperty({}, "&$".concat(key), child)
              }, null, 2), '', 'https://material-ui.com/r/pseudo-classes-guide'].join('\n'));
            } // Remove the style to prevent global conflicts.


            node[key] = {};
          }
        }
      };

      traverse(muiTheme.overrides);
    }

    return muiTheme;
  }

  var hasSymbol = typeof Symbol === 'function' && Symbol.for;
  var nested = hasSymbol ? Symbol.for('mui.nested') : '__THEME_NESTED__';

  /**
   * This is the list of the style rule name we use as drop in replacement for the built-in
   * pseudo classes (:checked, :disabled, :focused, etc.).
   *
   * Why do they exist in the first place?
   * These classes are used at a specificity of 2.
   * It allows them to override previously definied styles as well as
   * being untouched by simple user overrides.
   */

  var pseudoClasses = ['checked', 'disabled', 'error', 'focused', 'focusVisible', 'required', 'expanded', 'selected']; // Returns a function which generates unique class names based on counters.
  // When new generator function is created, rule counter is reset.
  // We need to reset the rule counter for SSR for each request.
  //
  // It's inspired by
  // https://github.com/cssinjs/jss/blob/4e6a05dd3f7b6572fdd3ab216861d9e446c20331/src/utils/createGenerateClassName.js

  function createGenerateClassName() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _options$disableGloba = options.disableGlobal,
        disableGlobal = _options$disableGloba === void 0 ? false : _options$disableGloba;
        options.productionPrefix;
        var _options$seed = options.seed,
        seed = _options$seed === void 0 ? '' : _options$seed;
    var seedPrefix = seed === '' ? '' : "".concat(seed, "-");
    var ruleCounter = 0;

    var getNextCounterId = function getNextCounterId() {
      ruleCounter += 1;

      {
        if (ruleCounter >= 1e10) {
          console.warn(['Material-UI: You might have a memory leak.', 'The ruleCounter is not supposed to grow that much.'].join(''));
        }
      }

      return ruleCounter;
    };

    return function (rule, styleSheet) {
      var name = styleSheet.options.name; // Is a global static MUI style?

      if (name && name.indexOf('Mui') === 0 && !styleSheet.options.link && !disableGlobal) {
        // We can use a shorthand class name, we never use the keys to style the components.
        if (pseudoClasses.indexOf(rule.key) !== -1) {
          return "Mui-".concat(rule.key);
        }

        var prefix = "".concat(seedPrefix).concat(name, "-").concat(rule.key);

        if (!styleSheet.options.theme[nested] || seed !== '') {
          return prefix;
        }

        return "".concat(prefix, "-").concat(getNextCounterId());
      }

      var suffix = "".concat(rule.key, "-").concat(getNextCounterId()); // Help with debuggability.

      if (styleSheet.options.classNamePrefix) {
        return "".concat(seedPrefix).concat(styleSheet.options.classNamePrefix, "-").concat(suffix);
      }

      return "".concat(seedPrefix).concat(suffix);
    };
  }

  /* eslint-disable no-restricted-syntax */
  function getThemeProps(params) {
    var theme = params.theme,
        name = params.name,
        props = params.props;

    if (!theme || !theme.props || !theme.props[name]) {
      return props;
    } // Resolve default props, code borrow from React source.
    // https://github.com/facebook/react/blob/15a8f031838a553e41c0b66eb1bcf1da8448104d/packages/react/src/ReactElement.js#L221


    var defaultProps = theme.props[name];
    var propName;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }

    return props;
  }

  var isProduction = 'development' === 'production';

  function warning(condition, message) {
    if (!isProduction) {
      if (condition) {
        return;
      }

      var text = "Warning: " + message;

      if (typeof console !== 'undefined') {
        console.warn(text);
      }

      try {
        throw Error(text);
      } catch (x) {}
    }
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var isBrowser$1 = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  var plainObjectConstrurctor = {}.constructor;

  function cloneStyle(style) {
    if (style == null || typeof style !== 'object') return style;
    if (Array.isArray(style)) return style.map(cloneStyle);
    if (style.constructor !== plainObjectConstrurctor) return style;
    var newStyle = {};

    for (var name in style) {
      newStyle[name] = cloneStyle(style[name]);
    }

    return newStyle;
  }
  /**
   * Create a rule instance.
   */


  function createRule(name, decl, options) {
    if (name === void 0) {
      name = 'unnamed';
    }

    var jss = options.jss;
    var declCopy = cloneStyle(decl);
    var rule = jss.plugins.onCreateRule(name, declCopy, options);
    if (rule) return rule; // It is an at-rule and it has no instance.

    if (name[0] === '@') {
      warning(false, "[JSS] Unknown rule " + name) ;
    }

    return null;
  }

  var join = function join(value, by) {
    var result = '';

    for (var i = 0; i < value.length; i++) {
      // Remove !important from the value, it will be readded later.
      if (value[i] === '!important') break;
      if (result) result += by;
      result += value[i];
    }

    return result;
  };
  /**
   * Converts JSS array value to a CSS string.
   *
   * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
   * `border: ['1px', '2px']` > `border: 1px, 2px;`
   * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
   * `color: ['red', !important]` > `color: red !important;`
   */


  var toCssValue = function toCssValue(value, ignoreImportant) {
    if (ignoreImportant === void 0) {
      ignoreImportant = false;
    }

    if (!Array.isArray(value)) return value;
    var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.

    if (Array.isArray(value[0])) {
      for (var i = 0; i < value.length; i++) {
        if (value[i] === '!important') break;
        if (cssValue) cssValue += ', ';
        cssValue += join(value[i], ' ');
      }
    } else cssValue = join(value, ', '); // Add !important, because it was ignored.


    if (!ignoreImportant && value[value.length - 1] === '!important') {
      cssValue += ' !important';
    }

    return cssValue;
  };

  function getWhitespaceSymbols(options) {
    if (options && options.format === false) {
      return {
        linebreak: '',
        space: ''
      };
    }

    return {
      linebreak: '\n',
      space: ' '
    };
  }
  /**
   * Indent a string.
   * http://jsperf.com/array-join-vs-for
   */


  function indentStr(str, indent) {
    var result = '';

    for (var index = 0; index < indent; index++) {
      result += '  ';
    }

    return result + str;
  }
  /**
   * Converts a Rule to CSS string.
   */


  function toCss(selector, style, options) {
    if (options === void 0) {
      options = {};
    }

    var result = '';
    if (!style) return result;
    var _options = options,
        _options$indent = _options.indent,
        indent = _options$indent === void 0 ? 0 : _options$indent;
    var fallbacks = style.fallbacks;

    if (options.format === false) {
      indent = -Infinity;
    }

    var _getWhitespaceSymbols = getWhitespaceSymbols(options),
        linebreak = _getWhitespaceSymbols.linebreak,
        space = _getWhitespaceSymbols.space;

    if (selector) indent++; // Apply fallbacks first.

    if (fallbacks) {
      // Array syntax {fallbacks: [{prop: value}]}
      if (Array.isArray(fallbacks)) {
        for (var index = 0; index < fallbacks.length; index++) {
          var fallback = fallbacks[index];

          for (var prop in fallback) {
            var value = fallback[prop];

            if (value != null) {
              if (result) result += linebreak;
              result += indentStr(prop + ":" + space + toCssValue(value) + ";", indent);
            }
          }
        }
      } else {
        // Object syntax {fallbacks: {prop: value}}
        for (var _prop in fallbacks) {
          var _value = fallbacks[_prop];

          if (_value != null) {
            if (result) result += linebreak;
            result += indentStr(_prop + ":" + space + toCssValue(_value) + ";", indent);
          }
        }
      }
    }

    for (var _prop2 in style) {
      var _value2 = style[_prop2];

      if (_value2 != null && _prop2 !== 'fallbacks') {
        if (result) result += linebreak;
        result += indentStr(_prop2 + ":" + space + toCssValue(_value2) + ";", indent);
      }
    } // Allow empty style in this case, because properties will be added dynamically.


    if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.

    if (!selector) return result;
    indent--;
    if (result) result = "" + linebreak + result + linebreak;
    return indentStr("" + selector + space + "{" + result, indent) + indentStr('}', indent);
  }

  var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
  var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;

  var escape = function (str) {
    return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
  };

  var BaseStyleRule = /*#__PURE__*/function () {
    function BaseStyleRule(key, style, options) {
      this.type = 'style';
      this.isProcessed = false;
      var sheet = options.sheet,
          Renderer = options.Renderer;
      this.key = key;
      this.options = options;
      this.style = style;
      if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();
    }
    /**
     * Get or set a style property.
     */


    var _proto = BaseStyleRule.prototype;

    _proto.prop = function prop(name, value, options) {
      // It's a getter.
      if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.

      var force = options ? options.force : false;
      if (!force && this.style[name] === value) return this;
      var newValue = value;

      if (!options || options.process !== false) {
        newValue = this.options.jss.plugins.onChangeValue(value, name, this);
      }

      var isEmpty = newValue == null || newValue === false;
      var isDefined = (name in this.style); // Value is empty and wasn't defined before.

      if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.

      var remove = isEmpty && isDefined;
      if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.

      if (this.renderable && this.renderer) {
        if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);
        return this;
      }

      var sheet = this.options.sheet;

      if (sheet && sheet.attached) {
        warning(false, '[JSS] Rule is not linked. Missing sheet option "link: true".') ;
      }

      return this;
    };

    return BaseStyleRule;
  }();

  var StyleRule = /*#__PURE__*/function (_BaseStyleRule) {
    _inheritsLoose(StyleRule, _BaseStyleRule);

    function StyleRule(key, style, options) {
      var _this;

      _this = _BaseStyleRule.call(this, key, style, options) || this;
      var selector = options.selector,
          scoped = options.scoped,
          sheet = options.sheet,
          generateId = options.generateId;

      if (selector) {
        _this.selectorText = selector;
      } else if (scoped !== false) {
        _this.id = generateId(_assertThisInitialized(_assertThisInitialized(_this)), sheet);
        _this.selectorText = "." + escape(_this.id);
      }

      return _this;
    }
    /**
     * Set selector string.
     * Attention: use this with caution. Most browsers didn't implement
     * selectorText setter, so this may result in rerendering of entire Style Sheet.
     */


    var _proto2 = StyleRule.prototype;
    /**
     * Apply rule to an element inline.
     */

    _proto2.applyTo = function applyTo(renderable) {
      var renderer = this.renderer;

      if (renderer) {
        var json = this.toJSON();

        for (var prop in json) {
          renderer.setProperty(renderable, prop, json[prop]);
        }
      }

      return this;
    }
    /**
     * Returns JSON representation of the rule.
     * Fallbacks are not supported.
     * Useful for inline styles.
     */
    ;

    _proto2.toJSON = function toJSON() {
      var json = {};

      for (var prop in this.style) {
        var value = this.style[prop];
        if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);
      }

      return json;
    }
    /**
     * Generates a CSS string.
     */
    ;

    _proto2.toString = function toString(options) {
      var sheet = this.options.sheet;
      var link = sheet ? sheet.options.link : false;
      var opts = link ? _extends$1({}, options, {
        allowEmpty: true
      }) : options;
      return toCss(this.selectorText, this.style, opts);
    };

    _createClass(StyleRule, [{
      key: "selector",
      set: function set(selector) {
        if (selector === this.selectorText) return;
        this.selectorText = selector;
        var renderer = this.renderer,
            renderable = this.renderable;
        if (!renderable || !renderer) return;
        var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.

        if (!hasChanged) {
          renderer.replaceRule(renderable, this);
        }
      }
      /**
       * Get selector string.
       */
      ,
      get: function get() {
        return this.selectorText;
      }
    }]);

    return StyleRule;
  }(BaseStyleRule);

  var pluginStyleRule = {
    onCreateRule: function onCreateRule(key, style, options) {
      if (key[0] === '@' || options.parent && options.parent.type === 'keyframes') {
        return null;
      }

      return new StyleRule(key, style, options);
    }
  };
  var defaultToStringOptions = {
    indent: 1,
    children: true
  };
  var atRegExp = /@([\w-]+)/;
  /**
   * Conditional rule for @media, @supports
   */

  var ConditionalRule = /*#__PURE__*/function () {
    function ConditionalRule(key, styles, options) {
      this.type = 'conditional';
      this.isProcessed = false;
      this.key = key;
      var atMatch = key.match(atRegExp);
      this.at = atMatch ? atMatch[1] : 'unknown'; // Key might contain a unique suffix in case the `name` passed by user was duplicate.

      this.query = options.name || "@" + this.at;
      this.options = options;
      this.rules = new RuleList(_extends$1({}, options, {
        parent: this
      }));

      for (var name in styles) {
        this.rules.add(name, styles[name]);
      }

      this.rules.process();
    }
    /**
     * Get a rule.
     */


    var _proto = ConditionalRule.prototype;

    _proto.getRule = function getRule(name) {
      return this.rules.get(name);
    }
    /**
     * Get index of a rule.
     */
    ;

    _proto.indexOf = function indexOf(rule) {
      return this.rules.indexOf(rule);
    }
    /**
     * Create and register rule, run plugins.
     */
    ;

    _proto.addRule = function addRule(name, style, options) {
      var rule = this.rules.add(name, style, options);
      if (!rule) return null;
      this.options.jss.plugins.onProcessRule(rule);
      return rule;
    }
    /**
     * Generates a CSS string.
     */
    ;

    _proto.toString = function toString(options) {
      if (options === void 0) {
        options = defaultToStringOptions;
      }

      var _getWhitespaceSymbols = getWhitespaceSymbols(options),
          linebreak = _getWhitespaceSymbols.linebreak;

      if (options.indent == null) options.indent = defaultToStringOptions.indent;
      if (options.children == null) options.children = defaultToStringOptions.children;

      if (options.children === false) {
        return this.query + " {}";
      }

      var children = this.rules.toString(options);
      return children ? this.query + " {" + linebreak + children + linebreak + "}" : '';
    };

    return ConditionalRule;
  }();

  var keyRegExp = /@media|@supports\s+/;
  var pluginConditionalRule = {
    onCreateRule: function onCreateRule(key, styles, options) {
      return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
    }
  };
  var defaultToStringOptions$1 = {
    indent: 1,
    children: true
  };
  var nameRegExp = /@keyframes\s+([\w-]+)/;
  /**
   * Rule for @keyframes
   */

  var KeyframesRule = /*#__PURE__*/function () {
    function KeyframesRule(key, frames, options) {
      this.type = 'keyframes';
      this.at = '@keyframes';
      this.isProcessed = false;
      var nameMatch = key.match(nameRegExp);

      if (nameMatch && nameMatch[1]) {
        this.name = nameMatch[1];
      } else {
        this.name = 'noname';
        warning(false, "[JSS] Bad keyframes name " + key) ;
      }

      this.key = this.type + "-" + this.name;
      this.options = options;
      var scoped = options.scoped,
          sheet = options.sheet,
          generateId = options.generateId;
      this.id = scoped === false ? this.name : escape(generateId(this, sheet));
      this.rules = new RuleList(_extends$1({}, options, {
        parent: this
      }));

      for (var name in frames) {
        this.rules.add(name, frames[name], _extends$1({}, options, {
          parent: this
        }));
      }

      this.rules.process();
    }
    /**
     * Generates a CSS string.
     */


    var _proto = KeyframesRule.prototype;

    _proto.toString = function toString(options) {
      if (options === void 0) {
        options = defaultToStringOptions$1;
      }

      var _getWhitespaceSymbols = getWhitespaceSymbols(options),
          linebreak = _getWhitespaceSymbols.linebreak;

      if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
      if (options.children == null) options.children = defaultToStringOptions$1.children;

      if (options.children === false) {
        return this.at + " " + this.id + " {}";
      }

      var children = this.rules.toString(options);
      if (children) children = "" + linebreak + children + linebreak;
      return this.at + " " + this.id + " {" + children + "}";
    };

    return KeyframesRule;
  }();

  var keyRegExp$1 = /@keyframes\s+/;
  var refRegExp$1 = /\$([\w-]+)/g;

  var findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
    if (typeof val === 'string') {
      return val.replace(refRegExp$1, function (match, name) {
        if (name in keyframes) {
          return keyframes[name];
        }

        warning(false, "[JSS] Referenced keyframes rule \"" + name + "\" is not defined.") ;
        return match;
      });
    }

    return val;
  };
  /**
   * Replace the reference for a animation name.
   */


  var replaceRef = function replaceRef(style, prop, keyframes) {
    var value = style[prop];
    var refKeyframe = findReferencedKeyframe(value, keyframes);

    if (refKeyframe !== value) {
      style[prop] = refKeyframe;
    }
  };

  var pluginKeyframesRule = {
    onCreateRule: function onCreateRule(key, frames, options) {
      return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
    },
    // Animation name ref replacer.
    onProcessStyle: function onProcessStyle(style, rule, sheet) {
      if (rule.type !== 'style' || !sheet) return style;
      if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
      if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
      return style;
    },
    onChangeValue: function onChangeValue(val, prop, rule) {
      var sheet = rule.options.sheet;

      if (!sheet) {
        return val;
      }

      switch (prop) {
        case 'animation':
          return findReferencedKeyframe(val, sheet.keyframes);

        case 'animation-name':
          return findReferencedKeyframe(val, sheet.keyframes);

        default:
          return val;
      }
    }
  };

  var KeyframeRule = /*#__PURE__*/function (_BaseStyleRule) {
    _inheritsLoose(KeyframeRule, _BaseStyleRule);

    function KeyframeRule() {
      return _BaseStyleRule.apply(this, arguments) || this;
    }

    var _proto = KeyframeRule.prototype;
    /**
     * Generates a CSS string.
     */

    _proto.toString = function toString(options) {
      var sheet = this.options.sheet;
      var link = sheet ? sheet.options.link : false;
      var opts = link ? _extends$1({}, options, {
        allowEmpty: true
      }) : options;
      return toCss(this.key, this.style, opts);
    };

    return KeyframeRule;
  }(BaseStyleRule);

  var pluginKeyframeRule = {
    onCreateRule: function onCreateRule(key, style, options) {
      if (options.parent && options.parent.type === 'keyframes') {
        return new KeyframeRule(key, style, options);
      }

      return null;
    }
  };

  var FontFaceRule = /*#__PURE__*/function () {
    function FontFaceRule(key, style, options) {
      this.type = 'font-face';
      this.at = '@font-face';
      this.isProcessed = false;
      this.key = key;
      this.style = style;
      this.options = options;
    }
    /**
     * Generates a CSS string.
     */


    var _proto = FontFaceRule.prototype;

    _proto.toString = function toString(options) {
      var _getWhitespaceSymbols = getWhitespaceSymbols(options),
          linebreak = _getWhitespaceSymbols.linebreak;

      if (Array.isArray(this.style)) {
        var str = '';

        for (var index = 0; index < this.style.length; index++) {
          str += toCss(this.at, this.style[index]);
          if (this.style[index + 1]) str += linebreak;
        }

        return str;
      }

      return toCss(this.at, this.style, options);
    };

    return FontFaceRule;
  }();

  var keyRegExp$2 = /@font-face/;
  var pluginFontFaceRule = {
    onCreateRule: function onCreateRule(key, style, options) {
      return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
    }
  };

  var ViewportRule = /*#__PURE__*/function () {
    function ViewportRule(key, style, options) {
      this.type = 'viewport';
      this.at = '@viewport';
      this.isProcessed = false;
      this.key = key;
      this.style = style;
      this.options = options;
    }
    /**
     * Generates a CSS string.
     */


    var _proto = ViewportRule.prototype;

    _proto.toString = function toString(options) {
      return toCss(this.key, this.style, options);
    };

    return ViewportRule;
  }();

  var pluginViewportRule = {
    onCreateRule: function onCreateRule(key, style, options) {
      return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
    }
  };

  var SimpleRule = /*#__PURE__*/function () {
    function SimpleRule(key, value, options) {
      this.type = 'simple';
      this.isProcessed = false;
      this.key = key;
      this.value = value;
      this.options = options;
    }
    /**
     * Generates a CSS string.
     */
    // eslint-disable-next-line no-unused-vars


    var _proto = SimpleRule.prototype;

    _proto.toString = function toString(options) {
      if (Array.isArray(this.value)) {
        var str = '';

        for (var index = 0; index < this.value.length; index++) {
          str += this.key + " " + this.value[index] + ";";
          if (this.value[index + 1]) str += '\n';
        }

        return str;
      }

      return this.key + " " + this.value + ";";
    };

    return SimpleRule;
  }();

  var keysMap = {
    '@charset': true,
    '@import': true,
    '@namespace': true
  };
  var pluginSimpleRule = {
    onCreateRule: function onCreateRule(key, value, options) {
      return key in keysMap ? new SimpleRule(key, value, options) : null;
    }
  };
  var plugins$1 = [pluginStyleRule, pluginConditionalRule, pluginKeyframesRule, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];
  var defaultUpdateOptions = {
    process: true
  };
  var forceUpdateOptions = {
    force: true,
    process: true
    /**
     * Contains rules objects and allows adding/removing etc.
     * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
     */

  };

  var RuleList = /*#__PURE__*/function () {
    // Rules registry for access by .get() method.
    // It contains the same rule registered by name and by selector.
    // Original styles object.
    // Used to ensure correct rules order.
    function RuleList(options) {
      this.map = {};
      this.raw = {};
      this.index = [];
      this.counter = 0;
      this.options = options;
      this.classes = options.classes;
      this.keyframes = options.keyframes;
    }
    /**
     * Create and register rule.
     *
     * Will not render after Style Sheet was rendered the first time.
     */


    var _proto = RuleList.prototype;

    _proto.add = function add(name, decl, ruleOptions) {
      var _this$options = this.options,
          parent = _this$options.parent,
          sheet = _this$options.sheet,
          jss = _this$options.jss,
          Renderer = _this$options.Renderer,
          generateId = _this$options.generateId,
          scoped = _this$options.scoped;

      var options = _extends$1({
        classes: this.classes,
        parent: parent,
        sheet: sheet,
        jss: jss,
        Renderer: Renderer,
        generateId: generateId,
        scoped: scoped,
        name: name,
        keyframes: this.keyframes,
        selector: undefined
      }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
      // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
      // we need to make the key unique within this RuleList instance scope.


      var key = name;

      if (name in this.raw) {
        key = name + "-d" + this.counter++;
      } // We need to save the original decl before creating the rule
      // because cache plugin needs to use it as a key to return a cached rule.


      this.raw[key] = decl;

      if (key in this.classes) {
        // E.g. rules inside of @media container
        options.selector = "." + escape(this.classes[key]);
      }

      var rule = createRule(key, decl, options);
      if (!rule) return null;
      this.register(rule);
      var index = options.index === undefined ? this.index.length : options.index;
      this.index.splice(index, 0, rule);
      return rule;
    }
    /**
     * Get a rule.
     */
    ;

    _proto.get = function get(name) {
      return this.map[name];
    }
    /**
     * Delete a rule.
     */
    ;

    _proto.remove = function remove(rule) {
      this.unregister(rule);
      delete this.raw[rule.key];
      this.index.splice(this.index.indexOf(rule), 1);
    }
    /**
     * Get index of a rule.
     */
    ;

    _proto.indexOf = function indexOf(rule) {
      return this.index.indexOf(rule);
    }
    /**
     * Run `onProcessRule()` plugins on every rule.
     */
    ;

    _proto.process = function process() {
      var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
      // we end up with very hard-to-track-down side effects.

      this.index.slice(0).forEach(plugins.onProcessRule, plugins);
    }
    /**
     * Register a rule in `.map`, `.classes` and `.keyframes` maps.
     */
    ;

    _proto.register = function register(rule) {
      this.map[rule.key] = rule;

      if (rule instanceof StyleRule) {
        this.map[rule.selector] = rule;
        if (rule.id) this.classes[rule.key] = rule.id;
      } else if (rule instanceof KeyframesRule && this.keyframes) {
        this.keyframes[rule.name] = rule.id;
      }
    }
    /**
     * Unregister a rule.
     */
    ;

    _proto.unregister = function unregister(rule) {
      delete this.map[rule.key];

      if (rule instanceof StyleRule) {
        delete this.map[rule.selector];
        delete this.classes[rule.key];
      } else if (rule instanceof KeyframesRule) {
        delete this.keyframes[rule.name];
      }
    }
    /**
     * Update the function values with a new data.
     */
    ;

    _proto.update = function update() {
      var name;
      var data;
      var options;

      if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
        name = arguments.length <= 0 ? undefined : arguments[0];
        data = arguments.length <= 1 ? undefined : arguments[1];
        options = arguments.length <= 2 ? undefined : arguments[2];
      } else {
        data = arguments.length <= 0 ? undefined : arguments[0];
        options = arguments.length <= 1 ? undefined : arguments[1];
        name = null;
      }

      if (name) {
        this.updateOne(this.map[name], data, options);
      } else {
        for (var index = 0; index < this.index.length; index++) {
          this.updateOne(this.index[index], data, options);
        }
      }
    }
    /**
     * Execute plugins, update rule props.
     */
    ;

    _proto.updateOne = function updateOne(rule, data, options) {
      if (options === void 0) {
        options = defaultUpdateOptions;
      }

      var _this$options2 = this.options,
          plugins = _this$options2.jss.plugins,
          sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.

      if (rule.rules instanceof RuleList) {
        rule.rules.update(data, options);
        return;
      }

      var style = rule.style;
      plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.

      if (options.process && style && style !== rule.style) {
        // We need to run the plugins in case new `style` relies on syntax plugins.
        plugins.onProcessStyle(rule.style, rule, sheet); // Update and add props.

        for (var prop in rule.style) {
          var nextValue = rule.style[prop];
          var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
          // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

          if (nextValue !== prevValue) {
            rule.prop(prop, nextValue, forceUpdateOptions);
          }
        } // Remove props.


        for (var _prop in style) {
          var _nextValue = rule.style[_prop];
          var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
          // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

          if (_nextValue == null && _nextValue !== _prevValue) {
            rule.prop(_prop, null, forceUpdateOptions);
          }
        }
      }
    }
    /**
     * Convert rules to a CSS string.
     */
    ;

    _proto.toString = function toString(options) {
      var str = '';
      var sheet = this.options.sheet;
      var link = sheet ? sheet.options.link : false;

      var _getWhitespaceSymbols = getWhitespaceSymbols(options),
          linebreak = _getWhitespaceSymbols.linebreak;

      for (var index = 0; index < this.index.length; index++) {
        var rule = this.index[index];
        var css = rule.toString(options); // No need to render an empty rule.

        if (!css && !link) continue;
        if (str) str += linebreak;
        str += css;
      }

      return str;
    };

    return RuleList;
  }();

  var StyleSheet = /*#__PURE__*/function () {
    function StyleSheet(styles, options) {
      this.attached = false;
      this.deployed = false;
      this.classes = {};
      this.keyframes = {};
      this.options = _extends$1({}, options, {
        sheet: this,
        parent: this,
        classes: this.classes,
        keyframes: this.keyframes
      });

      if (options.Renderer) {
        this.renderer = new options.Renderer(this);
      }

      this.rules = new RuleList(this.options);

      for (var name in styles) {
        this.rules.add(name, styles[name]);
      }

      this.rules.process();
    }
    /**
     * Attach renderable to the render tree.
     */


    var _proto = StyleSheet.prototype;

    _proto.attach = function attach() {
      if (this.attached) return this;
      if (this.renderer) this.renderer.attach();
      this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.

      if (!this.deployed) this.deploy();
      return this;
    }
    /**
     * Remove renderable from render tree.
     */
    ;

    _proto.detach = function detach() {
      if (!this.attached) return this;
      if (this.renderer) this.renderer.detach();
      this.attached = false;
      return this;
    }
    /**
     * Add a rule to the current stylesheet.
     * Will insert a rule also after the stylesheet has been rendered first time.
     */
    ;

    _proto.addRule = function addRule(name, decl, options) {
      var queue = this.queue; // Plugins can create rules.
      // In order to preserve the right order, we need to queue all `.addRule` calls,
      // which happen after the first `rules.add()` call.

      if (this.attached && !queue) this.queue = [];
      var rule = this.rules.add(name, decl, options);
      if (!rule) return null;
      this.options.jss.plugins.onProcessRule(rule);

      if (this.attached) {
        if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
        // It will be inserted all together when .attach is called.

        if (queue) queue.push(rule);else {
          this.insertRule(rule);

          if (this.queue) {
            this.queue.forEach(this.insertRule, this);
            this.queue = undefined;
          }
        }
        return rule;
      } // We can't add rules to a detached style node.
      // We will redeploy the sheet once user will attach it.


      this.deployed = false;
      return rule;
    }
    /**
     * Insert rule into the StyleSheet
     */
    ;

    _proto.insertRule = function insertRule(rule) {
      if (this.renderer) {
        this.renderer.insertRule(rule);
      }
    }
    /**
     * Create and add rules.
     * Will render also after Style Sheet was rendered the first time.
     */
    ;

    _proto.addRules = function addRules(styles, options) {
      var added = [];

      for (var name in styles) {
        var rule = this.addRule(name, styles[name], options);
        if (rule) added.push(rule);
      }

      return added;
    }
    /**
     * Get a rule by name.
     */
    ;

    _proto.getRule = function getRule(name) {
      return this.rules.get(name);
    }
    /**
     * Delete a rule by name.
     * Returns `true`: if rule has been deleted from the DOM.
     */
    ;

    _proto.deleteRule = function deleteRule(name) {
      var rule = typeof name === 'object' ? name : this.rules.get(name);

      if (!rule || // Style sheet was created without link: true and attached, in this case we
      // won't be able to remove the CSS rule from the DOM.
      this.attached && !rule.renderable) {
        return false;
      }

      this.rules.remove(rule);

      if (this.attached && rule.renderable && this.renderer) {
        return this.renderer.deleteRule(rule.renderable);
      }

      return true;
    }
    /**
     * Get index of a rule.
     */
    ;

    _proto.indexOf = function indexOf(rule) {
      return this.rules.indexOf(rule);
    }
    /**
     * Deploy pure CSS string to a renderable.
     */
    ;

    _proto.deploy = function deploy() {
      if (this.renderer) this.renderer.deploy();
      this.deployed = true;
      return this;
    }
    /**
     * Update the function values with a new data.
     */
    ;

    _proto.update = function update() {
      var _this$rules;

      (_this$rules = this.rules).update.apply(_this$rules, arguments);

      return this;
    }
    /**
     * Updates a single rule.
     */
    ;

    _proto.updateOne = function updateOne(rule, data, options) {
      this.rules.updateOne(rule, data, options);
      return this;
    }
    /**
     * Convert rules to a CSS string.
     */
    ;

    _proto.toString = function toString(options) {
      return this.rules.toString(options);
    };

    return StyleSheet;
  }();

  var PluginsRegistry = /*#__PURE__*/function () {
    function PluginsRegistry() {
      this.plugins = {
        internal: [],
        external: []
      };
      this.registry = {};
    }

    var _proto = PluginsRegistry.prototype;
    /**
     * Call `onCreateRule` hooks and return an object if returned by a hook.
     */

    _proto.onCreateRule = function onCreateRule(name, decl, options) {
      for (var i = 0; i < this.registry.onCreateRule.length; i++) {
        var rule = this.registry.onCreateRule[i](name, decl, options);
        if (rule) return rule;
      }

      return null;
    }
    /**
     * Call `onProcessRule` hooks.
     */
    ;

    _proto.onProcessRule = function onProcessRule(rule) {
      if (rule.isProcessed) return;
      var sheet = rule.options.sheet;

      for (var i = 0; i < this.registry.onProcessRule.length; i++) {
        this.registry.onProcessRule[i](rule, sheet);
      }

      if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
      rule.isProcessed = true;
    }
    /**
     * Call `onProcessStyle` hooks.
     */
    ;

    _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
      for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
        rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
      }
    }
    /**
     * Call `onProcessSheet` hooks.
     */
    ;

    _proto.onProcessSheet = function onProcessSheet(sheet) {
      for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
        this.registry.onProcessSheet[i](sheet);
      }
    }
    /**
     * Call `onUpdate` hooks.
     */
    ;

    _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
      for (var i = 0; i < this.registry.onUpdate.length; i++) {
        this.registry.onUpdate[i](data, rule, sheet, options);
      }
    }
    /**
     * Call `onChangeValue` hooks.
     */
    ;

    _proto.onChangeValue = function onChangeValue(value, prop, rule) {
      var processedValue = value;

      for (var i = 0; i < this.registry.onChangeValue.length; i++) {
        processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
      }

      return processedValue;
    }
    /**
     * Register a plugin.
     */
    ;

    _proto.use = function use(newPlugin, options) {
      if (options === void 0) {
        options = {
          queue: 'external'
        };
      }

      var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.

      if (plugins.indexOf(newPlugin) !== -1) {
        return;
      }

      plugins.push(newPlugin);
      this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {
        for (var name in plugin) {
          if (name in registry) {
            registry[name].push(plugin[name]);
          } else {
            warning(false, "[JSS] Unknown hook \"" + name + "\".") ;
          }
        }

        return registry;
      }, {
        onCreateRule: [],
        onProcessRule: [],
        onProcessStyle: [],
        onProcessSheet: [],
        onChangeValue: [],
        onUpdate: []
      });
    };

    return PluginsRegistry;
  }();
  /**
   * Sheets registry to access all instances in one place.
   */


  var SheetsRegistry = /*#__PURE__*/function () {
    function SheetsRegistry() {
      this.registry = [];
    }

    var _proto = SheetsRegistry.prototype;
    /**
     * Register a Style Sheet.
     */

    _proto.add = function add(sheet) {
      var registry = this.registry;
      var index = sheet.options.index;
      if (registry.indexOf(sheet) !== -1) return;

      if (registry.length === 0 || index >= this.index) {
        registry.push(sheet);
        return;
      } // Find a position.


      for (var i = 0; i < registry.length; i++) {
        if (registry[i].options.index > index) {
          registry.splice(i, 0, sheet);
          return;
        }
      }
    }
    /**
     * Reset the registry.
     */
    ;

    _proto.reset = function reset() {
      this.registry = [];
    }
    /**
     * Remove a Style Sheet.
     */
    ;

    _proto.remove = function remove(sheet) {
      var index = this.registry.indexOf(sheet);
      this.registry.splice(index, 1);
    }
    /**
     * Convert all attached sheets to a CSS string.
     */
    ;

    _proto.toString = function toString(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          attached = _ref.attached,
          options = _objectWithoutPropertiesLoose(_ref, ["attached"]);

      var _getWhitespaceSymbols = getWhitespaceSymbols(options),
          linebreak = _getWhitespaceSymbols.linebreak;

      var css = '';

      for (var i = 0; i < this.registry.length; i++) {
        var sheet = this.registry[i];

        if (attached != null && sheet.attached !== attached) {
          continue;
        }

        if (css) css += linebreak;
        css += sheet.toString(options);
      }

      return css;
    };

    _createClass(SheetsRegistry, [{
      key: "index",

      /**
       * Current highest index number.
       */
      get: function get() {
        return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
      }
    }]);

    return SheetsRegistry;
  }();
  /**
   * This is a global sheets registry. Only DomRenderer will add sheets to it.
   * On the server one should use an own SheetsRegistry instance and add the
   * sheets to it, because you need to make sure to create a new registry for
   * each request in order to not leak sheets across requests.
   */


  var sheets = new SheetsRegistry();
  /* eslint-disable */

  /**
   * Now that `globalThis` is available on most platforms
   * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)
   * we check for `globalThis` first. `globalThis` is necessary for jss
   * to run in Agoric's secure version of JavaScript (SES). Under SES,
   * `globalThis` exists, but `window`, `self`, and `Function('return
   * this')()` are all undefined for security reasons.
   *
   * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
   */

  var globalThis$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();
  var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
  if (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
  // the current version with just one short number and use it for classes generation
  // we use a counter. Also it is more accurate, because user can manually reevaluate
  // the module.

  var moduleId = globalThis$1[ns]++;
  var maxRules = 1e10;
  /**
   * Returns a function which generates unique class names based on counters.
   * When new generator function is created, rule counter is reseted.
   * We need to reset the rule counter for SSR for each request.
   */

  var createGenerateId = function createGenerateId(options) {
    if (options === void 0) {
      options = {};
    }

    var ruleCounter = 0;

    var generateId = function generateId(rule, sheet) {
      ruleCounter += 1;

      if (ruleCounter > maxRules) {
        warning(false, "[JSS] You might have a memory leak. Rule counter is at " + ruleCounter + ".") ;
      }

      var jssId = '';
      var prefix = '';

      if (sheet) {
        if (sheet.options.classNamePrefix) {
          prefix = sheet.options.classNamePrefix;
        }

        if (sheet.options.jss.id != null) {
          jssId = String(sheet.options.jss.id);
        }
      }

      if (options.minify) {
        // Using "c" because a number can't be the first char in a class name.
        return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
      }

      return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
    };

    return generateId;
  };
  /**
   * Cache the value from the first time a function is called.
   */


  var memoize = function memoize(fn) {
    var value;
    return function () {
      if (!value) value = fn();
      return value;
    };
  };
  /**
   * Get a style property value.
   */


  var getPropertyValue = function getPropertyValue(cssRule, prop) {
    try {
      // Support CSSTOM.
      if (cssRule.attributeStyleMap) {
        return cssRule.attributeStyleMap.get(prop);
      }

      return cssRule.style.getPropertyValue(prop);
    } catch (err) {
      // IE may throw if property is unknown.
      return '';
    }
  };
  /**
   * Set a style property.
   */


  var setProperty = function setProperty(cssRule, prop, value) {
    try {
      var cssValue = value;

      if (Array.isArray(value)) {
        cssValue = toCssValue(value, true);

        if (value[value.length - 1] === '!important') {
          cssRule.style.setProperty(prop, cssValue, 'important');
          return true;
        }
      } // Support CSSTOM.


      if (cssRule.attributeStyleMap) {
        cssRule.attributeStyleMap.set(prop, cssValue);
      } else {
        cssRule.style.setProperty(prop, cssValue);
      }
    } catch (err) {
      // IE may throw if property is unknown.
      return false;
    }

    return true;
  };
  /**
   * Remove a style property.
   */


  var removeProperty = function removeProperty(cssRule, prop) {
    try {
      // Support CSSTOM.
      if (cssRule.attributeStyleMap) {
        cssRule.attributeStyleMap.delete(prop);
      } else {
        cssRule.style.removeProperty(prop);
      }
    } catch (err) {
      warning(false, "[JSS] DOMException \"" + err.message + "\" was thrown. Tried to remove property \"" + prop + "\".") ;
    }
  };
  /**
   * Set the selector.
   */


  var setSelector = function setSelector(cssRule, selectorText) {
    cssRule.selectorText = selectorText; // Return false if setter was not successful.
    // Currently works in chrome only.

    return cssRule.selectorText === selectorText;
  };
  /**
   * Gets the `head` element upon the first call and caches it.
   * We assume it can't be null.
   */


  var getHead = memoize(function () {
    return document.querySelector('head');
  });
  /**
   * Find attached sheet with an index higher than the passed one.
   */

  function findHigherSheet(registry, options) {
    for (var i = 0; i < registry.length; i++) {
      var sheet = registry[i];

      if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
        return sheet;
      }
    }

    return null;
  }
  /**
   * Find attached sheet with the highest index.
   */


  function findHighestSheet(registry, options) {
    for (var i = registry.length - 1; i >= 0; i--) {
      var sheet = registry[i];

      if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
        return sheet;
      }
    }

    return null;
  }
  /**
   * Find a comment with "jss" inside.
   */


  function findCommentNode(text) {
    var head = getHead();

    for (var i = 0; i < head.childNodes.length; i++) {
      var node = head.childNodes[i];

      if (node.nodeType === 8 && node.nodeValue.trim() === text) {
        return node;
      }
    }

    return null;
  }
  /**
   * Find a node before which we can insert the sheet.
   */


  function findPrevNode(options) {
    var registry = sheets.registry;

    if (registry.length > 0) {
      // Try to insert before the next higher sheet.
      var sheet = findHigherSheet(registry, options);

      if (sheet && sheet.renderer) {
        return {
          parent: sheet.renderer.element.parentNode,
          node: sheet.renderer.element
        };
      } // Otherwise insert after the last attached.


      sheet = findHighestSheet(registry, options);

      if (sheet && sheet.renderer) {
        return {
          parent: sheet.renderer.element.parentNode,
          node: sheet.renderer.element.nextSibling
        };
      }
    } // Try to find a comment placeholder if registry is empty.


    var insertionPoint = options.insertionPoint;

    if (insertionPoint && typeof insertionPoint === 'string') {
      var comment = findCommentNode(insertionPoint);

      if (comment) {
        return {
          parent: comment.parentNode,
          node: comment.nextSibling
        };
      } // If user specifies an insertion point and it can't be found in the document -
      // bad specificity issues may appear.


      warning(false, "[JSS] Insertion point \"" + insertionPoint + "\" not found.") ;
    }

    return false;
  }
  /**
   * Insert style element into the DOM.
   */


  function insertStyle(style, options) {
    var insertionPoint = options.insertionPoint;
    var nextNode = findPrevNode(options);

    if (nextNode !== false && nextNode.parent) {
      nextNode.parent.insertBefore(style, nextNode.node);
      return;
    } // Works with iframes and any node types.


    if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
      var insertionPointElement = insertionPoint;
      var parentNode = insertionPointElement.parentNode;
      if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);else warning(false, '[JSS] Insertion point is not in the DOM.') ;
      return;
    }

    getHead().appendChild(style);
  }
  /**
   * Read jss nonce setting from the page if the user has set it.
   */


  var getNonce = memoize(function () {
    var node = document.querySelector('meta[property="csp-nonce"]');
    return node ? node.getAttribute('content') : null;
  });

  var _insertRule = function insertRule(container, rule, index) {
    try {
      if ('insertRule' in container) {
        container.insertRule(rule, index);
      } // Keyframes rule.
      else if ('appendRule' in container) {
        container.appendRule(rule);
      }
    } catch (err) {
      warning(false, "[JSS] " + err.message) ;
      return false;
    }

    return container.cssRules[index];
  };

  var getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {
    var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong

    if (index === undefined || index > maxIndex) {
      // eslint-disable-next-line no-param-reassign
      return maxIndex;
    }

    return index;
  };

  var createStyle = function createStyle() {
    var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
    // insert rules after we insert the style tag.
    // It seems to kick-off the source order specificity algorithm.

    el.textContent = '\n';
    return el;
  };

  var DomRenderer = /*#__PURE__*/function () {
    // Will be empty if link: true option is not set, because
    // it is only for use together with insertRule API.
    function DomRenderer(sheet) {
      this.getPropertyValue = getPropertyValue;
      this.setProperty = setProperty;
      this.removeProperty = removeProperty;
      this.setSelector = setSelector;
      this.hasInsertedRules = false;
      this.cssRules = []; // There is no sheet when the renderer is used from a standalone StyleRule.

      if (sheet) sheets.add(sheet);
      this.sheet = sheet;

      var _ref = this.sheet ? this.sheet.options : {},
          media = _ref.media,
          meta = _ref.meta,
          element = _ref.element;

      this.element = element || createStyle();
      this.element.setAttribute('data-jss', '');
      if (media) this.element.setAttribute('media', media);
      if (meta) this.element.setAttribute('data-meta', meta);
      var nonce = getNonce();
      if (nonce) this.element.setAttribute('nonce', nonce);
    }
    /**
     * Insert style element into render tree.
     */


    var _proto = DomRenderer.prototype;

    _proto.attach = function attach() {
      // In the case the element node is external and it is already in the DOM.
      if (this.element.parentNode || !this.sheet) return;
      insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
      // most browsers create a new CSSStyleSheet, except of all IEs.

      var deployed = Boolean(this.sheet && this.sheet.deployed);

      if (this.hasInsertedRules && deployed) {
        this.hasInsertedRules = false;
        this.deploy();
      }
    }
    /**
     * Remove style element from render tree.
     */
    ;

    _proto.detach = function detach() {
      if (!this.sheet) return;
      var parentNode = this.element.parentNode;
      if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.
      // Though IE will keep them and we need a consistent behavior.

      if (this.sheet.options.link) {
        this.cssRules = [];
        this.element.textContent = '\n';
      }
    }
    /**
     * Inject CSS string into element.
     */
    ;

    _proto.deploy = function deploy() {
      var sheet = this.sheet;
      if (!sheet) return;

      if (sheet.options.link) {
        this.insertRules(sheet.rules);
        return;
      }

      this.element.textContent = "\n" + sheet.toString() + "\n";
    }
    /**
     * Insert RuleList into an element.
     */
    ;

    _proto.insertRules = function insertRules(rules, nativeParent) {
      for (var i = 0; i < rules.index.length; i++) {
        this.insertRule(rules.index[i], i, nativeParent);
      }
    }
    /**
     * Insert a rule into element.
     */
    ;

    _proto.insertRule = function insertRule(rule, index, nativeParent) {
      if (nativeParent === void 0) {
        nativeParent = this.element.sheet;
      }

      if (rule.rules) {
        var parent = rule;
        var latestNativeParent = nativeParent;

        if (rule.type === 'conditional' || rule.type === 'keyframes') {
          var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.


          latestNativeParent = _insertRule(nativeParent, parent.toString({
            children: false
          }), _insertionIndex);

          if (latestNativeParent === false) {
            return false;
          }

          this.refCssRule(rule, _insertionIndex, latestNativeParent);
        }

        this.insertRules(parent.rules, latestNativeParent);
        return latestNativeParent;
      }

      var ruleStr = rule.toString();
      if (!ruleStr) return false;
      var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);

      var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);

      if (nativeRule === false) {
        return false;
      }

      this.hasInsertedRules = true;
      this.refCssRule(rule, insertionIndex, nativeRule);
      return nativeRule;
    };

    _proto.refCssRule = function refCssRule(rule, index, cssRule) {
      rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules
      // like rules inside media queries or keyframes

      if (rule.options.parent instanceof StyleSheet) {
        this.cssRules[index] = cssRule;
      }
    }
    /**
     * Delete a rule.
     */
    ;

    _proto.deleteRule = function deleteRule(cssRule) {
      var sheet = this.element.sheet;
      var index = this.indexOf(cssRule);
      if (index === -1) return false;
      sheet.deleteRule(index);
      this.cssRules.splice(index, 1);
      return true;
    }
    /**
     * Get index of a CSS Rule.
     */
    ;

    _proto.indexOf = function indexOf(cssRule) {
      return this.cssRules.indexOf(cssRule);
    }
    /**
     * Generate a new CSS rule and replace the existing one.
     *
     * Only used for some old browsers because they can't set a selector.
     */
    ;

    _proto.replaceRule = function replaceRule(cssRule, rule) {
      var index = this.indexOf(cssRule);
      if (index === -1) return false;
      this.element.sheet.deleteRule(index);
      this.cssRules.splice(index, 1);
      return this.insertRule(rule, index);
    }
    /**
     * Get all rules elements.
     */
    ;

    _proto.getRules = function getRules() {
      return this.element.sheet.cssRules;
    };

    return DomRenderer;
  }();

  var instanceCounter = 0;

  var Jss = /*#__PURE__*/function () {
    function Jss(options) {
      this.id = instanceCounter++;
      this.version = "10.8.0";
      this.plugins = new PluginsRegistry();
      this.options = {
        id: {
          minify: false
        },
        createGenerateId: createGenerateId,
        Renderer: isBrowser$1 ? DomRenderer : null,
        plugins: []
      };
      this.generateId = createGenerateId({
        minify: false
      });

      for (var i = 0; i < plugins$1.length; i++) {
        this.plugins.use(plugins$1[i], {
          queue: 'internal'
        });
      }

      this.setup(options);
    }
    /**
     * Prepares various options, applies plugins.
     * Should not be used twice on the same instance, because there is no plugins
     * deduplication logic.
     */


    var _proto = Jss.prototype;

    _proto.setup = function setup(options) {
      if (options === void 0) {
        options = {};
      }

      if (options.createGenerateId) {
        this.options.createGenerateId = options.createGenerateId;
      }

      if (options.id) {
        this.options.id = _extends$1({}, this.options.id, options.id);
      }

      if (options.createGenerateId || options.id) {
        this.generateId = this.options.createGenerateId(this.options.id);
      }

      if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;

      if ('Renderer' in options) {
        this.options.Renderer = options.Renderer;
      } // eslint-disable-next-line prefer-spread


      if (options.plugins) this.use.apply(this, options.plugins);
      return this;
    }
    /**
     * Create a Style Sheet.
     */
    ;

    _proto.createStyleSheet = function createStyleSheet(styles, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          index = _options.index;

      if (typeof index !== 'number') {
        index = sheets.index === 0 ? 0 : sheets.index + 1;
      }

      var sheet = new StyleSheet(styles, _extends$1({}, options, {
        jss: this,
        generateId: options.generateId || this.generateId,
        insertionPoint: this.options.insertionPoint,
        Renderer: this.options.Renderer,
        index: index
      }));
      this.plugins.onProcessSheet(sheet);
      return sheet;
    }
    /**
     * Detach the Style Sheet and remove it from the registry.
     */
    ;

    _proto.removeStyleSheet = function removeStyleSheet(sheet) {
      sheet.detach();
      sheets.remove(sheet);
      return this;
    }
    /**
     * Create a rule without a Style Sheet.
     * [Deprecated] will be removed in the next major version.
     */
    ;

    _proto.createRule = function createRule$1(name, style, options) {
      if (style === void 0) {
        style = {};
      }

      if (options === void 0) {
        options = {};
      } // Enable rule without name for inline styles.


      if (typeof name === 'object') {
        return this.createRule(undefined, name, style);
      }

      var ruleOptions = _extends$1({}, options, {
        name: name,
        jss: this,
        Renderer: this.options.Renderer
      });

      if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
      if (!ruleOptions.classes) ruleOptions.classes = {};
      if (!ruleOptions.keyframes) ruleOptions.keyframes = {};
      var rule = createRule(name, style, ruleOptions);
      if (rule) this.plugins.onProcessRule(rule);
      return rule;
    }
    /**
     * Register plugin. Passed function will be invoked with a rule instance.
     */
    ;

    _proto.use = function use() {
      var _this = this;

      for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
        plugins[_key] = arguments[_key];
      }

      plugins.forEach(function (plugin) {
        _this.plugins.use(plugin);
      });
      return this;
    };

    return Jss;
  }();

  var createJss = function createJss(options) {
    return new Jss(options);
  };
  /**
  * Export a constant indicating if this browser has CSSTOM support.
  * https://developers.google.com/web/updates/2018/03/cssom
  */


  var hasCSSTOMSupport = typeof CSS === 'object' && CSS != null && 'number' in CSS;
  /**
   * Extracts a styles object with only props that contain function values.
   */

  function getDynamicStyles(styles) {
    var to = null;

    for (var key in styles) {
      var value = styles[key];
      var type = typeof value;

      if (type === 'function') {
        if (!to) to = {};
        to[key] = value;
      } else if (type === 'object' && value !== null && !Array.isArray(value)) {
        var extracted = getDynamicStyles(value);

        if (extracted) {
          if (!to) to = {};
          to[key] = extracted;
        }
      }
    }

    return to;
  }
  /**
   * A better abstraction over CSS.
   *
   * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
   * @website https://github.com/cssinjs/jss
   * @license MIT
   */


  createJss();

  var now = Date.now();
  var fnValuesNs = "fnValues" + now;
  var fnRuleNs = "fnStyle" + ++now;

  var functionPlugin = function functionPlugin() {
    return {
      onCreateRule: function onCreateRule(name, decl, options) {
        if (typeof decl !== 'function') return null;
        var rule = createRule(name, {}, options);
        rule[fnRuleNs] = decl;
        return rule;
      },
      onProcessStyle: function onProcessStyle(style, rule) {
        // We need to extract function values from the declaration, so that we can keep core unaware of them.
        // We need to do that only once.
        // We don't need to extract functions on each style update, since this can happen only once.
        // We don't support function values inside of function rules.
        if (fnValuesNs in rule || fnRuleNs in rule) return style;
        var fnValues = {};

        for (var prop in style) {
          var value = style[prop];
          if (typeof value !== 'function') continue;
          delete style[prop];
          fnValues[prop] = value;
        }

        rule[fnValuesNs] = fnValues;
        return style;
      },
      onUpdate: function onUpdate(data, rule, sheet, options) {
        var styleRule = rule;
        var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object
        // will be returned from that function.

        if (fnRule) {
          // Empty object will remove all currently defined props
          // in case function rule returns a falsy value.
          styleRule.style = fnRule(data) || {};

          {
            for (var prop in styleRule.style) {
              if (typeof styleRule.style[prop] === 'function') {
                warning(false, '[JSS] Function values inside function rules are not supported.') ;
                break;
              }
            }
          }
        }

        var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.

        if (fnValues) {
          for (var _prop in fnValues) {
            styleRule.prop(_prop, fnValues[_prop](data), options);
          }
        }
      }
    };
  };

  var functions = functionPlugin;

  var at = '@global';
  var atPrefix = '@global ';

  var GlobalContainerRule = /*#__PURE__*/function () {
    function GlobalContainerRule(key, styles, options) {
      this.type = 'global';
      this.at = at;
      this.isProcessed = false;
      this.key = key;
      this.options = options;
      this.rules = new RuleList(_extends$1({}, options, {
        parent: this
      }));

      for (var selector in styles) {
        this.rules.add(selector, styles[selector]);
      }

      this.rules.process();
    }
    /**
     * Get a rule.
     */


    var _proto = GlobalContainerRule.prototype;

    _proto.getRule = function getRule(name) {
      return this.rules.get(name);
    }
    /**
     * Create and register rule, run plugins.
     */
    ;

    _proto.addRule = function addRule(name, style, options) {
      var rule = this.rules.add(name, style, options);
      if (rule) this.options.jss.plugins.onProcessRule(rule);
      return rule;
    }
    /**
     * Get index of a rule.
     */
    ;

    _proto.indexOf = function indexOf(rule) {
      return this.rules.indexOf(rule);
    }
    /**
     * Generates a CSS string.
     */
    ;

    _proto.toString = function toString() {
      return this.rules.toString();
    };

    return GlobalContainerRule;
  }();

  var GlobalPrefixedRule = /*#__PURE__*/function () {
    function GlobalPrefixedRule(key, style, options) {
      this.type = 'global';
      this.at = at;
      this.isProcessed = false;
      this.key = key;
      this.options = options;
      var selector = key.substr(atPrefix.length);
      this.rule = options.jss.createRule(selector, style, _extends$1({}, options, {
        parent: this
      }));
    }

    var _proto2 = GlobalPrefixedRule.prototype;

    _proto2.toString = function toString(options) {
      return this.rule ? this.rule.toString(options) : '';
    };

    return GlobalPrefixedRule;
  }();

  var separatorRegExp$1 = /\s*,\s*/g;

  function addScope(selector, scope) {
    var parts = selector.split(separatorRegExp$1);
    var scoped = '';

    for (var i = 0; i < parts.length; i++) {
      scoped += scope + " " + parts[i].trim();
      if (parts[i + 1]) scoped += ', ';
    }

    return scoped;
  }

  function handleNestedGlobalContainerRule(rule, sheet) {
    var options = rule.options,
        style = rule.style;
    var rules = style ? style[at] : null;
    if (!rules) return;

    for (var name in rules) {
      sheet.addRule(name, rules[name], _extends$1({}, options, {
        selector: addScope(name, rule.selector)
      }));
    }

    delete style[at];
  }

  function handlePrefixedGlobalRule(rule, sheet) {
    var options = rule.options,
        style = rule.style;

    for (var prop in style) {
      if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
      var selector = addScope(prop.substr(at.length), rule.selector);
      sheet.addRule(selector, style[prop], _extends$1({}, options, {
        selector: selector
      }));
      delete style[prop];
    }
  }
  /**
   * Convert nested rules to separate, remove them from original styles.
   */


  function jssGlobal() {
    function onCreateRule(name, styles, options) {
      if (!name) return null;

      if (name === at) {
        return new GlobalContainerRule(name, styles, options);
      }

      if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {
        return new GlobalPrefixedRule(name, styles, options);
      }

      var parent = options.parent;

      if (parent) {
        if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {
          options.scoped = false;
        }
      }

      if (options.scoped === false) {
        options.selector = name;
      }

      return null;
    }

    function onProcessRule(rule, sheet) {
      if (rule.type !== 'style' || !sheet) return;
      handleNestedGlobalContainerRule(rule, sheet);
      handlePrefixedGlobalRule(rule, sheet);
    }

    return {
      onCreateRule: onCreateRule,
      onProcessRule: onProcessRule
    };
  }

  var separatorRegExp = /\s*,\s*/g;
  var parentRegExp = /&/g;
  var refRegExp = /\$([\w-]+)/g;
  /**
   * Convert nested rules to separate, remove them from original styles.
   */

  function jssNested() {
    // Get a function to be used for $ref replacement.
    function getReplaceRef(container, sheet) {
      return function (match, key) {
        var rule = container.getRule(key) || sheet && sheet.getRule(key);

        if (rule) {
          return rule.selector;
        }

        warning(false, "[JSS] Could not find the referenced rule \"" + key + "\" in \"" + (container.options.meta || container.toString()) + "\".") ;
        return key;
      };
    }

    function replaceParentRefs(nestedProp, parentProp) {
      var parentSelectors = parentProp.split(separatorRegExp);
      var nestedSelectors = nestedProp.split(separatorRegExp);
      var result = '';

      for (var i = 0; i < parentSelectors.length; i++) {
        var parent = parentSelectors[i];

        for (var j = 0; j < nestedSelectors.length; j++) {
          var nested = nestedSelectors[j];
          if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.

          result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + " " + nested;
        }
      }

      return result;
    }

    function getOptions(rule, container, prevOptions) {
      // Options has been already created, now we only increase index.
      if (prevOptions) return _extends$1({}, prevOptions, {
        index: prevOptions.index + 1
      });
      var nestingLevel = rule.options.nestingLevel;
      nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;

      var options = _extends$1({}, rule.options, {
        nestingLevel: nestingLevel,
        index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.

      });

      delete options.name;
      return options;
    }

    function onProcessStyle(style, rule, sheet) {
      if (rule.type !== 'style') return style;
      var styleRule = rule;
      var container = styleRule.options.parent;
      var options;
      var replaceRef;

      for (var prop in style) {
        var isNested = prop.indexOf('&') !== -1;
        var isNestedConditional = prop[0] === '@';
        if (!isNested && !isNestedConditional) continue;
        options = getOptions(styleRule, container, options);

        if (isNested) {
          var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for
          // all nested rules within the sheet.

          if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.

          selector = selector.replace(refRegExp, replaceRef);
          container.addRule(selector, style[prop], _extends$1({}, options, {
            selector: selector
          }));
        } else if (isNestedConditional) {
          // Place conditional right after the parent rule to ensure right ordering.
          container.addRule(prop, {}, options).addRule(styleRule.key, style[prop], {
            selector: styleRule.selector
          });
        }

        delete style[prop];
      }

      return style;
    }

    return {
      onProcessStyle: onProcessStyle
    };
  }

  /* eslint-disable no-var, prefer-template */
  var uppercasePattern = /[A-Z]/g;
  var msPattern = /^ms-/;
  var cache$2 = {};

  function toHyphenLower(match) {
    return '-' + match.toLowerCase();
  }

  function hyphenateStyleName(name) {
    if (cache$2.hasOwnProperty(name)) {
      return cache$2[name];
    }

    var hName = name.replace(uppercasePattern, toHyphenLower);
    return cache$2[name] = msPattern.test(hName) ? '-' + hName : hName;
  }

  /**
   * Convert camel cased property names to dash separated.
   */

  function convertCase(style) {
    var converted = {};

    for (var prop in style) {
      var key = prop.indexOf('--') === 0 ? prop : hyphenateStyleName(prop);
      converted[key] = style[prop];
    }

    if (style.fallbacks) {
      if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
    }

    return converted;
  }
  /**
   * Allow camel cased property names by converting them back to dasherized.
   */


  function camelCase() {
    function onProcessStyle(style) {
      if (Array.isArray(style)) {
        // Handle rules like @font-face, which can have multiple styles in an array
        for (var index = 0; index < style.length; index++) {
          style[index] = convertCase(style[index]);
        }

        return style;
      }

      return convertCase(style);
    }

    function onChangeValue(value, prop, rule) {
      if (prop.indexOf('--') === 0) {
        return value;
      }

      var hyphenatedProp = hyphenateStyleName(prop); // There was no camel case in place

      if (prop === hyphenatedProp) return value;
      rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.

      return null;
    }

    return {
      onProcessStyle: onProcessStyle,
      onChangeValue: onChangeValue
    };
  }

  var px = hasCSSTOMSupport && CSS ? CSS.px : 'px';
  var ms = hasCSSTOMSupport && CSS ? CSS.ms : 'ms';
  var percent = hasCSSTOMSupport && CSS ? CSS.percent : '%';
  /**
   * Generated jss-plugin-default-unit CSS property units
   */

  var defaultUnits = {
    // Animation properties
    'animation-delay': ms,
    'animation-duration': ms,
    // Background properties
    'background-position': px,
    'background-position-x': px,
    'background-position-y': px,
    'background-size': px,
    // Border Properties
    border: px,
    'border-bottom': px,
    'border-bottom-left-radius': px,
    'border-bottom-right-radius': px,
    'border-bottom-width': px,
    'border-left': px,
    'border-left-width': px,
    'border-radius': px,
    'border-right': px,
    'border-right-width': px,
    'border-top': px,
    'border-top-left-radius': px,
    'border-top-right-radius': px,
    'border-top-width': px,
    'border-width': px,
    'border-block': px,
    'border-block-end': px,
    'border-block-end-width': px,
    'border-block-start': px,
    'border-block-start-width': px,
    'border-block-width': px,
    'border-inline': px,
    'border-inline-end': px,
    'border-inline-end-width': px,
    'border-inline-start': px,
    'border-inline-start-width': px,
    'border-inline-width': px,
    'border-start-start-radius': px,
    'border-start-end-radius': px,
    'border-end-start-radius': px,
    'border-end-end-radius': px,
    // Margin properties
    margin: px,
    'margin-bottom': px,
    'margin-left': px,
    'margin-right': px,
    'margin-top': px,
    'margin-block': px,
    'margin-block-end': px,
    'margin-block-start': px,
    'margin-inline': px,
    'margin-inline-end': px,
    'margin-inline-start': px,
    // Padding properties
    padding: px,
    'padding-bottom': px,
    'padding-left': px,
    'padding-right': px,
    'padding-top': px,
    'padding-block': px,
    'padding-block-end': px,
    'padding-block-start': px,
    'padding-inline': px,
    'padding-inline-end': px,
    'padding-inline-start': px,
    // Mask properties
    'mask-position-x': px,
    'mask-position-y': px,
    'mask-size': px,
    // Width and height properties
    height: px,
    width: px,
    'min-height': px,
    'max-height': px,
    'min-width': px,
    'max-width': px,
    // Position properties
    bottom: px,
    left: px,
    top: px,
    right: px,
    inset: px,
    'inset-block': px,
    'inset-block-end': px,
    'inset-block-start': px,
    'inset-inline': px,
    'inset-inline-end': px,
    'inset-inline-start': px,
    // Shadow properties
    'box-shadow': px,
    'text-shadow': px,
    // Column properties
    'column-gap': px,
    'column-rule': px,
    'column-rule-width': px,
    'column-width': px,
    // Font and text properties
    'font-size': px,
    'font-size-delta': px,
    'letter-spacing': px,
    'text-decoration-thickness': px,
    'text-indent': px,
    'text-stroke': px,
    'text-stroke-width': px,
    'word-spacing': px,
    // Motion properties
    motion: px,
    'motion-offset': px,
    // Outline properties
    outline: px,
    'outline-offset': px,
    'outline-width': px,
    // Perspective properties
    perspective: px,
    'perspective-origin-x': percent,
    'perspective-origin-y': percent,
    // Transform properties
    'transform-origin': percent,
    'transform-origin-x': percent,
    'transform-origin-y': percent,
    'transform-origin-z': percent,
    // Transition properties
    'transition-delay': ms,
    'transition-duration': ms,
    // Alignment properties
    'vertical-align': px,
    'flex-basis': px,
    // Some random properties
    'shape-margin': px,
    size: px,
    gap: px,
    // Grid properties
    grid: px,
    'grid-gap': px,
    'row-gap': px,
    'grid-row-gap': px,
    'grid-column-gap': px,
    'grid-template-rows': px,
    'grid-template-columns': px,
    'grid-auto-rows': px,
    'grid-auto-columns': px,
    // Not existing properties.
    // Used to avoid issues with jss-plugin-expand integration.
    'box-shadow-x': px,
    'box-shadow-y': px,
    'box-shadow-blur': px,
    'box-shadow-spread': px,
    'font-line-height': px,
    'text-shadow-x': px,
    'text-shadow-y': px,
    'text-shadow-blur': px
  };
  /**
   * Clones the object and adds a camel cased property version.
   */

  function addCamelCasedVersion(obj) {
    var regExp = /(-[a-z])/g;

    var replace = function replace(str) {
      return str[1].toUpperCase();
    };

    var newObj = {};

    for (var key in obj) {
      newObj[key] = obj[key];
      newObj[key.replace(regExp, replace)] = obj[key];
    }

    return newObj;
  }

  var units = addCamelCasedVersion(defaultUnits);
  /**
   * Recursive deep style passing function
   */

  function iterate(prop, value, options) {
    if (value == null) return value;

    if (Array.isArray(value)) {
      for (var i = 0; i < value.length; i++) {
        value[i] = iterate(prop, value[i], options);
      }
    } else if (typeof value === 'object') {
      if (prop === 'fallbacks') {
        for (var innerProp in value) {
          value[innerProp] = iterate(innerProp, value[innerProp], options);
        }
      } else {
        for (var _innerProp in value) {
          value[_innerProp] = iterate(prop + "-" + _innerProp, value[_innerProp], options);
        }
      } // eslint-disable-next-line no-restricted-globals

    } else if (typeof value === 'number' && isNaN(value) === false) {
      var unit = options[prop] || units[prop]; // Add the unit if available, except for the special case of 0px.

      if (unit && !(value === 0 && unit === px)) {
        return typeof unit === 'function' ? unit(value).toString() : "" + value + unit;
      }

      return value.toString();
    }

    return value;
  }
  /**
   * Add unit to numeric values.
   */


  function defaultUnit(options) {
    if (options === void 0) {
      options = {};
    }

    var camelCasedOptions = addCamelCasedVersion(options);

    function onProcessStyle(style, rule) {
      if (rule.type !== 'style') return style;

      for (var prop in style) {
        style[prop] = iterate(prop, style[prop], camelCasedOptions);
      }

      return style;
    }

    function onChangeValue(value, prop) {
      return iterate(prop, value, camelCasedOptions);
    }

    return {
      onProcessStyle: onProcessStyle,
      onChangeValue: onChangeValue
    };
  }

  var js = '';
  var css = '';
  var vendor = '';
  var browser = '';
  var isTouch = isBrowser$1 && 'ontouchstart' in document.documentElement; // We should not do anything if required serverside.

  if (isBrowser$1) {
    // Order matters. We need to check Webkit the last one because
    // other vendors use to add Webkit prefixes to some properties
    var jsCssMap = {
      Moz: '-moz-',
      ms: '-ms-',
      O: '-o-',
      Webkit: '-webkit-'
    };

    var _document$createEleme = document.createElement('p'),
        style = _document$createEleme.style;

    var testProp = 'Transform';

    for (var key in jsCssMap) {
      if (key + testProp in style) {
        js = key;
        css = jsCssMap[key];
        break;
      }
    } // Correctly detect the Edge browser.


    if (js === 'Webkit' && 'msHyphens' in style) {
      js = 'ms';
      css = jsCssMap.ms;
      browser = 'edge';
    } // Correctly detect the Safari browser.


    if (js === 'Webkit' && '-apple-trailing-word' in style) {
      vendor = 'apple';
    }
  }
  /**
   * Vendor prefix string for the current browser.
   *
   * @type {{js: String, css: String, vendor: String, browser: String}}
   * @api public
   */


  var prefix = {
    js: js,
    css: css,
    vendor: vendor,
    browser: browser,
    isTouch: isTouch
  };
  /**
   * Test if a keyframe at-rule should be prefixed or not
   *
   * @param {String} vendor prefix string for the current browser.
   * @return {String}
   * @api public
   */

  function supportedKeyframes(key) {
    // Keyframes is already prefixed. e.g. key = '@-webkit-keyframes a'
    if (key[1] === '-') return key; // No need to prefix IE/Edge. Older browsers will ignore unsupported rules.
    // https://caniuse.com/#search=keyframes

    if (prefix.js === 'ms') return key;
    return "@" + prefix.css + "keyframes" + key.substr(10);
  } // https://caniuse.com/#search=appearance


  var appearence = {
    noPrefill: ['appearance'],
    supportedProperty: function supportedProperty(prop) {
      if (prop !== 'appearance') return false;
      if (prefix.js === 'ms') return "-webkit-" + prop;
      return prefix.css + prop;
    }
  }; // https://caniuse.com/#search=color-adjust

  var colorAdjust = {
    noPrefill: ['color-adjust'],
    supportedProperty: function supportedProperty(prop) {
      if (prop !== 'color-adjust') return false;
      if (prefix.js === 'Webkit') return prefix.css + "print-" + prop;
      return prop;
    }
  };
  var regExp = /[-\s]+(.)?/g;
  /**
   * Replaces the letter with the capital letter
   *
   * @param {String} match
   * @param {String} c
   * @return {String}
   * @api private
   */

  function toUpper(match, c) {
    return c ? c.toUpperCase() : '';
  }
  /**
   * Convert dash separated strings to camel-cased.
   *
   * @param {String} str
   * @return {String}
   * @api private
   */


  function camelize(str) {
    return str.replace(regExp, toUpper);
  }
  /**
   * Convert dash separated strings to pascal cased.
   *
   * @param {String} str
   * @return {String}
   * @api private
   */


  function pascalize(str) {
    return camelize("-" + str);
  } // but we can use a longhand property instead.
  // https://caniuse.com/#search=mask


  var mask = {
    noPrefill: ['mask'],
    supportedProperty: function supportedProperty(prop, style) {
      if (!/^mask/.test(prop)) return false;

      if (prefix.js === 'Webkit') {
        var longhand = 'mask-image';

        if (camelize(longhand) in style) {
          return prop;
        }

        if (prefix.js + pascalize(longhand) in style) {
          return prefix.css + prop;
        }
      }

      return prop;
    }
  }; // https://caniuse.com/#search=text-orientation

  var textOrientation = {
    noPrefill: ['text-orientation'],
    supportedProperty: function supportedProperty(prop) {
      if (prop !== 'text-orientation') return false;

      if (prefix.vendor === 'apple' && !prefix.isTouch) {
        return prefix.css + prop;
      }

      return prop;
    }
  }; // https://caniuse.com/#search=transform

  var transform = {
    noPrefill: ['transform'],
    supportedProperty: function supportedProperty(prop, style, options) {
      if (prop !== 'transform') return false;

      if (options.transform) {
        return prop;
      }

      return prefix.css + prop;
    }
  }; // https://caniuse.com/#search=transition

  var transition = {
    noPrefill: ['transition'],
    supportedProperty: function supportedProperty(prop, style, options) {
      if (prop !== 'transition') return false;

      if (options.transition) {
        return prop;
      }

      return prefix.css + prop;
    }
  }; // https://caniuse.com/#search=writing-mode

  var writingMode = {
    noPrefill: ['writing-mode'],
    supportedProperty: function supportedProperty(prop) {
      if (prop !== 'writing-mode') return false;

      if (prefix.js === 'Webkit' || prefix.js === 'ms' && prefix.browser !== 'edge') {
        return prefix.css + prop;
      }

      return prop;
    }
  }; // https://caniuse.com/#search=user-select

  var userSelect = {
    noPrefill: ['user-select'],
    supportedProperty: function supportedProperty(prop) {
      if (prop !== 'user-select') return false;

      if (prefix.js === 'Moz' || prefix.js === 'ms' || prefix.vendor === 'apple') {
        return prefix.css + prop;
      }

      return prop;
    }
  }; // https://caniuse.com/#search=multicolumn
  // https://github.com/postcss/autoprefixer/issues/491
  // https://github.com/postcss/autoprefixer/issues/177

  var breakPropsOld = {
    supportedProperty: function supportedProperty(prop, style) {
      if (!/^break-/.test(prop)) return false;

      if (prefix.js === 'Webkit') {
        var jsProp = "WebkitColumn" + pascalize(prop);
        return jsProp in style ? prefix.css + "column-" + prop : false;
      }

      if (prefix.js === 'Moz') {
        var _jsProp = "page" + pascalize(prop);

        return _jsProp in style ? "page-" + prop : false;
      }

      return false;
    }
  }; // See https://github.com/postcss/autoprefixer/issues/324.

  var inlineLogicalOld = {
    supportedProperty: function supportedProperty(prop, style) {
      if (!/^(border|margin|padding)-inline/.test(prop)) return false;
      if (prefix.js === 'Moz') return prop;
      var newProp = prop.replace('-inline', '');
      return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
    }
  }; // Camelization is required because we can't test using.
  // CSS syntax for e.g. in FF.

  var unprefixed = {
    supportedProperty: function supportedProperty(prop, style) {
      return camelize(prop) in style ? prop : false;
    }
  };
  var prefixed = {
    supportedProperty: function supportedProperty(prop, style) {
      var pascalized = pascalize(prop); // Return custom CSS variable without prefixing.

      if (prop[0] === '-') return prop; // Return already prefixed value without prefixing.

      if (prop[0] === '-' && prop[1] === '-') return prop;
      if (prefix.js + pascalized in style) return prefix.css + prop; // Try webkit fallback.

      if (prefix.js !== 'Webkit' && "Webkit" + pascalized in style) return "-webkit-" + prop;
      return false;
    }
  }; // https://caniuse.com/#search=scroll-snap

  var scrollSnap = {
    supportedProperty: function supportedProperty(prop) {
      if (prop.substring(0, 11) !== 'scroll-snap') return false;

      if (prefix.js === 'ms') {
        return "" + prefix.css + prop;
      }

      return prop;
    }
  }; // https://caniuse.com/#search=overscroll-behavior

  var overscrollBehavior = {
    supportedProperty: function supportedProperty(prop) {
      if (prop !== 'overscroll-behavior') return false;

      if (prefix.js === 'ms') {
        return prefix.css + "scroll-chaining";
      }

      return prop;
    }
  };
  var propMap = {
    'flex-grow': 'flex-positive',
    'flex-shrink': 'flex-negative',
    'flex-basis': 'flex-preferred-size',
    'justify-content': 'flex-pack',
    order: 'flex-order',
    'align-items': 'flex-align',
    'align-content': 'flex-line-pack' // 'align-self' is handled by 'align-self' plugin.

  }; // Support old flex spec from 2012.

  var flex2012 = {
    supportedProperty: function supportedProperty(prop, style) {
      var newProp = propMap[prop];
      if (!newProp) return false;
      return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
    }
  };
  var propMap$1 = {
    flex: 'box-flex',
    'flex-grow': 'box-flex',
    'flex-direction': ['box-orient', 'box-direction'],
    order: 'box-ordinal-group',
    'align-items': 'box-align',
    'flex-flow': ['box-orient', 'box-direction'],
    'justify-content': 'box-pack'
  };
  var propKeys = Object.keys(propMap$1);

  var prefixCss = function prefixCss(p) {
    return prefix.css + p;
  }; // Support old flex spec from 2009.


  var flex2009 = {
    supportedProperty: function supportedProperty(prop, style, _ref) {
      var multiple = _ref.multiple;

      if (propKeys.indexOf(prop) > -1) {
        var newProp = propMap$1[prop];

        if (!Array.isArray(newProp)) {
          return prefix.js + pascalize(newProp) in style ? prefix.css + newProp : false;
        }

        if (!multiple) return false;

        for (var i = 0; i < newProp.length; i++) {
          if (!(prefix.js + pascalize(newProp[0]) in style)) {
            return false;
          }
        }

        return newProp.map(prefixCss);
      }

      return false;
    }
  }; // plugins = [
  //   ...plugins,
  //    breakPropsOld,
  //    inlineLogicalOld,
  //    unprefixed,
  //    prefixed,
  //    scrollSnap,
  //    flex2012,
  //    flex2009
  // ]
  // Plugins without 'noPrefill' value, going last.
  // 'flex-*' plugins should be at the bottom.
  // 'flex2009' going after 'flex2012'.
  // 'prefixed' going after 'unprefixed'

  var plugins = [appearence, colorAdjust, mask, textOrientation, transform, transition, writingMode, userSelect, breakPropsOld, inlineLogicalOld, unprefixed, prefixed, scrollSnap, overscrollBehavior, flex2012, flex2009];
  var propertyDetectors = plugins.filter(function (p) {
    return p.supportedProperty;
  }).map(function (p) {
    return p.supportedProperty;
  });
  var noPrefill = plugins.filter(function (p) {
    return p.noPrefill;
  }).reduce(function (a, p) {
    a.push.apply(a, _toConsumableArray(p.noPrefill));
    return a;
  }, []);
  var el;
  var cache = {};

  if (isBrowser$1) {
    el = document.createElement('p'); // We test every property on vendor prefix requirement.
    // Once tested, result is cached. It gives us up to 70% perf boost.
    // http://jsperf.com/element-style-object-access-vs-plain-object
    //
    // Prefill cache with known css properties to reduce amount of
    // properties we need to feature test at runtime.
    // http://davidwalsh.name/vendor-prefix

    var computed = window.getComputedStyle(document.documentElement, '');

    for (var key$1 in computed) {
      // eslint-disable-next-line no-restricted-globals
      if (!isNaN(key$1)) cache[computed[key$1]] = computed[key$1];
    } // Properties that cannot be correctly detected using the
    // cache prefill method.


    noPrefill.forEach(function (x) {
      return delete cache[x];
    });
  }
  /**
   * Test if a property is supported, returns supported property with vendor
   * prefix if required. Returns `false` if not supported.
   *
   * @param {String} prop dash separated
   * @param {Object} [options]
   * @return {String|Boolean}
   * @api public
   */


  function supportedProperty(prop, options) {
    if (options === void 0) {
      options = {};
    } // For server-side rendering.


    if (!el) return prop; // Remove cache for benchmark tests or return property from the cache.

    if (cache[prop] != null) {
      return cache[prop];
    } // Check if 'transition' or 'transform' natively supported in browser.


    if (prop === 'transition' || prop === 'transform') {
      options[prop] = prop in el.style;
    } // Find a plugin for current prefix property.


    for (var i = 0; i < propertyDetectors.length; i++) {
      cache[prop] = propertyDetectors[i](prop, el.style, options); // Break loop, if value found.

      if (cache[prop]) break;
    } // Reset styles for current property.
    // Firefox can even throw an error for invalid properties, e.g., "0".


    try {
      el.style[prop] = '';
    } catch (err) {
      return false;
    }

    return cache[prop];
  }

  var cache$1 = {};
  var transitionProperties = {
    transition: 1,
    'transition-property': 1,
    '-webkit-transition': 1,
    '-webkit-transition-property': 1
  };
  var transPropsRegExp = /(^\s*[\w-]+)|, (\s*[\w-]+)(?![^()]*\))/g;
  var el$1;
  /**
   * Returns prefixed value transition/transform if needed.
   *
   * @param {String} match
   * @param {String} p1
   * @param {String} p2
   * @return {String}
   * @api private
   */

  function prefixTransitionCallback(match, p1, p2) {
    if (p1 === 'var') return 'var';
    if (p1 === 'all') return 'all';
    if (p2 === 'all') return ', all';
    var prefixedValue = p1 ? supportedProperty(p1) : ", " + supportedProperty(p2);
    if (!prefixedValue) return p1 || p2;
    return prefixedValue;
  }

  if (isBrowser$1) el$1 = document.createElement('p');
  /**
   * Returns prefixed value if needed. Returns `false` if value is not supported.
   *
   * @param {String} property
   * @param {String} value
   * @return {String|Boolean}
   * @api public
   */

  function supportedValue(property, value) {
    // For server-side rendering.
    var prefixedValue = value;
    if (!el$1 || property === 'content') return value; // It is a string or a number as a string like '1'.
    // We want only prefixable values here.
    // eslint-disable-next-line no-restricted-globals

    if (typeof prefixedValue !== 'string' || !isNaN(parseInt(prefixedValue, 10))) {
      return prefixedValue;
    } // Create cache key for current value.


    var cacheKey = property + prefixedValue; // Remove cache for benchmark tests or return value from cache.

    if (cache$1[cacheKey] != null) {
      return cache$1[cacheKey];
    } // IE can even throw an error in some cases, for e.g. style.content = 'bar'.


    try {
      // Test value as it is.
      el$1.style[property] = prefixedValue;
    } catch (err) {
      // Return false if value not supported.
      cache$1[cacheKey] = false;
      return false;
    } // If 'transition' or 'transition-property' property.


    if (transitionProperties[property]) {
      prefixedValue = prefixedValue.replace(transPropsRegExp, prefixTransitionCallback);
    } else if (el$1.style[property] === '') {
      // Value with a vendor prefix.
      prefixedValue = prefix.css + prefixedValue; // Hardcode test to convert "flex" to "-ms-flexbox" for IE10.

      if (prefixedValue === '-ms-flex') el$1.style[property] = '-ms-flexbox'; // Test prefixed value.

      el$1.style[property] = prefixedValue; // Return false if value not supported.

      if (el$1.style[property] === '') {
        cache$1[cacheKey] = false;
        return false;
      }
    } // Reset styles for current property.


    el$1.style[property] = ''; // Write current value to cache.

    cache$1[cacheKey] = prefixedValue;
    return cache$1[cacheKey];
  }

  /**
   * Add vendor prefix to a property name when needed.
   */

  function jssVendorPrefixer() {
    function onProcessRule(rule) {
      if (rule.type === 'keyframes') {
        var atRule = rule;
        atRule.at = supportedKeyframes(atRule.at);
      }
    }

    function prefixStyle(style) {
      for (var prop in style) {
        var value = style[prop];

        if (prop === 'fallbacks' && Array.isArray(value)) {
          style[prop] = value.map(prefixStyle);
          continue;
        }

        var changeProp = false;
        var supportedProp = supportedProperty(prop);
        if (supportedProp && supportedProp !== prop) changeProp = true;
        var changeValue = false;
        var supportedValue$1 = supportedValue(supportedProp, toCssValue(value));
        if (supportedValue$1 && supportedValue$1 !== value) changeValue = true;

        if (changeProp || changeValue) {
          if (changeProp) delete style[prop];
          style[supportedProp || prop] = supportedValue$1 || value;
        }
      }

      return style;
    }

    function onProcessStyle(style, rule) {
      if (rule.type !== 'style') return style;
      return prefixStyle(style);
    }

    function onChangeValue(value, prop) {
      return supportedValue(prop, toCssValue(value)) || value;
    }

    return {
      onProcessRule: onProcessRule,
      onProcessStyle: onProcessStyle,
      onChangeValue: onChangeValue
    };
  }

  /**
   * Sort props by length.
   */
  function jssPropsSort() {
    var sort = function sort(prop0, prop1) {
      if (prop0.length === prop1.length) {
        return prop0 > prop1 ? 1 : -1;
      }

      return prop0.length - prop1.length;
    };

    return {
      onProcessStyle: function onProcessStyle(style, rule) {
        if (rule.type !== 'style') return style;
        var newStyle = {};
        var props = Object.keys(style).sort(sort);

        for (var i = 0; i < props.length; i++) {
          newStyle[props[i]] = style[props[i]];
        }

        return newStyle;
      }
    };
  }

  function jssPreset() {
    return {
      plugins: [functions(), jssGlobal(), jssNested(), camelCase(), defaultUnit(), // Disable the vendor prefixer server-side, it does nothing.
      // This way, we can get a performance boost.
      // In the documentation, we are using `autoprefixer` to solve this problem.
      typeof window === 'undefined' ? null : jssVendorPrefixer(), jssPropsSort()]
    };
  }

  function mergeClasses() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var baseClasses = options.baseClasses,
        newClasses = options.newClasses,
        Component = options.Component;

    if (!newClasses) {
      return baseClasses;
    }

    var nextClasses = _extends$1({}, baseClasses);

    {
      if (typeof newClasses === 'string') {
        console.error(["Material-UI: The value `".concat(newClasses, "` ") + "provided to the classes prop of ".concat(getDisplayName(Component), " is incorrect."), 'You might want to use the className prop instead.'].join('\n'));
        return baseClasses;
      }
    }

    Object.keys(newClasses).forEach(function (key) {
      {
        if (!baseClasses[key] && newClasses[key]) {
          console.error(["Material-UI: The key `".concat(key, "` ") + "provided to the classes prop is not implemented in ".concat(getDisplayName(Component), "."), "You can only override one of the following: ".concat(Object.keys(baseClasses).join(','), ".")].join('\n'));
        }

        if (newClasses[key] && typeof newClasses[key] !== 'string') {
          console.error(["Material-UI: The key `".concat(key, "` ") + "provided to the classes prop is not valid for ".concat(getDisplayName(Component), "."), "You need to provide a non empty string instead of: ".concat(newClasses[key], ".")].join('\n'));
        }
      }

      if (newClasses[key]) {
        nextClasses[key] = "".concat(baseClasses[key], " ").concat(newClasses[key]);
      }
    });
    return nextClasses;
  }

  // Used https://github.com/thinkloop/multi-key-cache as inspiration
  var multiKeyStore = {
    set: function set(cache, key1, key2, value) {
      var subCache = cache.get(key1);

      if (!subCache) {
        subCache = new Map();
        cache.set(key1, subCache);
      }

      subCache.set(key2, value);
    },
    get: function get(cache, key1, key2) {
      var subCache = cache.get(key1);
      return subCache ? subCache.get(key2) : undefined;
    },
    delete: function _delete(cache, key1, key2) {
      var subCache = cache.get(key1);
      subCache.delete(key2);
    }
  };
  var multiKeyStore$1 = multiKeyStore;

  var ThemeContext = React__default["default"].createContext(null);

  {
    ThemeContext.displayName = 'ThemeContext';
  }

  var ThemeContext$1 = ThemeContext;

  function useTheme$1() {
    var theme = React__default["default"].useContext(ThemeContext$1);

    {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React__default["default"].useDebugValue(theme);
    }

    return theme;
  }

  var jss = createJss(jssPreset()); // Use a singleton or the provided one by the context.
  //
  // The counter-based approach doesn't tolerate any mistake.
  // It's much safer to use the same counter everywhere.

  var generateClassName = createGenerateClassName(); // Exported for test purposes

  var sheetsManager = new Map();
  var defaultOptions = {
    disableGeneration: false,
    generateClassName: generateClassName,
    jss: jss,
    sheetsCache: null,
    sheetsManager: sheetsManager,
    sheetsRegistry: null
  };
  var StylesContext = React__default["default"].createContext(defaultOptions);

  {
    StylesContext.displayName = 'StylesContext';
  }

  var injectFirstNode;
  function StylesProvider(props) {
    var children = props.children,
        _props$injectFirst = props.injectFirst,
        injectFirst = _props$injectFirst === void 0 ? false : _props$injectFirst,
        _props$disableGenerat = props.disableGeneration,
        disableGeneration = _props$disableGenerat === void 0 ? false : _props$disableGenerat,
        localOptions = _objectWithoutProperties(props, ["children", "injectFirst", "disableGeneration"]);

    var outerOptions = React__default["default"].useContext(StylesContext);

    var context = _extends$1({}, outerOptions, {
      disableGeneration: disableGeneration
    }, localOptions);

    {
      if (typeof window === 'undefined' && !context.sheetsManager) {
        console.error('Material-UI: You need to use the ServerStyleSheets API when rendering on the server.');
      }
    }

    {
      if (context.jss.options.insertionPoint && injectFirst) {
        console.error('Material-UI: You cannot use a custom insertionPoint and <StylesContext injectFirst> at the same time.');
      }
    }

    {
      if (injectFirst && localOptions.jss) {
        console.error('Material-UI: You cannot use the jss and injectFirst props at the same time.');
      }
    }

    if (!context.jss.options.insertionPoint && injectFirst && typeof window !== 'undefined') {
      if (!injectFirstNode) {
        var head = document.head;
        injectFirstNode = document.createComment('mui-inject-first');
        head.insertBefore(injectFirstNode, head.firstChild);
      }

      context.jss = createJss({
        plugins: jssPreset().plugins,
        insertionPoint: injectFirstNode
      });
    }

    return /*#__PURE__*/React__default["default"].createElement(StylesContext.Provider, {
      value: context
    }, children);
  }
  StylesProvider.propTypes = {
    /**
     * Your component tree.
     */
    children: PropTypes.node.isRequired,

    /**
     * You can disable the generation of the styles with this option.
     * It can be useful when traversing the React tree outside of the HTML
     * rendering step on the server.
     * Let's say you are using react-apollo to extract all
     * the queries made by the interface server-side - you can significantly speed up the traversal with this prop.
     */
    disableGeneration: PropTypes.bool,

    /**
     * JSS's class name generator.
     */
    generateClassName: PropTypes.func,

    /**
     * By default, the styles are injected last in the <head> element of the page.
     * As a result, they gain more specificity than any other style sheet.
     * If you want to override Material-UI's styles, set this prop.
     */
    injectFirst: PropTypes.bool,

    /**
     * JSS's instance.
     */
    jss: PropTypes.object,

    /**
     * @ignore
     */
    serverGenerateClassName: PropTypes.func,

    /**
     * @ignore
     *
     * Beta feature.
     *
     * Cache for the sheets.
     */
    sheetsCache: PropTypes.object,

    /**
     * @ignore
     *
     * The sheetsManager is used to deduplicate style sheet injection in the page.
     * It's deduplicating using the (theme, styles) couple.
     * On the server, you should provide a new instance for each request.
     */
    sheetsManager: PropTypes.object,

    /**
     * @ignore
     *
     * Collect the sheets.
     */
    sheetsRegistry: PropTypes.object
  } ;

  {
    StylesProvider.propTypes = exactProp(StylesProvider.propTypes) ;
  }

  /* eslint-disable import/prefer-default-export */
  // Global index counter to preserve source order.
  // We create the style sheet during the creation of the component,
  // children are handled after the parents, so the order of style elements would be parent->child.
  // It is a problem though when a parent passes a className
  // which needs to override any child's styles.
  // StyleSheet of the child has a higher specificity, because of the source order.
  // So our solution is to render sheets them in the reverse order child->sheet, so
  // that parent has a higher specificity.
  var indexCounter = -1e9;
  function increment() {
    indexCounter += 1;

    {
      if (indexCounter >= 0) {
        console.warn(['Material-UI: You might have a memory leak.', 'The indexCounter is not supposed to grow that much.'].join('\n'));
      }
    }

    return indexCounter;
  }

  // We use the same empty object to ref count the styles that don't need a theme object.
  var noopTheme = {};
  var noopTheme$1 = noopTheme;

  function getStylesCreator(stylesOrCreator) {
    var themingEnabled = typeof stylesOrCreator === 'function';

    {
      if (_typeof$1(stylesOrCreator) !== 'object' && !themingEnabled) {
        console.error(['Material-UI: The `styles` argument provided is invalid.', 'You need to provide a function generating the styles or a styles object.'].join('\n'));
      }
    }

    return {
      create: function create(theme, name) {
        var styles;

        try {
          styles = themingEnabled ? stylesOrCreator(theme) : stylesOrCreator;
        } catch (err) {
          {
            if (themingEnabled === true && theme === noopTheme$1) {
              // TODO: prepend error message/name instead
              console.error(['Material-UI: The `styles` argument provided is invalid.', 'You are providing a function without a theme in the context.', 'One of the parent elements needs to use a ThemeProvider.'].join('\n'));
            }
          }

          throw err;
        }

        if (!name || !theme.overrides || !theme.overrides[name]) {
          return styles;
        }

        var overrides = theme.overrides[name];

        var stylesWithOverrides = _extends$1({}, styles);

        Object.keys(overrides).forEach(function (key) {
          {
            if (!stylesWithOverrides[key]) {
              console.warn(['Material-UI: You are trying to override a style that does not exist.', "Fix the `".concat(key, "` key of `theme.overrides.").concat(name, "`.")].join('\n'));
            }
          }

          stylesWithOverrides[key] = deepmerge(stylesWithOverrides[key], overrides[key]);
        });
        return stylesWithOverrides;
      },
      options: {}
    };
  }

  function getClasses(_ref, classes, Component) {
    var state = _ref.state,
        stylesOptions = _ref.stylesOptions;

    if (stylesOptions.disableGeneration) {
      return classes || {};
    }

    if (!state.cacheClasses) {
      state.cacheClasses = {
        // Cache for the finalized classes value.
        value: null,
        // Cache for the last used classes prop pointer.
        lastProp: null,
        // Cache for the last used rendered classes pointer.
        lastJSS: {}
      };
    } // Tracks if either the rendered classes or classes prop has changed,
    // requiring the generation of a new finalized classes object.


    var generate = false;

    if (state.classes !== state.cacheClasses.lastJSS) {
      state.cacheClasses.lastJSS = state.classes;
      generate = true;
    }

    if (classes !== state.cacheClasses.lastProp) {
      state.cacheClasses.lastProp = classes;
      generate = true;
    }

    if (generate) {
      state.cacheClasses.value = mergeClasses({
        baseClasses: state.cacheClasses.lastJSS,
        newClasses: classes,
        Component: Component
      });
    }

    return state.cacheClasses.value;
  }

  function attach(_ref2, props) {
    var state = _ref2.state,
        theme = _ref2.theme,
        stylesOptions = _ref2.stylesOptions,
        stylesCreator = _ref2.stylesCreator,
        name = _ref2.name;

    if (stylesOptions.disableGeneration) {
      return;
    }

    var sheetManager = multiKeyStore$1.get(stylesOptions.sheetsManager, stylesCreator, theme);

    if (!sheetManager) {
      sheetManager = {
        refs: 0,
        staticSheet: null,
        dynamicStyles: null
      };
      multiKeyStore$1.set(stylesOptions.sheetsManager, stylesCreator, theme, sheetManager);
    }

    var options = _extends$1({}, stylesCreator.options, stylesOptions, {
      theme: theme,
      flip: typeof stylesOptions.flip === 'boolean' ? stylesOptions.flip : theme.direction === 'rtl'
    });

    options.generateId = options.serverGenerateClassName || options.generateClassName;
    var sheetsRegistry = stylesOptions.sheetsRegistry;

    if (sheetManager.refs === 0) {
      var staticSheet;

      if (stylesOptions.sheetsCache) {
        staticSheet = multiKeyStore$1.get(stylesOptions.sheetsCache, stylesCreator, theme);
      }

      var styles = stylesCreator.create(theme, name);

      if (!staticSheet) {
        staticSheet = stylesOptions.jss.createStyleSheet(styles, _extends$1({
          link: false
        }, options));
        staticSheet.attach();

        if (stylesOptions.sheetsCache) {
          multiKeyStore$1.set(stylesOptions.sheetsCache, stylesCreator, theme, staticSheet);
        }
      }

      if (sheetsRegistry) {
        sheetsRegistry.add(staticSheet);
      }

      sheetManager.staticSheet = staticSheet;
      sheetManager.dynamicStyles = getDynamicStyles(styles);
    }

    if (sheetManager.dynamicStyles) {
      var dynamicSheet = stylesOptions.jss.createStyleSheet(sheetManager.dynamicStyles, _extends$1({
        link: true
      }, options));
      dynamicSheet.update(props);
      dynamicSheet.attach();
      state.dynamicSheet = dynamicSheet;
      state.classes = mergeClasses({
        baseClasses: sheetManager.staticSheet.classes,
        newClasses: dynamicSheet.classes
      });

      if (sheetsRegistry) {
        sheetsRegistry.add(dynamicSheet);
      }
    } else {
      state.classes = sheetManager.staticSheet.classes;
    }

    sheetManager.refs += 1;
  }

  function update$1(_ref3, props) {
    var state = _ref3.state;

    if (state.dynamicSheet) {
      state.dynamicSheet.update(props);
    }
  }

  function detach(_ref4) {
    var state = _ref4.state,
        theme = _ref4.theme,
        stylesOptions = _ref4.stylesOptions,
        stylesCreator = _ref4.stylesCreator;

    if (stylesOptions.disableGeneration) {
      return;
    }

    var sheetManager = multiKeyStore$1.get(stylesOptions.sheetsManager, stylesCreator, theme);
    sheetManager.refs -= 1;
    var sheetsRegistry = stylesOptions.sheetsRegistry;

    if (sheetManager.refs === 0) {
      multiKeyStore$1.delete(stylesOptions.sheetsManager, stylesCreator, theme);
      stylesOptions.jss.removeStyleSheet(sheetManager.staticSheet);

      if (sheetsRegistry) {
        sheetsRegistry.remove(sheetManager.staticSheet);
      }
    }

    if (state.dynamicSheet) {
      stylesOptions.jss.removeStyleSheet(state.dynamicSheet);

      if (sheetsRegistry) {
        sheetsRegistry.remove(state.dynamicSheet);
      }
    }
  }

  function useSynchronousEffect(func, values) {
    var key = React__default["default"].useRef([]);
    var output; // Store "generation" key. Just returns a new object every time

    var currentKey = React__default["default"].useMemo(function () {
      return {};
    }, values); // eslint-disable-line react-hooks/exhaustive-deps
    // "the first render", or "memo dropped the value"

    if (key.current !== currentKey) {
      key.current = currentKey;
      output = func();
    }

    React__default["default"].useEffect(function () {
      return function () {
        if (output) {
          output();
        }
      };
    }, [currentKey] // eslint-disable-line react-hooks/exhaustive-deps
    );
  }

  function makeStyles(stylesOrCreator) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var name = options.name,
        classNamePrefixOption = options.classNamePrefix,
        Component = options.Component,
        _options$defaultTheme = options.defaultTheme,
        defaultTheme = _options$defaultTheme === void 0 ? noopTheme$1 : _options$defaultTheme,
        stylesOptions2 = _objectWithoutProperties(options, ["name", "classNamePrefix", "Component", "defaultTheme"]);

    var stylesCreator = getStylesCreator(stylesOrCreator);
    var classNamePrefix = name || classNamePrefixOption || 'makeStyles';
    stylesCreator.options = {
      index: increment(),
      name: name,
      meta: classNamePrefix,
      classNamePrefix: classNamePrefix
    };

    var useStyles = function useStyles() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var theme = useTheme$1() || defaultTheme;

      var stylesOptions = _extends$1({}, React__default["default"].useContext(StylesContext), stylesOptions2);

      var instance = React__default["default"].useRef();
      var shouldUpdate = React__default["default"].useRef();
      useSynchronousEffect(function () {
        var current = {
          name: name,
          state: {},
          stylesCreator: stylesCreator,
          stylesOptions: stylesOptions,
          theme: theme
        };
        attach(current, props);
        shouldUpdate.current = false;
        instance.current = current;
        return function () {
          detach(current);
        };
      }, [theme, stylesCreator]);
      React__default["default"].useEffect(function () {
        if (shouldUpdate.current) {
          update$1(instance.current, props);
        }

        shouldUpdate.current = true;
      });
      var classes = getClasses(instance.current, props.classes, Component);

      {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        React__default["default"].useDebugValue(classes);
      }

      return classes;
    };

    return useStyles;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var reactIs = reactIs$1.exports;
  /**
   * Copyright 2015, Yahoo! Inc.
   * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
   */


  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    '$$typeof': true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    '$$typeof': true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

  function getStatics(component) {
    // React v16.11 and below
    if (reactIs.isMemo(component)) {
      return MEMO_STATICS;
    } // React v16.12 and above


    return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
  }

  var defineProperty$1 = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;

  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
      // don't hoist over string (html) components
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf(sourceComponent);

        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
      }

      var keys = getOwnPropertyNames(sourceComponent);

      if (getOwnPropertySymbols) {
        keys = keys.concat(getOwnPropertySymbols(sourceComponent));
      }

      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);

      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];

        if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
          var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

          try {
            // Avoid failures from read-only properties
            defineProperty$1(targetComponent, key, descriptor);
          } catch (e) {}
        }
      }
    }

    return targetComponent;
  }

  var hoistNonReactStatics_cjs = hoistNonReactStatics;

  // It does not modify the component passed to it;
  // instead, it returns a new component, with a `classes` property.

  var withStyles$1 = function withStyles(stylesOrCreator) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function (Component) {
      var defaultTheme = options.defaultTheme,
          _options$withTheme = options.withTheme,
          withTheme = _options$withTheme === void 0 ? false : _options$withTheme,
          name = options.name,
          stylesOptions = _objectWithoutProperties(options, ["defaultTheme", "withTheme", "name"]);

      {
        if (Component === undefined) {
          throw new Error(['You are calling withStyles(styles)(Component) with an undefined component.', 'You may have forgotten to import it.'].join('\n'));
        }
      }

      var classNamePrefix = name;

      {
        if (!name) {
          // Provide a better DX outside production.
          var displayName = getDisplayName(Component);

          if (displayName !== undefined) {
            classNamePrefix = displayName;
          }
        }
      }

      var useStyles = makeStyles(stylesOrCreator, _extends$1({
        defaultTheme: defaultTheme,
        Component: Component,
        name: name || Component.displayName,
        classNamePrefix: classNamePrefix
      }, stylesOptions));
      var WithStyles = /*#__PURE__*/React__default["default"].forwardRef(function WithStyles(props, ref) {
        props.classes;
            var innerRef = props.innerRef,
            other = _objectWithoutProperties(props, ["classes", "innerRef"]); // The wrapper receives only user supplied props, which could be a subset of
        // the actual props Component might receive due to merging with defaultProps.
        // So copying it here would give us the same result in the wrapper as well.


        var classes = useStyles(_extends$1({}, Component.defaultProps, props));
        var theme;
        var more = other;

        if (typeof name === 'string' || withTheme) {
          // name and withTheme are invariant in the outer scope
          // eslint-disable-next-line react-hooks/rules-of-hooks
          theme = useTheme$1() || defaultTheme;

          if (name) {
            more = getThemeProps({
              theme: theme,
              name: name,
              props: other
            });
          } // Provide the theme to the wrapped component.
          // So we don't have to use the `withTheme()` Higher-order Component.


          if (withTheme && !more.theme) {
            more.theme = theme;
          }
        }

        return /*#__PURE__*/React__default["default"].createElement(Component, _extends$1({
          ref: innerRef || ref,
          classes: classes
        }, more));
      });
      WithStyles.propTypes = {
        /**
         * Override or extend the styles applied to the component.
         */
        classes: PropTypes.object,

        /**
         * Use that prop to pass a ref to the decorated component.
         * @deprecated
         */
        innerRef: chainPropTypes(PropTypes.oneOfType([PropTypes.func, PropTypes.object]), function (props) {
          if (props.innerRef == null) {
            return null;
          }

          return null; // return new Error(
          //   'Material-UI: The `innerRef` prop is deprecated and will be removed in v5. ' +
          //     'Refs are now automatically forwarded to the inner component.',
          // );
        })
      } ;

      {
        WithStyles.displayName = "WithStyles(".concat(getDisplayName(Component), ")");
      }

      hoistNonReactStatics_cjs(WithStyles, Component);

      {
        // Exposed for test purposes.
        WithStyles.Naked = Component;
        WithStyles.options = options;
        WithStyles.useStyles = useStyles;
      }

      return WithStyles;
    };
  };

  var withStylesWithoutDefault = withStyles$1;

  var defaultTheme = createTheme();
  var defaultTheme$1 = defaultTheme;

  function useTheme() {
    var theme = useTheme$1() || defaultTheme$1;

    {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React__default["default"].useDebugValue(theme);
    }

    return theme;
  }

  function withStyles(stylesOrCreator, options) {
    return withStylesWithoutDefault(stylesOrCreator, _extends$1({
      defaultTheme: defaultTheme$1
    }, options));
  }

  /**!
   * @fileOverview Kickass library to create and place poppers near their reference elements.
   * @version 1.16.1-lts
   * @license
   * Copyright (c) 2016 Federico Zivolo and contributors
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

  var timeoutDuration = function () {
    var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];

    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
      if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
        return 1;
      }
    }

    return 0;
  }();

  function microtaskDebounce(fn) {
    var called = false;
    return function () {
      if (called) {
        return;
      }

      called = true;
      window.Promise.resolve().then(function () {
        called = false;
        fn();
      });
    };
  }

  function taskDebounce(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }

  var supportsMicroTasks = isBrowser && window.Promise;
  /**
  * Create a debounced version of a method, that's asynchronously deferred
  * but called in the minimum time possible.
  *
  * @method
  * @memberof Popper.Utils
  * @argument {Function} fn
  * @returns {Function}
  */

  var debounce$1 = supportsMicroTasks ? microtaskDebounce : taskDebounce;
  /**
   * Check if the given variable is a function
   * @method
   * @memberof Popper.Utils
   * @argument {Any} functionToCheck - variable to check
   * @returns {Boolean} answer to: is a function?
   */

  function isFunction(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }
  /**
   * Get CSS computed property of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Eement} element
   * @argument {String} property
   */


  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    } // NOTE: 1 DOM access here


    var window = element.ownerDocument.defaultView;
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
  }
  /**
   * Returns the parentNode or the host of the element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} parent
   */


  function getParentNode(element) {
    if (element.nodeName === 'HTML') {
      return element;
    }

    return element.parentNode || element.host;
  }
  /**
   * Returns the scrolling parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} scroll parent
   */


  function getScrollParent$1(element) {
    // Return body, `getScroll` will take care to get the correct `scrollTop` from it
    if (!element) {
      return document.body;
    }

    switch (element.nodeName) {
      case 'HTML':
      case 'BODY':
        return element.ownerDocument.body;

      case '#document':
        return element.body;
    } // Firefox want us to check `-x` and `-y` variations as well


    var _getStyleComputedProp = getStyleComputedProperty(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;

    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return element;
    }

    return getScrollParent$1(getParentNode(element));
  }
  /**
   * Returns the reference node of the reference object, or the reference object itself.
   * @method
   * @memberof Popper.Utils
   * @param {Element|Object} reference - the reference element (the popper will be relative to this)
   * @returns {Element} parent
   */


  function getReferenceNode(reference) {
    return reference && reference.referenceNode ? reference.referenceNode : reference;
  }

  var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
  var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
  /**
   * Determines if the browser is Internet Explorer
   * @method
   * @memberof Popper.Utils
   * @param {Number} version to check
   * @returns {Boolean} isIE
   */

  function isIE(version) {
    if (version === 11) {
      return isIE11;
    }

    if (version === 10) {
      return isIE10;
    }

    return isIE11 || isIE10;
  }
  /**
   * Returns the offset parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} offset parent
   */


  function getOffsetParent(element) {
    if (!element) {
      return document.documentElement;
    }

    var noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here

    var offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent

    while (offsetParent === noOffsetParent && element.nextElementSibling) {
      offsetParent = (element = element.nextElementSibling).offsetParent;
    }

    var nodeName = offsetParent && offsetParent.nodeName;

    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
      return element ? element.ownerDocument.documentElement : document.documentElement;
    } // .offsetParent will return the closest TH, TD or TABLE in case
    // no offsetParent is present, I hate this job...


    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
      return getOffsetParent(offsetParent);
    }

    return offsetParent;
  }

  function isOffsetContainer(element) {
    var nodeName = element.nodeName;

    if (nodeName === 'BODY') {
      return false;
    }

    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
  }
  /**
   * Finds the root node (document, shadowDOM root) of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} node
   * @returns {Element} root node
   */


  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }

    return node;
  }
  /**
   * Finds the offset parent common to the two provided nodes
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element1
   * @argument {Element} element2
   * @returns {Element} common offset parent
   */


  function findCommonOffsetParent(element1, element2) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return document.documentElement;
    } // Here we make sure to give as "start" the element that comes first in the DOM


    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1; // Get common ancestor container

    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document

    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }

      return getOffsetParent(commonAncestorContainer);
    } // one of the nodes is inside shadowDOM, find which one


    var element1root = getRoot(element1);

    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }
  /**
   * Gets the scroll value of the given element in the given side (top and left)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {String} side `top` or `left`
   * @returns {number} amount of scrolled pixels
   */


  function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;

    if (nodeName === 'BODY' || nodeName === 'HTML') {
      var html = element.ownerDocument.documentElement;
      var scrollingElement = element.ownerDocument.scrollingElement || html;
      return scrollingElement[upperSide];
    }

    return element[upperSide];
  }
  /*
   * Sum or subtract the element scroll values (left and top) from a given rect object
   * @method
   * @memberof Popper.Utils
   * @param {Object} rect - Rect object you want to change
   * @param {HTMLElement} element - The element from the function reads the scroll values
   * @param {Boolean} subtract - set to true if you want to subtract the scroll values
   * @return {Object} rect - The modifier rect object
   */


  function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var scrollTop = getScroll(element, 'top');
    var scrollLeft = getScroll(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }
  /*
   * Helper to detect borders of a given element
   * @method
   * @memberof Popper.Utils
   * @param {CSSStyleDeclaration} styles
   * Result of `getStyleComputedProperty` on the given element
   * @param {String} axis - `x` or `y`
   * @return {number} borders - The borders size of the given axis
   */


  function getBordersSize(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
    return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
  }

  function getSize(axis, body, html, computedStyle) {
    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
  }

  function getWindowSizes(document) {
    var body = document.body;
    var html = document.documentElement;
    var computedStyle = isIE(10) && getComputedStyle(html);
    return {
      height: getSize('Height', body, html, computedStyle),
      width: getSize('Width', body, html, computedStyle)
    };
  }

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  /**
   * Given element offsets, generate an output similar to getBoundingClientRect
   * @method
   * @memberof Popper.Utils
   * @argument {Object} offsets
   * @returns {Object} ClientRect like output
   */


  function getClientRect(offsets) {
    return _extends({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }
  /**
   * Get bounding client rect of given element
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} element
   * @return {Object} client rect
   */


  function getBoundingClientRect(element) {
    var rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't
    // considered in DOM in some circumstances...
    // This isn't reproducible in IE10 compatibility mode of IE11

    try {
      if (isIE(10)) {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, 'top');
        var scrollLeft = getScroll(element, 'left');
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } else {
        rect = element.getBoundingClientRect();
      }
    } catch (e) {}

    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    }; // subtract scrollbar size from sizes

    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
    var width = sizes.width || element.clientWidth || result.width;
    var height = sizes.height || element.clientHeight || result.height;
    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
    // we make this check conditional for performance reasons

    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, 'x');
      vertScrollbar -= getBordersSize(styles, 'y');
      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }

    return getClientRect(result);
  }

  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var isIE10 = isIE(10);
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent$1(children);
    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = parseFloat(styles.borderTopWidth);
    var borderLeftWidth = parseFloat(styles.borderLeftWidth); // In cases where the parent is fixed, we must ignore negative scroll in offset calc

    if (fixedPosition && isHTML) {
      parentRect.top = Math.max(parentRect.top, 0);
      parentRect.left = Math.max(parentRect.left, 0);
    }

    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent
    // we do this only on HTML because it's the only element that behaves
    // differently when margins are applied to it. The margins are included in
    // the box of the documentElement, in the other cases not.

    if (!isIE10 && isHTML) {
      var marginTop = parseFloat(styles.marginTop);
      var marginLeft = parseFloat(styles.marginLeft);
      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them

      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }

    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
      offsets = includeScroll(offsets, parent);
    }

    return offsets;
  }

  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);
    var scrollTop = !excludeScroll ? getScroll(html) : 0;
    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    };
    return getClientRect(offset);
  }
  /**
   * Check if the given element is fixed or is inside a fixed parent
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {Element} customContainer
   * @returns {Boolean} answer to "isFixed?"
   */


  function isFixed(element) {
    var nodeName = element.nodeName;

    if (nodeName === 'BODY' || nodeName === 'HTML') {
      return false;
    }

    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true;
    }

    var parentNode = getParentNode(element);

    if (!parentNode) {
      return false;
    }

    return isFixed(parentNode);
  }
  /**
   * Finds the first parent of an element that has a transformed property defined
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} first transformed parent or documentElement
   */


  function getFixedPositionOffsetParent(element) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element || !element.parentElement || isIE()) {
      return document.documentElement;
    }

    var el = element.parentElement;

    while (el && getStyleComputedProperty(el, 'transform') === 'none') {
      el = el.parentElement;
    }

    return el || document.documentElement;
  }
  /**
   * Computed the boundaries limits and return them
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} popper
   * @param {HTMLElement} reference
   * @param {number} padding
   * @param {HTMLElement} boundariesElement - Element used to define the boundaries
   * @param {Boolean} fixedPosition - Is in fixed position mode
   * @returns {Object} Coordinates of the boundaries
   */


  function getBoundaries(popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; // NOTE: 1 DOM access here

    var boundaries = {
      top: 0,
      left: 0
    };
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference)); // Handle viewport case

    if (boundariesElement === 'viewport') {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
    } else {
      // Handle other cases based on DOM element used as boundaries
      var boundariesNode = void 0;

      if (boundariesElement === 'scrollParent') {
        boundariesNode = getScrollParent$1(getParentNode(reference));

        if (boundariesNode.nodeName === 'BODY') {
          boundariesNode = popper.ownerDocument.documentElement;
        }
      } else if (boundariesElement === 'window') {
        boundariesNode = popper.ownerDocument.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }

      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation

      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(popper.ownerDocument),
            height = _getWindowSizes.height,
            width = _getWindowSizes.width;

        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        // for all the other DOM elements, this one is good
        boundaries = offsets;
      }
    } // Add paddings


    padding = padding || 0;
    var isPaddingNumber = typeof padding === 'number';
    boundaries.left += isPaddingNumber ? padding : padding.left || 0;
    boundaries.top += isPaddingNumber ? padding : padding.top || 0;
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    return boundaries;
  }

  function getArea(_ref) {
    var width = _ref.width,
        height = _ref.height;
    return width * height;
  }
  /**
   * Utility used to transform the `auto` placement to the placement with more
   * available space.
   * @method
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    if (placement.indexOf('auto') === -1) {
      return placement;
    }

    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };
    var sortedAreas = Object.keys(rects).map(function (key) {
      return _extends({
        key: key
      }, rects[key], {
        area: getArea(rects[key])
      });
    }).sort(function (a, b) {
      return b.area - a.area;
    });
    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });
    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
    var variation = placement.split('-')[1];
    return computedPlacement + (variation ? '-' + variation : '');
  }
  /**
   * Get offsets to the reference element
   * @method
   * @memberof Popper.Utils
   * @param {Object} state
   * @param {Element} popper - the popper element
   * @param {Element} reference - the reference element (the popper will be relative to this)
   * @param {Element} fixedPosition - is in fixed position mode
   * @returns {Object} An object containing the offsets which will be applied to the popper
   */


  function getReferenceOffsets(state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
  }
  /**
   * Get the outer sizes of the given element (offset size + margins)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Object} object containing width and height properties
   */


  function getOuterSizes(element) {
    var window = element.ownerDocument.defaultView;
    var styles = window.getComputedStyle(element);
    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }
  /**
   * Get the opposite placement of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement
   * @returns {String} flipped placement
   */


  function getOppositePlacement(placement) {
    var hash = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }
  /**
   * Get offsets to the popper
   * @method
   * @memberof Popper.Utils
   * @param {Object} position - CSS position the Popper will get applied
   * @param {HTMLElement} popper - the popper element
   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
   * @param {String} placement - one of the valid placement options
   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
   */


  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0]; // Get popper node sizes

    var popperRect = getOuterSizes(popper); // Add position, width and height to our offsets object

    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    }; // depending by the popper placement we have to compute its offsets slightly differently

    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';
    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;

    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }

    return popperOffsets;
  }
  /**
   * Mimics the `find` method of Array
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */


  function find(arr, check) {
    // use native find if supported
    if (Array.prototype.find) {
      return arr.find(check);
    } // use `filter` to obtain the same behavior of `find`


    return arr.filter(check)[0];
  }
  /**
   * Return the index of the matching object
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */


  function findIndex$1(arr, prop, value) {
    // use native findIndex if supported
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    } // use `find` + `indexOf` if `findIndex` isn't supported


    var match = find(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }
  /**
   * Loop trough the list of modifiers and run them in order,
   * each of them will then edit the data object.
   * @method
   * @memberof Popper.Utils
   * @param {dataObject} data
   * @param {Array} modifiers
   * @param {String} ends - Optional modifier name used as stopper
   * @returns {dataObject}
   */


  function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex$1(modifiers, 'name', ends));
    modifiersToRun.forEach(function (modifier) {
      if (modifier['function']) {
        // eslint-disable-line dot-notation
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
      }

      var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation

      if (modifier.enabled && isFunction(fn)) {
        // Add properties to offsets to make them a complete clientRect object
        // we do this before each modifier to make sure the previous one doesn't
        // mess with these values
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);
        data = fn(data, modifier);
      }
    });
    return data;
  }
  /**
   * Updates the position of the popper, computing the new offsets and applying
   * the new style.<br />
   * Prefer `scheduleUpdate` over `update` because of performance reasons.
   * @method
   * @memberof Popper
   */


  function update() {
    // if popper is destroyed, don't perform any further update
    if (this.state.isDestroyed) {
      return;
    }

    var data = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    }; // compute reference element offsets

    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed); // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value

    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding); // store the computed placement inside `originalPlacement`

    data.originalPlacement = data.placement;
    data.positionFixed = this.options.positionFixed; // compute the popper offsets

    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute'; // run the modifiers

    data = runModifiers(this.modifiers, data); // the first `update` will call `onCreate` callback
    // the other ones will call `onUpdate` callback

    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }
  /**
   * Helper used to know if the given modifier is enabled.
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean}
   */


  function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref) {
      var name = _ref.name,
          enabled = _ref.enabled;
      return enabled && name === modifierName;
    });
  }
  /**
   * Get the prefixed supported property name
   * @method
   * @memberof Popper.Utils
   * @argument {String} property (camelCase)
   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
   */


  function getSupportedPropertyName(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i];
      var toCheck = prefix ? '' + prefix + upperProp : property;

      if (typeof document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }

    return null;
  }
  /**
   * Destroys the popper.
   * @method
   * @memberof Popper
   */


  function destroy() {
    this.state.isDestroyed = true; // touch DOM only if `applyStyle` modifier is enabled

    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
      this.popper.removeAttribute('x-placement');
      this.popper.style.position = '';
      this.popper.style.top = '';
      this.popper.style.left = '';
      this.popper.style.right = '';
      this.popper.style.bottom = '';
      this.popper.style.willChange = '';
      this.popper.style[getSupportedPropertyName('transform')] = '';
    }

    this.disableEventListeners(); // remove the popper if user explicitly asked for the deletion on destroy
    // do not use `remove` because IE11 doesn't support it

    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }

    return this;
  }
  /**
   * Get the window associated with the element
   * @argument {Element} element
   * @returns {Window}
   */


  function getWindow(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }

  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event, callback, {
      passive: true
    });

    if (!isBody) {
      attachToScrollParents(getScrollParent$1(target.parentNode), event, callback, scrollParents);
    }

    scrollParents.push(target);
  }
  /**
   * Setup needed event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */


  function setupEventListeners(reference, options, state, updateBound) {
    // Resize event listener on window
    state.updateBound = updateBound;
    getWindow(reference).addEventListener('resize', state.updateBound, {
      passive: true
    }); // Scroll event listener on scroll parents

    var scrollElement = getScrollParent$1(reference);
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;
    return state;
  }
  /**
   * It will add resize/scroll events and start recalculating
   * position of the popper element when they are triggered.
   * @method
   * @memberof Popper
   */


  function enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }
  /**
   * Remove event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */


  function removeEventListeners(reference, state) {
    // Remove resize event listener on window
    getWindow(reference).removeEventListener('resize', state.updateBound); // Remove scroll event listener on scroll parents

    state.scrollParents.forEach(function (target) {
      target.removeEventListener('scroll', state.updateBound);
    }); // Reset state

    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }
  /**
   * It will remove resize/scroll events and won't recalculate popper position
   * when they are triggered. It also won't trigger `onUpdate` callback anymore,
   * unless you call `update` method manually.
   * @method
   * @memberof Popper
   */


  function disableEventListeners() {
    if (this.state.eventsEnabled) {
      cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }
  /**
   * Tells if a given input is a number
   * @method
   * @memberof Popper.Utils
   * @param {*} input to check
   * @return {Boolean}
   */


  function isNumeric(n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
  }
  /**
   * Set the style to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the style to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */


  function setStyles(element, styles) {
    Object.keys(styles).forEach(function (prop) {
      var unit = ''; // add unit if the value is numeric and is one of the following

      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
        unit = 'px';
      }

      element.style[prop] = styles[prop] + unit;
    });
  }
  /**
   * Set the attributes to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the attributes to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */


  function setAttributes(element, attributes) {
    Object.keys(attributes).forEach(function (prop) {
      var value = attributes[prop];

      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} data.styles - List of style properties - values to apply to popper element
   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The same data object
   */


  function applyStyle(data) {
    // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!
    setStyles(data.instance.popper, data.styles); // any property present in `data.attributes` will be applied to the popper,
    // they will be set as HTML attributes of the element

    setAttributes(data.instance.popper, data.attributes); // if arrowElement is defined and arrowStyles has some properties

    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
      setStyles(data.arrowElement, data.arrowStyles);
    }

    return data;
  }
  /**
   * Set the x-placement attribute before everything else because it could be used
   * to add margins to the popper margins needs to be calculated to get the
   * correct popper offsets.
   * @method
   * @memberof Popper.modifiers
   * @param {HTMLElement} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper
   * @param {Object} options - Popper.js options
   */


  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    // compute reference element offsets
    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed); // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value

    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
    popper.setAttribute('x-placement', placement); // Apply `position` to popper before anything else because
    // without the position applied we can't guarantee correct computations

    setStyles(popper, {
      position: options.positionFixed ? 'fixed' : 'absolute'
    });
    return options;
  }
  /**
   * @function
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Boolean} shouldRound - If the offsets should be rounded at all
   * @returns {Object} The popper's position offsets rounded
   *
   * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
   * good as it can be within reason.
   * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
   *
   * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
   * as well on High DPI screens).
   *
   * Firefox prefers no rounding for positioning and does not have blurriness on
   * high DPI screens.
   *
   * Only horizontal placement and left/right values need to be considered.
   */


  function getRoundedOffsets(data, shouldRound) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var round = Math.round,
        floor = Math.floor;

    var noRound = function noRound(v) {
      return v;
    };

    var referenceWidth = round(reference.width);
    var popperWidth = round(popper.width);
    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
    var isVariation = data.placement.indexOf('-') !== -1;
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
    var verticalToInteger = !shouldRound ? noRound : round;
    return {
      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
      top: verticalToInteger(popper.top),
      bottom: verticalToInteger(popper.bottom),
      right: horizontalToInteger(popper.right)
    };
  }

  var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */

  function computeStyle(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper; // Remove this legacy support in Popper.js v2

    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'applyStyle';
    }).gpuAcceleration;

    if (legacyGpuAccelerationOption !== undefined) {
      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }

    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent); // Styles

    var styles = {
      position: popper.position
    };
    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right'; // if gpuAcceleration is set to `true` and transform is supported,
    //  we use `translate3d` to apply the position to the popper we
    // automatically use the supported prefixed version if needed

    var prefixedProperty = getSupportedPropertyName('transform'); // now, let's make a step back and look at this code closely (wtf?)
    // If the content of the popper grows once it's been positioned, it
    // may happen that the popper gets misplaced because of the new content
    // overflowing its reference element
    // To avoid this problem, we provide two options (x and y), which allow
    // the consumer to define the offset origin.
    // If we position a popper on top of a reference element, we can set
    // `x` to `top` to make the popper grow towards its top instead of
    // its bottom.

    var left = void 0,
        top = void 0;

    if (sideA === 'bottom') {
      // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
      // and not the bottom of the html element
      if (offsetParent.nodeName === 'HTML') {
        top = -offsetParent.clientHeight + offsets.bottom;
      } else {
        top = -offsetParentRect.height + offsets.bottom;
      }
    } else {
      top = offsets.top;
    }

    if (sideB === 'right') {
      if (offsetParent.nodeName === 'HTML') {
        left = -offsetParent.clientWidth + offsets.right;
      } else {
        left = -offsetParentRect.width + offsets.right;
      }
    } else {
      left = offsets.left;
    }

    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = 'transform';
    } else {
      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
      var invertTop = sideA === 'bottom' ? -1 : 1;
      var invertLeft = sideB === 'right' ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = sideA + ', ' + sideB;
    } // Attributes


    var attributes = {
      'x-placement': data.placement
    }; // Update `data` attributes, styles and arrowStyles

    data.attributes = _extends({}, attributes, data.attributes);
    data.styles = _extends({}, styles, data.styles);
    data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
    return data;
  }
  /**
   * Helper used to know if the given modifier depends from another one.<br />
   * It checks if the needed modifier is listed and enabled.
   * @method
   * @memberof Popper.Utils
   * @param {Array} modifiers - list of modifiers
   * @param {String} requestingName - name of requesting modifier
   * @param {String} requestedName - name of requested modifier
   * @returns {Boolean}
   */


  function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref) {
      var name = _ref.name;
      return name === requestingName;
    });
    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });

    if (!isRequired) {
      var _requesting = '`' + requestingName + '`';

      var requested = '`' + requestedName + '`';
      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
    }

    return isRequired;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function arrow(data, options) {
    var _data$offsets$arrow; // arrow depends on keepTogether in order to work


    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
      return data;
    }

    var arrowElement = options.element; // if arrowElement is a string, suppose it's a CSS selector

    if (typeof arrowElement === 'string') {
      arrowElement = data.instance.popper.querySelector(arrowElement); // if arrowElement is not found, don't run the modifier

      if (!arrowElement) {
        return data;
      }
    } else {
      // if the arrowElement isn't a query selector we must check that the
      // provided DOM node is child of its popper node
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn('WARNING: `arrow.element` must be child of its popper element!');
        return data;
      }
    }

    var placement = data.placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var isVertical = ['left', 'right'].indexOf(placement) !== -1;
    var len = isVertical ? 'height' : 'width';
    var sideCapitalized = isVertical ? 'Top' : 'Left';
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes(arrowElement)[len]; //
    // extends keepTogether behavior making sure the popper and its
    // reference have enough pixels in conjunction
    //
    // top/left side

    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    } // bottom/right side


    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }

    data.offsets.popper = getClientRect(data.offsets.popper); // compute center of the popper

    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2; // Compute the sideValue using the updated popper offsets
    // take popper margin in account because we don't have this info available

    var css = getStyleComputedProperty(data.instance.popper);
    var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; // prevent arrowElement from being placed not contiguously to its popper

    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
    return data;
  }
  /**
   * Get the opposite placement variation of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement variation
   * @returns {String} flipped placement variation
   */


  function getOppositeVariation(variation) {
    if (variation === 'end') {
      return 'start';
    } else if (variation === 'start') {
      return 'end';
    }

    return variation;
  }
  /**
   * List of accepted placements to use as values of the `placement` option.<br />
   * Valid placements are:
   * - `auto`
   * - `top`
   * - `right`
   * - `bottom`
   * - `left`
   *
   * Each placement can have a variation from this list:
   * - `-start`
   * - `-end`
   *
   * Variations are interpreted easily if you think of them as the left to right
   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
   * is right.<br />
   * Vertically (`left` and `right`), `start` is top and `end` is bottom.
   *
   * Some valid examples are:
   * - `top-end` (on top of reference, right aligned)
   * - `right-start` (on right of reference, top aligned)
   * - `bottom` (on bottom, centered)
   * - `auto-end` (on the side with more space available, alignment depends by placement)
   *
   * @static
   * @type {Array}
   * @enum {String}
   * @readonly
   * @method placements
   * @memberof Popper
   */


  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; // Get rid of `auto` `auto-start` and `auto-end`

  var validPlacements = placements.slice(3);
  /**
   * Given an initial placement, returns all the subsequent placements
   * clockwise (or counter-clockwise).
   *
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement - A valid placement (it accepts variations)
   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
   * @returns {Array} placements including their variations
   */

  function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }

  var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  };
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */

  function flip(data, options) {
    // if `inner` modifier is enabled, we can't use the `flip` modifier
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
      return data;
    }

    if (data.flipped && data.placement === data.originalPlacement) {
      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
      return data;
    }

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';
    var flipOrder = [];

    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;

      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;

      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;

      default:
        flipOrder = options.behavior;
    }

    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }

      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);
      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference; // using floor because the reference offsets may contain decimals we are not going to consider here

      var floor = Math.floor;
      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required

      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1; // flips variation if reference element overflows boundaries

      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom); // flips variation if popper content overflows boundaries

      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
      var flippedVariation = flippedVariationByRef || flippedVariationByContent;

      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        // this boolean to detect any flip loop
        data.flipped = true;

        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }

        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }

        data.placement = placement + (variation ? '-' + variation : ''); // this object contains `position`, we want to preserve it along with
        // any additional property we may add in the future

        data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
        data = runModifiers(data.instance.modifiers, data, 'flip');
      }
    });
    return data;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function keepTogether(data) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }

    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }

    return data;
  }
  /**
   * Converts a string containing value + unit into a px value number
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} str - Value + unit string
   * @argument {String} measurement - `height` or `width`
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @returns {Number|String}
   * Value in pixels, or original string if no values were extracted
   */


  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    // separate value from unit
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2]; // If it's not a number it's an operator, I guess

    if (!value) {
      return str;
    }

    if (unit.indexOf('%') === 0) {
      var element = void 0;

      switch (unit) {
        case '%p':
          element = popperOffsets;
          break;

        case '%':
        case '%r':
        default:
          element = referenceOffsets;
      }

      var rect = getClientRect(element);
      return rect[measurement] / 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
      // if is a vh or vw, we calculate the size based on the viewport
      var size = void 0;

      if (unit === 'vh') {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }

      return size / 100 * value;
    } else {
      // if is an explicit pixel unit, we get rid of the unit and keep the value
      // if is an implicit unit, it's px, and we return just the value
      return value;
    }
  }
  /**
   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} offset
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @argument {String} basePlacement
   * @returns {Array} a two cells array with x and y offsets in numbers
   */


  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0]; // Use height if placement is left or right and index is 0 otherwise use width
    // in this way the first offset will use an axis and the second one
    // will use the other one

    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1; // Split the offset string to obtain a list of values and operands
    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)

    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    }); // Detect if the offset string contains a pair of values or a single one
    // they could be separated by comma or space

    var divider = fragments.indexOf(find(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1;
    }));

    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    } // If divider is found, we divide the list of values and operands to divide
    // them by ofset X and Y.


    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments]; // Convert the values with units to absolute pixels to allow our computations

    ops = ops.map(function (op, index) {
      // Most of the units rely on the orientation of the popper
      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
      var mergeWithPrevious = false;
      return op // This aggregates any `+` or `-` sign that aren't considered operators
      // e.g.: 10 + +5 => [10, +, +5]
      .reduce(function (a, b) {
        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
          a[a.length - 1] = b;
          mergeWithPrevious = true;
          return a;
        } else if (mergeWithPrevious) {
          a[a.length - 1] += b;
          mergeWithPrevious = false;
          return a;
        } else {
          return a.concat(b);
        }
      }, []) // Here we convert the string values into number values (in px)
      .map(function (str) {
        return toValue(str, measurement, popperOffsets, referenceOffsets);
      });
    }); // Loop trough the offsets arrays and execute the operations

    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
        }
      });
    });
    return offsets;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @argument {Number|String} options.offset=0
   * The offset value as described in the modifier description
   * @returns {Object} The data object, properly modified
   */


  function offset(data, _ref) {
    var offset = _ref.offset;
    var placement = data.placement,
        _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var basePlacement = placement.split('-')[0];
    var offsets = void 0;

    if (isNumeric(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement);
    }

    if (basePlacement === 'left') {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === 'top') {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }

    data.popper = popper;
    return data;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); // If offsetParent is the reference element, we really want to
    // go one step up and use the next offsetParent as reference to
    // avoid to make this modifier completely useless and look like broken

    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement);
    } // NOTE: DOM access here
    // resets the popper's position so that the document size can be calculated excluding
    // the size of the popper element itself


    var transformProp = getSupportedPropertyName('transform');
    var popperStyles = data.instance.popper.style; // assignment to help minification

    var top = popperStyles.top,
        left = popperStyles.left,
        transform = popperStyles[transformProp];
    popperStyles.top = '';
    popperStyles.left = '';
    popperStyles[transformProp] = '';
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed); // NOTE: DOM access here
    // restores the original style properties after the offsets have been computed

    popperStyles.top = top;
    popperStyles.left = left;
    popperStyles[transformProp] = transform;
    options.boundaries = boundaries;
    var order = options.priority;
    var popper = data.offsets.popper;
    var check = {
      primary: function primary(placement) {
        var value = popper[placement];

        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }

        return defineProperty({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === 'right' ? 'left' : 'top';
        var value = popper[mainSide];

        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
        }

        return defineProperty({}, mainSide, value);
      }
    };
    order.forEach(function (placement) {
      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
      popper = _extends({}, popper, check[side](placement));
    });
    data.offsets.popper = popper;
    return data;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1]; // if shift shiftvariation is specified, run the modifier

    if (shiftvariation) {
      var _data$offsets = data.offsets,
          reference = _data$offsets.reference,
          popper = _data$offsets.popper;
      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
      var side = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';
      var shiftOffsets = {
        start: defineProperty({}, side, reference[side]),
        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
      };
      data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
    }

    return data;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
      return data;
    }

    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'preventOverflow';
    }).boundaries;

    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === true) {
        return data;
      }

      data.hide = true;
      data.attributes['x-out-of-boundaries'] = '';
    } else {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === false) {
        return data;
      }

      data.hide = false;
      data.attributes['x-out-of-boundaries'] = false;
    }

    return data;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);
    return data;
  }
  /**
   * Modifier function, each modifier can have a function of this type assigned
   * to its `fn` property.<br />
   * These functions will be called on each update, this means that you must
   * make sure they are performant enough to avoid performance bottlenecks.
   *
   * @function ModifierFn
   * @argument {dataObject} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {dataObject} The data object, properly modified
   */

  /**
   * Modifiers are plugins used to alter the behavior of your poppers.<br />
   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
   * needed by the library.
   *
   * Usually you don't want to override the `order`, `fn` and `onLoad` props.
   * All the other properties are configurations that could be tweaked.
   * @namespace modifiers
   */


  var modifiers = {
    /**
     * Modifier used to shift the popper on the start or end of its reference
     * element.<br />
     * It will read the variation of the `placement` property.<br />
     * It can be one either `-end` or `-start`.
     * @memberof modifiers
     * @inner
     */
    shift: {
      /** @prop {number} order=100 - Index used to define the order of execution */
      order: 100,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: shift
    },

    /**
     * The `offset` modifier can shift your popper on both its axis.
     *
     * It accepts the following units:
     * - `px` or unit-less, interpreted as pixels
     * - `%` or `%r`, percentage relative to the length of the reference element
     * - `%p`, percentage relative to the length of the popper element
     * - `vw`, CSS viewport width unit
     * - `vh`, CSS viewport height unit
     *
     * For length is intended the main axis relative to the placement of the popper.<br />
     * This means that if the placement is `top` or `bottom`, the length will be the
     * `width`. In case of `left` or `right`, it will be the `height`.
     *
     * You can provide a single value (as `Number` or `String`), or a pair of values
     * as `String` divided by a comma or one (or more) white spaces.<br />
     * The latter is a deprecated method because it leads to confusion and will be
     * removed in v2.<br />
     * Additionally, it accepts additions and subtractions between different units.
     * Note that multiplications and divisions aren't supported.
     *
     * Valid examples are:
     * ```
     * 10
     * '10%'
     * '10, 10'
     * '10%, 10'
     * '10 + 10%'
     * '10 - 5vh + 3%'
     * '-10px + 5vh, 5px - 6%'
     * ```
     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
     *
     * @memberof modifiers
     * @inner
     */
    offset: {
      /** @prop {number} order=200 - Index used to define the order of execution */
      order: 200,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: offset,

      /** @prop {Number|String} offset=0
       * The offset value as described in the modifier description
       */
      offset: 0
    },

    /**
     * Modifier used to prevent the popper from being positioned outside the boundary.
     *
     * A scenario exists where the reference itself is not within the boundaries.<br />
     * We can say it has "escaped the boundaries"  or just "escaped".<br />
     * In this case we need to decide whether the popper should either:
     *
     * - detach from the reference and remain "trapped" in the boundaries, or
     * - if it should ignore the boundary and "escape with its reference"
     *
     * When `escapeWithReference` is set to`true` and reference is completely
     * outside its boundaries, the popper will overflow (or completely leave)
     * the boundaries in order to remain attached to the edge of the reference.
     *
     * @memberof modifiers
     * @inner
     */
    preventOverflow: {
      /** @prop {number} order=300 - Index used to define the order of execution */
      order: 300,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: preventOverflow,

      /**
       * @prop {Array} [priority=['left','right','top','bottom']]
       * Popper will try to prevent overflow following these priorities by default,
       * then, it could overflow on the left and on top of the `boundariesElement`
       */
      priority: ['left', 'right', 'top', 'bottom'],

      /**
       * @prop {number} padding=5
       * Amount of pixel used to define a minimum distance between the boundaries
       * and the popper. This makes sure the popper always has a little padding
       * between the edges of its container
       */
      padding: 5,

      /**
       * @prop {String|HTMLElement} boundariesElement='scrollParent'
       * Boundaries used by the modifier. Can be `scrollParent`, `window`,
       * `viewport` or any DOM element.
       */
      boundariesElement: 'scrollParent'
    },

    /**
     * Modifier used to make sure the reference and its popper stay near each other
     * without leaving any gap between the two. Especially useful when the arrow is
     * enabled and you want to ensure that it points to its reference element.
     * It cares only about the first axis. You can still have poppers with margin
     * between the popper and its reference element.
     * @memberof modifiers
     * @inner
     */
    keepTogether: {
      /** @prop {number} order=400 - Index used to define the order of execution */
      order: 400,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: keepTogether
    },

    /**
     * This modifier is used to move the `arrowElement` of the popper to make
     * sure it is positioned between the reference element and its popper element.
     * It will read the outer size of the `arrowElement` node to detect how many
     * pixels of conjunction are needed.
     *
     * It has no effect if no `arrowElement` is provided.
     * @memberof modifiers
     * @inner
     */
    arrow: {
      /** @prop {number} order=500 - Index used to define the order of execution */
      order: 500,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: arrow,

      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
      element: '[x-arrow]'
    },

    /**
     * Modifier used to flip the popper's placement when it starts to overlap its
     * reference element.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     *
     * **NOTE:** this modifier will interrupt the current update cycle and will
     * restart it if it detects the need to flip the placement.
     * @memberof modifiers
     * @inner
     */
    flip: {
      /** @prop {number} order=600 - Index used to define the order of execution */
      order: 600,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: flip,

      /**
       * @prop {String|Array} behavior='flip'
       * The behavior used to change the popper's placement. It can be one of
       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
       * placements (with optional variations)
       */
      behavior: 'flip',

      /**
       * @prop {number} padding=5
       * The popper will flip if it hits the edges of the `boundariesElement`
       */
      padding: 5,

      /**
       * @prop {String|HTMLElement} boundariesElement='viewport'
       * The element which will define the boundaries of the popper position.
       * The popper will never be placed outside of the defined boundaries
       * (except if `keepTogether` is enabled)
       */
      boundariesElement: 'viewport',

      /**
       * @prop {Boolean} flipVariations=false
       * The popper will switch placement variation between `-start` and `-end` when
       * the reference element overlaps its boundaries.
       *
       * The original placement should have a set variation.
       */
      flipVariations: false,

      /**
       * @prop {Boolean} flipVariationsByContent=false
       * The popper will switch placement variation between `-start` and `-end` when
       * the popper element overlaps its reference boundaries.
       *
       * The original placement should have a set variation.
       */
      flipVariationsByContent: false
    },

    /**
     * Modifier used to make the popper flow toward the inner of the reference element.
     * By default, when this modifier is disabled, the popper will be placed outside
     * the reference element.
     * @memberof modifiers
     * @inner
     */
    inner: {
      /** @prop {number} order=700 - Index used to define the order of execution */
      order: 700,

      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
      enabled: false,

      /** @prop {ModifierFn} */
      fn: inner
    },

    /**
     * Modifier used to hide the popper when its reference element is outside of the
     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
     * be used to hide with a CSS selector the popper when its reference is
     * out of boundaries.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     * @memberof modifiers
     * @inner
     */
    hide: {
      /** @prop {number} order=800 - Index used to define the order of execution */
      order: 800,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: hide
    },

    /**
     * Computes the style that will be applied to the popper element to gets
     * properly positioned.
     *
     * Note that this modifier will not touch the DOM, it just prepares the styles
     * so that `applyStyle` modifier can apply it. This separation is useful
     * in case you need to replace `applyStyle` with a custom implementation.
     *
     * This modifier has `850` as `order` value to maintain backward compatibility
     * with previous versions of Popper.js. Expect the modifiers ordering method
     * to change in future major versions of the library.
     *
     * @memberof modifiers
     * @inner
     */
    computeStyle: {
      /** @prop {number} order=850 - Index used to define the order of execution */
      order: 850,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: computeStyle,

      /**
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: true,

      /**
       * @prop {string} [x='bottom']
       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
       * Change this if your popper should grow in a direction different from `bottom`
       */
      x: 'bottom',

      /**
       * @prop {string} [x='left']
       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
       * Change this if your popper should grow in a direction different from `right`
       */
      y: 'right'
    },

    /**
     * Applies the computed styles to the popper element.
     *
     * All the DOM manipulations are limited to this modifier. This is useful in case
     * you want to integrate Popper.js inside a framework or view library and you
     * want to delegate all the DOM manipulations to it.
     *
     * Note that if you disable this modifier, you must make sure the popper element
     * has its position set to `absolute` before Popper.js can do its work!
     *
     * Just disable this modifier and define your own to achieve the desired effect.
     *
     * @memberof modifiers
     * @inner
     */
    applyStyle: {
      /** @prop {number} order=900 - Index used to define the order of execution */
      order: 900,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: applyStyle,

      /** @prop {Function} */
      onLoad: applyStyleOnLoad,

      /**
       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: undefined
    }
  };
  /**
   * The `dataObject` is an object containing all the information used by Popper.js.
   * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
   * @name dataObject
   * @property {Object} data.instance The Popper.js instance
   * @property {String} data.placement Placement applied to popper
   * @property {String} data.originalPlacement Placement originally defined on init
   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
   * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.boundaries Offsets of the popper boundaries
   * @property {Object} data.offsets The measurements of popper, reference and arrow elements
   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
   */

  /**
   * Default options provided to Popper.js constructor.<br />
   * These can be overridden using the `options` argument of Popper.js.<br />
   * To override an option, simply pass an object with the same
   * structure of the `options` object, as the 3rd argument. For example:
   * ```
   * new Popper(ref, pop, {
   *   modifiers: {
   *     preventOverflow: { enabled: false }
   *   }
   * })
   * ```
   * @type {Object}
   * @static
   * @memberof Popper
   */

  var Defaults = {
    /**
     * Popper's placement.
     * @prop {Popper.placements} placement='bottom'
     */
    placement: 'bottom',

    /**
     * Set this to true if you want popper to position it self in 'fixed' mode
     * @prop {Boolean} positionFixed=false
     */
    positionFixed: false,

    /**
     * Whether events (resize, scroll) are initially enabled.
     * @prop {Boolean} eventsEnabled=true
     */
    eventsEnabled: true,

    /**
     * Set to true if you want to automatically remove the popper when
     * you call the `destroy` method.
     * @prop {Boolean} removeOnDestroy=false
     */
    removeOnDestroy: false,

    /**
     * Callback called when the popper is created.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onCreate}
     */
    onCreate: function onCreate() {},

    /**
     * Callback called when the popper is updated. This callback is not called
     * on the initialization/creation of the popper, but only on subsequent
     * updates.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onUpdate}
     */
    onUpdate: function onUpdate() {},

    /**
     * List of modifiers used to modify the offsets before they are applied to the popper.
     * They provide most of the functionalities of Popper.js.
     * @prop {modifiers}
     */
    modifiers: modifiers
  };
  /**
   * @callback onCreate
   * @param {dataObject} data
   */

  /**
   * @callback onUpdate
   * @param {dataObject} data
   */
  // Utils
  // Methods

  var Popper$2 = function () {
    /**
     * Creates a new Popper.js instance.
     * @class Popper
     * @param {Element|referenceObject} reference - The reference element used to position the popper
     * @param {Element} popper - The HTML / XML element used as the popper
     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
     * @return {Object} instance - The generated Popper.js instance
     */
    function Popper(reference, popper) {
      var _this = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, Popper);

      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      }; // make update() debounced, so that it only runs at most once-per-tick


      this.update = debounce$1(this.update.bind(this)); // with {} we create a new object with the options inside it

      this.options = _extends({}, Popper.Defaults, options); // init state

      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      }; // get reference and popper elements (allow jQuery wrappers)

      this.reference = reference && reference.jquery ? reference[0] : reference;
      this.popper = popper && popper.jquery ? popper[0] : popper; // Deep merge modifiers options

      this.options.modifiers = {};
      Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      }); // Refactoring modifiers' list (Object => Array)

      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
        return _extends({
          name: name
        }, _this.options.modifiers[name]);
      }) // sort the modifiers by order
      .sort(function (a, b) {
        return a.order - b.order;
      }); // modifiers have the ability to execute arbitrary code when Popper.js get inited
      // such code is executed in the same order of its modifier
      // they could add new properties to their options configuration
      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!

      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      }); // fire the first update to position the popper in the right place

      this.update();
      var eventsEnabled = this.options.eventsEnabled;

      if (eventsEnabled) {
        // setup event listeners, they will take care of update the position in specific situations
        this.enableEventListeners();
      }

      this.state.eventsEnabled = eventsEnabled;
    } // We can't use class properties because they don't get listed in the
    // class prototype and break stuff like Sinon stubs


    createClass(Popper, [{
      key: 'update',
      value: function update$$1() {
        return update.call(this);
      }
    }, {
      key: 'destroy',
      value: function destroy$$1() {
        return destroy.call(this);
      }
    }, {
      key: 'enableEventListeners',
      value: function enableEventListeners$$1() {
        return enableEventListeners.call(this);
      }
    }, {
      key: 'disableEventListeners',
      value: function disableEventListeners$$1() {
        return disableEventListeners.call(this);
      }
      /**
       * Schedules an update. It will run on the next UI update available.
       * @method scheduleUpdate
       * @memberof Popper
       */

      /**
       * Collection of utilities useful when writing custom modifiers.
       * Starting from version 1.7, this method is available only if you
       * include `popper-utils.js` before `popper.js`.
       *
       * **DEPRECATION**: This way to access PopperUtils is deprecated
       * and will be removed in v2! Use the PopperUtils module directly instead.
       * Due to the high instability of the methods contained in Utils, we can't
       * guarantee them to follow semver. Use them at your own risk!
       * @static
       * @private
       * @type {Object}
       * @deprecated since version 1.8
       * @member Utils
       * @memberof Popper
       */

    }]);
    return Popper;
  }();
  /**
   * The `referenceObject` is an object that provides an interface compatible with Popper.js
   * and lets you use it as replacement of a real DOM node.<br />
   * You can use this method to position a popper relatively to a set of coordinates
   * in case you don't have a DOM node to use as reference.
   *
   * ```
   * new Popper(referenceObject, popperNode);
   * ```
   *
   * NB: This feature isn't supported in Internet Explorer 10.
   * @name referenceObject
   * @property {Function} data.getBoundingClientRect
   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
   * @property {number} data.clientWidth
   * An ES6 getter that will return the width of the virtual reference element.
   * @property {number} data.clientHeight
   * An ES6 getter that will return the height of the virtual reference element.
   */


  Popper$2.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
  Popper$2.placements = placements;
  Popper$2.Defaults = Defaults;
  var PopperJs = Popper$2;

  function deprecatedPropType(validator, reason) {

    return function (props, propName, componentName, location, propFullName) {
      var componentNameSafe = componentName || '<<anonymous>>';
      var propFullNameSafe = propFullName || propName;

      if (typeof props[propName] !== 'undefined') {
        return new Error("The ".concat(location, " `").concat(propFullNameSafe, "` of ") + "`".concat(componentNameSafe, "` is deprecated. ").concat(reason));
      }

      return null;
    };
  }

  // TODO v5: consider to make it private
  function setRef(ref, value) {
    if (typeof ref === 'function') {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
  }

  function useForkRef(refA, refB) {
    /**
     * This will create a new function if the ref props change and are defined.
     * This means react will call the old forkRef with `null` and the new forkRef
     * with the ref. Cleanup naturally emerges from this behavior
     */
    return React__namespace.useMemo(function () {
      if (refA == null && refB == null) {
        return null;
      }

      return function (refValue) {
        setRef(refA, refValue);
        setRef(refB, refValue);
      };
    }, [refA, refB]);
  }

  function getContainer$1(container) {
    container = typeof container === 'function' ? container() : container; // #StrictMode ready

    return ReactDOM__namespace.findDOMNode(container);
  }

  var useEnhancedEffect$6 = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;
  /**
   * Portals provide a first-class way to render children into a DOM node
   * that exists outside the DOM hierarchy of the parent component.
   */

  var Portal = /*#__PURE__*/React__namespace.forwardRef(function Portal(props, ref) {
    var children = props.children,
        container = props.container,
        _props$disablePortal = props.disablePortal,
        disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal,
        onRendered = props.onRendered;

    var _React$useState = React__namespace.useState(null),
        mountNode = _React$useState[0],
        setMountNode = _React$useState[1];

    var handleRef = useForkRef( /*#__PURE__*/React__namespace.isValidElement(children) ? children.ref : null, ref);
    useEnhancedEffect$6(function () {
      if (!disablePortal) {
        setMountNode(getContainer$1(container) || document.body);
      }
    }, [container, disablePortal]);
    useEnhancedEffect$6(function () {
      if (mountNode && !disablePortal) {
        setRef(ref, mountNode);
        return function () {
          setRef(ref, null);
        };
      }

      return undefined;
    }, [ref, mountNode, disablePortal]);
    useEnhancedEffect$6(function () {
      if (onRendered && (mountNode || disablePortal)) {
        onRendered();
      }
    }, [onRendered, mountNode, disablePortal]);

    if (disablePortal) {
      if ( /*#__PURE__*/React__namespace.isValidElement(children)) {
        return /*#__PURE__*/React__namespace.cloneElement(children, {
          ref: handleRef
        });
      }

      return children;
    }

    return mountNode ? /*#__PURE__*/ReactDOM__namespace.createPortal(children, mountNode) : mountNode;
  });
  Portal.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * The children to render into the `container`.
     */
    children: PropTypes.node,

    /**
     * A HTML element, component instance, or function that returns either.
     * The `container` will have the portal children appended to it.
     *
     * By default, it uses the body of the top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: PropTypes
    /* @typescript-to-proptypes-ignore */
    .oneOfType([HTMLElementType, PropTypes.instanceOf(React__namespace.Component), PropTypes.func]),

    /**
     * Disable the portal behavior.
     * The children stay within it's parent DOM hierarchy.
     */
    disablePortal: PropTypes.bool,

    /**
     * Callback fired once the children has been mounted into the `container`.
     *
     * This prop will be removed in v5, the ref can be used instead.
     * @deprecated Use the ref instead.
     */
    onRendered: deprecatedPropType(PropTypes.func, 'Use the ref instead.')
  } ;

  {
    // eslint-disable-next-line
    Portal['propTypes' + ''] = exactProp(Portal.propTypes);
  }

  var Portal$1 = Portal;

  /**
   * Safe chained function
   *
   * Will only create a new function if needed,
   * otherwise will pass back existing functions or null.
   *
   * @param {function} functions to chain
   * @returns {function|null}
   */
  function createChainedFunction() {
    for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }

    return funcs.reduce(function (acc, func) {
      if (func == null) {
        return acc;
      }

      {
        if (typeof func !== 'function') {
          console.error('Material-UI: Invalid Argument Type, must only provide functions, undefined, or null.');
        }
      }

      return function chainedFunction() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        acc.apply(this, args);
        func.apply(this, args);
      };
    }, function () {});
  }

  function flipPlacement(placement, theme) {
    var direction = theme && theme.direction || 'ltr';

    if (direction === 'ltr') {
      return placement;
    }

    switch (placement) {
      case 'bottom-end':
        return 'bottom-start';

      case 'bottom-start':
        return 'bottom-end';

      case 'top-end':
        return 'top-start';

      case 'top-start':
        return 'top-end';

      default:
        return placement;
    }
  }

  function getAnchorEl$1(anchorEl) {
    return typeof anchorEl === 'function' ? anchorEl() : anchorEl;
  }

  var useEnhancedEffect$5 = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;
  var defaultPopperOptions = {};
  /**
   * Poppers rely on the 3rd party library [Popper.js](https://popper.js.org/docs/v1/) for positioning.
   */

  var Popper = /*#__PURE__*/React__namespace.forwardRef(function Popper(props, ref) {
    var anchorEl = props.anchorEl,
        children = props.children,
        container = props.container,
        _props$disablePortal = props.disablePortal,
        disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal,
        _props$keepMounted = props.keepMounted,
        keepMounted = _props$keepMounted === void 0 ? false : _props$keepMounted,
        modifiers = props.modifiers,
        open = props.open,
        _props$placement = props.placement,
        initialPlacement = _props$placement === void 0 ? 'bottom' : _props$placement,
        _props$popperOptions = props.popperOptions,
        popperOptions = _props$popperOptions === void 0 ? defaultPopperOptions : _props$popperOptions,
        popperRefProp = props.popperRef,
        style = props.style,
        _props$transition = props.transition,
        transition = _props$transition === void 0 ? false : _props$transition,
        other = _objectWithoutProperties(props, ["anchorEl", "children", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition"]);

    var tooltipRef = React__namespace.useRef(null);
    var ownRef = useForkRef(tooltipRef, ref);
    var popperRef = React__namespace.useRef(null);
    var handlePopperRef = useForkRef(popperRef, popperRefProp);
    var handlePopperRefRef = React__namespace.useRef(handlePopperRef);
    useEnhancedEffect$5(function () {
      handlePopperRefRef.current = handlePopperRef;
    }, [handlePopperRef]);
    React__namespace.useImperativeHandle(popperRefProp, function () {
      return popperRef.current;
    }, []);

    var _React$useState = React__namespace.useState(true),
        exited = _React$useState[0],
        setExited = _React$useState[1];

    var theme = useTheme$1();
    var rtlPlacement = flipPlacement(initialPlacement, theme);
    /**
     * placement initialized from prop but can change during lifetime if modifiers.flip.
     * modifiers.flip is essentially a flip for controlled/uncontrolled behavior
     */

    var _React$useState2 = React__namespace.useState(rtlPlacement),
        placement = _React$useState2[0],
        setPlacement = _React$useState2[1];

    React__namespace.useEffect(function () {
      if (popperRef.current) {
        popperRef.current.update();
      }
    });
    var handleOpen = React__namespace.useCallback(function () {
      if (!tooltipRef.current || !anchorEl || !open) {
        return;
      }

      if (popperRef.current) {
        popperRef.current.destroy();
        handlePopperRefRef.current(null);
      }

      var handlePopperUpdate = function handlePopperUpdate(data) {
        setPlacement(data.placement);
      };

      var resolvedAnchorEl = getAnchorEl$1(anchorEl);

      {
        if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
          var box = resolvedAnchorEl.getBoundingClientRect();

          if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
            console.warn(['Material-UI: The `anchorEl` prop provided to the component is invalid.', 'The anchor element should be part of the document layout.', "Make sure the element is present in the document or that it's not display none."].join('\n'));
          }
        }
      }

      var popper = new PopperJs(getAnchorEl$1(anchorEl), tooltipRef.current, _extends$1({
        placement: rtlPlacement
      }, popperOptions, {
        modifiers: _extends$1({}, disablePortal ? {} : {
          // It's using scrollParent by default, we can use the viewport when using a portal.
          preventOverflow: {
            boundariesElement: 'window'
          }
        }, modifiers, popperOptions.modifiers),
        // We could have been using a custom modifier like react-popper is doing.
        // But it seems this is the best public API for this use case.
        onCreate: createChainedFunction(handlePopperUpdate, popperOptions.onCreate),
        onUpdate: createChainedFunction(handlePopperUpdate, popperOptions.onUpdate)
      }));
      handlePopperRefRef.current(popper);
    }, [anchorEl, disablePortal, modifiers, open, rtlPlacement, popperOptions]);
    var handleRef = React__namespace.useCallback(function (node) {
      setRef(ownRef, node);
      handleOpen();
    }, [ownRef, handleOpen]);

    var handleEnter = function handleEnter() {
      setExited(false);
    };

    var handleClose = function handleClose() {
      if (!popperRef.current) {
        return;
      }

      popperRef.current.destroy();
      handlePopperRefRef.current(null);
    };

    var handleExited = function handleExited() {
      setExited(true);
      handleClose();
    };

    React__namespace.useEffect(function () {
      return function () {
        handleClose();
      };
    }, []);
    React__namespace.useEffect(function () {
      if (!open && !transition) {
        // Otherwise handleExited will call this.
        handleClose();
      }
    }, [open, transition]);

    if (!keepMounted && !open && (!transition || exited)) {
      return null;
    }

    var childProps = {
      placement: placement
    };

    if (transition) {
      childProps.TransitionProps = {
        in: open,
        onEnter: handleEnter,
        onExited: handleExited
      };
    }

    return /*#__PURE__*/React__namespace.createElement(Portal$1, {
      disablePortal: disablePortal,
      container: container
    }, /*#__PURE__*/React__namespace.createElement("div", _extends$1({
      ref: handleRef,
      role: "tooltip"
    }, other, {
      style: _extends$1({
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: 'fixed',
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display: !open && keepMounted && !transition ? 'none' : null
      }, style)
    }), typeof children === 'function' ? children(childProps) : children));
  });
  Popper.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * A HTML element, [referenceObject](https://popper.js.org/docs/v1/#referenceObject),
     * or a function that returns either.
     * It's used to set the position of the popper.
     * The return value will passed as the reference object of the Popper instance.
     */
    anchorEl: chainPropTypes(PropTypes.oneOfType([HTMLElementType, PropTypes.object, PropTypes.func]), function (props) {
      if (props.open) {
        var resolvedAnchorEl = getAnchorEl$1(props.anchorEl);

        if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
          var box = resolvedAnchorEl.getBoundingClientRect();

          if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
            return new Error(['Material-UI: The `anchorEl` prop provided to the component is invalid.', 'The anchor element should be part of the document layout.', "Make sure the element is present in the document or that it's not display none."].join('\n'));
          }
        } else if (!resolvedAnchorEl || typeof resolvedAnchorEl.clientWidth !== 'number' || typeof resolvedAnchorEl.clientHeight !== 'number' || typeof resolvedAnchorEl.getBoundingClientRect !== 'function') {
          return new Error(['Material-UI: The `anchorEl` prop provided to the component is invalid.', 'It should be an HTML element instance or a referenceObject ', '(https://popper.js.org/docs/v1/#referenceObject).'].join('\n'));
        }
      }

      return null;
    }),

    /**
     * Popper render function or node.
     */
    children: PropTypes
    /* @typescript-to-proptypes-ignore */
    .oneOfType([PropTypes.node, PropTypes.func]).isRequired,

    /**
     * A HTML element, component instance, or function that returns either.
     * The `container` will have the portal children appended to it.
     *
     * By default, it uses the body of the top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: PropTypes
    /* @typescript-to-proptypes-ignore */
    .oneOfType([HTMLElementType, PropTypes.instanceOf(React__namespace.Component), PropTypes.func]),

    /**
     * Disable the portal behavior.
     * The children stay within it's parent DOM hierarchy.
     */
    disablePortal: PropTypes.bool,

    /**
     * Always keep the children in the DOM.
     * This prop can be useful in SEO situation or
     * when you want to maximize the responsiveness of the Popper.
     */
    keepMounted: PropTypes.bool,

    /**
     * Popper.js is based on a "plugin-like" architecture,
     * most of its features are fully encapsulated "modifiers".
     *
     * A modifier is a function that is called each time Popper.js needs to
     * compute the position of the popper.
     * For this reason, modifiers should be very performant to avoid bottlenecks.
     * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v1/#modifiers).
     */
    modifiers: PropTypes.object,

    /**
     * If `true`, the popper is visible.
     */
    open: PropTypes.bool.isRequired,

    /**
     * Popper placement.
     */
    placement: PropTypes.oneOf(['bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),

    /**
     * Options provided to the [`popper.js`](https://popper.js.org/docs/v1/) instance.
     */
    popperOptions: PropTypes.object,

    /**
     * A ref that points to the used popper instance.
     */
    popperRef: refType$1,

    /**
     * @ignore
     */
    style: PropTypes.object,

    /**
     * Help supporting a react-transition-group/Transition component.
     */
    transition: PropTypes.bool
  } ;
  var Popper$1 = Popper;

  //
  // A strict capitalization should uppercase the first letter of each word a the sentence.
  // We only handle the first word.

  function capitalize(string) {
    if (typeof string !== 'string') {
      throw new Error("Material-UI: capitalize(string) expects a string argument." );
    }

    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  var styles$s = function styles(theme) {
    return {
      /* Styles applied to the root element. */
      root: {
        boxSizing: 'border-box',
        lineHeight: '48px',
        listStyle: 'none',
        color: theme.palette.text.secondary,
        fontFamily: theme.typography.fontFamily,
        fontWeight: theme.typography.fontWeightMedium,
        fontSize: theme.typography.pxToRem(14)
      },

      /* Styles applied to the root element if `color="primary"`. */
      colorPrimary: {
        color: theme.palette.primary.main
      },

      /* Styles applied to the root element if `color="inherit"`. */
      colorInherit: {
        color: 'inherit'
      },

      /* Styles applied to the inner `component` element if `disableGutters={false}`. */
      gutters: {
        paddingLeft: 16,
        paddingRight: 16
      },

      /* Styles applied to the root element if `inset={true}`. */
      inset: {
        paddingLeft: 72
      },

      /* Styles applied to the root element if `disableSticky={false}`. */
      sticky: {
        position: 'sticky',
        top: 0,
        zIndex: 1,
        backgroundColor: 'inherit'
      }
    };
  };
  var ListSubheader = /*#__PURE__*/React__namespace.forwardRef(function ListSubheader(props, ref) {
    var classes = props.classes,
        className = props.className,
        _props$color = props.color,
        color = _props$color === void 0 ? 'default' : _props$color,
        _props$component = props.component,
        Component = _props$component === void 0 ? 'li' : _props$component,
        _props$disableGutters = props.disableGutters,
        disableGutters = _props$disableGutters === void 0 ? false : _props$disableGutters,
        _props$disableSticky = props.disableSticky,
        disableSticky = _props$disableSticky === void 0 ? false : _props$disableSticky,
        _props$inset = props.inset,
        inset = _props$inset === void 0 ? false : _props$inset,
        other = _objectWithoutProperties(props, ["classes", "className", "color", "component", "disableGutters", "disableSticky", "inset"]);

    return /*#__PURE__*/React__namespace.createElement(Component, _extends$1({
      className: clsx(classes.root, className, color !== 'default' && classes["color".concat(capitalize(color))], inset && classes.inset, !disableSticky && classes.sticky, !disableGutters && classes.gutters),
      ref: ref
    }, other));
  });
  ListSubheader.propTypes = {
    /**
     * The content of the component.
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object.isRequired,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * The color of the component. It supports those theme colors that make sense for this component.
     */
    color: PropTypes.oneOf(['default', 'primary', 'inherit']),

    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: PropTypes
    /* @typescript-to-proptypes-ignore */
    .elementType,

    /**
     * If `true`, the List Subheader will not have gutters.
     */
    disableGutters: PropTypes.bool,

    /**
     * If `true`, the List Subheader will not stick to the top during scroll.
     */
    disableSticky: PropTypes.bool,

    /**
     * If `true`, the List Subheader will be indented.
     */
    inset: PropTypes.bool
  } ;
  var ListSubheader$1 = withStyles(styles$s, {
    name: 'MuiListSubheader'
  })(ListSubheader);

  var styles$r = function styles(theme) {
    var elevations = {};
    theme.shadows.forEach(function (shadow, index) {
      elevations["elevation".concat(index)] = {
        boxShadow: shadow
      };
    });
    return _extends$1({
      /* Styles applied to the root element. */
      root: {
        backgroundColor: theme.palette.background.paper,
        color: theme.palette.text.primary,
        transition: theme.transitions.create('box-shadow')
      },

      /* Styles applied to the root element if `square={false}`. */
      rounded: {
        borderRadius: theme.shape.borderRadius
      },

      /* Styles applied to the root element if `variant="outlined"`. */
      outlined: {
        border: "1px solid ".concat(theme.palette.divider)
      }
    }, elevations);
  };
  var Paper = /*#__PURE__*/React__namespace.forwardRef(function Paper(props, ref) {
    var classes = props.classes,
        className = props.className,
        _props$component = props.component,
        Component = _props$component === void 0 ? 'div' : _props$component,
        _props$square = props.square,
        square = _props$square === void 0 ? false : _props$square,
        _props$elevation = props.elevation,
        elevation = _props$elevation === void 0 ? 1 : _props$elevation,
        _props$variant = props.variant,
        variant = _props$variant === void 0 ? 'elevation' : _props$variant,
        other = _objectWithoutProperties(props, ["classes", "className", "component", "square", "elevation", "variant"]);

    return /*#__PURE__*/React__namespace.createElement(Component, _extends$1({
      className: clsx(classes.root, className, variant === 'outlined' ? classes.outlined : classes["elevation".concat(elevation)], !square && classes.rounded),
      ref: ref
    }, other));
  });
  Paper.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * The content of the component.
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: PropTypes
    /* @typescript-to-proptypes-ignore */
    .elementType,

    /**
     * Shadow depth, corresponds to `dp` in the spec.
     * It accepts values between 0 and 24 inclusive.
     */
    elevation: chainPropTypes(PropTypes.number, function (props) {
      var classes = props.classes,
          elevation = props.elevation; // in case `withStyles` fails to inject we don't need this warning

      if (classes === undefined) {
        return null;
      }

      if (elevation != null && classes["elevation".concat(elevation)] === undefined) {
        return new Error("Material-UI: This elevation `".concat(elevation, "` is not implemented."));
      }

      return null;
    }),

    /**
     * If `true`, rounded corners are disabled.
     */
    square: PropTypes.bool,

    /**
     * The variant to use.
     */
    variant: PropTypes.oneOf(['elevation', 'outlined'])
  } ;
  var Paper$1 = withStyles(styles$r, {
    name: 'MuiPaper'
  })(Paper);

  var useEnhancedEffect$4 = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;
  /**
   * https://github.com/facebook/react/issues/14099#issuecomment-440013892
   *
   * @param {function} fn
   */

  function useEventCallback(fn) {
    var ref = React__namespace.useRef(fn);
    useEnhancedEffect$4(function () {
      ref.current = fn;
    });
    return React__namespace.useCallback(function () {
      return (ref.current).apply(void 0, arguments);
    }, []);
  }

  // based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js
  var hadKeyboardEvent = true;
  var hadFocusVisibleRecently = false;
  var hadFocusVisibleRecentlyTimeout = null;
  var inputTypesWhitelist = {
    text: true,
    search: true,
    url: true,
    tel: true,
    email: true,
    password: true,
    number: true,
    date: true,
    month: true,
    week: true,
    time: true,
    datetime: true,
    'datetime-local': true
  };
  /**
   * Computes whether the given element should automatically trigger the
   * `focus-visible` class being added, i.e. whether it should always match
   * `:focus-visible` when focused.
   * @param {Element} node
   * @return {boolean}
   */

  function focusTriggersKeyboardModality(node) {
    var type = node.type,
        tagName = node.tagName;

    if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {
      return true;
    }

    if (tagName === 'TEXTAREA' && !node.readOnly) {
      return true;
    }

    if (node.isContentEditable) {
      return true;
    }

    return false;
  }
  /**
   * Keep track of our keyboard modality state with `hadKeyboardEvent`.
   * If the most recent user interaction was via the keyboard;
   * and the key press did not include a meta, alt/option, or control key;
   * then the modality is keyboard. Otherwise, the modality is not keyboard.
   * @param {KeyboardEvent} event
   */


  function handleKeyDown(event) {
    if (event.metaKey || event.altKey || event.ctrlKey) {
      return;
    }

    hadKeyboardEvent = true;
  }
  /**
   * If at any point a user clicks with a pointing device, ensure that we change
   * the modality away from keyboard.
   * This avoids the situation where a user presses a key on an already focused
   * element, and then clicks on a different element, focusing it with a
   * pointing device, while we still think we're in keyboard modality.
   */


  function handlePointerDown() {
    hadKeyboardEvent = false;
  }

  function handleVisibilityChange() {
    if (this.visibilityState === 'hidden') {
      // If the tab becomes active again, the browser will handle calling focus
      // on the element (Safari actually calls it twice).
      // If this tab change caused a blur on an element with focus-visible,
      // re-apply the class when the user switches back to the tab.
      if (hadFocusVisibleRecently) {
        hadKeyboardEvent = true;
      }
    }
  }

  function prepare(doc) {
    doc.addEventListener('keydown', handleKeyDown, true);
    doc.addEventListener('mousedown', handlePointerDown, true);
    doc.addEventListener('pointerdown', handlePointerDown, true);
    doc.addEventListener('touchstart', handlePointerDown, true);
    doc.addEventListener('visibilitychange', handleVisibilityChange, true);
  }

  function isFocusVisible(event) {
    var target = event.target;

    try {
      return target.matches(':focus-visible');
    } catch (error) {} // browsers not implementing :focus-visible will throw a SyntaxError
    // we use our own heuristic for those browsers
    // rethrow might be better if it's not the expected error but do we really
    // want to crash if focus-visible malfunctioned?
    // no need for validFocusTarget check. the user does that by attaching it to
    // focusable events only


    return hadKeyboardEvent || focusTriggersKeyboardModality(target);
  }
  /**
   * Should be called if a blur event is fired on a focus-visible element
   */


  function handleBlurVisible() {
    // To detect a tab/window switch, we look for a blur event followed
    // rapidly by a visibility change.
    // If we don't see a visibility change within 100ms, it's probably a
    // regular focus change.
    hadFocusVisibleRecently = true;
    window.clearTimeout(hadFocusVisibleRecentlyTimeout);
    hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {
      hadFocusVisibleRecently = false;
    }, 100);
  }

  function useIsFocusVisible() {
    var ref = React__namespace.useCallback(function (instance) {
      var node = ReactDOM__namespace.findDOMNode(instance);

      if (node != null) {
        prepare(node.ownerDocument);
      }
    }, []);

    {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React__namespace.useDebugValue(isFocusVisible);
    }

    return {
      isFocusVisible: isFocusVisible,
      onBlurVisible: handleBlurVisible,
      ref: ref
    };
  }

  var config = {
    disabled: false
  };

  var timeoutsShape = PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
    enter: PropTypes.number,
    exit: PropTypes.number,
    appear: PropTypes.number
  }).isRequired]) ;
  PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
    enter: PropTypes.string,
    exit: PropTypes.string,
    active: PropTypes.string
  }), PropTypes.shape({
    enter: PropTypes.string,
    enterDone: PropTypes.string,
    enterActive: PropTypes.string,
    exit: PropTypes.string,
    exitDone: PropTypes.string,
    exitActive: PropTypes.string
  })]) ;

  var TransitionGroupContext = React__default["default"].createContext(null);

  var UNMOUNTED = 'unmounted';
  var EXITED = 'exited';
  var ENTERING = 'entering';
  var ENTERED = 'entered';
  var EXITING = 'exiting';
  /**
   * The Transition component lets you describe a transition from one component
   * state to another _over time_ with a simple declarative API. Most commonly
   * it's used to animate the mounting and unmounting of a component, but can also
   * be used to describe in-place transition states as well.
   *
   * ---
   *
   * **Note**: `Transition` is a platform-agnostic base component. If you're using
   * transitions in CSS, you'll probably want to use
   * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
   * instead. It inherits all the features of `Transition`, but contains
   * additional features necessary to play nice with CSS transitions (hence the
   * name of the component).
   *
   * ---
   *
   * By default the `Transition` component does not alter the behavior of the
   * component it renders, it only tracks "enter" and "exit" states for the
   * components. It's up to you to give meaning and effect to those states. For
   * example we can add styles to a component when it enters or exits:
   *
   * ```jsx
   * import { Transition } from 'react-transition-group';
   *
   * const duration = 300;
   *
   * const defaultStyle = {
   *   transition: `opacity ${duration}ms ease-in-out`,
   *   opacity: 0,
   * }
   *
   * const transitionStyles = {
   *   entering: { opacity: 1 },
   *   entered:  { opacity: 1 },
   *   exiting:  { opacity: 0 },
   *   exited:  { opacity: 0 },
   * };
   *
   * const Fade = ({ in: inProp }) => (
   *   <Transition in={inProp} timeout={duration}>
   *     {state => (
   *       <div style={{
   *         ...defaultStyle,
   *         ...transitionStyles[state]
   *       }}>
   *         I'm a fade Transition!
   *       </div>
   *     )}
   *   </Transition>
   * );
   * ```
   *
   * There are 4 main states a Transition can be in:
   *  - `'entering'`
   *  - `'entered'`
   *  - `'exiting'`
   *  - `'exited'`
   *
   * Transition state is toggled via the `in` prop. When `true` the component
   * begins the "Enter" stage. During this stage, the component will shift from
   * its current transition state, to `'entering'` for the duration of the
   * transition and then to the `'entered'` stage once it's complete. Let's take
   * the following example (we'll use the
   * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
   *
   * ```jsx
   * function App() {
   *   const [inProp, setInProp] = useState(false);
   *   return (
   *     <div>
   *       <Transition in={inProp} timeout={500}>
   *         {state => (
   *           // ...
   *         )}
   *       </Transition>
   *       <button onClick={() => setInProp(true)}>
   *         Click to Enter
   *       </button>
   *     </div>
   *   );
   * }
   * ```
   *
   * When the button is clicked the component will shift to the `'entering'` state
   * and stay there for 500ms (the value of `timeout`) before it finally switches
   * to `'entered'`.
   *
   * When `in` is `false` the same thing happens except the state moves from
   * `'exiting'` to `'exited'`.
   */

  var Transition = /*#__PURE__*/function (_React$Component) {
    _inheritsLoose(Transition, _React$Component);

    function Transition(props, context) {
      var _this;

      _this = _React$Component.call(this, props, context) || this;
      var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;

      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }

      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }

    Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;

      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }

      return null;
    } // getSnapshotBeforeUpdate(prevProps) {
    //   let nextStatus = null
    //   if (prevProps !== this.props) {
    //     const { status } = this.state
    //     if (this.props.in) {
    //       if (status !== ENTERING && status !== ENTERED) {
    //         nextStatus = ENTERING
    //       }
    //     } else {
    //       if (status === ENTERING || status === ENTERED) {
    //         nextStatus = EXITING
    //       }
    //     }
    //   }
    //   return { nextStatus }
    // }
    ;

    var _proto = Transition.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;

      if (prevProps !== this.props) {
        var status = this.state.status;

        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }

      this.updateStatus(false, nextStatus);
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };

    _proto.getTimeouts = function getTimeouts() {
      var timeout = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout;

      if (timeout != null && typeof timeout !== 'number') {
        exit = timeout.exit;
        enter = timeout.enter; // TODO: remove fallback for next major

        appear = timeout.appear !== undefined ? timeout.appear : enter;
      }

      return {
        exit: exit,
        enter: enter,
        appear: appear
      };
    };

    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }

      if (nextStatus !== null) {
        // nextStatus will always be ENTERING or EXITING.
        this.cancelNextCallback();

        if (nextStatus === ENTERING) {
          this.performEnter(mounting);
        } else {
          this.performExit();
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };

    _proto.performEnter = function performEnter(mounting) {
      var _this2 = this;

      var enter = this.props.enter;
      var appearing = this.context ? this.context.isMounting : mounting;

      var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM__default["default"].findDOMNode(this), appearing],
          maybeNode = _ref2[0],
          maybeAppearing = _ref2[1];

      var timeouts = this.getTimeouts();
      var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
      // if we are mounting and running this it means appear _must_ be set

      if (!mounting && !enter || config.disabled) {
        this.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(maybeNode);
        });
        return;
      }

      this.props.onEnter(maybeNode, maybeAppearing);
      this.safeSetState({
        status: ENTERING
      }, function () {
        _this2.props.onEntering(maybeNode, maybeAppearing);

        _this2.onTransitionEnd(enterTimeout, function () {
          _this2.safeSetState({
            status: ENTERED
          }, function () {
            _this2.props.onEntered(maybeNode, maybeAppearing);
          });
        });
      });
    };

    _proto.performExit = function performExit() {
      var _this3 = this;

      var exit = this.props.exit;
      var timeouts = this.getTimeouts();
      var maybeNode = this.props.nodeRef ? undefined : ReactDOM__default["default"].findDOMNode(this); // no exit animation skip right to EXITED

      if (!exit || config.disabled) {
        this.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(maybeNode);
        });
        return;
      }

      this.props.onExit(maybeNode);
      this.safeSetState({
        status: EXITING
      }, function () {
        _this3.props.onExiting(maybeNode);

        _this3.onTransitionEnd(timeouts.exit, function () {
          _this3.safeSetState({
            status: EXITED
          }, function () {
            _this3.props.onExited(maybeNode);
          });
        });
      });
    };

    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };

    _proto.safeSetState = function safeSetState(nextState, callback) {
      // This shouldn't be necessary, but there are weird race conditions with
      // setState callbacks and unmounting in testing, so always make sure that
      // we can cancel any pending setState callbacks after we unmount.
      callback = this.setNextCallback(callback);
      this.setState(nextState, callback);
    };

    _proto.setNextCallback = function setNextCallback(callback) {
      var _this4 = this;

      var active = true;

      this.nextCallback = function (event) {
        if (active) {
          active = false;
          _this4.nextCallback = null;
          callback(event);
        }
      };

      this.nextCallback.cancel = function () {
        active = false;
      };

      return this.nextCallback;
    };

    _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
      this.setNextCallback(handler);
      var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM__default["default"].findDOMNode(this);
      var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

      if (!node || doesNotHaveTimeoutOrListener) {
        setTimeout(this.nextCallback, 0);
        return;
      }

      if (this.props.addEndListener) {
        var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
            maybeNode = _ref3[0],
            maybeNextCallback = _ref3[1];

        this.props.addEndListener(maybeNode, maybeNextCallback);
      }

      if (timeout != null) {
        setTimeout(this.nextCallback, timeout);
      }
    };

    _proto.render = function render() {
      var status = this.state.status;

      if (status === UNMOUNTED) {
        return null;
      }

      var _this$props = this.props,
          children = _this$props.children;
          _this$props.in;
          _this$props.mountOnEnter;
          _this$props.unmountOnExit;
          _this$props.appear;
          _this$props.enter;
          _this$props.exit;
          _this$props.timeout;
          _this$props.addEndListener;
          _this$props.onEnter;
          _this$props.onEntering;
          _this$props.onEntered;
          _this$props.onExit;
          _this$props.onExiting;
          _this$props.onExited;
          _this$props.nodeRef;
          var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);

      return (
        /*#__PURE__*/
        // allows for nested Transitions
        React__default["default"].createElement(TransitionGroupContext.Provider, {
          value: null
        }, typeof children === 'function' ? children(status, childProps) : React__default["default"].cloneElement(React__default["default"].Children.only(children), childProps))
      );
    };

    return Transition;
  }(React__default["default"].Component);

  Transition.contextType = TransitionGroupContext;
  Transition.propTypes = {
    /**
     * A React reference to DOM element that need to transition:
     * https://stackoverflow.com/a/51127130/4671932
     *
     *   - When `nodeRef` prop is used, `node` is not passed to callback functions
     *      (e.g. `onEnter`) because user already has direct access to the node.
     *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
     *     `nodeRef` need to be provided to `Transition` with changed `key` prop
     *     (see
     *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
     */
    nodeRef: PropTypes.shape({
      current: typeof Element === 'undefined' ? PropTypes.any : function (propValue, key, componentName, location, propFullName, secret) {
        var value = propValue[key];
        return PropTypes.instanceOf(value && 'ownerDocument' in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
      }
    }),

    /**
     * A `function` child can be used instead of a React element. This function is
     * called with the current transition status (`'entering'`, `'entered'`,
     * `'exiting'`, `'exited'`), which can be used to apply context
     * specific props to a component.
     *
     * ```jsx
     * <Transition in={this.state.in} timeout={150}>
     *   {state => (
     *     <MyComponent className={`fade fade-${state}`} />
     *   )}
     * </Transition>
     * ```
     */
    children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,

    /**
     * Show the component; triggers the enter or exit states
     */
    in: PropTypes.bool,

    /**
     * By default the child component is mounted immediately along with
     * the parent `Transition` component. If you want to "lazy mount" the component on the
     * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
     * mounted, even on "exited", unless you also specify `unmountOnExit`.
     */
    mountOnEnter: PropTypes.bool,

    /**
     * By default the child component stays mounted after it reaches the `'exited'` state.
     * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
     */
    unmountOnExit: PropTypes.bool,

    /**
     * By default the child component does not perform the enter transition when
     * it first mounts, regardless of the value of `in`. If you want this
     * behavior, set both `appear` and `in` to `true`.
     *
     * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
     * > only adds an additional enter transition. However, in the
     * > `<CSSTransition>` component that first enter transition does result in
     * > additional `.appear-*` classes, that way you can choose to style it
     * > differently.
     */
    appear: PropTypes.bool,

    /**
     * Enable or disable enter transitions.
     */
    enter: PropTypes.bool,

    /**
     * Enable or disable exit transitions.
     */
    exit: PropTypes.bool,

    /**
     * The duration of the transition, in milliseconds.
     * Required unless `addEndListener` is provided.
     *
     * You may specify a single timeout for all transitions:
     *
     * ```jsx
     * timeout={500}
     * ```
     *
     * or individually:
     *
     * ```jsx
     * timeout={{
     *  appear: 500,
     *  enter: 300,
     *  exit: 500,
     * }}
     * ```
     *
     * - `appear` defaults to the value of `enter`
     * - `enter` defaults to `0`
     * - `exit` defaults to `0`
     *
     * @type {number | { enter?: number, exit?: number, appear?: number }}
     */
    timeout: function timeout(props) {
      var pt = timeoutsShape;
      if (!props.addEndListener) pt = pt.isRequired;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return pt.apply(void 0, [props].concat(args));
    },

    /**
     * Add a custom transition end trigger. Called with the transitioning
     * DOM node and a `done` callback. Allows for more fine grained transition end
     * logic. Timeouts are still used as a fallback if provided.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * ```jsx
     * addEndListener={(node, done) => {
     *   // use the css transitionend event to mark the finish of a transition
     *   node.addEventListener('transitionend', done, false);
     * }}
     * ```
     */
    addEndListener: PropTypes.func,

    /**
     * Callback fired before the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEnter: PropTypes.func,

    /**
     * Callback fired after the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntering: PropTypes.func,

    /**
     * Callback fired after the "entered" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEntered: PropTypes.func,

    /**
     * Callback fired before the "exiting" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExit: PropTypes.func,

    /**
     * Callback fired after the "exiting" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExiting: PropTypes.func,

    /**
     * Callback fired after the "exited" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExited: PropTypes.func
  } ; // Name the function so it is clearer in the documentation

  function noop() {}

  Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop,
    onEntering: noop,
    onEntered: noop,
    onExit: noop,
    onExiting: noop,
    onExited: noop
  };
  Transition.UNMOUNTED = UNMOUNTED;
  Transition.EXITED = EXITED;
  Transition.ENTERING = ENTERING;
  Transition.ENTERED = ENTERED;
  Transition.EXITING = EXITING;
  var Transition$1 = Transition;

  /**
   * Given `this.props.children`, return an object mapping key to child.
   *
   * @param {*} children `this.props.children`
   * @return {object} Mapping of key to child
   */

  function getChildMapping(children, mapFn) {
    var mapper = function mapper(child) {
      return mapFn && React.isValidElement(child) ? mapFn(child) : child;
    };

    var result = Object.create(null);
    if (children) React.Children.map(children, function (c) {
      return c;
    }).forEach(function (child) {
      // run the map function here instead so that the key is the computed one
      result[child.key] = mapper(child);
    });
    return result;
  }
  /**
   * When you're adding or removing children some may be added or removed in the
   * same render pass. We want to show *both* since we want to simultaneously
   * animate elements in and out. This function takes a previous set of keys
   * and a new set of keys and merges them with its best guess of the correct
   * ordering. In the future we may expose some of the utilities in
   * ReactMultiChild to make this easy, but for now React itself does not
   * directly have this concept of the union of prevChildren and nextChildren
   * so we implement it here.
   *
   * @param {object} prev prev children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @param {object} next next children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @return {object} a key set that contains all keys in `prev` and all keys
   * in `next` in a reasonable order.
   */

  function mergeChildMappings(prev, next) {
    prev = prev || {};
    next = next || {};

    function getValueForKey(key) {
      return key in next ? next[key] : prev[key];
    } // For each key of `next`, the list of keys to insert before that key in
    // the combined list


    var nextKeysPending = Object.create(null);
    var pendingKeys = [];

    for (var prevKey in prev) {
      if (prevKey in next) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }

    var i;
    var childMapping = {};

    for (var nextKey in next) {
      if (nextKeysPending[nextKey]) {
        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey][i];
          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
        }
      }

      childMapping[nextKey] = getValueForKey(nextKey);
    } // Finally, add the keys which didn't appear before any key in `next`


    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }

    return childMapping;
  }

  function getProp(child, prop, props) {
    return props[prop] != null ? props[prop] : child.props[prop];
  }

  function getInitialChildMapping(props, onExited) {
    return getChildMapping(props.children, function (child) {
      return React.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        appear: getProp(child, 'appear', props),
        enter: getProp(child, 'enter', props),
        exit: getProp(child, 'exit', props)
      });
    });
  }
  function getNextChildMapping(nextProps, prevChildMapping, onExited) {
    var nextChildMapping = getChildMapping(nextProps.children);
    var children = mergeChildMappings(prevChildMapping, nextChildMapping);
    Object.keys(children).forEach(function (key) {
      var child = children[key];
      if (!React.isValidElement(child)) return;
      var hasPrev = (key in prevChildMapping);
      var hasNext = (key in nextChildMapping);
      var prevChild = prevChildMapping[key];
      var isLeaving = React.isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)

      if (hasNext && (!hasPrev || isLeaving)) {
        // console.log('entering', key)
        children[key] = React.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: true,
          exit: getProp(child, 'exit', nextProps),
          enter: getProp(child, 'enter', nextProps)
        });
      } else if (!hasNext && hasPrev && !isLeaving) {
        // item is old (exiting)
        // console.log('leaving', key)
        children[key] = React.cloneElement(child, {
          in: false
        });
      } else if (hasNext && hasPrev && React.isValidElement(prevChild)) {
        // item hasn't changed transition states
        // copy over the last transition props;
        // console.log('unchanged', key)
        children[key] = React.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: prevChild.props.in,
          exit: getProp(child, 'exit', nextProps),
          enter: getProp(child, 'enter', nextProps)
        });
      }
    });
    return children;
  }

  var values = Object.values || function (obj) {
    return Object.keys(obj).map(function (k) {
      return obj[k];
    });
  };

  var defaultProps = {
    component: 'div',
    childFactory: function childFactory(child) {
      return child;
    }
  };
  /**
   * The `<TransitionGroup>` component manages a set of transition components
   * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
   * components, `<TransitionGroup>` is a state machine for managing the mounting
   * and unmounting of components over time.
   *
   * Consider the example below. As items are removed or added to the TodoList the
   * `in` prop is toggled automatically by the `<TransitionGroup>`.
   *
   * Note that `<TransitionGroup>`  does not define any animation behavior!
   * Exactly _how_ a list item animates is up to the individual transition
   * component. This means you can mix and match animations across different list
   * items.
   */

  var TransitionGroup = /*#__PURE__*/function (_React$Component) {
    _inheritsLoose(TransitionGroup, _React$Component);

    function TransitionGroup(props, context) {
      var _this;

      _this = _React$Component.call(this, props, context) || this;

      var handleExited = _this.handleExited.bind(_assertThisInitialized(_this)); // Initial children should all be entering, dependent on appear


      _this.state = {
        contextValue: {
          isMounting: true
        },
        handleExited: handleExited,
        firstRender: true
      };
      return _this;
    }

    var _proto = TransitionGroup.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this.mounted = true;
      this.setState({
        contextValue: {
          isMounting: false
        }
      });
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.mounted = false;
    };

    TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
      var prevChildMapping = _ref.children,
          handleExited = _ref.handleExited,
          firstRender = _ref.firstRender;
      return {
        children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
        firstRender: false
      };
    } // node is `undefined` when user provided `nodeRef` prop
    ;

    _proto.handleExited = function handleExited(child, node) {
      var currentChildMapping = getChildMapping(this.props.children);
      if (child.key in currentChildMapping) return;

      if (child.props.onExited) {
        child.props.onExited(node);
      }

      if (this.mounted) {
        this.setState(function (state) {
          var children = _extends$1({}, state.children);

          delete children[child.key];
          return {
            children: children
          };
        });
      }
    };

    _proto.render = function render() {
      var _this$props = this.props,
          Component = _this$props.component,
          childFactory = _this$props.childFactory,
          props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);

      var contextValue = this.state.contextValue;
      var children = values(this.state.children).map(childFactory);
      delete props.appear;
      delete props.enter;
      delete props.exit;

      if (Component === null) {
        return /*#__PURE__*/React__default["default"].createElement(TransitionGroupContext.Provider, {
          value: contextValue
        }, children);
      }

      return /*#__PURE__*/React__default["default"].createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, /*#__PURE__*/React__default["default"].createElement(Component, props, children));
    };

    return TransitionGroup;
  }(React__default["default"].Component);

  TransitionGroup.propTypes = {
    /**
     * `<TransitionGroup>` renders a `<div>` by default. You can change this
     * behavior by providing a `component` prop.
     * If you use React v16+ and would like to avoid a wrapping `<div>` element
     * you can pass in `component={null}`. This is useful if the wrapping div
     * borks your css styles.
     */
    component: PropTypes.any,

    /**
     * A set of `<Transition>` components, that are toggled `in` and out as they
     * leave. the `<TransitionGroup>` will inject specific transition props, so
     * remember to spread them through if you are wrapping the `<Transition>` as
     * with our `<Fade>` example.
     *
     * While this component is meant for multiple `Transition` or `CSSTransition`
     * children, sometimes you may want to have a single transition child with
     * content that you want to be transitioned out and in when you change it
     * (e.g. routes, images etc.) In that case you can change the `key` prop of
     * the transition child as you change its content, this will cause
     * `TransitionGroup` to transition the child out and back in.
     */
    children: PropTypes.node,

    /**
     * A convenience prop that enables or disables appear animations
     * for all children. Note that specifying this will override any defaults set
     * on individual children Transitions.
     */
    appear: PropTypes.bool,

    /**
     * A convenience prop that enables or disables enter animations
     * for all children. Note that specifying this will override any defaults set
     * on individual children Transitions.
     */
    enter: PropTypes.bool,

    /**
     * A convenience prop that enables or disables exit animations
     * for all children. Note that specifying this will override any defaults set
     * on individual children Transitions.
     */
    exit: PropTypes.bool,

    /**
     * You may need to apply reactive updates to a child as it is exiting.
     * This is generally done by using `cloneElement` however in the case of an exiting
     * child the element has already been removed and not accessible to the consumer.
     *
     * If you do need to update a child as it leaves you can provide a `childFactory`
     * to wrap every child, even the ones that are leaving.
     *
     * @type Function(child: ReactElement) -> ReactElement
     */
    childFactory: PropTypes.func
  } ;
  TransitionGroup.defaultProps = defaultProps;
  var TransitionGroup$1 = TransitionGroup;

  var useEnhancedEffect$3 = typeof window === 'undefined' ? React__namespace.useEffect : React__namespace.useLayoutEffect;
  /**
   * @ignore - internal component.
   */

  function Ripple(props) {
    var classes = props.classes,
        _props$pulsate = props.pulsate,
        pulsate = _props$pulsate === void 0 ? false : _props$pulsate,
        rippleX = props.rippleX,
        rippleY = props.rippleY,
        rippleSize = props.rippleSize,
        inProp = props.in,
        _props$onExited = props.onExited,
        onExited = _props$onExited === void 0 ? function () {} : _props$onExited,
        timeout = props.timeout;

    var _React$useState = React__namespace.useState(false),
        leaving = _React$useState[0],
        setLeaving = _React$useState[1];

    var rippleClassName = clsx(classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
    var rippleStyles = {
      width: rippleSize,
      height: rippleSize,
      top: -(rippleSize / 2) + rippleY,
      left: -(rippleSize / 2) + rippleX
    };
    var childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
    var handleExited = useEventCallback(onExited); // Ripple is used for user feedback (e.g. click or press) so we want to apply styles with the highest priority

    useEnhancedEffect$3(function () {
      if (!inProp) {
        // react-transition-group#onExit
        setLeaving(true); // react-transition-group#onExited

        var timeoutId = setTimeout(handleExited, timeout);
        return function () {
          clearTimeout(timeoutId);
        };
      }

      return undefined;
    }, [handleExited, inProp, timeout]);
    return /*#__PURE__*/React__namespace.createElement("span", {
      className: rippleClassName,
      style: rippleStyles
    }, /*#__PURE__*/React__namespace.createElement("span", {
      className: childClassName
    }));
  }

  Ripple.propTypes = {
    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object.isRequired,

    /**
     * @ignore - injected from TransitionGroup
     */
    in: PropTypes.bool,

    /**
     * @ignore - injected from TransitionGroup
     */
    onExited: PropTypes.func,

    /**
     * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.
     */
    pulsate: PropTypes.bool,

    /**
     * Diameter of the ripple.
     */
    rippleSize: PropTypes.number,

    /**
     * Horizontal position of the ripple center.
     */
    rippleX: PropTypes.number,

    /**
     * Vertical position of the ripple center.
     */
    rippleY: PropTypes.number,

    /**
     * exit delay
     */
    timeout: PropTypes.number.isRequired
  } ;

  var DURATION = 550;
  var DELAY_RIPPLE = 80;
  var styles$q = function styles(theme) {
    return {
      /* Styles applied to the root element. */
      root: {
        overflow: 'hidden',
        pointerEvents: 'none',
        position: 'absolute',
        zIndex: 0,
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        borderRadius: 'inherit'
      },

      /* Styles applied to the internal `Ripple` components `ripple` class. */
      ripple: {
        opacity: 0,
        position: 'absolute'
      },

      /* Styles applied to the internal `Ripple` components `rippleVisible` class. */
      rippleVisible: {
        opacity: 0.3,
        transform: 'scale(1)',
        animation: "$enter ".concat(DURATION, "ms ").concat(theme.transitions.easing.easeInOut)
      },

      /* Styles applied to the internal `Ripple` components `ripplePulsate` class. */
      ripplePulsate: {
        animationDuration: "".concat(theme.transitions.duration.shorter, "ms")
      },

      /* Styles applied to the internal `Ripple` components `child` class. */
      child: {
        opacity: 1,
        display: 'block',
        width: '100%',
        height: '100%',
        borderRadius: '50%',
        backgroundColor: 'currentColor'
      },

      /* Styles applied to the internal `Ripple` components `childLeaving` class. */
      childLeaving: {
        opacity: 0,
        animation: "$exit ".concat(DURATION, "ms ").concat(theme.transitions.easing.easeInOut)
      },

      /* Styles applied to the internal `Ripple` components `childPulsate` class. */
      childPulsate: {
        position: 'absolute',
        left: 0,
        top: 0,
        animation: "$pulsate 2500ms ".concat(theme.transitions.easing.easeInOut, " 200ms infinite")
      },
      '@keyframes enter': {
        '0%': {
          transform: 'scale(0)',
          opacity: 0.1
        },
        '100%': {
          transform: 'scale(1)',
          opacity: 0.3
        }
      },
      '@keyframes exit': {
        '0%': {
          opacity: 1
        },
        '100%': {
          opacity: 0
        }
      },
      '@keyframes pulsate': {
        '0%': {
          transform: 'scale(1)'
        },
        '50%': {
          transform: 'scale(0.92)'
        },
        '100%': {
          transform: 'scale(1)'
        }
      }
    };
  };
  /**
   * @ignore - internal component.
   *
   * TODO v5: Make private
   */

  var TouchRipple = /*#__PURE__*/React__namespace.forwardRef(function TouchRipple(props, ref) {
    var _props$center = props.center,
        centerProp = _props$center === void 0 ? false : _props$center,
        classes = props.classes,
        className = props.className,
        other = _objectWithoutProperties(props, ["center", "classes", "className"]);

    var _React$useState = React__namespace.useState([]),
        ripples = _React$useState[0],
        setRipples = _React$useState[1];

    var nextKey = React__namespace.useRef(0);
    var rippleCallback = React__namespace.useRef(null);
    React__namespace.useEffect(function () {
      if (rippleCallback.current) {
        rippleCallback.current();
        rippleCallback.current = null;
      }
    }, [ripples]); // Used to filter out mouse emulated events on mobile.

    var ignoringMouseDown = React__namespace.useRef(false); // We use a timer in order to only show the ripples for touch "click" like events.
    // We don't want to display the ripple for touch scroll events.

    var startTimer = React__namespace.useRef(null); // This is the hook called once the previous timeout is ready.

    var startTimerCommit = React__namespace.useRef(null);
    var container = React__namespace.useRef(null);
    React__namespace.useEffect(function () {
      return function () {
        clearTimeout(startTimer.current);
      };
    }, []);
    var startCommit = React__namespace.useCallback(function (params) {
      var pulsate = params.pulsate,
          rippleX = params.rippleX,
          rippleY = params.rippleY,
          rippleSize = params.rippleSize,
          cb = params.cb;
      setRipples(function (oldRipples) {
        return [].concat(_toConsumableArray(oldRipples), [/*#__PURE__*/React__namespace.createElement(Ripple, {
          key: nextKey.current,
          classes: classes,
          timeout: DURATION,
          pulsate: pulsate,
          rippleX: rippleX,
          rippleY: rippleY,
          rippleSize: rippleSize
        })]);
      });
      nextKey.current += 1;
      rippleCallback.current = cb;
    }, [classes]);
    var start = React__namespace.useCallback(function () {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var cb = arguments.length > 2 ? arguments[2] : undefined;
      var _options$pulsate = options.pulsate,
          pulsate = _options$pulsate === void 0 ? false : _options$pulsate,
          _options$center = options.center,
          center = _options$center === void 0 ? centerProp || options.pulsate : _options$center,
          _options$fakeElement = options.fakeElement,
          fakeElement = _options$fakeElement === void 0 ? false : _options$fakeElement;

      if (event.type === 'mousedown' && ignoringMouseDown.current) {
        ignoringMouseDown.current = false;
        return;
      }

      if (event.type === 'touchstart') {
        ignoringMouseDown.current = true;
      }

      var element = fakeElement ? null : container.current;
      var rect = element ? element.getBoundingClientRect() : {
        width: 0,
        height: 0,
        left: 0,
        top: 0
      }; // Get the size of the ripple

      var rippleX;
      var rippleY;
      var rippleSize;

      if (center || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
        rippleX = Math.round(rect.width / 2);
        rippleY = Math.round(rect.height / 2);
      } else {
        var _ref = event.touches ? event.touches[0] : event,
            clientX = _ref.clientX,
            clientY = _ref.clientY;

        rippleX = Math.round(clientX - rect.left);
        rippleY = Math.round(clientY - rect.top);
      }

      if (center) {
        rippleSize = Math.sqrt((2 * Math.pow(rect.width, 2) + Math.pow(rect.height, 2)) / 3); // For some reason the animation is broken on Mobile Chrome if the size if even.

        if (rippleSize % 2 === 0) {
          rippleSize += 1;
        }
      } else {
        var sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
        var sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
        rippleSize = Math.sqrt(Math.pow(sizeX, 2) + Math.pow(sizeY, 2));
      } // Touche devices


      if (event.touches) {
        // check that this isn't another touchstart due to multitouch
        // otherwise we will only clear a single timer when unmounting while two
        // are running
        if (startTimerCommit.current === null) {
          // Prepare the ripple effect.
          startTimerCommit.current = function () {
            startCommit({
              pulsate: pulsate,
              rippleX: rippleX,
              rippleY: rippleY,
              rippleSize: rippleSize,
              cb: cb
            });
          }; // Delay the execution of the ripple effect.


          startTimer.current = setTimeout(function () {
            if (startTimerCommit.current) {
              startTimerCommit.current();
              startTimerCommit.current = null;
            }
          }, DELAY_RIPPLE); // We have to make a tradeoff with this value.
        }
      } else {
        startCommit({
          pulsate: pulsate,
          rippleX: rippleX,
          rippleY: rippleY,
          rippleSize: rippleSize,
          cb: cb
        });
      }
    }, [centerProp, startCommit]);
    var pulsate = React__namespace.useCallback(function () {
      start({}, {
        pulsate: true
      });
    }, [start]);
    var stop = React__namespace.useCallback(function (event, cb) {
      clearTimeout(startTimer.current); // The touch interaction occurs too quickly.
      // We still want to show ripple effect.

      if (event.type === 'touchend' && startTimerCommit.current) {
        event.persist();
        startTimerCommit.current();
        startTimerCommit.current = null;
        startTimer.current = setTimeout(function () {
          stop(event, cb);
        });
        return;
      }

      startTimerCommit.current = null;
      setRipples(function (oldRipples) {
        if (oldRipples.length > 0) {
          return oldRipples.slice(1);
        }

        return oldRipples;
      });
      rippleCallback.current = cb;
    }, []);
    React__namespace.useImperativeHandle(ref, function () {
      return {
        pulsate: pulsate,
        start: start,
        stop: stop
      };
    }, [pulsate, start, stop]);
    return /*#__PURE__*/React__namespace.createElement("span", _extends$1({
      className: clsx(classes.root, className),
      ref: container
    }, other), /*#__PURE__*/React__namespace.createElement(TransitionGroup$1, {
      component: null,
      exit: true
    }, ripples));
  });
  TouchRipple.propTypes = {
    /**
     * If `true`, the ripple starts at the center of the component
     * rather than at the point of interaction.
     */
    center: PropTypes.bool,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object.isRequired,

    /**
     * @ignore
     */
    className: PropTypes.string
  } ;
  var TouchRipple$1 = withStyles(styles$q, {
    flip: false,
    name: 'MuiTouchRipple'
  })( /*#__PURE__*/React__namespace.memo(TouchRipple));

  var styles$p = {
    /* Styles applied to the root element. */
    root: {
      display: 'inline-flex',
      alignItems: 'center',
      justifyContent: 'center',
      position: 'relative',
      WebkitTapHighlightColor: 'transparent',
      backgroundColor: 'transparent',
      // Reset default value
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0,
      border: 0,
      margin: 0,
      // Remove the margin in Safari
      borderRadius: 0,
      padding: 0,
      // Remove the padding in Firefox
      cursor: 'pointer',
      userSelect: 'none',
      verticalAlign: 'middle',
      '-moz-appearance': 'none',
      // Reset
      '-webkit-appearance': 'none',
      // Reset
      textDecoration: 'none',
      // So we take precedent over the style of a native <a /> element.
      color: 'inherit',
      '&::-moz-focus-inner': {
        borderStyle: 'none' // Remove Firefox dotted outline.

      },
      '&$disabled': {
        pointerEvents: 'none',
        // Disable link interactions
        cursor: 'default'
      },
      '@media print': {
        colorAdjust: 'exact'
      }
    },

    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},

    /* Pseudo-class applied to the root element if keyboard focused. */
    focusVisible: {}
  };
  /**
   * `ButtonBase` contains as few styles as possible.
   * It aims to be a simple building block for creating a button.
   * It contains a load of style reset and some focus/ripple logic.
   */

  var ButtonBase = /*#__PURE__*/React__namespace.forwardRef(function ButtonBase(props, ref) {
    var action = props.action,
        buttonRefProp = props.buttonRef,
        _props$centerRipple = props.centerRipple,
        centerRipple = _props$centerRipple === void 0 ? false : _props$centerRipple,
        children = props.children,
        classes = props.classes,
        className = props.className,
        _props$component = props.component,
        component = _props$component === void 0 ? 'button' : _props$component,
        _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled,
        _props$disableRipple = props.disableRipple,
        disableRipple = _props$disableRipple === void 0 ? false : _props$disableRipple,
        _props$disableTouchRi = props.disableTouchRipple,
        disableTouchRipple = _props$disableTouchRi === void 0 ? false : _props$disableTouchRi,
        _props$focusRipple = props.focusRipple,
        focusRipple = _props$focusRipple === void 0 ? false : _props$focusRipple,
        focusVisibleClassName = props.focusVisibleClassName,
        onBlur = props.onBlur,
        onClick = props.onClick,
        onFocus = props.onFocus,
        onFocusVisible = props.onFocusVisible,
        onKeyDown = props.onKeyDown,
        onKeyUp = props.onKeyUp,
        onMouseDown = props.onMouseDown,
        onMouseLeave = props.onMouseLeave,
        onMouseUp = props.onMouseUp,
        onTouchEnd = props.onTouchEnd,
        onTouchMove = props.onTouchMove,
        onTouchStart = props.onTouchStart,
        onDragLeave = props.onDragLeave,
        _props$tabIndex = props.tabIndex,
        tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex,
        TouchRippleProps = props.TouchRippleProps,
        _props$type = props.type,
        type = _props$type === void 0 ? 'button' : _props$type,
        other = _objectWithoutProperties(props, ["action", "buttonRef", "centerRipple", "children", "classes", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "onBlur", "onClick", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "onDragLeave", "tabIndex", "TouchRippleProps", "type"]);

    var buttonRef = React__namespace.useRef(null);

    function getButtonNode() {
      // #StrictMode ready
      return ReactDOM__namespace.findDOMNode(buttonRef.current);
    }

    var rippleRef = React__namespace.useRef(null);

    var _React$useState = React__namespace.useState(false),
        focusVisible = _React$useState[0],
        setFocusVisible = _React$useState[1];

    if (disabled && focusVisible) {
      setFocusVisible(false);
    }

    var _useIsFocusVisible = useIsFocusVisible(),
        isFocusVisible = _useIsFocusVisible.isFocusVisible,
        onBlurVisible = _useIsFocusVisible.onBlurVisible,
        focusVisibleRef = _useIsFocusVisible.ref;

    React__namespace.useImperativeHandle(action, function () {
      return {
        focusVisible: function focusVisible() {
          setFocusVisible(true);
          buttonRef.current.focus();
        }
      };
    }, []);
    React__namespace.useEffect(function () {
      if (focusVisible && focusRipple && !disableRipple) {
        rippleRef.current.pulsate();
      }
    }, [disableRipple, focusRipple, focusVisible]);

    function useRippleHandler(rippleAction, eventCallback) {
      var skipRippleAction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : disableTouchRipple;
      return useEventCallback(function (event) {
        if (eventCallback) {
          eventCallback(event);
        }

        var ignore = skipRippleAction;

        if (!ignore && rippleRef.current) {
          rippleRef.current[rippleAction](event);
        }

        return true;
      });
    }

    var handleMouseDown = useRippleHandler('start', onMouseDown);
    var handleDragLeave = useRippleHandler('stop', onDragLeave);
    var handleMouseUp = useRippleHandler('stop', onMouseUp);
    var handleMouseLeave = useRippleHandler('stop', function (event) {
      if (focusVisible) {
        event.preventDefault();
      }

      if (onMouseLeave) {
        onMouseLeave(event);
      }
    });
    var handleTouchStart = useRippleHandler('start', onTouchStart);
    var handleTouchEnd = useRippleHandler('stop', onTouchEnd);
    var handleTouchMove = useRippleHandler('stop', onTouchMove);
    var handleBlur = useRippleHandler('stop', function (event) {
      if (focusVisible) {
        onBlurVisible(event);
        setFocusVisible(false);
      }

      if (onBlur) {
        onBlur(event);
      }
    }, false);
    var handleFocus = useEventCallback(function (event) {
      // Fix for https://github.com/facebook/react/issues/7769
      if (!buttonRef.current) {
        buttonRef.current = event.currentTarget;
      }

      if (isFocusVisible(event)) {
        setFocusVisible(true);

        if (onFocusVisible) {
          onFocusVisible(event);
        }
      }

      if (onFocus) {
        onFocus(event);
      }
    });

    var isNonNativeButton = function isNonNativeButton() {
      var button = getButtonNode();
      return component && component !== 'button' && !(button.tagName === 'A' && button.href);
    };
    /**
     * IE 11 shim for https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat
     */


    var keydownRef = React__namespace.useRef(false);
    var handleKeyDown = useEventCallback(function (event) {
      // Check if key is already down to avoid repeats being counted as multiple activations
      if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === ' ') {
        keydownRef.current = true;
        event.persist();
        rippleRef.current.stop(event, function () {
          rippleRef.current.start(event);
        });
      }

      if (event.target === event.currentTarget && isNonNativeButton() && event.key === ' ') {
        event.preventDefault();
      }

      if (onKeyDown) {
        onKeyDown(event);
      } // Keyboard accessibility for non interactive elements


      if (event.target === event.currentTarget && isNonNativeButton() && event.key === 'Enter' && !disabled) {
        event.preventDefault();

        if (onClick) {
          onClick(event);
        }
      }
    });
    var handleKeyUp = useEventCallback(function (event) {
      // calling preventDefault in keyUp on a <button> will not dispatch a click event if Space is pressed
      // https://codesandbox.io/s/button-keyup-preventdefault-dn7f0
      if (focusRipple && event.key === ' ' && rippleRef.current && focusVisible && !event.defaultPrevented) {
        keydownRef.current = false;
        event.persist();
        rippleRef.current.stop(event, function () {
          rippleRef.current.pulsate(event);
        });
      }

      if (onKeyUp) {
        onKeyUp(event);
      } // Keyboard accessibility for non interactive elements


      if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === ' ' && !event.defaultPrevented) {
        onClick(event);
      }
    });
    var ComponentProp = component;

    if (ComponentProp === 'button' && other.href) {
      ComponentProp = 'a';
    }

    var buttonProps = {};

    if (ComponentProp === 'button') {
      buttonProps.type = type;
      buttonProps.disabled = disabled;
    } else {
      if (ComponentProp !== 'a' || !other.href) {
        buttonProps.role = 'button';
      }

      buttonProps['aria-disabled'] = disabled;
    }

    var handleUserRef = useForkRef(buttonRefProp, ref);
    var handleOwnRef = useForkRef(focusVisibleRef, buttonRef);
    var handleRef = useForkRef(handleUserRef, handleOwnRef);

    var _React$useState2 = React__namespace.useState(false),
        mountedState = _React$useState2[0],
        setMountedState = _React$useState2[1];

    React__namespace.useEffect(function () {
      setMountedState(true);
    }, []);
    var enableTouchRipple = mountedState && !disableRipple && !disabled;

    {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React__namespace.useEffect(function () {
        if (enableTouchRipple && !rippleRef.current) {
          console.error(['Material-UI: The `component` prop provided to ButtonBase is invalid.', 'Please make sure the children prop is rendered in this custom component.'].join('\n'));
        }
      }, [enableTouchRipple]);
    }

    return /*#__PURE__*/React__namespace.createElement(ComponentProp, _extends$1({
      className: clsx(classes.root, className, focusVisible && [classes.focusVisible, focusVisibleClassName], disabled && classes.disabled),
      onBlur: handleBlur,
      onClick: onClick,
      onFocus: handleFocus,
      onKeyDown: handleKeyDown,
      onKeyUp: handleKeyUp,
      onMouseDown: handleMouseDown,
      onMouseLeave: handleMouseLeave,
      onMouseUp: handleMouseUp,
      onDragLeave: handleDragLeave,
      onTouchEnd: handleTouchEnd,
      onTouchMove: handleTouchMove,
      onTouchStart: handleTouchStart,
      ref: handleRef,
      tabIndex: disabled ? -1 : tabIndex
    }, buttonProps, other), children, enableTouchRipple ?
    /*#__PURE__*/

    /* TouchRipple is only needed client-side, x2 boost on the server. */
    React__namespace.createElement(TouchRipple$1, _extends$1({
      ref: rippleRef,
      center: centerRipple
    }, TouchRippleProps)) : null);
  });
  ButtonBase.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * A ref for imperative actions.
     * It currently only supports `focusVisible()` action.
     */
    action: refType$1,

    /**
     * @ignore
     *
     * Use that prop to pass a ref to the native button component.
     * @deprecated Use `ref` instead.
     */
    buttonRef: deprecatedPropType(refType$1, 'Use `ref` instead.'),

    /**
     * If `true`, the ripples will be centered.
     * They won't start at the cursor interaction position.
     */
    centerRipple: PropTypes.bool,

    /**
     * The content of the component.
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: elementTypeAcceptingRef$1,

    /**
     * If `true`, the base button will be disabled.
     */
    disabled: PropTypes.bool,

    /**
     * If `true`, the ripple effect will be disabled.
     *
     *  Without a ripple there is no styling for :focus-visible by default. Be sure
     * to highlight the element by applying separate styles with the `focusVisibleClassName`.
     */
    disableRipple: PropTypes.bool,

    /**
     * If `true`, the touch ripple effect will be disabled.
     */
    disableTouchRipple: PropTypes.bool,

    /**
     * If `true`, the base button will have a keyboard focus ripple.
     */
    focusRipple: PropTypes.bool,

    /**
     * This prop can help identify which element has keyboard focus.
     * The class name will be applied when the element gains the focus through keyboard interaction.
     * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
     * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/master/explainer.md).
     * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
     * if needed.
     */
    focusVisibleClassName: PropTypes.string,

    /**
     * @ignore
     */
    href: PropTypes.string,

    /**
     * @ignore
     */
    onBlur: PropTypes.func,

    /**
     * @ignore
     */
    onClick: PropTypes.func,

    /**
     * @ignore
     */
    onDragLeave: PropTypes.func,

    /**
     * @ignore
     */
    onFocus: PropTypes.func,

    /**
     * Callback fired when the component is focused with a keyboard.
     * We trigger a `onFocus` callback too.
     */
    onFocusVisible: PropTypes.func,

    /**
     * @ignore
     */
    onKeyDown: PropTypes.func,

    /**
     * @ignore
     */
    onKeyUp: PropTypes.func,

    /**
     * @ignore
     */
    onMouseDown: PropTypes.func,

    /**
     * @ignore
     */
    onMouseLeave: PropTypes.func,

    /**
     * @ignore
     */
    onMouseUp: PropTypes.func,

    /**
     * @ignore
     */
    onTouchEnd: PropTypes.func,

    /**
     * @ignore
     */
    onTouchMove: PropTypes.func,

    /**
     * @ignore
     */
    onTouchStart: PropTypes.func,

    /**
     * @ignore
     */
    tabIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * Props applied to the `TouchRipple` element.
     */
    TouchRippleProps: PropTypes.object,

    /**
     * @ignore
     */
    type: PropTypes.oneOfType([PropTypes.oneOf(['button', 'reset', 'submit']), PropTypes.string])
  } ;
  var ButtonBase$1 = withStyles(styles$p, {
    name: 'MuiButtonBase'
  })(ButtonBase);

  var styles$o = function styles(theme) {
    return {
      /* Styles applied to the root element. */
      root: {
        textAlign: 'center',
        flex: '0 0 auto',
        fontSize: theme.typography.pxToRem(24),
        padding: 12,
        borderRadius: '50%',
        overflow: 'visible',
        // Explicitly set the default value to solve a bug on IE 11.
        color: theme.palette.action.active,
        transition: theme.transitions.create('background-color', {
          duration: theme.transitions.duration.shortest
        }),
        '&:hover': {
          backgroundColor: alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: 'transparent'
          }
        },
        '&$disabled': {
          backgroundColor: 'transparent',
          color: theme.palette.action.disabled
        }
      },

      /* Styles applied to the root element if `edge="start"`. */
      edgeStart: {
        marginLeft: -12,
        '$sizeSmall&': {
          marginLeft: -3
        }
      },

      /* Styles applied to the root element if `edge="end"`. */
      edgeEnd: {
        marginRight: -12,
        '$sizeSmall&': {
          marginRight: -3
        }
      },

      /* Styles applied to the root element if `color="inherit"`. */
      colorInherit: {
        color: 'inherit'
      },

      /* Styles applied to the root element if `color="primary"`. */
      colorPrimary: {
        color: theme.palette.primary.main,
        '&:hover': {
          backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: 'transparent'
          }
        }
      },

      /* Styles applied to the root element if `color="secondary"`. */
      colorSecondary: {
        color: theme.palette.secondary.main,
        '&:hover': {
          backgroundColor: alpha(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: 'transparent'
          }
        }
      },

      /* Pseudo-class applied to the root element if `disabled={true}`. */
      disabled: {},

      /* Styles applied to the root element if `size="small"`. */
      sizeSmall: {
        padding: 3,
        fontSize: theme.typography.pxToRem(18)
      },

      /* Styles applied to the children container element. */
      label: {
        width: '100%',
        display: 'flex',
        alignItems: 'inherit',
        justifyContent: 'inherit'
      }
    };
  };
  /**
   * Refer to the [Icons](/components/icons/) section of the documentation
   * regarding the available icon options.
   */

  var IconButton = /*#__PURE__*/React__namespace.forwardRef(function IconButton(props, ref) {
    var _props$edge = props.edge,
        edge = _props$edge === void 0 ? false : _props$edge,
        children = props.children,
        classes = props.classes,
        className = props.className,
        _props$color = props.color,
        color = _props$color === void 0 ? 'default' : _props$color,
        _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled,
        _props$disableFocusRi = props.disableFocusRipple,
        disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi,
        _props$size = props.size,
        size = _props$size === void 0 ? 'medium' : _props$size,
        other = _objectWithoutProperties(props, ["edge", "children", "classes", "className", "color", "disabled", "disableFocusRipple", "size"]);

    return /*#__PURE__*/React__namespace.createElement(ButtonBase$1, _extends$1({
      className: clsx(classes.root, className, color !== 'default' && classes["color".concat(capitalize(color))], disabled && classes.disabled, size === "small" && classes["size".concat(capitalize(size))], {
        'start': classes.edgeStart,
        'end': classes.edgeEnd
      }[edge]),
      centerRipple: true,
      focusRipple: !disableFocusRipple,
      disabled: disabled,
      ref: ref
    }, other), /*#__PURE__*/React__namespace.createElement("span", {
      className: classes.label
    }, children));
  });
  IconButton.propTypes = {
    /**
     * The icon element.
     */
    children: chainPropTypes(PropTypes.node, function (props) {
      var found = React__namespace.Children.toArray(props.children).some(function (child) {
        return /*#__PURE__*/React__namespace.isValidElement(child) && child.props.onClick;
      });

      if (found) {
        return new Error(['Material-UI: You are providing an onClick event listener ' + 'to a child of a button element.', 'Firefox will never trigger the event.', 'You should move the onClick listener to the parent button element.', 'https://github.com/mui-org/material-ui/issues/13957'].join('\n'));
      }

      return null;
    }),

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object.isRequired,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * The color of the component. It supports those theme colors that make sense for this component.
     */
    color: PropTypes.oneOf(['default', 'inherit', 'primary', 'secondary']),

    /**
     * If `true`, the button will be disabled.
     */
    disabled: PropTypes.bool,

    /**
     * If `true`, the  keyboard focus ripple will be disabled.
     */
    disableFocusRipple: PropTypes.bool,

    /**
     * If `true`, the ripple effect will be disabled.
     */
    disableRipple: PropTypes.bool,

    /**
     * If given, uses a negative margin to counteract the padding on one
     * side (this is often helpful for aligning the left or right
     * side of the icon with content above or below, without ruining the border
     * size and shape).
     */
    edge: PropTypes.oneOf(['start', 'end', false]),

    /**
     * The size of the button.
     * `small` is equivalent to the dense button styling.
     */
    size: PropTypes.oneOf(['small', 'medium'])
  } ;
  var IconButton$1 = withStyles(styles$o, {
    name: 'MuiIconButton'
  })(IconButton);

  var styles$n = function styles(theme) {
    return {
      /* Styles applied to the root element. */
      root: {
        userSelect: 'none',
        width: '1em',
        height: '1em',
        display: 'inline-block',
        fill: 'currentColor',
        flexShrink: 0,
        fontSize: theme.typography.pxToRem(24),
        transition: theme.transitions.create('fill', {
          duration: theme.transitions.duration.shorter
        })
      },

      /* Styles applied to the root element if `color="primary"`. */
      colorPrimary: {
        color: theme.palette.primary.main
      },

      /* Styles applied to the root element if `color="secondary"`. */
      colorSecondary: {
        color: theme.palette.secondary.main
      },

      /* Styles applied to the root element if `color="action"`. */
      colorAction: {
        color: theme.palette.action.active
      },

      /* Styles applied to the root element if `color="error"`. */
      colorError: {
        color: theme.palette.error.main
      },

      /* Styles applied to the root element if `color="disabled"`. */
      colorDisabled: {
        color: theme.palette.action.disabled
      },

      /* Styles applied to the root element if `fontSize="inherit"`. */
      fontSizeInherit: {
        fontSize: 'inherit'
      },

      /* Styles applied to the root element if `fontSize="small"`. */
      fontSizeSmall: {
        fontSize: theme.typography.pxToRem(20)
      },

      /* Styles applied to the root element if `fontSize="large"`. */
      fontSizeLarge: {
        fontSize: theme.typography.pxToRem(35)
      }
    };
  };
  var SvgIcon = /*#__PURE__*/React__namespace.forwardRef(function SvgIcon(props, ref) {
    var children = props.children,
        classes = props.classes,
        className = props.className,
        _props$color = props.color,
        color = _props$color === void 0 ? 'inherit' : _props$color,
        _props$component = props.component,
        Component = _props$component === void 0 ? 'svg' : _props$component,
        _props$fontSize = props.fontSize,
        fontSize = _props$fontSize === void 0 ? 'medium' : _props$fontSize,
        htmlColor = props.htmlColor,
        titleAccess = props.titleAccess,
        _props$viewBox = props.viewBox,
        viewBox = _props$viewBox === void 0 ? '0 0 24 24' : _props$viewBox,
        other = _objectWithoutProperties(props, ["children", "classes", "className", "color", "component", "fontSize", "htmlColor", "titleAccess", "viewBox"]);

    return /*#__PURE__*/React__namespace.createElement(Component, _extends$1({
      className: clsx(classes.root, className, color !== 'inherit' && classes["color".concat(capitalize(color))], fontSize !== 'default' && fontSize !== 'medium' && classes["fontSize".concat(capitalize(fontSize))]),
      focusable: "false",
      viewBox: viewBox,
      color: htmlColor,
      "aria-hidden": titleAccess ? undefined : true,
      role: titleAccess ? 'img' : undefined,
      ref: ref
    }, other), children, titleAccess ? /*#__PURE__*/React__namespace.createElement("title", null, titleAccess) : null);
  });
  SvgIcon.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * Node passed into the SVG element.
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * The color of the component. It supports those theme colors that make sense for this component.
     * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
     */
    color: PropTypes.oneOf(['action', 'disabled', 'error', 'inherit', 'primary', 'secondary']),

    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: PropTypes
    /* @typescript-to-proptypes-ignore */
    .elementType,

    /**
     * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
     */
    fontSize: chainPropTypes(PropTypes.oneOf(['default', 'inherit', 'large', 'medium', 'small']), function (props) {
      var fontSize = props.fontSize;

      if (fontSize === 'default') {
        throw new Error('Material-UI: `fontSize="default"` is deprecated. Use `fontSize="medium"` instead.');
      }

      return null;
    }),

    /**
     * Applies a color attribute to the SVG element.
     */
    htmlColor: PropTypes.string,

    /**
     * The shape-rendering attribute. The behavior of the different options is described on the
     * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).
     * If you are having issues with blurry icons you should investigate this property.
     */
    shapeRendering: PropTypes.string,

    /**
     * Provides a human-readable title for the element that contains it.
     * https://www.w3.org/TR/SVG-access/#Equivalent
     */
    titleAccess: PropTypes.string,

    /**
     * Allows you to redefine what the coordinates without units mean inside an SVG element.
     * For example, if the SVG element is 500 (width) by 200 (height),
     * and you pass viewBox="0 0 50 20",
     * this means that the coordinates inside the SVG will go from the top left corner (0,0)
     * to bottom right (50,20) and each unit will be worth 10px.
     */
    viewBox: PropTypes.string
  } ;
  SvgIcon.muiName = 'SvgIcon';
  var SvgIcon$1 = withStyles(styles$n, {
    name: 'MuiSvgIcon'
  })(SvgIcon);

  /**
   * Private module reserved for @material-ui/x packages.
   */

  function createSvgIcon(path, displayName) {
    var Component = function Component(props, ref) {
      return /*#__PURE__*/React__default["default"].createElement(SvgIcon$1, _extends$1({
        ref: ref
      }, props), path);
    };

    {
      // Need to set `displayName` on the inner component for React.memo.
      // React prior to 16.14 ignores `displayName` on the wrapper.
      Component.displayName = "".concat(displayName, "Icon");
    }

    Component.muiName = SvgIcon$1.muiName;
    return /*#__PURE__*/React__default["default"].memo( /*#__PURE__*/React__default["default"].forwardRef(Component));
  }

  /**
   * @ignore - internal component.
   */

  var CancelIcon = createSvgIcon( /*#__PURE__*/React__namespace.createElement("path", {
    d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
  }), 'Cancel');

  function unsupportedProp(props, propName, componentName, location, propFullName) {

    var propFullNameSafe = propFullName || propName;

    if (typeof props[propName] !== 'undefined') {
      return new Error("The prop `".concat(propFullNameSafe, "` is not supported. Please remove it."));
    }

    return null;
  }

  var styles$m = function styles(theme) {
    var backgroundColor = theme.palette.type === 'light' ? theme.palette.grey[300] : theme.palette.grey[700];
    var deleteIconColor = alpha(theme.palette.text.primary, 0.26);
    return {
      /* Styles applied to the root element. */
      root: {
        fontFamily: theme.typography.fontFamily,
        fontSize: theme.typography.pxToRem(13),
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        height: 32,
        color: theme.palette.getContrastText(backgroundColor),
        backgroundColor: backgroundColor,
        borderRadius: 32 / 2,
        whiteSpace: 'nowrap',
        transition: theme.transitions.create(['background-color', 'box-shadow']),
        // label will inherit this from root, then `clickable` class overrides this for both
        cursor: 'default',
        // We disable the focus ring for mouse, touch and keyboard users.
        outline: 0,
        textDecoration: 'none',
        border: 'none',
        // Remove `button` border
        padding: 0,
        // Remove `button` padding
        verticalAlign: 'middle',
        boxSizing: 'border-box',
        '&$disabled': {
          opacity: 0.5,
          pointerEvents: 'none'
        },
        '& $avatar': {
          marginLeft: 5,
          marginRight: -6,
          width: 24,
          height: 24,
          color: theme.palette.type === 'light' ? theme.palette.grey[700] : theme.palette.grey[300],
          fontSize: theme.typography.pxToRem(12)
        },
        '& $avatarColorPrimary': {
          color: theme.palette.primary.contrastText,
          backgroundColor: theme.palette.primary.dark
        },
        '& $avatarColorSecondary': {
          color: theme.palette.secondary.contrastText,
          backgroundColor: theme.palette.secondary.dark
        },
        '& $avatarSmall': {
          marginLeft: 4,
          marginRight: -4,
          width: 18,
          height: 18,
          fontSize: theme.typography.pxToRem(10)
        }
      },

      /* Styles applied to the root element if `size="small"`. */
      sizeSmall: {
        height: 24
      },

      /* Styles applied to the root element if `color="primary"`. */
      colorPrimary: {
        backgroundColor: theme.palette.primary.main,
        color: theme.palette.primary.contrastText
      },

      /* Styles applied to the root element if `color="secondary"`. */
      colorSecondary: {
        backgroundColor: theme.palette.secondary.main,
        color: theme.palette.secondary.contrastText
      },

      /* Pseudo-class applied to the root element if `disabled={true}`. */
      disabled: {},

      /* Styles applied to the root element if `onClick` is defined or `clickable={true}`. */
      clickable: {
        userSelect: 'none',
        WebkitTapHighlightColor: 'transparent',
        cursor: 'pointer',
        '&:hover, &:focus': {
          backgroundColor: emphasize(backgroundColor, 0.08)
        },
        '&:active': {
          boxShadow: theme.shadows[1]
        }
      },

      /* Styles applied to the root element if `onClick` and `color="primary"` is defined or `clickable={true}`. */
      clickableColorPrimary: {
        '&:hover, &:focus': {
          backgroundColor: emphasize(theme.palette.primary.main, 0.08)
        }
      },

      /* Styles applied to the root element if `onClick` and `color="secondary"` is defined or `clickable={true}`. */
      clickableColorSecondary: {
        '&:hover, &:focus': {
          backgroundColor: emphasize(theme.palette.secondary.main, 0.08)
        }
      },

      /* Styles applied to the root element if `onDelete` is defined. */
      deletable: {
        '&:focus': {
          backgroundColor: emphasize(backgroundColor, 0.08)
        }
      },

      /* Styles applied to the root element if `onDelete` and `color="primary"` is defined. */
      deletableColorPrimary: {
        '&:focus': {
          backgroundColor: emphasize(theme.palette.primary.main, 0.2)
        }
      },

      /* Styles applied to the root element if `onDelete` and `color="secondary"` is defined. */
      deletableColorSecondary: {
        '&:focus': {
          backgroundColor: emphasize(theme.palette.secondary.main, 0.2)
        }
      },

      /* Styles applied to the root element if `variant="outlined"`. */
      outlined: {
        backgroundColor: 'transparent',
        border: "1px solid ".concat(theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)'),
        '$clickable&:hover, $clickable&:focus, $deletable&:focus': {
          backgroundColor: alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity)
        },
        '& $avatar': {
          marginLeft: 4
        },
        '& $avatarSmall': {
          marginLeft: 2
        },
        '& $icon': {
          marginLeft: 4
        },
        '& $iconSmall': {
          marginLeft: 2
        },
        '& $deleteIcon': {
          marginRight: 5
        },
        '& $deleteIconSmall': {
          marginRight: 3
        }
      },

      /* Styles applied to the root element if `variant="outlined"` and `color="primary"`. */
      outlinedPrimary: {
        color: theme.palette.primary.main,
        border: "1px solid ".concat(theme.palette.primary.main),
        '$clickable&:hover, $clickable&:focus, $deletable&:focus': {
          backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity)
        }
      },

      /* Styles applied to the root element if `variant="outlined"` and `color="secondary"`. */
      outlinedSecondary: {
        color: theme.palette.secondary.main,
        border: "1px solid ".concat(theme.palette.secondary.main),
        '$clickable&:hover, $clickable&:focus, $deletable&:focus': {
          backgroundColor: alpha(theme.palette.secondary.main, theme.palette.action.hoverOpacity)
        }
      },
      // TODO v5: remove

      /* Styles applied to the `avatar` element. */
      avatar: {},

      /* Styles applied to the `avatar` element if `size="small"`. */
      avatarSmall: {},

      /* Styles applied to the `avatar` element if `color="primary"`. */
      avatarColorPrimary: {},

      /* Styles applied to the `avatar` element if `color="secondary"`. */
      avatarColorSecondary: {},

      /* Styles applied to the `icon` element. */
      icon: {
        color: theme.palette.type === 'light' ? theme.palette.grey[700] : theme.palette.grey[300],
        marginLeft: 5,
        marginRight: -6
      },

      /* Styles applied to the `icon` element if `size="small"`. */
      iconSmall: {
        width: 18,
        height: 18,
        marginLeft: 4,
        marginRight: -4
      },

      /* Styles applied to the `icon` element if `color="primary"`. */
      iconColorPrimary: {
        color: 'inherit'
      },

      /* Styles applied to the `icon` element if `color="secondary"`. */
      iconColorSecondary: {
        color: 'inherit'
      },

      /* Styles applied to the label `span` element. */
      label: {
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        paddingLeft: 12,
        paddingRight: 12,
        whiteSpace: 'nowrap'
      },

      /* Styles applied to the label `span` element if `size="small"`. */
      labelSmall: {
        paddingLeft: 8,
        paddingRight: 8
      },

      /* Styles applied to the `deleteIcon` element. */
      deleteIcon: {
        WebkitTapHighlightColor: 'transparent',
        color: deleteIconColor,
        height: 22,
        width: 22,
        cursor: 'pointer',
        margin: '0 5px 0 -6px',
        '&:hover': {
          color: alpha(deleteIconColor, 0.4)
        }
      },

      /* Styles applied to the `deleteIcon` element if `size="small"`. */
      deleteIconSmall: {
        height: 16,
        width: 16,
        marginRight: 4,
        marginLeft: -4
      },

      /* Styles applied to the deleteIcon element if `color="primary"` and `variant="default"`. */
      deleteIconColorPrimary: {
        color: alpha(theme.palette.primary.contrastText, 0.7),
        '&:hover, &:active': {
          color: theme.palette.primary.contrastText
        }
      },

      /* Styles applied to the deleteIcon element if `color="secondary"` and `variant="default"`. */
      deleteIconColorSecondary: {
        color: alpha(theme.palette.secondary.contrastText, 0.7),
        '&:hover, &:active': {
          color: theme.palette.secondary.contrastText
        }
      },

      /* Styles applied to the deleteIcon element if `color="primary"` and `variant="outlined"`. */
      deleteIconOutlinedColorPrimary: {
        color: alpha(theme.palette.primary.main, 0.7),
        '&:hover, &:active': {
          color: theme.palette.primary.main
        }
      },

      /* Styles applied to the deleteIcon element if `color="secondary"` and `variant="outlined"`. */
      deleteIconOutlinedColorSecondary: {
        color: alpha(theme.palette.secondary.main, 0.7),
        '&:hover, &:active': {
          color: theme.palette.secondary.main
        }
      }
    };
  };

  function isDeleteKeyboardEvent(keyboardEvent) {
    return keyboardEvent.key === 'Backspace' || keyboardEvent.key === 'Delete';
  }
  /**
   * Chips represent complex entities in small blocks, such as a contact.
   */


  var Chip = /*#__PURE__*/React__namespace.forwardRef(function Chip(props, ref) {
    var avatarProp = props.avatar,
        classes = props.classes,
        className = props.className,
        clickableProp = props.clickable,
        _props$color = props.color,
        color = _props$color === void 0 ? 'default' : _props$color,
        ComponentProp = props.component,
        deleteIconProp = props.deleteIcon,
        _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled,
        iconProp = props.icon,
        label = props.label,
        onClick = props.onClick,
        onDelete = props.onDelete,
        onKeyDown = props.onKeyDown,
        onKeyUp = props.onKeyUp,
        _props$size = props.size,
        size = _props$size === void 0 ? 'medium' : _props$size,
        _props$variant = props.variant,
        variant = _props$variant === void 0 ? 'default' : _props$variant,
        other = _objectWithoutProperties(props, ["avatar", "classes", "className", "clickable", "color", "component", "deleteIcon", "disabled", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "size", "variant"]);

    var chipRef = React__namespace.useRef(null);
    var handleRef = useForkRef(chipRef, ref);

    var handleDeleteIconClick = function handleDeleteIconClick(event) {
      // Stop the event from bubbling up to the `Chip`
      event.stopPropagation();

      if (onDelete) {
        onDelete(event);
      }
    };

    var handleKeyDown = function handleKeyDown(event) {
      // Ignore events from children of `Chip`.
      if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
        // will be handled in keyUp, otherwise some browsers
        // might init navigation
        event.preventDefault();
      }

      if (onKeyDown) {
        onKeyDown(event);
      }
    };

    var handleKeyUp = function handleKeyUp(event) {
      // Ignore events from children of `Chip`.
      if (event.currentTarget === event.target) {
        if (onDelete && isDeleteKeyboardEvent(event)) {
          onDelete(event);
        } else if (event.key === 'Escape' && chipRef.current) {
          chipRef.current.blur();
        }
      }

      if (onKeyUp) {
        onKeyUp(event);
      }
    };

    var clickable = clickableProp !== false && onClick ? true : clickableProp;
    var small = size === 'small';
    var Component = ComponentProp || (clickable ? ButtonBase$1 : 'div');
    var moreProps = Component === ButtonBase$1 ? {
      component: 'div'
    } : {};
    var deleteIcon = null;

    if (onDelete) {
      var customClasses = clsx(color !== 'default' && (variant === "default" ? classes["deleteIconColor".concat(capitalize(color))] : classes["deleteIconOutlinedColor".concat(capitalize(color))]), small && classes.deleteIconSmall);
      deleteIcon = deleteIconProp && /*#__PURE__*/React__namespace.isValidElement(deleteIconProp) ? /*#__PURE__*/React__namespace.cloneElement(deleteIconProp, {
        className: clsx(deleteIconProp.props.className, classes.deleteIcon, customClasses),
        onClick: handleDeleteIconClick
      }) : /*#__PURE__*/React__namespace.createElement(CancelIcon, {
        className: clsx(classes.deleteIcon, customClasses),
        onClick: handleDeleteIconClick
      });
    }

    var avatar = null;

    if (avatarProp && /*#__PURE__*/React__namespace.isValidElement(avatarProp)) {
      avatar = /*#__PURE__*/React__namespace.cloneElement(avatarProp, {
        className: clsx(classes.avatar, avatarProp.props.className, small && classes.avatarSmall, color !== 'default' && classes["avatarColor".concat(capitalize(color))])
      });
    }

    var icon = null;

    if (iconProp && /*#__PURE__*/React__namespace.isValidElement(iconProp)) {
      icon = /*#__PURE__*/React__namespace.cloneElement(iconProp, {
        className: clsx(classes.icon, iconProp.props.className, small && classes.iconSmall, color !== 'default' && classes["iconColor".concat(capitalize(color))])
      });
    }

    {
      if (avatar && icon) {
        console.error('Material-UI: The Chip component can not handle the avatar ' + 'and the icon prop at the same time. Pick one.');
      }
    }

    return /*#__PURE__*/React__namespace.createElement(Component, _extends$1({
      role: clickable || onDelete ? 'button' : undefined,
      className: clsx(classes.root, className, color !== 'default' && [classes["color".concat(capitalize(color))], clickable && classes["clickableColor".concat(capitalize(color))], onDelete && classes["deletableColor".concat(capitalize(color))]], variant !== "default" && [classes.outlined, {
        'primary': classes.outlinedPrimary,
        'secondary': classes.outlinedSecondary
      }[color]], disabled && classes.disabled, small && classes.sizeSmall, clickable && classes.clickable, onDelete && classes.deletable),
      "aria-disabled": disabled ? true : undefined,
      tabIndex: clickable || onDelete ? 0 : undefined,
      onClick: onClick,
      onKeyDown: handleKeyDown,
      onKeyUp: handleKeyUp,
      ref: handleRef
    }, moreProps, other), avatar || icon, /*#__PURE__*/React__namespace.createElement("span", {
      className: clsx(classes.label, small && classes.labelSmall)
    }, label), deleteIcon);
  });
  Chip.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * Avatar element.
     */
    avatar: PropTypes.element,

    /**
     * This prop isn't supported.
     * Use the `component` prop if you need to change the children structure.
     */
    children: unsupportedProp,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * If `true`, the chip will appear clickable, and will raise when pressed,
     * even if the onClick prop is not defined.
     * If false, the chip will not be clickable, even if onClick prop is defined.
     * This can be used, for example,
     * along with the component prop to indicate an anchor Chip is clickable.
     */
    clickable: PropTypes.bool,

    /**
     * The color of the component. It supports those theme colors that make sense for this component.
     */
    color: PropTypes.oneOf(['default', 'primary', 'secondary']),

    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: PropTypes
    /* @typescript-to-proptypes-ignore */
    .elementType,

    /**
     * Override the default delete icon element. Shown only if `onDelete` is set.
     */
    deleteIcon: PropTypes.element,

    /**
     * If `true`, the chip should be displayed in a disabled state.
     */
    disabled: PropTypes.bool,

    /**
     * Icon element.
     */
    icon: PropTypes.element,

    /**
     * The content of the label.
     */
    label: PropTypes.node,

    /**
     * @ignore
     */
    onClick: PropTypes.func,

    /**
     * Callback function fired when the delete icon is clicked.
     * If set, the delete icon will be shown.
     */
    onDelete: PropTypes.func,

    /**
     * @ignore
     */
    onKeyDown: PropTypes.func,

    /**
     * @ignore
     */
    onKeyUp: PropTypes.func,

    /**
     * The size of the chip.
     */
    size: PropTypes.oneOf(['medium', 'small']),

    /**
     * The variant to use.
     */
    variant: PropTypes.oneOf(['default', 'outlined'])
  } ;
  var Chip$1 = withStyles(styles$m, {
    name: 'MuiChip'
  })(Chip);

  // Corresponds to 10 frames at 60 Hz.
  // A few bytes payload overhead when lodash/debounce is ~3 kB and debounce ~300 B.
  function debounce(func) {
    var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 166;
    var timeout;

    function debounced() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      } // eslint-disable-next-line consistent-this


      var that = this;

      var later = function later() {
        func.apply(that, args);
      };

      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    }

    debounced.clear = function () {
      clearTimeout(timeout);
    };

    return debounced;
  }

  function isMuiElement(element, muiNames) {
    return /*#__PURE__*/React__namespace.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;
  }

  function ownerDocument(node) {
    return node && node.ownerDocument || document;
  }

  function ownerWindow(node) {
    var doc = ownerDocument(node);
    return doc.defaultView || window;
  }

  /* eslint-disable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */
  function useControlled(_ref) {
    var controlled = _ref.controlled,
        defaultProp = _ref.default,
        name = _ref.name,
        _ref$state = _ref.state,
        state = _ref$state === void 0 ? 'value' : _ref$state;

    var _React$useRef = React__namespace.useRef(controlled !== undefined),
        isControlled = _React$useRef.current;

    var _React$useState = React__namespace.useState(defaultProp),
        valueState = _React$useState[0],
        setValue = _React$useState[1];

    var value = isControlled ? controlled : valueState;

    {
      React__namespace.useEffect(function () {
        if (isControlled !== (controlled !== undefined)) {
          console.error(["Material-UI: A component is changing the ".concat(isControlled ? '' : 'un', "controlled ").concat(state, " state of ").concat(name, " to be ").concat(isControlled ? 'un' : '', "controlled."), 'Elements should not switch from uncontrolled to controlled (or vice versa).', "Decide between using a controlled or uncontrolled ".concat(name, " ") + 'element for the lifetime of the component.', "The nature of the state is determined during the first render, it's considered controlled if the value is not `undefined`.", 'More info: https://fb.me/react-controlled-components'].join('\n'));
        }
      }, [controlled]);

      var _React$useRef2 = React__namespace.useRef(defaultProp),
          defaultValue = _React$useRef2.current;

      React__namespace.useEffect(function () {
        if (!isControlled && defaultValue !== defaultProp) {
          console.error(["Material-UI: A component is changing the default ".concat(state, " state of an uncontrolled ").concat(name, " after being initialized. ") + "To suppress this warning opt to use a controlled ".concat(name, ".")].join('\n'));
        }
      }, [JSON.stringify(defaultProp)]);
    }

    var setValueIfUncontrolled = React__namespace.useCallback(function (newValue) {
      if (!isControlled) {
        setValue(newValue);
      }
    }, []);
    return [value, setValueIfUncontrolled];
  }

  /**
   * Private module reserved for @material-ui/x packages.
   */

  function useId(idOverride) {
    var _React$useState = React__namespace.useState(idOverride),
        defaultId = _React$useState[0],
        setDefaultId = _React$useState[1];

    var id = idOverride || defaultId;
    React__namespace.useEffect(function () {
      if (defaultId == null) {
        // Fallback to this default id when possible.
        // Use the random value for client-side rendering only.
        // We can't use it server-side.
        setDefaultId("mui-".concat(Math.round(Math.random() * 1e5)));
      }
    }, [defaultId]);
    return id;
  }

  /**
   * @ignore - internal component.
   */

  var CloseIcon = createSvgIcon( /*#__PURE__*/React__namespace.createElement("path", {
    d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
  }), 'Close');

  /**
   * @ignore - internal component.
   */

  var ArrowDropDownIcon$1 = createSvgIcon( /*#__PURE__*/React__namespace.createElement("path", {
    d: "M7 10l5 5 5-5z"
  }), 'ArrowDropDown');

  // Give up on IE 11 support for this feature

  function stripDiacritics(string) {
    return typeof string.normalize !== 'undefined' ? string.normalize('NFD').replace(/[\u0300-\u036f]/g, '') : string;
  }

  function createFilterOptions() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _config$ignoreAccents = config.ignoreAccents,
        ignoreAccents = _config$ignoreAccents === void 0 ? true : _config$ignoreAccents,
        _config$ignoreCase = config.ignoreCase,
        ignoreCase = _config$ignoreCase === void 0 ? true : _config$ignoreCase,
        limit = config.limit,
        _config$matchFrom = config.matchFrom,
        matchFrom = _config$matchFrom === void 0 ? 'any' : _config$matchFrom,
        stringify = config.stringify,
        _config$trim = config.trim,
        trim = _config$trim === void 0 ? false : _config$trim;
    return function (options, _ref) {
      var inputValue = _ref.inputValue,
          getOptionLabel = _ref.getOptionLabel;
      var input = trim ? inputValue.trim() : inputValue;

      if (ignoreCase) {
        input = input.toLowerCase();
      }

      if (ignoreAccents) {
        input = stripDiacritics(input);
      }

      var filteredOptions = options.filter(function (option) {
        var candidate = (stringify || getOptionLabel)(option);

        if (ignoreCase) {
          candidate = candidate.toLowerCase();
        }

        if (ignoreAccents) {
          candidate = stripDiacritics(candidate);
        }

        return matchFrom === 'start' ? candidate.indexOf(input) === 0 : candidate.indexOf(input) > -1;
      });
      return typeof limit === 'number' ? filteredOptions.slice(0, limit) : filteredOptions;
    };
  } // To replace with .findIndex() once we stop IE 11 support.

  function findIndex(array, comp) {
    for (var i = 0; i < array.length; i += 1) {
      if (comp(array[i])) {
        return i;
      }
    }

    return -1;
  }

  var defaultFilterOptions = createFilterOptions(); // Number of options to jump in list box when pageup and pagedown keys are used.

  var pageSize = 5;
  function useAutocomplete(props) {
    var _props$autoComplete = props.autoComplete,
        autoComplete = _props$autoComplete === void 0 ? false : _props$autoComplete,
        _props$autoHighlight = props.autoHighlight,
        autoHighlight = _props$autoHighlight === void 0 ? false : _props$autoHighlight,
        _props$autoSelect = props.autoSelect,
        autoSelect = _props$autoSelect === void 0 ? false : _props$autoSelect,
        _props$blurOnSelect = props.blurOnSelect,
        blurOnSelect = _props$blurOnSelect === void 0 ? false : _props$blurOnSelect,
        _props$clearOnBlur = props.clearOnBlur,
        clearOnBlur = _props$clearOnBlur === void 0 ? !props.freeSolo : _props$clearOnBlur,
        _props$clearOnEscape = props.clearOnEscape,
        clearOnEscape = _props$clearOnEscape === void 0 ? false : _props$clearOnEscape,
        _props$componentName = props.componentName,
        componentName = _props$componentName === void 0 ? 'useAutocomplete' : _props$componentName,
        _props$debug = props.debug,
        debug = _props$debug === void 0 ? false : _props$debug,
        _props$defaultValue = props.defaultValue,
        defaultValue = _props$defaultValue === void 0 ? props.multiple ? [] : null : _props$defaultValue,
        _props$disableClearab = props.disableClearable,
        disableClearable = _props$disableClearab === void 0 ? false : _props$disableClearab,
        _props$disableCloseOn = props.disableCloseOnSelect,
        disableCloseOnSelect = _props$disableCloseOn === void 0 ? false : _props$disableCloseOn,
        _props$disabledItemsF = props.disabledItemsFocusable,
        disabledItemsFocusable = _props$disabledItemsF === void 0 ? false : _props$disabledItemsF,
        _props$disableListWra = props.disableListWrap,
        disableListWrap = _props$disableListWra === void 0 ? false : _props$disableListWra,
        _props$filterOptions = props.filterOptions,
        filterOptions = _props$filterOptions === void 0 ? defaultFilterOptions : _props$filterOptions,
        _props$filterSelected = props.filterSelectedOptions,
        filterSelectedOptions = _props$filterSelected === void 0 ? false : _props$filterSelected,
        _props$freeSolo = props.freeSolo,
        freeSolo = _props$freeSolo === void 0 ? false : _props$freeSolo,
        getOptionDisabled = props.getOptionDisabled,
        _props$getOptionLabel = props.getOptionLabel,
        getOptionLabelProp = _props$getOptionLabel === void 0 ? function (option) {
      return option;
    } : _props$getOptionLabel,
        _props$getOptionSelec = props.getOptionSelected,
        getOptionSelected = _props$getOptionSelec === void 0 ? function (option, value) {
      return option === value;
    } : _props$getOptionSelec,
        groupBy = props.groupBy,
        _props$handleHomeEndK = props.handleHomeEndKeys,
        handleHomeEndKeys = _props$handleHomeEndK === void 0 ? !props.freeSolo : _props$handleHomeEndK,
        idProp = props.id,
        _props$includeInputIn = props.includeInputInList,
        includeInputInList = _props$includeInputIn === void 0 ? false : _props$includeInputIn,
        inputValueProp = props.inputValue,
        _props$multiple = props.multiple,
        multiple = _props$multiple === void 0 ? false : _props$multiple,
        onChange = props.onChange,
        onClose = props.onClose,
        onHighlightChange = props.onHighlightChange,
        onInputChange = props.onInputChange,
        onOpen = props.onOpen,
        openProp = props.open,
        _props$openOnFocus = props.openOnFocus,
        openOnFocus = _props$openOnFocus === void 0 ? false : _props$openOnFocus,
        options = props.options,
        _props$selectOnFocus = props.selectOnFocus,
        selectOnFocus = _props$selectOnFocus === void 0 ? !props.freeSolo : _props$selectOnFocus,
        valueProp = props.value;
    var id = useId(idProp);
    var getOptionLabel = getOptionLabelProp;

    {
      getOptionLabel = function getOptionLabel(option) {
        var optionLabel = getOptionLabelProp(option);

        if (typeof optionLabel !== 'string') {
          var erroneousReturn = optionLabel === undefined ? 'undefined' : "".concat(_typeof$1(optionLabel), " (").concat(optionLabel, ")");
          console.error("Material-UI: The `getOptionLabel` method of ".concat(componentName, " returned ").concat(erroneousReturn, " instead of a string for ").concat(JSON.stringify(option), "."));
        }

        return optionLabel;
      };
    }

    var ignoreFocus = React__namespace.useRef(false);
    var firstFocus = React__namespace.useRef(true);
    var inputRef = React__namespace.useRef(null);
    var listboxRef = React__namespace.useRef(null);

    var _React$useState = React__namespace.useState(null),
        anchorEl = _React$useState[0],
        setAnchorEl = _React$useState[1];

    var _React$useState2 = React__namespace.useState(-1),
        focusedTag = _React$useState2[0],
        setFocusedTag = _React$useState2[1];

    var defaultHighlighted = autoHighlight ? 0 : -1;
    var highlightedIndexRef = React__namespace.useRef(defaultHighlighted);

    var _useControlled = useControlled({
      controlled: valueProp,
      default: defaultValue,
      name: componentName
    }),
        _useControlled2 = _slicedToArray(_useControlled, 2),
        value = _useControlled2[0],
        setValue = _useControlled2[1];

    var _useControlled3 = useControlled({
      controlled: inputValueProp,
      default: '',
      name: componentName,
      state: 'inputValue'
    }),
        _useControlled4 = _slicedToArray(_useControlled3, 2),
        inputValue = _useControlled4[0],
        setInputValue = _useControlled4[1];

    var _React$useState3 = React__namespace.useState(false),
        focused = _React$useState3[0],
        setFocused = _React$useState3[1];

    var resetInputValue = useEventCallback(function (event, newValue) {
      var newInputValue;

      if (multiple) {
        newInputValue = '';
      } else if (newValue == null) {
        newInputValue = '';
      } else {
        var optionLabel = getOptionLabel(newValue);
        newInputValue = typeof optionLabel === 'string' ? optionLabel : '';
      }

      if (inputValue === newInputValue) {
        return;
      }

      setInputValue(newInputValue);

      if (onInputChange) {
        onInputChange(event, newInputValue, 'reset');
      }
    });
    React__namespace.useEffect(function () {
      resetInputValue(null, value);
    }, [value, resetInputValue]);

    var _useControlled5 = useControlled({
      controlled: openProp,
      default: false,
      name: componentName,
      state: 'open'
    }),
        _useControlled6 = _slicedToArray(_useControlled5, 2),
        open = _useControlled6[0],
        setOpenState = _useControlled6[1];

    var inputValueIsSelectedValue = !multiple && value != null && inputValue === getOptionLabel(value);
    var popupOpen = open;
    var filteredOptions = popupOpen ? filterOptions(options.filter(function (option) {
      if (filterSelectedOptions && (multiple ? value : [value]).some(function (value2) {
        return value2 !== null && getOptionSelected(option, value2);
      })) {
        return false;
      }

      return true;
    }), // we use the empty string to manipulate `filterOptions` to not filter any options
    // i.e. the filter predicate always returns true
    {
      inputValue: inputValueIsSelectedValue ? '' : inputValue,
      getOptionLabel: getOptionLabel
    }) : [];

    {
      if (value !== null && !freeSolo && options.length > 0) {
        var missingValue = (multiple ? value : [value]).filter(function (value2) {
          return !options.some(function (option) {
            return getOptionSelected(option, value2);
          });
        });

        if (missingValue.length > 0) {
          console.warn(["Material-UI: The value provided to ".concat(componentName, " is invalid."), "None of the options match with `".concat(missingValue.length > 1 ? JSON.stringify(missingValue) : JSON.stringify(missingValue[0]), "`."), 'You can use the `getOptionSelected` prop to customize the equality test.'].join('\n'));
        }
      }
    }

    var focusTag = useEventCallback(function (tagToFocus) {
      if (tagToFocus === -1) {
        inputRef.current.focus();
      } else {
        anchorEl.querySelector("[data-tag-index=\"".concat(tagToFocus, "\"]")).focus();
      }
    }); // Ensure the focusedTag is never inconsistent

    React__namespace.useEffect(function () {
      if (multiple && focusedTag > value.length - 1) {
        setFocusedTag(-1);
        focusTag(-1);
      }
    }, [value, multiple, focusedTag, focusTag]);

    function validOptionIndex(index, direction) {
      if (!listboxRef.current || index === -1) {
        return -1;
      }

      var nextFocus = index;

      while (true) {
        // Out of range
        if (direction === 'next' && nextFocus === filteredOptions.length || direction === 'previous' && nextFocus === -1) {
          return -1;
        }

        var option = listboxRef.current.querySelector("[data-option-index=\"".concat(nextFocus, "\"]")); // Same logic as MenuList.js

        var nextFocusDisabled = disabledItemsFocusable ? false : option && (option.disabled || option.getAttribute('aria-disabled') === 'true');

        if (option && !option.hasAttribute('tabindex') || nextFocusDisabled) {
          // Move to the next element.
          nextFocus += direction === 'next' ? 1 : -1;
        } else {
          return nextFocus;
        }
      }
    }

    var setHighlightedIndex = useEventCallback(function (_ref2) {
      var event = _ref2.event,
          index = _ref2.index,
          _ref2$reason = _ref2.reason,
          reason = _ref2$reason === void 0 ? 'auto' : _ref2$reason;
      highlightedIndexRef.current = index; // does the index exist?

      if (index === -1) {
        inputRef.current.removeAttribute('aria-activedescendant');
      } else {
        inputRef.current.setAttribute('aria-activedescendant', "".concat(id, "-option-").concat(index));
      }

      if (onHighlightChange) {
        onHighlightChange(event, index === -1 ? null : filteredOptions[index], reason);
      }

      if (!listboxRef.current) {
        return;
      }

      var prev = listboxRef.current.querySelector('[data-focus]');

      if (prev) {
        prev.removeAttribute('data-focus');
      }

      var listboxNode = listboxRef.current.parentElement.querySelector('[role="listbox"]'); // "No results"

      if (!listboxNode) {
        return;
      }

      if (index === -1) {
        listboxNode.scrollTop = 0;
        return;
      }

      var option = listboxRef.current.querySelector("[data-option-index=\"".concat(index, "\"]"));

      if (!option) {
        return;
      }

      option.setAttribute('data-focus', 'true'); // Scroll active descendant into view.
      // Logic copied from https://www.w3.org/TR/wai-aria-practices/examples/listbox/js/listbox.js
      //
      // Consider this API instead once it has a better browser support:
      // .scrollIntoView({ scrollMode: 'if-needed', block: 'nearest' });

      if (listboxNode.scrollHeight > listboxNode.clientHeight && reason !== 'mouse') {
        var element = option;
        var scrollBottom = listboxNode.clientHeight + listboxNode.scrollTop;
        var elementBottom = element.offsetTop + element.offsetHeight;

        if (elementBottom > scrollBottom) {
          listboxNode.scrollTop = elementBottom - listboxNode.clientHeight;
        } else if (element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0) < listboxNode.scrollTop) {
          listboxNode.scrollTop = element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0);
        }
      }
    });
    var changeHighlightedIndex = useEventCallback(function (_ref3) {
      var event = _ref3.event,
          diff = _ref3.diff,
          _ref3$direction = _ref3.direction,
          direction = _ref3$direction === void 0 ? 'next' : _ref3$direction,
          _ref3$reason = _ref3.reason,
          reason = _ref3$reason === void 0 ? 'auto' : _ref3$reason;

      if (!popupOpen) {
        return;
      }

      var getNextIndex = function getNextIndex() {
        var maxIndex = filteredOptions.length - 1;

        if (diff === 'reset') {
          return defaultHighlighted;
        }

        if (diff === 'start') {
          return 0;
        }

        if (diff === 'end') {
          return maxIndex;
        }

        var newIndex = highlightedIndexRef.current + diff;

        if (newIndex < 0) {
          if (newIndex === -1 && includeInputInList) {
            return -1;
          }

          if (disableListWrap && highlightedIndexRef.current !== -1 || Math.abs(diff) > 1) {
            return 0;
          }

          return maxIndex;
        }

        if (newIndex > maxIndex) {
          if (newIndex === maxIndex + 1 && includeInputInList) {
            return -1;
          }

          if (disableListWrap || Math.abs(diff) > 1) {
            return maxIndex;
          }

          return 0;
        }

        return newIndex;
      };

      var nextIndex = validOptionIndex(getNextIndex(), direction);
      setHighlightedIndex({
        index: nextIndex,
        reason: reason,
        event: event
      }); // Sync the content of the input with the highlighted option.

      if (autoComplete && diff !== 'reset') {
        if (nextIndex === -1) {
          inputRef.current.value = inputValue;
        } else {
          var option = getOptionLabel(filteredOptions[nextIndex]);
          inputRef.current.value = option; // The portion of the selected suggestion that has not been typed by the user,
          // a completion string, appears inline after the input cursor in the textbox.

          var index = option.toLowerCase().indexOf(inputValue.toLowerCase());

          if (index === 0 && inputValue.length > 0) {
            inputRef.current.setSelectionRange(inputValue.length, option.length);
          }
        }
      }
    });
    var syncHighlightedIndex = React__namespace.useCallback(function () {
      if (!popupOpen) {
        return;
      }

      var valueItem = multiple ? value[0] : value; // The popup is empty, reset

      if (filteredOptions.length === 0 || valueItem == null) {
        changeHighlightedIndex({
          diff: 'reset'
        });
        return;
      }

      if (!listboxRef.current) {
        return;
      } // Synchronize the value with the highlighted index


      if (!filterSelectedOptions && valueItem != null) {
        var currentOption = filteredOptions[highlightedIndexRef.current]; // Keep the current highlighted index if possible

        if (multiple && currentOption && findIndex(value, function (val) {
          return getOptionSelected(currentOption, val);
        }) !== -1) {
          return;
        }

        var itemIndex = findIndex(filteredOptions, function (optionItem) {
          return getOptionSelected(optionItem, valueItem);
        });

        if (itemIndex === -1) {
          changeHighlightedIndex({
            diff: 'reset'
          });
        } else {
          setHighlightedIndex({
            index: itemIndex
          });
        }

        return;
      } // Prevent the highlighted index to leak outside the boundaries.


      if (highlightedIndexRef.current >= filteredOptions.length - 1) {
        setHighlightedIndex({
          index: filteredOptions.length - 1
        });
        return;
      } // Restore the focus to the previous index.


      setHighlightedIndex({
        index: highlightedIndexRef.current
      }); // Ignore filteredOptions (and options, getOptionSelected, getOptionLabel) not to break the scroll position
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [// Only sync the highlighted index when the option switch between empty and not
    // eslint-disable-next-line react-hooks/exhaustive-deps
    filteredOptions.length === 0, // Don't sync the highlighted index with the value when multiple
    // eslint-disable-next-line react-hooks/exhaustive-deps
    multiple ? false : value, filterSelectedOptions, changeHighlightedIndex, setHighlightedIndex, popupOpen, inputValue, multiple]);
    var handleListboxRef = useEventCallback(function (node) {
      setRef(listboxRef, node);

      if (!node) {
        return;
      }

      syncHighlightedIndex();
    });
    React__namespace.useEffect(function () {
      syncHighlightedIndex();
    }, [syncHighlightedIndex]);

    var handleOpen = function handleOpen(event) {
      if (open) {
        return;
      }

      setOpenState(true);

      if (onOpen) {
        onOpen(event);
      }
    };

    var handleClose = function handleClose(event, reason) {
      if (!open) {
        return;
      }

      setOpenState(false);

      if (onClose) {
        onClose(event, reason);
      }
    };

    var handleValue = function handleValue(event, newValue, reason, details) {
      if (value === newValue) {
        return;
      }

      if (onChange) {
        onChange(event, newValue, reason, details);
      }

      setValue(newValue);
    };

    var isTouch = React__namespace.useRef(false);

    var selectNewValue = function selectNewValue(event, option) {
      var reasonProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'select-option';
      var origin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'options';
      var reason = reasonProp;
      var newValue = option;

      if (multiple) {
        newValue = Array.isArray(value) ? value.slice() : [];

        {
          var matches = newValue.filter(function (val) {
            return getOptionSelected(option, val);
          });

          if (matches.length > 1) {
            console.error(["Material-UI: The `getOptionSelected` method of ".concat(componentName, " do not handle the arguments correctly."), "The component expects a single value to match a given option but found ".concat(matches.length, " matches.")].join('\n'));
          }
        }

        var itemIndex = findIndex(newValue, function (valueItem) {
          return getOptionSelected(option, valueItem);
        });

        if (itemIndex === -1) {
          newValue.push(option);
        } else if (origin !== 'freeSolo') {
          newValue.splice(itemIndex, 1);
          reason = 'remove-option';
        }
      }

      resetInputValue(event, newValue);
      handleValue(event, newValue, reason, {
        option: option
      });

      if (!disableCloseOnSelect) {
        handleClose(event, reason);
      }

      if (blurOnSelect === true || blurOnSelect === 'touch' && isTouch.current || blurOnSelect === 'mouse' && !isTouch.current) {
        inputRef.current.blur();
      }
    };

    function validTagIndex(index, direction) {
      if (index === -1) {
        return -1;
      }

      var nextFocus = index;

      while (true) {
        // Out of range
        if (direction === 'next' && nextFocus === value.length || direction === 'previous' && nextFocus === -1) {
          return -1;
        }

        var option = anchorEl.querySelector("[data-tag-index=\"".concat(nextFocus, "\"]")); // Same logic as MenuList.js

        if (option && (!option.hasAttribute('tabindex') || option.disabled || option.getAttribute('aria-disabled') === 'true')) {
          nextFocus += direction === 'next' ? 1 : -1;
        } else {
          return nextFocus;
        }
      }
    }

    var handleFocusTag = function handleFocusTag(event, direction) {
      if (!multiple) {
        return;
      }

      handleClose(event, 'toggleInput');
      var nextTag = focusedTag;

      if (focusedTag === -1) {
        if (inputValue === '' && direction === 'previous') {
          nextTag = value.length - 1;
        }
      } else {
        nextTag += direction === 'next' ? 1 : -1;

        if (nextTag < 0) {
          nextTag = 0;
        }

        if (nextTag === value.length) {
          nextTag = -1;
        }
      }

      nextTag = validTagIndex(nextTag, direction);
      setFocusedTag(nextTag);
      focusTag(nextTag);
    };

    var handleClear = function handleClear(event) {
      ignoreFocus.current = true;
      setInputValue('');

      if (onInputChange) {
        onInputChange(event, '', 'clear');
      }

      handleValue(event, multiple ? [] : null, 'clear');
    };

    var handleKeyDown = function handleKeyDown(other) {
      return function (event) {
        if (focusedTag !== -1 && ['ArrowLeft', 'ArrowRight'].indexOf(event.key) === -1) {
          setFocusedTag(-1);
          focusTag(-1);
        }

        switch (event.key) {
          case 'Home':
            if (popupOpen && handleHomeEndKeys) {
              // Prevent scroll of the page
              event.preventDefault();
              changeHighlightedIndex({
                diff: 'start',
                direction: 'next',
                reason: 'keyboard',
                event: event
              });
            }

            break;

          case 'End':
            if (popupOpen && handleHomeEndKeys) {
              // Prevent scroll of the page
              event.preventDefault();
              changeHighlightedIndex({
                diff: 'end',
                direction: 'previous',
                reason: 'keyboard',
                event: event
              });
            }

            break;

          case 'PageUp':
            // Prevent scroll of the page
            event.preventDefault();
            changeHighlightedIndex({
              diff: -pageSize,
              direction: 'previous',
              reason: 'keyboard',
              event: event
            });
            handleOpen(event);
            break;

          case 'PageDown':
            // Prevent scroll of the page
            event.preventDefault();
            changeHighlightedIndex({
              diff: pageSize,
              direction: 'next',
              reason: 'keyboard',
              event: event
            });
            handleOpen(event);
            break;

          case 'ArrowDown':
            // Prevent cursor move
            event.preventDefault();
            changeHighlightedIndex({
              diff: 1,
              direction: 'next',
              reason: 'keyboard',
              event: event
            });
            handleOpen(event);
            break;

          case 'ArrowUp':
            // Prevent cursor move
            event.preventDefault();
            changeHighlightedIndex({
              diff: -1,
              direction: 'previous',
              reason: 'keyboard',
              event: event
            });
            handleOpen(event);
            break;

          case 'ArrowLeft':
            handleFocusTag(event, 'previous');
            break;

          case 'ArrowRight':
            handleFocusTag(event, 'next');
            break;

          case 'Enter':
            // Wait until IME is settled.
            if (event.which === 229) {
              break;
            }

            if (highlightedIndexRef.current !== -1 && popupOpen) {
              var option = filteredOptions[highlightedIndexRef.current];
              var disabled = getOptionDisabled ? getOptionDisabled(option) : false; // We don't want to validate the form.

              event.preventDefault();

              if (disabled) {
                return;
              }

              selectNewValue(event, option, 'select-option'); // Move the selection to the end.

              if (autoComplete) {
                inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
              }
            } else if (freeSolo && inputValue !== '' && inputValueIsSelectedValue === false) {
              if (multiple) {
                // Allow people to add new values before they submit the form.
                event.preventDefault();
              }

              selectNewValue(event, inputValue, 'create-option', 'freeSolo');
            }

            break;

          case 'Escape':
            if (popupOpen) {
              // Avoid Opera to exit fullscreen mode.
              event.preventDefault(); // Avoid the Modal to handle the event.

              event.stopPropagation();
              handleClose(event, 'escape');
            } else if (clearOnEscape && (inputValue !== '' || multiple && value.length > 0)) {
              // Avoid Opera to exit fullscreen mode.
              event.preventDefault(); // Avoid the Modal to handle the event.

              event.stopPropagation();
              handleClear(event);
            }

            break;

          case 'Backspace':
            if (multiple && inputValue === '' && value.length > 0) {
              var index = focusedTag === -1 ? value.length - 1 : focusedTag;
              var newValue = value.slice();
              newValue.splice(index, 1);
              handleValue(event, newValue, 'remove-option', {
                option: value[index]
              });
            }

            break;
        }

        if (other.onKeyDown) {
          other.onKeyDown(event);
        }
      };
    };

    var handleFocus = function handleFocus(event) {
      setFocused(true);

      if (openOnFocus && !ignoreFocus.current) {
        handleOpen(event);
      }
    };

    var handleBlur = function handleBlur(event) {
      // Ignore the event when using the scrollbar with IE 11
      if (listboxRef.current !== null && document.activeElement === listboxRef.current.parentElement) {
        inputRef.current.focus();
        return;
      }

      setFocused(false);
      firstFocus.current = true;
      ignoreFocus.current = false;

      if (debug && inputValue !== '') {
        return;
      }

      if (autoSelect && highlightedIndexRef.current !== -1 && popupOpen) {
        selectNewValue(event, filteredOptions[highlightedIndexRef.current], 'blur');
      } else if (autoSelect && freeSolo && inputValue !== '') {
        selectNewValue(event, inputValue, 'blur', 'freeSolo');
      } else if (clearOnBlur) {
        resetInputValue(event, value);
      }

      handleClose(event, 'blur');
    };

    var handleInputChange = function handleInputChange(event) {
      var newValue = event.target.value;

      if (inputValue !== newValue) {
        setInputValue(newValue);

        if (onInputChange) {
          onInputChange(event, newValue, 'input');
        }
      }

      if (newValue === '') {
        if (!disableClearable && !multiple) {
          handleValue(event, null, 'clear');
        }
      } else {
        handleOpen(event);
      }
    };

    var handleOptionMouseOver = function handleOptionMouseOver(event) {
      setHighlightedIndex({
        event: event,
        index: Number(event.currentTarget.getAttribute('data-option-index')),
        reason: 'mouse'
      });
    };

    var handleOptionTouchStart = function handleOptionTouchStart() {
      isTouch.current = true;
    };

    var handleOptionClick = function handleOptionClick(event) {
      var index = Number(event.currentTarget.getAttribute('data-option-index'));
      selectNewValue(event, filteredOptions[index], 'select-option');
      isTouch.current = false;
    };

    var handleTagDelete = function handleTagDelete(index) {
      return function (event) {
        var newValue = value.slice();
        newValue.splice(index, 1);
        handleValue(event, newValue, 'remove-option', {
          option: value[index]
        });
      };
    };

    var handlePopupIndicator = function handlePopupIndicator(event) {
      if (open) {
        handleClose(event, 'toggleInput');
      } else {
        handleOpen(event);
      }
    }; // Prevent input blur when interacting with the combobox


    var handleMouseDown = function handleMouseDown(event) {
      if (event.target.getAttribute('id') !== id) {
        event.preventDefault();
      }
    }; // Focus the input when interacting with the combobox


    var handleClick = function handleClick() {
      inputRef.current.focus();

      if (selectOnFocus && firstFocus.current && inputRef.current.selectionEnd - inputRef.current.selectionStart === 0) {
        inputRef.current.select();
      }

      firstFocus.current = false;
    };

    var handleInputMouseDown = function handleInputMouseDown(event) {
      if (inputValue === '' || !open) {
        handlePopupIndicator(event);
      }
    };

    var dirty = freeSolo && inputValue.length > 0;
    dirty = dirty || (multiple ? value.length > 0 : value !== null);
    var groupedOptions = filteredOptions;

    if (groupBy) {
      // used to keep track of key and indexes in the result array
      var indexBy = new Map();
      var warn = false;
      groupedOptions = filteredOptions.reduce(function (acc, option, index) {
        var group = groupBy(option);

        if (acc.length > 0 && acc[acc.length - 1].group === group) {
          acc[acc.length - 1].options.push(option);
        } else {
          {
            if (indexBy.get(group) && !warn) {
              console.warn("Material-UI: The options provided combined with the `groupBy` method of ".concat(componentName, " returns duplicated headers."), 'You can solve the issue by sorting the options with the output of `groupBy`.');
              warn = true;
            }

            indexBy.set(group, true);
          }

          acc.push({
            key: index,
            index: index,
            group: group,
            options: [option]
          });
        }

        return acc;
      }, []);
    }

    return {
      getRootProps: function getRootProps() {
        var other = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return _extends$1({
          'aria-owns': popupOpen ? "".concat(id, "-popup") : null,
          role: 'combobox',
          'aria-expanded': popupOpen
        }, other, {
          onKeyDown: handleKeyDown(other),
          onMouseDown: handleMouseDown,
          onClick: handleClick
        });
      },
      getInputLabelProps: function getInputLabelProps() {
        return {
          id: "".concat(id, "-label"),
          htmlFor: id
        };
      },
      getInputProps: function getInputProps() {
        return {
          id: id,
          value: inputValue,
          onBlur: handleBlur,
          onFocus: handleFocus,
          onChange: handleInputChange,
          onMouseDown: handleInputMouseDown,
          // if open then this is handled imperativeley so don't let react override
          // only have an opinion about this when closed
          'aria-activedescendant': popupOpen ? '' : null,
          'aria-autocomplete': autoComplete ? 'both' : 'list',
          'aria-controls': popupOpen ? "".concat(id, "-popup") : null,
          // Disable browser's suggestion that might overlap with the popup.
          // Handle autocomplete but not autofill.
          autoComplete: 'off',
          ref: inputRef,
          autoCapitalize: 'none',
          spellCheck: 'false'
        };
      },
      getClearProps: function getClearProps() {
        return {
          tabIndex: -1,
          onClick: handleClear
        };
      },
      getPopupIndicatorProps: function getPopupIndicatorProps() {
        return {
          tabIndex: -1,
          onClick: handlePopupIndicator
        };
      },
      getTagProps: function getTagProps(_ref4) {
        var index = _ref4.index;
        return {
          key: index,
          'data-tag-index': index,
          tabIndex: -1,
          onDelete: handleTagDelete(index)
        };
      },
      getListboxProps: function getListboxProps() {
        return {
          role: 'listbox',
          id: "".concat(id, "-popup"),
          'aria-labelledby': "".concat(id, "-label"),
          ref: handleListboxRef,
          onMouseDown: function onMouseDown(event) {
            // Prevent blur
            event.preventDefault();
          }
        };
      },
      getOptionProps: function getOptionProps(_ref5) {
        var index = _ref5.index,
            option = _ref5.option;
        var selected = (multiple ? value : [value]).some(function (value2) {
          return value2 != null && getOptionSelected(option, value2);
        });
        var disabled = getOptionDisabled ? getOptionDisabled(option) : false;
        return {
          key: index,
          tabIndex: -1,
          role: 'option',
          id: "".concat(id, "-option-").concat(index),
          onMouseOver: handleOptionMouseOver,
          onClick: handleOptionClick,
          onTouchStart: handleOptionTouchStart,
          'data-option-index': index,
          'aria-disabled': disabled,
          'aria-selected': selected
        };
      },
      id: id,
      inputValue: inputValue,
      value: value,
      dirty: dirty,
      popupOpen: popupOpen,
      focused: focused || focusedTag !== -1,
      anchorEl: anchorEl,
      setAnchorEl: setAnchorEl,
      focusedTag: focusedTag,
      groupedOptions: groupedOptions
    };
  }

  var styles$l = function styles(theme) {
    var _option;

    return {
      /* Styles applied to the root element. */
      root: {
        '&$focused $clearIndicatorDirty': {
          visibility: 'visible'
        },

        /* Avoid double tap issue on iOS */
        '@media (pointer: fine)': {
          '&:hover $clearIndicatorDirty': {
            visibility: 'visible'
          }
        }
      },

      /* Styles applied to the root element if `fullWidth={true}`. */
      fullWidth: {
        width: '100%'
      },

      /* Pseudo-class applied to the root element if focused. */
      focused: {},

      /* Styles applied to the tag elements, e.g. the chips. */
      tag: {
        margin: 3,
        maxWidth: 'calc(100% - 6px)'
      },

      /* Styles applied to the tag elements, e.g. the chips if `size="small"`. */
      tagSizeSmall: {
        margin: 2,
        maxWidth: 'calc(100% - 4px)'
      },

      /* Styles applied when the popup icon is rendered. */
      hasPopupIcon: {},

      /* Styles applied when the clear icon is rendered. */
      hasClearIcon: {},

      /* Styles applied to the Input element. */
      inputRoot: {
        flexWrap: 'wrap',
        '$hasPopupIcon &, $hasClearIcon &': {
          paddingRight: 26 + 4
        },
        '$hasPopupIcon$hasClearIcon &': {
          paddingRight: 52 + 4
        },
        '& $input': {
          width: 0,
          minWidth: 30
        },
        '&[class*="MuiInput-root"]': {
          paddingBottom: 1,
          '& $input': {
            padding: 4
          },
          '& $input:first-child': {
            padding: '6px 0'
          }
        },
        '&[class*="MuiInput-root"][class*="MuiInput-marginDense"]': {
          '& $input': {
            padding: '4px 4px 5px'
          },
          '& $input:first-child': {
            padding: '3px 0 6px'
          }
        },
        '&[class*="MuiOutlinedInput-root"]': {
          padding: 9,
          '$hasPopupIcon &, $hasClearIcon &': {
            paddingRight: 26 + 4 + 9
          },
          '$hasPopupIcon$hasClearIcon &': {
            paddingRight: 52 + 4 + 9
          },
          '& $input': {
            padding: '9.5px 4px'
          },
          '& $input:first-child': {
            paddingLeft: 6
          },
          '& $endAdornment': {
            right: 9
          }
        },
        '&[class*="MuiOutlinedInput-root"][class*="MuiOutlinedInput-marginDense"]': {
          padding: 6,
          '& $input': {
            padding: '4.5px 4px'
          }
        },
        '&[class*="MuiFilledInput-root"]': {
          paddingTop: 19,
          paddingLeft: 8,
          '$hasPopupIcon &, $hasClearIcon &': {
            paddingRight: 26 + 4 + 9
          },
          '$hasPopupIcon$hasClearIcon &': {
            paddingRight: 52 + 4 + 9
          },
          '& $input': {
            padding: '9px 4px'
          },
          '& $endAdornment': {
            right: 9
          }
        },
        '&[class*="MuiFilledInput-root"][class*="MuiFilledInput-marginDense"]': {
          paddingBottom: 1,
          '& $input': {
            padding: '4.5px 4px'
          }
        }
      },

      /* Styles applied to the input element. */
      input: {
        flexGrow: 1,
        textOverflow: 'ellipsis',
        opacity: 0
      },

      /* Styles applied to the input element if tag focused. */
      inputFocused: {
        opacity: 1
      },

      /* Styles applied to the endAdornment element. */
      endAdornment: {
        // We use a position absolute to support wrapping tags.
        position: 'absolute',
        right: 0,
        top: 'calc(50% - 14px)' // Center vertically

      },

      /* Styles applied to the clear indicator. */
      clearIndicator: {
        marginRight: -2,
        padding: 4,
        visibility: 'hidden'
      },

      /* Styles applied to the clear indicator if the input is dirty. */
      clearIndicatorDirty: {},

      /* Styles applied to the popup indicator. */
      popupIndicator: {
        padding: 2,
        marginRight: -2
      },

      /* Styles applied to the popup indicator if the popup is open. */
      popupIndicatorOpen: {
        transform: 'rotate(180deg)'
      },

      /* Styles applied to the popper element. */
      popper: {
        zIndex: theme.zIndex.modal
      },

      /* Styles applied to the popper element if `disablePortal={true}`. */
      popperDisablePortal: {
        position: 'absolute'
      },

      /* Styles applied to the `Paper` component. */
      paper: _extends$1({}, theme.typography.body1, {
        overflow: 'hidden',
        margin: '4px 0'
      }),

      /* Styles applied to the `listbox` component. */
      listbox: {
        listStyle: 'none',
        margin: 0,
        padding: '8px 0',
        maxHeight: '40vh',
        overflow: 'auto'
      },

      /* Styles applied to the loading wrapper. */
      loading: {
        color: theme.palette.text.secondary,
        padding: '14px 16px'
      },

      /* Styles applied to the no option wrapper. */
      noOptions: {
        color: theme.palette.text.secondary,
        padding: '14px 16px'
      },

      /* Styles applied to the option elements. */
      option: (_option = {
        minHeight: 48,
        display: 'flex',
        justifyContent: 'flex-start',
        alignItems: 'center',
        cursor: 'pointer',
        paddingTop: 6,
        boxSizing: 'border-box',
        outline: '0',
        WebkitTapHighlightColor: 'transparent',
        paddingBottom: 6,
        paddingLeft: 16,
        paddingRight: 16
      }, _defineProperty(_option, theme.breakpoints.up('sm'), {
        minHeight: 'auto'
      }), _defineProperty(_option, '&[aria-selected="true"]', {
        backgroundColor: theme.palette.action.selected
      }), _defineProperty(_option, '&[data-focus="true"]', {
        backgroundColor: theme.palette.action.hover
      }), _defineProperty(_option, '&:active', {
        backgroundColor: theme.palette.action.selected
      }), _defineProperty(_option, '&[aria-disabled="true"]', {
        opacity: theme.palette.action.disabledOpacity,
        pointerEvents: 'none'
      }), _option),

      /* Styles applied to the group's label elements. */
      groupLabel: {
        backgroundColor: theme.palette.background.paper,
        top: -8
      },

      /* Styles applied to the group's ul elements. */
      groupUl: {
        padding: 0,
        '& $option': {
          paddingLeft: 24
        }
      }
    };
  };

  function DisablePortal(props) {
    // eslint-disable-next-line react/prop-types
    props.anchorEl;
        props.open;
        var other = _objectWithoutProperties(props, ["anchorEl", "open"]);

    return /*#__PURE__*/React__namespace.createElement("div", other);
  }

  var _ref$1 = /*#__PURE__*/React__namespace.createElement(CloseIcon, {
    fontSize: "small"
  });

  var _ref2$1 = /*#__PURE__*/React__namespace.createElement(ArrowDropDownIcon$1, null);

  var Autocomplete = /*#__PURE__*/React__namespace.forwardRef(function Autocomplete(props, ref) {
    /* eslint-disable no-unused-vars */
    props.autoComplete;
        props.autoHighlight;
        props.autoSelect;
        props.blurOnSelect;
        var ChipProps = props.ChipProps,
        classes = props.classes,
        className = props.className,
        _props$clearOnBlur = props.clearOnBlur;
        _props$clearOnBlur === void 0 ? !props.freeSolo : _props$clearOnBlur;
        props.clearOnEscape;
        var _props$clearText = props.clearText,
        clearText = _props$clearText === void 0 ? 'Clear' : _props$clearText,
        _props$closeIcon = props.closeIcon,
        closeIcon = _props$closeIcon === void 0 ? _ref$1 : _props$closeIcon,
        _props$closeText = props.closeText,
        closeText = _props$closeText === void 0 ? 'Close' : _props$closeText;
        props.debug;
        var _props$defaultValue = props.defaultValue;
        _props$defaultValue === void 0 ? props.multiple ? [] : null : _props$defaultValue;
        var _props$disableClearab = props.disableClearable,
        disableClearable = _props$disableClearab === void 0 ? false : _props$disableClearab;
        props.disableCloseOnSelect;
        var _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled;
        props.disabledItemsFocusable;
        props.disableListWrap;
        var _props$disablePortal = props.disablePortal,
        disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal;
        props.filterOptions;
        props.filterSelectedOptions;
        var _props$forcePopupIcon = props.forcePopupIcon,
        forcePopupIcon = _props$forcePopupIcon === void 0 ? 'auto' : _props$forcePopupIcon,
        _props$freeSolo = props.freeSolo,
        freeSolo = _props$freeSolo === void 0 ? false : _props$freeSolo,
        _props$fullWidth = props.fullWidth,
        fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
        _props$getLimitTagsTe = props.getLimitTagsText,
        getLimitTagsText = _props$getLimitTagsTe === void 0 ? function (more) {
      return "+".concat(more);
    } : _props$getLimitTagsTe;
        props.getOptionDisabled;
        var _props$getOptionLabel = props.getOptionLabel,
        getOptionLabel = _props$getOptionLabel === void 0 ? function (x) {
      return x;
    } : _props$getOptionLabel;
        props.getOptionSelected;
        var groupBy = props.groupBy,
        _props$handleHomeEndK = props.handleHomeEndKeys;
        _props$handleHomeEndK === void 0 ? !props.freeSolo : _props$handleHomeEndK;
        props.id;
        props.includeInputInList;
        props.inputValue;
        var _props$limitTags = props.limitTags,
        limitTags = _props$limitTags === void 0 ? -1 : _props$limitTags,
        _props$ListboxCompone = props.ListboxComponent,
        ListboxComponent = _props$ListboxCompone === void 0 ? 'ul' : _props$ListboxCompone,
        ListboxProps = props.ListboxProps,
        _props$loading = props.loading,
        loading = _props$loading === void 0 ? false : _props$loading,
        _props$loadingText = props.loadingText,
        loadingText = _props$loadingText === void 0 ? 'Loading' : _props$loadingText,
        _props$multiple = props.multiple,
        multiple = _props$multiple === void 0 ? false : _props$multiple,
        _props$noOptionsText = props.noOptionsText,
        noOptionsText = _props$noOptionsText === void 0 ? 'No options' : _props$noOptionsText;
        props.onChange;
        props.onClose;
        props.onHighlightChange;
        props.onInputChange;
        props.onOpen;
        props.open;
        props.openOnFocus;
        var _props$openText = props.openText,
        openText = _props$openText === void 0 ? 'Open' : _props$openText;
        props.options;
        var _props$PaperComponent = props.PaperComponent,
        PaperComponent = _props$PaperComponent === void 0 ? Paper$1 : _props$PaperComponent,
        _props$PopperComponen = props.PopperComponent,
        PopperComponentProp = _props$PopperComponen === void 0 ? Popper$1 : _props$PopperComponen,
        _props$popupIcon = props.popupIcon,
        popupIcon = _props$popupIcon === void 0 ? _ref2$1 : _props$popupIcon,
        renderGroupProp = props.renderGroup,
        renderInput = props.renderInput,
        renderOptionProp = props.renderOption,
        renderTags = props.renderTags,
        _props$selectOnFocus = props.selectOnFocus;
        _props$selectOnFocus === void 0 ? !props.freeSolo : _props$selectOnFocus;
        var _props$size = props.size,
        size = _props$size === void 0 ? 'medium' : _props$size;
        props.value;
        var other = _objectWithoutProperties(props, ["autoComplete", "autoHighlight", "autoSelect", "blurOnSelect", "ChipProps", "classes", "className", "clearOnBlur", "clearOnEscape", "clearText", "closeIcon", "closeText", "debug", "defaultValue", "disableClearable", "disableCloseOnSelect", "disabled", "disabledItemsFocusable", "disableListWrap", "disablePortal", "filterOptions", "filterSelectedOptions", "forcePopupIcon", "freeSolo", "fullWidth", "getLimitTagsText", "getOptionDisabled", "getOptionLabel", "getOptionSelected", "groupBy", "handleHomeEndKeys", "id", "includeInputInList", "inputValue", "limitTags", "ListboxComponent", "ListboxProps", "loading", "loadingText", "multiple", "noOptionsText", "onChange", "onClose", "onHighlightChange", "onInputChange", "onOpen", "open", "openOnFocus", "openText", "options", "PaperComponent", "PopperComponent", "popupIcon", "renderGroup", "renderInput", "renderOption", "renderTags", "selectOnFocus", "size", "value"]);
    /* eslint-enable no-unused-vars */


    var PopperComponent = disablePortal ? DisablePortal : PopperComponentProp;

    var _useAutocomplete = useAutocomplete(_extends$1({}, props, {
      componentName: 'Autocomplete'
    })),
        getRootProps = _useAutocomplete.getRootProps,
        getInputProps = _useAutocomplete.getInputProps,
        getInputLabelProps = _useAutocomplete.getInputLabelProps,
        getPopupIndicatorProps = _useAutocomplete.getPopupIndicatorProps,
        getClearProps = _useAutocomplete.getClearProps,
        getTagProps = _useAutocomplete.getTagProps,
        getListboxProps = _useAutocomplete.getListboxProps,
        getOptionProps = _useAutocomplete.getOptionProps,
        value = _useAutocomplete.value,
        dirty = _useAutocomplete.dirty,
        id = _useAutocomplete.id,
        popupOpen = _useAutocomplete.popupOpen,
        focused = _useAutocomplete.focused,
        focusedTag = _useAutocomplete.focusedTag,
        anchorEl = _useAutocomplete.anchorEl,
        setAnchorEl = _useAutocomplete.setAnchorEl,
        inputValue = _useAutocomplete.inputValue,
        groupedOptions = _useAutocomplete.groupedOptions;

    var startAdornment;

    if (multiple && value.length > 0) {
      var getCustomizedTagProps = function getCustomizedTagProps(params) {
        return _extends$1({
          className: clsx(classes.tag, size === 'small' && classes.tagSizeSmall),
          disabled: disabled
        }, getTagProps(params));
      };

      if (renderTags) {
        startAdornment = renderTags(value, getCustomizedTagProps);
      } else {
        startAdornment = value.map(function (option, index) {
          return /*#__PURE__*/React__namespace.createElement(Chip$1, _extends$1({
            label: getOptionLabel(option),
            size: size
          }, getCustomizedTagProps({
            index: index
          }), ChipProps));
        });
      }
    }

    if (limitTags > -1 && Array.isArray(startAdornment)) {
      var more = startAdornment.length - limitTags;

      if (!focused && more > 0) {
        startAdornment = startAdornment.splice(0, limitTags);
        startAdornment.push( /*#__PURE__*/React__namespace.createElement("span", {
          className: classes.tag,
          key: startAdornment.length
        }, getLimitTagsText(more)));
      }
    }

    var defaultRenderGroup = function defaultRenderGroup(params) {
      return /*#__PURE__*/React__namespace.createElement("li", {
        key: params.key
      }, /*#__PURE__*/React__namespace.createElement(ListSubheader$1, {
        className: classes.groupLabel,
        component: "div"
      }, params.group), /*#__PURE__*/React__namespace.createElement("ul", {
        className: classes.groupUl
      }, params.children));
    };

    var renderGroup = renderGroupProp || defaultRenderGroup;
    var renderOption = renderOptionProp || getOptionLabel;

    var renderListOption = function renderListOption(option, index) {
      var optionProps = getOptionProps({
        option: option,
        index: index
      });
      return /*#__PURE__*/React__namespace.createElement("li", _extends$1({}, optionProps, {
        className: classes.option
      }), renderOption(option, {
        selected: optionProps['aria-selected'],
        inputValue: inputValue
      }));
    };

    var hasClearIcon = !disableClearable && !disabled;
    var hasPopupIcon = (!freeSolo || forcePopupIcon === true) && forcePopupIcon !== false;
    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement("div", _extends$1({
      ref: ref,
      className: clsx(classes.root, className, focused && classes.focused, fullWidth && classes.fullWidth, hasClearIcon && classes.hasClearIcon, hasPopupIcon && classes.hasPopupIcon)
    }, getRootProps(other)), renderInput({
      id: id,
      disabled: disabled,
      fullWidth: true,
      size: size === 'small' ? 'small' : undefined,
      InputLabelProps: getInputLabelProps(),
      InputProps: {
        ref: setAnchorEl,
        className: classes.inputRoot,
        startAdornment: startAdornment,
        endAdornment: /*#__PURE__*/React__namespace.createElement("div", {
          className: classes.endAdornment
        }, hasClearIcon ? /*#__PURE__*/React__namespace.createElement(IconButton$1, _extends$1({}, getClearProps(), {
          "aria-label": clearText,
          title: clearText,
          className: clsx(classes.clearIndicator, dirty && classes.clearIndicatorDirty)
        }), closeIcon) : null, hasPopupIcon ? /*#__PURE__*/React__namespace.createElement(IconButton$1, _extends$1({}, getPopupIndicatorProps(), {
          disabled: disabled,
          "aria-label": popupOpen ? closeText : openText,
          title: popupOpen ? closeText : openText,
          className: clsx(classes.popupIndicator, popupOpen && classes.popupIndicatorOpen)
        }), popupIcon) : null)
      },
      inputProps: _extends$1({
        className: clsx(classes.input, focusedTag === -1 && classes.inputFocused),
        disabled: disabled
      }, getInputProps())
    })), popupOpen && anchorEl ? /*#__PURE__*/React__namespace.createElement(PopperComponent, {
      className: clsx(classes.popper, disablePortal && classes.popperDisablePortal),
      style: {
        width: anchorEl ? anchorEl.clientWidth : null
      },
      role: "presentation",
      anchorEl: anchorEl,
      open: true
    }, /*#__PURE__*/React__namespace.createElement(PaperComponent, {
      className: classes.paper
    }, loading && groupedOptions.length === 0 ? /*#__PURE__*/React__namespace.createElement("div", {
      className: classes.loading
    }, loadingText) : null, groupedOptions.length === 0 && !freeSolo && !loading ? /*#__PURE__*/React__namespace.createElement("div", {
      className: classes.noOptions
    }, noOptionsText) : null, groupedOptions.length > 0 ? /*#__PURE__*/React__namespace.createElement(ListboxComponent, _extends$1({
      className: classes.listbox
    }, getListboxProps(), ListboxProps), groupedOptions.map(function (option, index) {
      if (groupBy) {
        return renderGroup({
          key: option.key,
          group: option.group,
          children: option.options.map(function (option2, index2) {
            return renderListOption(option2, option.index + index2);
          })
        });
      }

      return renderListOption(option, index);
    })) : null)) : null);
  });
  Autocomplete.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * If `true`, the portion of the selected suggestion that has not been typed by the user,
     * known as the completion string, appears inline after the input cursor in the textbox.
     * The inline completion string is visually highlighted and has a selected state.
     */
    autoComplete: PropTypes.bool,

    /**
     * If `true`, the first option is automatically highlighted.
     */
    autoHighlight: PropTypes.bool,

    /**
     * If `true`, the selected option becomes the value of the input
     * when the Autocomplete loses focus unless the user chooses
     * a different option or changes the character string in the input.
     */
    autoSelect: PropTypes.bool,

    /**
     * Control if the input should be blurred when an option is selected:
     *
     * - `false` the input is not blurred.
     * - `true` the input is always blurred.
     * - `touch` the input is blurred after a touch event.
     * - `mouse` the input is blurred after a mouse event.
     */
    blurOnSelect: PropTypes.oneOfType([PropTypes.oneOf(['mouse', 'touch']), PropTypes.bool]),

    /**
     * Props applied to the [`Chip`](/api/chip/) element.
     */
    ChipProps: PropTypes.object,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * If `true`, the input's text will be cleared on blur if no value is selected.
     *
     * Set to `true` if you want to help the user enter a new value.
     * Set to `false` if you want to help the user resume his search.
     */
    clearOnBlur: PropTypes.bool,

    /**
     * If `true`, clear all values when the user presses escape and the popup is closed.
     */
    clearOnEscape: PropTypes.bool,

    /**
     * Override the default text for the *clear* icon button.
     *
     * For localization purposes, you can use the provided [translations](/guides/localization/).
     */
    clearText: PropTypes.string,

    /**
     * The icon to display in place of the default close icon.
     */
    closeIcon: PropTypes.node,

    /**
     * Override the default text for the *close popup* icon button.
     *
     * For localization purposes, you can use the provided [translations](/guides/localization/).
     */
    closeText: PropTypes.string,

    /**
     * If `true`, the popup will ignore the blur event if the input is filled.
     * You can inspect the popup markup with your browser tools.
     * Consider this option when you need to customize the component.
     */
    debug: PropTypes.bool,

    /**
     * The default input value. Use when the component is not controlled.
     */
    defaultValue: PropTypes.any,

    /**
     * If `true`, the input can't be cleared.
     */
    disableClearable: PropTypes
    /* @typescript-to-proptypes-ignore */
    .bool,

    /**
     * If `true`, the popup won't close when a value is selected.
     */
    disableCloseOnSelect: PropTypes.bool,

    /**
     * If `true`, the input will be disabled.
     */
    disabled: PropTypes.bool,

    /**
     * If `true`, will allow focus on disabled items.
     */
    disabledItemsFocusable: PropTypes.bool,

    /**
     * If `true`, the list box in the popup will not wrap focus.
     */
    disableListWrap: PropTypes.bool,

    /**
     * Disable the portal behavior.
     * The children stay within it's parent DOM hierarchy.
     */
    disablePortal: PropTypes.bool,

    /**
     * A filter function that determines the options that are eligible.
     *
     * @param {T[]} options The options to render.
     * @param {object} state The state of the component.
     * @returns {T[]}
     */
    filterOptions: PropTypes.func,

    /**
     * If `true`, hide the selected options from the list box.
     */
    filterSelectedOptions: PropTypes.bool,

    /**
     * Force the visibility display of the popup icon.
     */
    forcePopupIcon: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.bool]),

    /**
     * If `true`, the Autocomplete is free solo, meaning that the user input is not bound to provided options.
     */
    freeSolo: PropTypes
    /* @typescript-to-proptypes-ignore */
    .bool,

    /**
     * If `true`, the input will take up the full width of its container.
     */
    fullWidth: PropTypes.bool,

    /**
     * The label to display when the tags are truncated (`limitTags`).
     *
     * @param {number} more The number of truncated tags.
     * @returns {ReactNode}
     */
    getLimitTagsText: PropTypes.func,

    /**
     * Used to determine the disabled state for a given option.
     *
     * @param {T} option The option to test.
     * @returns {boolean}
     */
    getOptionDisabled: PropTypes.func,

    /**
     * Used to determine the string value for a given option.
     * It's used to fill the input (and the list box options if `renderOption` is not provided).
     *
     * @param {T} option
     * @returns {string}
     */
    getOptionLabel: PropTypes.func,

    /**
     * Used to determine if an option is selected, considering the current value.
     * Uses strict equality by default.
     *
     * @param {T} option The option to test.
     * @param {T} value The value to test against.
     * @returns {boolean}
     */
    getOptionSelected: PropTypes.func,

    /**
     * If provided, the options will be grouped under the returned string.
     * The groupBy value is also used as the text for group headings when `renderGroup` is not provided.
     *
     * @param {T} options The options to group.
     * @returns {string}
     */
    groupBy: PropTypes.func,

    /**
     * If `true`, the component handles the "Home" and "End" keys when the popup is open.
     * It should move focus to the first option and last option, respectively.
     */
    handleHomeEndKeys: PropTypes.bool,

    /**
     * This prop is used to help implement the accessibility logic.
     * If you don't provide this prop. It falls back to a randomly generated id.
     */
    id: PropTypes.string,

    /**
     * If `true`, the highlight can move to the input.
     */
    includeInputInList: PropTypes.bool,

    /**
     * The input value.
     */
    inputValue: PropTypes.string,

    /**
     * The maximum number of tags that will be visible when not focused.
     * Set `-1` to disable the limit.
     */
    limitTags: PropTypes.number,

    /**
     * The component used to render the listbox.
     */
    ListboxComponent: PropTypes.elementType,

    /**
     * Props applied to the Listbox element.
     */
    ListboxProps: PropTypes.object,

    /**
     * If `true`, the component is in a loading state.
     */
    loading: PropTypes.bool,

    /**
     * Text to display when in a loading state.
     *
     * For localization purposes, you can use the provided [translations](/guides/localization/).
     */
    loadingText: PropTypes.node,

    /**
     * If `true`, `value` must be an array and the menu will support multiple selections.
     */
    multiple: PropTypes
    /* @typescript-to-proptypes-ignore */
    .bool,

    /**
     * Text to display when there are no options.
     *
     * For localization purposes, you can use the provided [translations](/guides/localization/).
     */
    noOptionsText: PropTypes.node,

    /**
     * Callback fired when the value changes.
     *
     * @param {object} event The event source of the callback.
     * @param {T|T[]} value The new value of the component.
     * @param {string} reason One of "create-option", "select-option", "remove-option", "blur" or "clear".
     */
    onChange: PropTypes.func,

    /**
     * Callback fired when the popup requests to be closed.
     * Use in controlled mode (see open).
     *
     * @param {object} event The event source of the callback.
     * @param {string} reason Can be: `"toggleInput"`, `"escape"`, `"select-option"`, `"blur"`.
     */
    onClose: PropTypes.func,

    /**
     * Callback fired when the highlight option changes.
     *
     * @param {object} event The event source of the callback.
     * @param {T} option The highlighted option.
     * @param {string} reason Can be: `"keyboard"`, `"auto"`, `"mouse"`.
     */
    onHighlightChange: PropTypes.func,

    /**
     * Callback fired when the input value changes.
     *
     * @param {object} event The event source of the callback.
     * @param {string} value The new value of the text input.
     * @param {string} reason Can be: `"input"` (user input), `"reset"` (programmatic change), `"clear"`.
     */
    onInputChange: PropTypes.func,

    /**
     * Callback fired when the popup requests to be opened.
     * Use in controlled mode (see open).
     *
     * @param {object} event The event source of the callback.
     */
    onOpen: PropTypes.func,

    /**
     * Control the popup` open state.
     */
    open: PropTypes.bool,

    /**
     * If `true`, the popup will open on input focus.
     */
    openOnFocus: PropTypes.bool,

    /**
     * Override the default text for the *open popup* icon button.
     *
     * For localization purposes, you can use the provided [translations](/guides/localization/).
     */
    openText: PropTypes.string,

    /**
     * Array of options.
     */
    options: PropTypes.array.isRequired,

    /**
     * The component used to render the body of the popup.
     */
    PaperComponent: PropTypes.elementType,

    /**
     * The component used to position the popup.
     */
    PopperComponent: PropTypes.elementType,

    /**
     * The icon to display in place of the default popup icon.
     */
    popupIcon: PropTypes.node,

    /**
     * Render the group.
     *
     * @param {any} option The group to render.
     * @returns {ReactNode}
     */
    renderGroup: PropTypes.func,

    /**
     * Render the input.
     *
     * @param {object} params
     * @returns {ReactNode}
     */
    renderInput: PropTypes.func.isRequired,

    /**
     * Render the option, use `getOptionLabel` by default.
     *
     * @param {T} option The option to render.
     * @param {object} state The state of the component.
     * @returns {ReactNode}
     */
    renderOption: PropTypes.func,

    /**
     * Render the selected value.
     *
     * @param {T[]} value The `value` provided to the component.
     * @param {function} getTagProps A tag props getter.
     * @returns {ReactNode}
     */
    renderTags: PropTypes.func,

    /**
     * If `true`, the input's text will be selected on focus.
     * It helps the user clear the selected value.
     */
    selectOnFocus: PropTypes.bool,

    /**
     * The size of the autocomplete.
     */
    size: PropTypes.oneOf(['medium', 'small']),

    /**
     * The value of the autocomplete.
     *
     * The value must have reference equality with the option in order to be selected.
     * You can customize the equality behavior with the `getOptionSelected` prop.
     */
    value: PropTypes.any
  } ;
  var Autocomplete$1 = withStyles(styles$l, {
    name: 'MuiAutocomplete'
  })(Autocomplete);

  function formControlState(_ref) {
    var props = _ref.props,
        states = _ref.states,
        muiFormControl = _ref.muiFormControl;
    return states.reduce(function (acc, state) {
      acc[state] = props[state];

      if (muiFormControl) {
        if (typeof props[state] === 'undefined') {
          acc[state] = muiFormControl[state];
        }
      }

      return acc;
    }, {});
  }

  /**
   * @ignore - internal component.
   */

  var FormControlContext = React__namespace.createContext();

  {
    FormControlContext.displayName = 'FormControlContext';
  }

  function useFormControl$1() {
    return React__namespace.useContext(FormControlContext);
  }
  var FormControlContext$1 = FormControlContext;

  function getStyleValue(computedStyle, property) {
    return parseInt(computedStyle[property], 10) || 0;
  }

  var useEnhancedEffect$2 = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;
  var styles$k = {
    /* Styles applied to the shadow textarea element. */
    shadow: {
      // Visibility needed to hide the extra text area on iPads
      visibility: 'hidden',
      // Remove from the content flow
      position: 'absolute',
      // Ignore the scrollbar width
      overflow: 'hidden',
      height: 0,
      top: 0,
      left: 0,
      // Create a new layer, increase the isolation of the computed values
      transform: 'translateZ(0)'
    }
  };
  var TextareaAutosize = /*#__PURE__*/React__namespace.forwardRef(function TextareaAutosize(props, ref) {
    var onChange = props.onChange,
        rows = props.rows,
        rowsMax = props.rowsMax,
        rowsMinProp = props.rowsMin,
        maxRowsProp = props.maxRows,
        _props$minRows = props.minRows,
        minRowsProp = _props$minRows === void 0 ? 1 : _props$minRows,
        style = props.style,
        value = props.value,
        other = _objectWithoutProperties(props, ["onChange", "rows", "rowsMax", "rowsMin", "maxRows", "minRows", "style", "value"]);

    var maxRows = maxRowsProp || rowsMax;
    var minRows = rows || rowsMinProp || minRowsProp;

    var _React$useRef = React__namespace.useRef(value != null),
        isControlled = _React$useRef.current;

    var inputRef = React__namespace.useRef(null);
    var handleRef = useForkRef(ref, inputRef);
    var shadowRef = React__namespace.useRef(null);
    var renders = React__namespace.useRef(0);

    var _React$useState = React__namespace.useState({}),
        state = _React$useState[0],
        setState = _React$useState[1];

    var syncHeight = React__namespace.useCallback(function () {
      var input = inputRef.current;
      var computedStyle = window.getComputedStyle(input);
      var inputShallow = shadowRef.current;
      inputShallow.style.width = computedStyle.width;
      inputShallow.value = input.value || props.placeholder || 'x';

      if (inputShallow.value.slice(-1) === '\n') {
        // Certain fonts which overflow the line height will cause the textarea
        // to report a different scrollHeight depending on whether the last line
        // is empty. Make it non-empty to avoid this issue.
        inputShallow.value += ' ';
      }

      var boxSizing = computedStyle['box-sizing'];
      var padding = getStyleValue(computedStyle, 'padding-bottom') + getStyleValue(computedStyle, 'padding-top');
      var border = getStyleValue(computedStyle, 'border-bottom-width') + getStyleValue(computedStyle, 'border-top-width'); // The height of the inner content

      var innerHeight = inputShallow.scrollHeight - padding; // Measure height of a textarea with a single row

      inputShallow.value = 'x';
      var singleRowHeight = inputShallow.scrollHeight - padding; // The height of the outer content

      var outerHeight = innerHeight;

      if (minRows) {
        outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
      }

      if (maxRows) {
        outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
      }

      outerHeight = Math.max(outerHeight, singleRowHeight); // Take the box sizing into account for applying this value as a style.

      var outerHeightStyle = outerHeight + (boxSizing === 'border-box' ? padding + border : 0);
      var overflow = Math.abs(outerHeight - innerHeight) <= 1;
      setState(function (prevState) {
        // Need a large enough difference to update the height.
        // This prevents infinite rendering loop.
        if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow)) {
          renders.current += 1;
          return {
            overflow: overflow,
            outerHeightStyle: outerHeightStyle
          };
        }

        {
          if (renders.current === 20) {
            console.error(['Material-UI: Too many re-renders. The layout is unstable.', 'TextareaAutosize limits the number of renders to prevent an infinite loop.'].join('\n'));
          }
        }

        return prevState;
      });
    }, [maxRows, minRows, props.placeholder]);
    React__namespace.useEffect(function () {
      var handleResize = debounce(function () {
        renders.current = 0;
        syncHeight();
      });
      window.addEventListener('resize', handleResize);
      return function () {
        handleResize.clear();
        window.removeEventListener('resize', handleResize);
      };
    }, [syncHeight]);
    useEnhancedEffect$2(function () {
      syncHeight();
    });
    React__namespace.useEffect(function () {
      renders.current = 0;
    }, [value]);

    var handleChange = function handleChange(event) {
      renders.current = 0;

      if (!isControlled) {
        syncHeight();
      }

      if (onChange) {
        onChange(event);
      }
    };

    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement("textarea", _extends$1({
      value: value,
      onChange: handleChange,
      ref: handleRef // Apply the rows prop to get a "correct" first SSR paint
      ,
      rows: minRows,
      style: _extends$1({
        height: state.outerHeightStyle,
        // Need a large enough difference to allow scrolling.
        // This prevents infinite rendering loop.
        overflow: state.overflow ? 'hidden' : null
      }, style)
    }, other)), /*#__PURE__*/React__namespace.createElement("textarea", {
      "aria-hidden": true,
      className: props.className,
      readOnly: true,
      ref: shadowRef,
      tabIndex: -1,
      style: _extends$1({}, styles$k.shadow, style)
    }));
  });
  TextareaAutosize.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * Maximum number of rows to display.
     */
    maxRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * Minimum number of rows to display.
     */
    minRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * @ignore
     */
    onChange: PropTypes.func,

    /**
     * @ignore
     */
    placeholder: PropTypes.string,

    /**
     * Minimum number of rows to display.
     * @deprecated Use `minRows` instead.
     */
    rows: deprecatedPropType(PropTypes.oneOfType([PropTypes.number, PropTypes.string]), 'Use `minRows` instead.'),

    /**
     * Maximum number of rows to display.
     * @deprecated Use `maxRows` instead.
     */
    rowsMax: deprecatedPropType(PropTypes.oneOfType([PropTypes.number, PropTypes.string]), 'Use `maxRows` instead.'),

    /**
     * Minimum number of rows to display.
     * @deprecated Use `minRows` instead.
     */
    rowsMin: deprecatedPropType(PropTypes.oneOfType([PropTypes.number, PropTypes.string]), 'Use `minRows` instead.'),

    /**
     * @ignore
     */
    style: PropTypes.object,

    /**
     * @ignore
     */
    value: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.number, PropTypes.string])
  } ;
  var TextareaAutosize$1 = TextareaAutosize;

  // Supports determination of isControlled().
  // Controlled input accepts its current value as a prop.
  //
  // @see https://facebook.github.io/react/docs/forms.html#controlled-components
  // @param value
  // @returns {boolean} true if string (including '') or number (including zero)
  function hasValue(value) {
    return value != null && !(Array.isArray(value) && value.length === 0);
  } // Determine if field is empty or filled.
  // Response determines if label is presented above field or as placeholder.
  //
  // @param obj
  // @param SSR
  // @returns {boolean} False when not present or empty string.
  //                    True when any number or string with length.

  function isFilled(obj) {
    var SSR = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return obj && (hasValue(obj.value) && obj.value !== '' || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== '');
  } // Determine if an Input is adorned on start.
  // It's corresponding to the left with LTR.
  //
  // @param obj
  // @returns {boolean} False when no adornments.
  //                    True when adorned at the start.

  function isAdornedStart(obj) {
    return obj.startAdornment;
  }

  var styles$j = function styles(theme) {
    var light = theme.palette.type === 'light';
    var placeholder = {
      color: 'currentColor',
      opacity: light ? 0.42 : 0.5,
      transition: theme.transitions.create('opacity', {
        duration: theme.transitions.duration.shorter
      })
    };
    var placeholderHidden = {
      opacity: '0 !important'
    };
    var placeholderVisible = {
      opacity: light ? 0.42 : 0.5
    };
    return {
      '@global': {
        '@keyframes mui-auto-fill': {},
        '@keyframes mui-auto-fill-cancel': {}
      },

      /* Styles applied to the root element. */
      root: _extends$1({}, theme.typography.body1, {
        color: theme.palette.text.primary,
        lineHeight: '1.1876em',
        // Reset (19px), match the native input line-height
        boxSizing: 'border-box',
        // Prevent padding issue with fullWidth.
        position: 'relative',
        cursor: 'text',
        display: 'inline-flex',
        alignItems: 'center',
        '&$disabled': {
          color: theme.palette.text.disabled,
          cursor: 'default'
        }
      }),

      /* Styles applied to the root element if the component is a descendant of `FormControl`. */
      formControl: {},

      /* Styles applied to the root element if the component is focused. */
      focused: {},

      /* Styles applied to the root element if `disabled={true}`. */
      disabled: {},

      /* Styles applied to the root element if `startAdornment` is provided. */
      adornedStart: {},

      /* Styles applied to the root element if `endAdornment` is provided. */
      adornedEnd: {},

      /* Pseudo-class applied to the root element if `error={true}`. */
      error: {},

      /* Styles applied to the `input` element if `margin="dense"`. */
      marginDense: {},

      /* Styles applied to the root element if `multiline={true}`. */
      multiline: {
        padding: "".concat(8 - 2, "px 0 ").concat(8 - 1, "px"),
        '&$marginDense': {
          paddingTop: 4 - 1
        }
      },

      /* Styles applied to the root element if the color is secondary. */
      colorSecondary: {},

      /* Styles applied to the root element if `fullWidth={true}`. */
      fullWidth: {
        width: '100%'
      },

      /* Styles applied to the `input` element. */
      input: {
        font: 'inherit',
        letterSpacing: 'inherit',
        color: 'currentColor',
        padding: "".concat(8 - 2, "px 0 ").concat(8 - 1, "px"),
        border: 0,
        boxSizing: 'content-box',
        background: 'none',
        height: '1.1876em',
        // Reset (19px), match the native input line-height
        margin: 0,
        // Reset for Safari
        WebkitTapHighlightColor: 'transparent',
        display: 'block',
        // Make the flex item shrink with Firefox
        minWidth: 0,
        width: '100%',
        // Fix IE 11 width issue
        animationName: 'mui-auto-fill-cancel',
        animationDuration: '10ms',
        '&::-webkit-input-placeholder': placeholder,
        '&::-moz-placeholder': placeholder,
        // Firefox 19+
        '&:-ms-input-placeholder': placeholder,
        // IE 11
        '&::-ms-input-placeholder': placeholder,
        // Edge
        '&:focus': {
          outline: 0
        },
        // Reset Firefox invalid required input style
        '&:invalid': {
          boxShadow: 'none'
        },
        '&::-webkit-search-decoration': {
          // Remove the padding when type=search.
          '-webkit-appearance': 'none'
        },
        // Show and hide the placeholder logic
        'label[data-shrink=false] + $formControl &': {
          '&::-webkit-input-placeholder': placeholderHidden,
          '&::-moz-placeholder': placeholderHidden,
          // Firefox 19+
          '&:-ms-input-placeholder': placeholderHidden,
          // IE 11
          '&::-ms-input-placeholder': placeholderHidden,
          // Edge
          '&:focus::-webkit-input-placeholder': placeholderVisible,
          '&:focus::-moz-placeholder': placeholderVisible,
          // Firefox 19+
          '&:focus:-ms-input-placeholder': placeholderVisible,
          // IE 11
          '&:focus::-ms-input-placeholder': placeholderVisible // Edge

        },
        '&$disabled': {
          opacity: 1 // Reset iOS opacity

        },
        '&:-webkit-autofill': {
          animationDuration: '5000s',
          animationName: 'mui-auto-fill'
        }
      },

      /* Styles applied to the `input` element if `margin="dense"`. */
      inputMarginDense: {
        paddingTop: 4 - 1
      },

      /* Styles applied to the `input` element if `multiline={true}`. */
      inputMultiline: {
        height: 'auto',
        resize: 'none',
        padding: 0
      },

      /* Styles applied to the `input` element if `type="search"`. */
      inputTypeSearch: {
        // Improve type search style.
        '-moz-appearance': 'textfield',
        '-webkit-appearance': 'textfield'
      },

      /* Styles applied to the `input` element if `startAdornment` is provided. */
      inputAdornedStart: {},

      /* Styles applied to the `input` element if `endAdornment` is provided. */
      inputAdornedEnd: {},

      /* Styles applied to the `input` element if `hiddenLabel={true}`. */
      inputHiddenLabel: {}
    };
  };
  var useEnhancedEffect$1 = typeof window === 'undefined' ? React__namespace.useEffect : React__namespace.useLayoutEffect;
  /**
   * `InputBase` contains as few styles as possible.
   * It aims to be a simple building block for creating an input.
   * It contains a load of style reset and some state logic.
   */

  var InputBase = /*#__PURE__*/React__namespace.forwardRef(function InputBase(props, ref) {
    var ariaDescribedby = props['aria-describedby'],
        autoComplete = props.autoComplete,
        autoFocus = props.autoFocus,
        classes = props.classes,
        className = props.className;
        props.color;
        var defaultValue = props.defaultValue,
        disabled = props.disabled,
        endAdornment = props.endAdornment;
        props.error;
        var _props$fullWidth = props.fullWidth,
        fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
        id = props.id,
        _props$inputComponent = props.inputComponent,
        inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent,
        _props$inputProps = props.inputProps,
        inputPropsProp = _props$inputProps === void 0 ? {} : _props$inputProps,
        inputRefProp = props.inputRef;
        props.margin;
        var _props$multiline = props.multiline,
        multiline = _props$multiline === void 0 ? false : _props$multiline,
        name = props.name,
        onBlur = props.onBlur,
        onChange = props.onChange,
        onClick = props.onClick,
        onFocus = props.onFocus,
        onKeyDown = props.onKeyDown,
        onKeyUp = props.onKeyUp,
        placeholder = props.placeholder,
        readOnly = props.readOnly,
        renderSuffix = props.renderSuffix,
        rows = props.rows,
        rowsMax = props.rowsMax,
        rowsMin = props.rowsMin,
        maxRows = props.maxRows,
        minRows = props.minRows,
        startAdornment = props.startAdornment,
        _props$type = props.type,
        type = _props$type === void 0 ? 'text' : _props$type,
        valueProp = props.value,
        other = _objectWithoutProperties(props, ["aria-describedby", "autoComplete", "autoFocus", "classes", "className", "color", "defaultValue", "disabled", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "rowsMax", "rowsMin", "maxRows", "minRows", "startAdornment", "type", "value"]);

    var value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;

    var _React$useRef = React__namespace.useRef(value != null),
        isControlled = _React$useRef.current;

    var inputRef = React__namespace.useRef();
    var handleInputRefWarning = React__namespace.useCallback(function (instance) {
      {
        if (instance && instance.nodeName !== 'INPUT' && !instance.focus) {
          console.error(['Material-UI: You have provided a `inputComponent` to the input component', 'that does not correctly handle the `inputRef` prop.', 'Make sure the `inputRef` prop is called with a HTMLInputElement.'].join('\n'));
        }
      }
    }, []);
    var handleInputPropsRefProp = useForkRef(inputPropsProp.ref, handleInputRefWarning);
    var handleInputRefProp = useForkRef(inputRefProp, handleInputPropsRefProp);
    var handleInputRef = useForkRef(inputRef, handleInputRefProp);

    var _React$useState = React__namespace.useState(false),
        focused = _React$useState[0],
        setFocused = _React$useState[1];

    var muiFormControl = useFormControl$1();

    {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React__namespace.useEffect(function () {
        if (muiFormControl) {
          return muiFormControl.registerEffect();
        }

        return undefined;
      }, [muiFormControl]);
    }

    var fcs = formControlState({
      props: props,
      muiFormControl: muiFormControl,
      states: ['color', 'disabled', 'error', 'hiddenLabel', 'margin', 'required', 'filled']
    });
    fcs.focused = muiFormControl ? muiFormControl.focused : focused; // The blur won't fire when the disabled state is set on a focused input.
    // We need to book keep the focused state manually.

    React__namespace.useEffect(function () {
      if (!muiFormControl && disabled && focused) {
        setFocused(false);

        if (onBlur) {
          onBlur();
        }
      }
    }, [muiFormControl, disabled, focused, onBlur]);
    var onFilled = muiFormControl && muiFormControl.onFilled;
    var onEmpty = muiFormControl && muiFormControl.onEmpty;
    var checkDirty = React__namespace.useCallback(function (obj) {
      if (isFilled(obj)) {
        if (onFilled) {
          onFilled();
        }
      } else if (onEmpty) {
        onEmpty();
      }
    }, [onFilled, onEmpty]);
    useEnhancedEffect$1(function () {
      if (isControlled) {
        checkDirty({
          value: value
        });
      }
    }, [value, checkDirty, isControlled]);

    var handleFocus = function handleFocus(event) {
      // Fix a bug with IE 11 where the focus/blur events are triggered
      // while the input is disabled.
      if (fcs.disabled) {
        event.stopPropagation();
        return;
      }

      if (onFocus) {
        onFocus(event);
      }

      if (inputPropsProp.onFocus) {
        inputPropsProp.onFocus(event);
      }

      if (muiFormControl && muiFormControl.onFocus) {
        muiFormControl.onFocus(event);
      } else {
        setFocused(true);
      }
    };

    var handleBlur = function handleBlur(event) {
      if (onBlur) {
        onBlur(event);
      }

      if (inputPropsProp.onBlur) {
        inputPropsProp.onBlur(event);
      }

      if (muiFormControl && muiFormControl.onBlur) {
        muiFormControl.onBlur(event);
      } else {
        setFocused(false);
      }
    };

    var handleChange = function handleChange(event) {
      if (!isControlled) {
        var element = event.target || inputRef.current;

        if (element == null) {
          throw new Error("Material-UI: Expected valid input target. Did you use a custom `inputComponent` and forget to forward refs? See https://material-ui.com/r/input-component-ref-interface for more info." );
        }

        checkDirty({
          value: element.value
        });
      }

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (inputPropsProp.onChange) {
        inputPropsProp.onChange.apply(inputPropsProp, [event].concat(args));
      } // Perform in the willUpdate


      if (onChange) {
        onChange.apply(void 0, [event].concat(args));
      }
    }; // Check the input state on mount, in case it was filled by the user
    // or auto filled by the browser before the hydration (for SSR).


    React__namespace.useEffect(function () {
      checkDirty(inputRef.current);
    }, []); // eslint-disable-line react-hooks/exhaustive-deps

    var handleClick = function handleClick(event) {
      if (inputRef.current && event.currentTarget === event.target) {
        inputRef.current.focus();
      }

      if (onClick) {
        onClick(event);
      }
    };

    var InputComponent = inputComponent;

    var inputProps = _extends$1({}, inputPropsProp, {
      ref: handleInputRef
    });

    if (typeof InputComponent !== 'string') {
      inputProps = _extends$1({
        // Rename ref to inputRef as we don't know the
        // provided `inputComponent` structure.
        inputRef: handleInputRef,
        type: type
      }, inputProps, {
        ref: null
      });
    } else if (multiline) {
      if (rows && !maxRows && !minRows && !rowsMax && !rowsMin) {
        InputComponent = 'textarea';
      } else {
        inputProps = _extends$1({
          minRows: rows || minRows,
          rowsMax: rowsMax,
          maxRows: maxRows
        }, inputProps);
        InputComponent = TextareaAutosize$1;
      }
    } else {
      inputProps = _extends$1({
        type: type
      }, inputProps);
    }

    var handleAutoFill = function handleAutoFill(event) {
      // Provide a fake value as Chrome might not let you access it for security reasons.
      checkDirty(event.animationName === 'mui-auto-fill-cancel' ? inputRef.current : {
        value: 'x'
      });
    };

    React__namespace.useEffect(function () {
      if (muiFormControl) {
        muiFormControl.setAdornedStart(Boolean(startAdornment));
      }
    }, [muiFormControl, startAdornment]);
    return /*#__PURE__*/React__namespace.createElement("div", _extends$1({
      className: clsx(classes.root, classes["color".concat(capitalize(fcs.color || 'primary'))], className, fcs.disabled && classes.disabled, fcs.error && classes.error, fullWidth && classes.fullWidth, fcs.focused && classes.focused, muiFormControl && classes.formControl, multiline && classes.multiline, startAdornment && classes.adornedStart, endAdornment && classes.adornedEnd, fcs.margin === 'dense' && classes.marginDense),
      onClick: handleClick,
      ref: ref
    }, other), startAdornment, /*#__PURE__*/React__namespace.createElement(FormControlContext$1.Provider, {
      value: null
    }, /*#__PURE__*/React__namespace.createElement(InputComponent, _extends$1({
      "aria-invalid": fcs.error,
      "aria-describedby": ariaDescribedby,
      autoComplete: autoComplete,
      autoFocus: autoFocus,
      defaultValue: defaultValue,
      disabled: fcs.disabled,
      id: id,
      onAnimationStart: handleAutoFill,
      name: name,
      placeholder: placeholder,
      readOnly: readOnly,
      required: fcs.required,
      rows: rows,
      value: value,
      onKeyDown: onKeyDown,
      onKeyUp: onKeyUp
    }, inputProps, {
      className: clsx(classes.input, inputPropsProp.className, fcs.disabled && classes.disabled, multiline && classes.inputMultiline, fcs.hiddenLabel && classes.inputHiddenLabel, startAdornment && classes.inputAdornedStart, endAdornment && classes.inputAdornedEnd, type === 'search' && classes.inputTypeSearch, fcs.margin === 'dense' && classes.inputMarginDense),
      onBlur: handleBlur,
      onChange: handleChange,
      onFocus: handleFocus
    }))), endAdornment, renderSuffix ? renderSuffix(_extends$1({}, fcs, {
      startAdornment: startAdornment
    })) : null);
  });
  InputBase.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * @ignore
     */
    'aria-describedby': PropTypes.string,

    /**
     * This prop helps users to fill forms faster, especially on mobile devices.
     * The name can be confusing, as it's more like an autofill.
     * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
     */
    autoComplete: PropTypes.string,

    /**
     * If `true`, the `input` element will be focused during the first mount.
     */
    autoFocus: PropTypes.bool,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * The color of the component. It supports those theme colors that make sense for this component.
     */
    color: PropTypes.oneOf(['primary', 'secondary']),

    /**
     * The default `input` element value. Use when the component is not controlled.
     */
    defaultValue: PropTypes.any,

    /**
     * If `true`, the `input` element will be disabled.
     */
    disabled: PropTypes.bool,

    /**
     * End `InputAdornment` for this component.
     */
    endAdornment: PropTypes.node,

    /**
     * If `true`, the input will indicate an error. This is normally obtained via context from
     * FormControl.
     */
    error: PropTypes.bool,

    /**
     * If `true`, the input will take up the full width of its container.
     */
    fullWidth: PropTypes.bool,

    /**
     * The id of the `input` element.
     */
    id: PropTypes.string,

    /**
     * The component used for the `input` element.
     * Either a string to use a HTML element or a component.
     */
    inputComponent: PropTypes.elementType,

    /**
     * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
     */
    inputProps: PropTypes.object,

    /**
     * Pass a ref to the `input` element.
     */
    inputRef: refType$1,

    /**
     * If `dense`, will adjust vertical spacing. This is normally obtained via context from
     * FormControl.
     */
    margin: PropTypes.oneOf(['dense', 'none']),

    /**
     * Maximum number of rows to display when multiline option is set to true.
     */
    maxRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * Minimum number of rows to display when multiline option is set to true.
     */
    minRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * If `true`, a textarea element will be rendered.
     */
    multiline: PropTypes.bool,

    /**
     * Name attribute of the `input` element.
     */
    name: PropTypes.string,

    /**
     * Callback fired when the input is blurred.
     *
     * Notice that the first argument (event) might be undefined.
     */
    onBlur: PropTypes.func,

    /**
     * Callback fired when the value is changed.
     *
     * @param {object} event The event source of the callback.
     * You can pull out the new value by accessing `event.target.value` (string).
     */
    onChange: PropTypes.func,

    /**
     * @ignore
     */
    onClick: PropTypes.func,

    /**
     * @ignore
     */
    onFocus: PropTypes.func,

    /**
     * @ignore
     */
    onKeyDown: PropTypes.func,

    /**
     * @ignore
     */
    onKeyUp: PropTypes.func,

    /**
     * The short hint displayed in the input before the user enters a value.
     */
    placeholder: PropTypes.string,

    /**
     * It prevents the user from changing the value of the field
     * (not from interacting with the field).
     */
    readOnly: PropTypes.bool,

    /**
     * @ignore
     */
    renderSuffix: PropTypes.func,

    /**
     * If `true`, the `input` element will be required.
     */
    required: PropTypes.bool,

    /**
     * Number of rows to display when multiline option is set to true.
     */
    rows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * Maximum number of rows to display.
     * @deprecated Use `maxRows` instead.
     */
    rowsMax: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * Minimum number of rows to display.
     * @deprecated Use `minRows` instead.
     */
    rowsMin: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * Start `InputAdornment` for this component.
     */
    startAdornment: PropTypes.node,

    /**
     * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
     */
    type: PropTypes.string,

    /**
     * The value of the `input` element, required for a controlled component.
     */
    value: PropTypes.any
  } ;
  var InputBase$1 = withStyles(styles$j, {
    name: 'MuiInputBase'
  })(InputBase);

  var styles$i = function styles(theme) {
    var light = theme.palette.type === 'light';
    var bottomLineColor = light ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)';
    return {
      /* Styles applied to the root element. */
      root: {
        position: 'relative'
      },

      /* Styles applied to the root element if the component is a descendant of `FormControl`. */
      formControl: {
        'label + &': {
          marginTop: 16
        }
      },

      /* Styles applied to the root element if the component is focused. */
      focused: {},

      /* Styles applied to the root element if `disabled={true}`. */
      disabled: {},

      /* Styles applied to the root element if color secondary. */
      colorSecondary: {
        '&$underline:after': {
          borderBottomColor: theme.palette.secondary.main
        }
      },

      /* Styles applied to the root element if `disableUnderline={false}`. */
      underline: {
        '&:after': {
          borderBottom: "2px solid ".concat(theme.palette.primary.main),
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
          content: '""',
          position: 'absolute',
          right: 0,
          transform: 'scaleX(0)',
          transition: theme.transitions.create('transform', {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          pointerEvents: 'none' // Transparent to the hover style.

        },
        '&$focused:after': {
          transform: 'scaleX(1)'
        },
        '&$error:after': {
          borderBottomColor: theme.palette.error.main,
          transform: 'scaleX(1)' // error is always underlined in red

        },
        '&:before': {
          borderBottom: "1px solid ".concat(bottomLineColor),
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
          content: '"\\00a0"',
          position: 'absolute',
          right: 0,
          transition: theme.transitions.create('border-bottom-color', {
            duration: theme.transitions.duration.shorter
          }),
          pointerEvents: 'none' // Transparent to the hover style.

        },
        '&:hover:not($disabled):before': {
          borderBottom: "2px solid ".concat(theme.palette.text.primary),
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            borderBottom: "1px solid ".concat(bottomLineColor)
          }
        },
        '&$disabled:before': {
          borderBottomStyle: 'dotted'
        }
      },

      /* Pseudo-class applied to the root element if `error={true}`. */
      error: {},

      /* Styles applied to the `input` element if `margin="dense"`. */
      marginDense: {},

      /* Styles applied to the root element if `multiline={true}`. */
      multiline: {},

      /* Styles applied to the root element if `fullWidth={true}`. */
      fullWidth: {},

      /* Styles applied to the `input` element. */
      input: {},

      /* Styles applied to the `input` element if `margin="dense"`. */
      inputMarginDense: {},

      /* Styles applied to the `input` element if `multiline={true}`. */
      inputMultiline: {},

      /* Styles applied to the `input` element if `type="search"`. */
      inputTypeSearch: {}
    };
  };
  var Input = /*#__PURE__*/React__namespace.forwardRef(function Input(props, ref) {
    var disableUnderline = props.disableUnderline,
        classes = props.classes,
        _props$fullWidth = props.fullWidth,
        fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
        _props$inputComponent = props.inputComponent,
        inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent,
        _props$multiline = props.multiline,
        multiline = _props$multiline === void 0 ? false : _props$multiline,
        _props$type = props.type,
        type = _props$type === void 0 ? 'text' : _props$type,
        other = _objectWithoutProperties(props, ["disableUnderline", "classes", "fullWidth", "inputComponent", "multiline", "type"]);

    return /*#__PURE__*/React__namespace.createElement(InputBase$1, _extends$1({
      classes: _extends$1({}, classes, {
        root: clsx(classes.root, !disableUnderline && classes.underline),
        underline: null
      }),
      fullWidth: fullWidth,
      inputComponent: inputComponent,
      multiline: multiline,
      ref: ref,
      type: type
    }, other));
  });
  Input.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * This prop helps users to fill forms faster, especially on mobile devices.
     * The name can be confusing, as it's more like an autofill.
     * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
     */
    autoComplete: PropTypes.string,

    /**
     * If `true`, the `input` element will be focused during the first mount.
     */
    autoFocus: PropTypes.bool,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * The color of the component. It supports those theme colors that make sense for this component.
     */
    color: PropTypes.oneOf(['primary', 'secondary']),

    /**
     * The default `input` element value. Use when the component is not controlled.
     */
    defaultValue: PropTypes.any,

    /**
     * If `true`, the `input` element will be disabled.
     */
    disabled: PropTypes.bool,

    /**
     * If `true`, the input will not have an underline.
     */
    disableUnderline: PropTypes.bool,

    /**
     * End `InputAdornment` for this component.
     */
    endAdornment: PropTypes.node,

    /**
     * If `true`, the input will indicate an error. This is normally obtained via context from
     * FormControl.
     */
    error: PropTypes.bool,

    /**
     * If `true`, the input will take up the full width of its container.
     */
    fullWidth: PropTypes.bool,

    /**
     * The id of the `input` element.
     */
    id: PropTypes.string,

    /**
     * The component used for the `input` element.
     * Either a string to use a HTML element or a component.
     */
    inputComponent: PropTypes.elementType,

    /**
     * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
     */
    inputProps: PropTypes.object,

    /**
     * Pass a ref to the `input` element.
     */
    inputRef: refType$1,

    /**
     * If `dense`, will adjust vertical spacing. This is normally obtained via context from
     * FormControl.
     */
    margin: PropTypes.oneOf(['dense', 'none']),

    /**
     * Maximum number of rows to display when multiline option is set to true.
     */
    maxRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * If `true`, a textarea element will be rendered.
     */
    multiline: PropTypes.bool,

    /**
     * Name attribute of the `input` element.
     */
    name: PropTypes.string,

    /**
     * Callback fired when the value is changed.
     *
     * @param {object} event The event source of the callback.
     * You can pull out the new value by accessing `event.target.value` (string).
     */
    onChange: PropTypes.func,

    /**
     * The short hint displayed in the input before the user enters a value.
     */
    placeholder: PropTypes.string,

    /**
     * It prevents the user from changing the value of the field
     * (not from interacting with the field).
     */
    readOnly: PropTypes.bool,

    /**
     * If `true`, the `input` element will be required.
     */
    required: PropTypes.bool,

    /**
     * Number of rows to display when multiline option is set to true.
     */
    rows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * Start `InputAdornment` for this component.
     */
    startAdornment: PropTypes.node,

    /**
     * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
     */
    type: PropTypes.string,

    /**
     * The value of the `input` element, required for a controlled component.
     */
    value: PropTypes.any
  } ;
  Input.muiName = 'Input';
  var Input$1 = withStyles(styles$i, {
    name: 'MuiInput'
  })(Input);

  var styles$h = function styles(theme) {
    var light = theme.palette.type === 'light';
    var bottomLineColor = light ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)';
    var backgroundColor = light ? 'rgba(0, 0, 0, 0.09)' : 'rgba(255, 255, 255, 0.09)';
    return {
      /* Styles applied to the root element. */
      root: {
        position: 'relative',
        backgroundColor: backgroundColor,
        borderTopLeftRadius: theme.shape.borderRadius,
        borderTopRightRadius: theme.shape.borderRadius,
        transition: theme.transitions.create('background-color', {
          duration: theme.transitions.duration.shorter,
          easing: theme.transitions.easing.easeOut
        }),
        '&:hover': {
          backgroundColor: light ? 'rgba(0, 0, 0, 0.13)' : 'rgba(255, 255, 255, 0.13)',
          // Reset on touch devices, it doesn't add specificity
          '@media (hover: none)': {
            backgroundColor: backgroundColor
          }
        },
        '&$focused': {
          backgroundColor: light ? 'rgba(0, 0, 0, 0.09)' : 'rgba(255, 255, 255, 0.09)'
        },
        '&$disabled': {
          backgroundColor: light ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.12)'
        }
      },

      /* Styles applied to the root element if color secondary. */
      colorSecondary: {
        '&$underline:after': {
          borderBottomColor: theme.palette.secondary.main
        }
      },

      /* Styles applied to the root element if `disableUnderline={false}`. */
      underline: {
        '&:after': {
          borderBottom: "2px solid ".concat(theme.palette.primary.main),
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
          content: '""',
          position: 'absolute',
          right: 0,
          transform: 'scaleX(0)',
          transition: theme.transitions.create('transform', {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          pointerEvents: 'none' // Transparent to the hover style.

        },
        '&$focused:after': {
          transform: 'scaleX(1)'
        },
        '&$error:after': {
          borderBottomColor: theme.palette.error.main,
          transform: 'scaleX(1)' // error is always underlined in red

        },
        '&:before': {
          borderBottom: "1px solid ".concat(bottomLineColor),
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE 11 "''" https://github.com/cssinjs/jss/issues/242
          content: '"\\00a0"',
          position: 'absolute',
          right: 0,
          transition: theme.transitions.create('border-bottom-color', {
            duration: theme.transitions.duration.shorter
          }),
          pointerEvents: 'none' // Transparent to the hover style.

        },
        '&:hover:before': {
          borderBottom: "1px solid ".concat(theme.palette.text.primary)
        },
        '&$disabled:before': {
          borderBottomStyle: 'dotted'
        }
      },

      /* Pseudo-class applied to the root element if the component is focused. */
      focused: {},

      /* Pseudo-class applied to the root element if `disabled={true}`. */
      disabled: {},

      /* Styles applied to the root element if `startAdornment` is provided. */
      adornedStart: {
        paddingLeft: 12
      },

      /* Styles applied to the root element if `endAdornment` is provided. */
      adornedEnd: {
        paddingRight: 12
      },

      /* Pseudo-class applied to the root element if `error={true}`. */
      error: {},

      /* Styles applied to the `input` element if `margin="dense"`. */
      marginDense: {},

      /* Styles applied to the root element if `multiline={true}`. */
      multiline: {
        padding: '27px 12px 10px',
        '&$marginDense': {
          paddingTop: 23,
          paddingBottom: 6
        }
      },

      /* Styles applied to the `input` element. */
      input: {
        padding: '27px 12px 10px',
        '&:-webkit-autofill': {
          WebkitBoxShadow: theme.palette.type === 'light' ? null : '0 0 0 100px #266798 inset',
          WebkitTextFillColor: theme.palette.type === 'light' ? null : '#fff',
          caretColor: theme.palette.type === 'light' ? null : '#fff',
          borderTopLeftRadius: 'inherit',
          borderTopRightRadius: 'inherit'
        }
      },

      /* Styles applied to the `input` element if `margin="dense"`. */
      inputMarginDense: {
        paddingTop: 23,
        paddingBottom: 6
      },

      /* Styles applied to the `input` if in `<FormControl hiddenLabel />`. */
      inputHiddenLabel: {
        paddingTop: 18,
        paddingBottom: 19,
        '&$inputMarginDense': {
          paddingTop: 10,
          paddingBottom: 11
        }
      },

      /* Styles applied to the `input` element if `multiline={true}`. */
      inputMultiline: {
        padding: 0
      },

      /* Styles applied to the `input` element if `startAdornment` is provided. */
      inputAdornedStart: {
        paddingLeft: 0
      },

      /* Styles applied to the `input` element if `endAdornment` is provided. */
      inputAdornedEnd: {
        paddingRight: 0
      }
    };
  };
  var FilledInput = /*#__PURE__*/React__namespace.forwardRef(function FilledInput(props, ref) {
    var disableUnderline = props.disableUnderline,
        classes = props.classes,
        _props$fullWidth = props.fullWidth,
        fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
        _props$inputComponent = props.inputComponent,
        inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent,
        _props$multiline = props.multiline,
        multiline = _props$multiline === void 0 ? false : _props$multiline,
        _props$type = props.type,
        type = _props$type === void 0 ? 'text' : _props$type,
        other = _objectWithoutProperties(props, ["disableUnderline", "classes", "fullWidth", "inputComponent", "multiline", "type"]);

    return /*#__PURE__*/React__namespace.createElement(InputBase$1, _extends$1({
      classes: _extends$1({}, classes, {
        root: clsx(classes.root, !disableUnderline && classes.underline),
        underline: null
      }),
      fullWidth: fullWidth,
      inputComponent: inputComponent,
      multiline: multiline,
      ref: ref,
      type: type
    }, other));
  });
  FilledInput.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * This prop helps users to fill forms faster, especially on mobile devices.
     * The name can be confusing, as it's more like an autofill.
     * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
     */
    autoComplete: PropTypes.string,

    /**
     * If `true`, the `input` element will be focused during the first mount.
     */
    autoFocus: PropTypes.bool,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * The color of the component. It supports those theme colors that make sense for this component.
     */
    color: PropTypes.oneOf(['primary', 'secondary']),

    /**
     * The default `input` element value. Use when the component is not controlled.
     */
    defaultValue: PropTypes.any,

    /**
     * If `true`, the `input` element will be disabled.
     */
    disabled: PropTypes.bool,

    /**
     * If `true`, the input will not have an underline.
     */
    disableUnderline: PropTypes.bool,

    /**
     * End `InputAdornment` for this component.
     */
    endAdornment: PropTypes.node,

    /**
     * If `true`, the input will indicate an error. This is normally obtained via context from
     * FormControl.
     */
    error: PropTypes.bool,

    /**
     * If `true`, the input will take up the full width of its container.
     */
    fullWidth: PropTypes.bool,

    /**
     * The id of the `input` element.
     */
    id: PropTypes.string,

    /**
     * The component used for the `input` element.
     * Either a string to use a HTML element or a component.
     */
    inputComponent: PropTypes.elementType,

    /**
     * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
     */
    inputProps: PropTypes.object,

    /**
     * Pass a ref to the `input` element.
     */
    inputRef: refType$1,

    /**
     * If `dense`, will adjust vertical spacing. This is normally obtained via context from
     * FormControl.
     */
    margin: PropTypes.oneOf(['dense', 'none']),

    /**
     * Maximum number of rows to display when multiline option is set to true.
     */
    maxRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * If `true`, a textarea element will be rendered.
     */
    multiline: PropTypes.bool,

    /**
     * Name attribute of the `input` element.
     */
    name: PropTypes.string,

    /**
     * Callback fired when the value is changed.
     *
     * @param {object} event The event source of the callback.
     * You can pull out the new value by accessing `event.target.value` (string).
     */
    onChange: PropTypes.func,

    /**
     * The short hint displayed in the input before the user enters a value.
     */
    placeholder: PropTypes.string,

    /**
     * It prevents the user from changing the value of the field
     * (not from interacting with the field).
     */
    readOnly: PropTypes.bool,

    /**
     * If `true`, the `input` element will be required.
     */
    required: PropTypes.bool,

    /**
     * Number of rows to display when multiline option is set to true.
     */
    rows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * Start `InputAdornment` for this component.
     */
    startAdornment: PropTypes.node,

    /**
     * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
     */
    type: PropTypes.string,

    /**
     * The value of the `input` element, required for a controlled component.
     */
    value: PropTypes.any
  } ;
  FilledInput.muiName = 'Input';
  var FilledInput$1 = withStyles(styles$h, {
    name: 'MuiFilledInput'
  })(FilledInput);

  var styles$g = function styles(theme) {
    return {
      /* Styles applied to the root element. */
      root: {
        position: 'absolute',
        bottom: 0,
        right: 0,
        top: -5,
        left: 0,
        margin: 0,
        padding: '0 8px',
        pointerEvents: 'none',
        borderRadius: 'inherit',
        borderStyle: 'solid',
        borderWidth: 1,
        overflow: 'hidden'
      },

      /* Styles applied to the legend element when `labelWidth` is provided. */
      legend: {
        textAlign: 'left',
        padding: 0,
        lineHeight: '11px',
        // sync with `height` in `legend` styles
        transition: theme.transitions.create('width', {
          duration: 150,
          easing: theme.transitions.easing.easeOut
        })
      },

      /* Styles applied to the legend element. */
      legendLabelled: {
        display: 'block',
        width: 'auto',
        textAlign: 'left',
        padding: 0,
        height: 11,
        // sync with `lineHeight` in `legend` styles
        fontSize: '0.75em',
        visibility: 'hidden',
        maxWidth: 0.01,
        transition: theme.transitions.create('max-width', {
          duration: 50,
          easing: theme.transitions.easing.easeOut
        }),
        '& > span': {
          paddingLeft: 5,
          paddingRight: 5,
          display: 'inline-block'
        }
      },

      /* Styles applied to the legend element is notched. */
      legendNotched: {
        maxWidth: 1000,
        transition: theme.transitions.create('max-width', {
          duration: 100,
          easing: theme.transitions.easing.easeOut,
          delay: 50
        })
      }
    };
  };
  /**
   * @ignore - internal component.
   */

  var NotchedOutline = /*#__PURE__*/React__namespace.forwardRef(function NotchedOutline(props, ref) {
    props.children;
        var classes = props.classes,
        className = props.className,
        label = props.label,
        labelWidthProp = props.labelWidth,
        notched = props.notched,
        style = props.style,
        other = _objectWithoutProperties(props, ["children", "classes", "className", "label", "labelWidth", "notched", "style"]);

    var theme = useTheme();
    var align = theme.direction === 'rtl' ? 'right' : 'left';

    if (label !== undefined) {
      return /*#__PURE__*/React__namespace.createElement("fieldset", _extends$1({
        "aria-hidden": true,
        className: clsx(classes.root, className),
        ref: ref,
        style: style
      }, other), /*#__PURE__*/React__namespace.createElement("legend", {
        className: clsx(classes.legendLabelled, notched && classes.legendNotched)
      }, label ? /*#__PURE__*/React__namespace.createElement("span", null, label) : /*#__PURE__*/React__namespace.createElement("span", {
        dangerouslySetInnerHTML: {
          __html: '&#8203;'
        }
      })));
    }

    var labelWidth = labelWidthProp > 0 ? labelWidthProp * 0.75 + 8 : 0.01;
    return /*#__PURE__*/React__namespace.createElement("fieldset", _extends$1({
      "aria-hidden": true,
      style: _extends$1(_defineProperty({}, "padding".concat(capitalize(align)), 8), style),
      className: clsx(classes.root, className),
      ref: ref
    }, other), /*#__PURE__*/React__namespace.createElement("legend", {
      className: classes.legend,
      style: {
        // IE 11: fieldset with legend does not render
        // a border radius. This maintains consistency
        // by always having a legend rendered
        width: notched ? labelWidth : 0.01
      }
    }, /*#__PURE__*/React__namespace.createElement("span", {
      dangerouslySetInnerHTML: {
        __html: '&#8203;'
      }
    })));
  });
  NotchedOutline.propTypes = {
    /**
     * The content of the component.
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * The label.
     */
    label: PropTypes.node,

    /**
     * The width of the label.
     */
    labelWidth: PropTypes.number.isRequired,

    /**
     * If `true`, the outline is notched to accommodate the label.
     */
    notched: PropTypes.bool.isRequired,

    /**
     * @ignore
     */
    style: PropTypes.object
  } ;
  var NotchedOutline$1 = withStyles(styles$g, {
    name: 'PrivateNotchedOutline'
  })(NotchedOutline);

  var styles$f = function styles(theme) {
    var borderColor = theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.23)' : 'rgba(255, 255, 255, 0.23)';
    return {
      /* Styles applied to the root element. */
      root: {
        position: 'relative',
        borderRadius: theme.shape.borderRadius,
        '&:hover $notchedOutline': {
          borderColor: theme.palette.text.primary
        },
        // Reset on touch devices, it doesn't add specificity
        '@media (hover: none)': {
          '&:hover $notchedOutline': {
            borderColor: borderColor
          }
        },
        '&$focused $notchedOutline': {
          borderColor: theme.palette.primary.main,
          borderWidth: 2
        },
        '&$error $notchedOutline': {
          borderColor: theme.palette.error.main
        },
        '&$disabled $notchedOutline': {
          borderColor: theme.palette.action.disabled
        }
      },

      /* Styles applied to the root element if the color is secondary. */
      colorSecondary: {
        '&$focused $notchedOutline': {
          borderColor: theme.palette.secondary.main
        }
      },

      /* Styles applied to the root element if the component is focused. */
      focused: {},

      /* Styles applied to the root element if `disabled={true}`. */
      disabled: {},

      /* Styles applied to the root element if `startAdornment` is provided. */
      adornedStart: {
        paddingLeft: 14
      },

      /* Styles applied to the root element if `endAdornment` is provided. */
      adornedEnd: {
        paddingRight: 14
      },

      /* Pseudo-class applied to the root element if `error={true}`. */
      error: {},

      /* Styles applied to the `input` element if `margin="dense"`. */
      marginDense: {},

      /* Styles applied to the root element if `multiline={true}`. */
      multiline: {
        padding: '18.5px 14px',
        '&$marginDense': {
          paddingTop: 10.5,
          paddingBottom: 10.5
        }
      },

      /* Styles applied to the `NotchedOutline` element. */
      notchedOutline: {
        borderColor: borderColor
      },

      /* Styles applied to the `input` element. */
      input: {
        padding: '18.5px 14px',
        '&:-webkit-autofill': {
          WebkitBoxShadow: theme.palette.type === 'light' ? null : '0 0 0 100px #266798 inset',
          WebkitTextFillColor: theme.palette.type === 'light' ? null : '#fff',
          caretColor: theme.palette.type === 'light' ? null : '#fff',
          borderRadius: 'inherit'
        }
      },

      /* Styles applied to the `input` element if `margin="dense"`. */
      inputMarginDense: {
        paddingTop: 10.5,
        paddingBottom: 10.5
      },

      /* Styles applied to the `input` element if `multiline={true}`. */
      inputMultiline: {
        padding: 0
      },

      /* Styles applied to the `input` element if `startAdornment` is provided. */
      inputAdornedStart: {
        paddingLeft: 0
      },

      /* Styles applied to the `input` element if `endAdornment` is provided. */
      inputAdornedEnd: {
        paddingRight: 0
      }
    };
  };
  var OutlinedInput = /*#__PURE__*/React__namespace.forwardRef(function OutlinedInput(props, ref) {
    var classes = props.classes,
        _props$fullWidth = props.fullWidth,
        fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
        _props$inputComponent = props.inputComponent,
        inputComponent = _props$inputComponent === void 0 ? 'input' : _props$inputComponent,
        label = props.label,
        _props$labelWidth = props.labelWidth,
        labelWidth = _props$labelWidth === void 0 ? 0 : _props$labelWidth,
        _props$multiline = props.multiline,
        multiline = _props$multiline === void 0 ? false : _props$multiline,
        notched = props.notched,
        _props$type = props.type,
        type = _props$type === void 0 ? 'text' : _props$type,
        other = _objectWithoutProperties(props, ["classes", "fullWidth", "inputComponent", "label", "labelWidth", "multiline", "notched", "type"]);

    return /*#__PURE__*/React__namespace.createElement(InputBase$1, _extends$1({
      renderSuffix: function renderSuffix(state) {
        return /*#__PURE__*/React__namespace.createElement(NotchedOutline$1, {
          className: classes.notchedOutline,
          label: label,
          labelWidth: labelWidth,
          notched: typeof notched !== 'undefined' ? notched : Boolean(state.startAdornment || state.filled || state.focused)
        });
      },
      classes: _extends$1({}, classes, {
        root: clsx(classes.root, classes.underline),
        notchedOutline: null
      }),
      fullWidth: fullWidth,
      inputComponent: inputComponent,
      multiline: multiline,
      ref: ref,
      type: type
    }, other));
  });
  OutlinedInput.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * This prop helps users to fill forms faster, especially on mobile devices.
     * The name can be confusing, as it's more like an autofill.
     * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
     */
    autoComplete: PropTypes.string,

    /**
     * If `true`, the `input` element will be focused during the first mount.
     */
    autoFocus: PropTypes.bool,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * The color of the component. It supports those theme colors that make sense for this component.
     */
    color: PropTypes.oneOf(['primary', 'secondary']),

    /**
     * The default `input` element value. Use when the component is not controlled.
     */
    defaultValue: PropTypes.any,

    /**
     * If `true`, the `input` element will be disabled.
     */
    disabled: PropTypes.bool,

    /**
     * End `InputAdornment` for this component.
     */
    endAdornment: PropTypes.node,

    /**
     * If `true`, the input will indicate an error. This is normally obtained via context from
     * FormControl.
     */
    error: PropTypes.bool,

    /**
     * If `true`, the input will take up the full width of its container.
     */
    fullWidth: PropTypes.bool,

    /**
     * The id of the `input` element.
     */
    id: PropTypes.string,

    /**
     * The component used for the `input` element.
     * Either a string to use a HTML element or a component.
     */
    inputComponent: PropTypes.elementType,

    /**
     * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
     */
    inputProps: PropTypes.object,

    /**
     * Pass a ref to the `input` element.
     */
    inputRef: refType$1,

    /**
     * The label of the input. It is only used for layout. The actual labelling
     * is handled by `InputLabel`. If specified `labelWidth` is ignored.
     */
    label: PropTypes.node,

    /**
     * The width of the label. Is ignored if `label` is provided. Prefer `label`
     * if the input label appears with a strike through.
     */
    labelWidth: PropTypes.number,

    /**
     * If `dense`, will adjust vertical spacing. This is normally obtained via context from
     * FormControl.
     */
    margin: PropTypes.oneOf(['dense', 'none']),

    /**
     * Maximum number of rows to display when multiline option is set to true.
     */
    maxRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * If `true`, a textarea element will be rendered.
     */
    multiline: PropTypes.bool,

    /**
     * Name attribute of the `input` element.
     */
    name: PropTypes.string,

    /**
     * If `true`, the outline is notched to accommodate the label.
     */
    notched: PropTypes.bool,

    /**
     * Callback fired when the value is changed.
     *
     * @param {object} event The event source of the callback.
     * You can pull out the new value by accessing `event.target.value` (string).
     */
    onChange: PropTypes.func,

    /**
     * The short hint displayed in the input before the user enters a value.
     */
    placeholder: PropTypes.string,

    /**
     * It prevents the user from changing the value of the field
     * (not from interacting with the field).
     */
    readOnly: PropTypes.bool,

    /**
     * If `true`, the `input` element will be required.
     */
    required: PropTypes.bool,

    /**
     * Number of rows to display when multiline option is set to true.
     */
    rows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * Start `InputAdornment` for this component.
     */
    startAdornment: PropTypes.node,

    /**
     * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
     */
    type: PropTypes.string,

    /**
     * The value of the `input` element, required for a controlled component.
     */
    value: PropTypes.any
  } ;
  OutlinedInput.muiName = 'Input';
  var OutlinedInput$1 = withStyles(styles$f, {
    name: 'MuiOutlinedInput'
  })(OutlinedInput);

  function useFormControl() {
    return React__namespace.useContext(FormControlContext$1);
  }

  var styles$e = function styles(theme) {
    return {
      /* Styles applied to the root element. */
      root: _extends$1({
        color: theme.palette.text.secondary
      }, theme.typography.body1, {
        lineHeight: 1,
        padding: 0,
        '&$focused': {
          color: theme.palette.primary.main
        },
        '&$disabled': {
          color: theme.palette.text.disabled
        },
        '&$error': {
          color: theme.palette.error.main
        }
      }),

      /* Styles applied to the root element if the color is secondary. */
      colorSecondary: {
        '&$focused': {
          color: theme.palette.secondary.main
        }
      },

      /* Pseudo-class applied to the root element if `focused={true}`. */
      focused: {},

      /* Pseudo-class applied to the root element if `disabled={true}`. */
      disabled: {},

      /* Pseudo-class applied to the root element if `error={true}`. */
      error: {},

      /* Pseudo-class applied to the root element if `filled={true}`. */
      filled: {},

      /* Pseudo-class applied to the root element if `required={true}`. */
      required: {},

      /* Styles applied to the asterisk element. */
      asterisk: {
        '&$error': {
          color: theme.palette.error.main
        }
      }
    };
  };
  var FormLabel = /*#__PURE__*/React__namespace.forwardRef(function FormLabel(props, ref) {
    var children = props.children,
        classes = props.classes,
        className = props.className;
        props.color;
        var _props$component = props.component,
        Component = _props$component === void 0 ? 'label' : _props$component;
        props.disabled;
        props.error;
        props.filled;
        props.focused;
        props.required;
        var other = _objectWithoutProperties(props, ["children", "classes", "className", "color", "component", "disabled", "error", "filled", "focused", "required"]);

    var muiFormControl = useFormControl();
    var fcs = formControlState({
      props: props,
      muiFormControl: muiFormControl,
      states: ['color', 'required', 'focused', 'disabled', 'error', 'filled']
    });
    return /*#__PURE__*/React__namespace.createElement(Component, _extends$1({
      className: clsx(classes.root, classes["color".concat(capitalize(fcs.color || 'primary'))], className, fcs.disabled && classes.disabled, fcs.error && classes.error, fcs.filled && classes.filled, fcs.focused && classes.focused, fcs.required && classes.required),
      ref: ref
    }, other), children, fcs.required && /*#__PURE__*/React__namespace.createElement("span", {
      "aria-hidden": true,
      className: clsx(classes.asterisk, fcs.error && classes.error)
    }, "\u2009", '*'));
  });
  FormLabel.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * The content of the component.
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * The color of the component. It supports those theme colors that make sense for this component.
     */
    color: PropTypes.oneOf(['primary', 'secondary']),

    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: PropTypes
    /* @typescript-to-proptypes-ignore */
    .elementType,

    /**
     * If `true`, the label should be displayed in a disabled state.
     */
    disabled: PropTypes.bool,

    /**
     * If `true`, the label should be displayed in an error state.
     */
    error: PropTypes.bool,

    /**
     * If `true`, the label should use filled classes key.
     */
    filled: PropTypes.bool,

    /**
     * If `true`, the input of this label is focused (used by `FormGroup` components).
     */
    focused: PropTypes.bool,

    /**
     * If `true`, the label will indicate that the input is required.
     */
    required: PropTypes.bool
  } ;
  var FormLabel$1 = withStyles(styles$e, {
    name: 'MuiFormLabel'
  })(FormLabel);

  var styles$d = function styles(theme) {
    return {
      /* Styles applied to the root element. */
      root: {
        display: 'block',
        transformOrigin: 'top left'
      },

      /* Pseudo-class applied to the root element if `focused={true}`. */
      focused: {},

      /* Pseudo-class applied to the root element if `disabled={true}`. */
      disabled: {},

      /* Pseudo-class applied to the root element if `error={true}`. */
      error: {},

      /* Pseudo-class applied to the root element if `required={true}`. */
      required: {},

      /* Pseudo-class applied to the asterisk element. */
      asterisk: {},

      /* Styles applied to the root element if the component is a descendant of `FormControl`. */
      formControl: {
        position: 'absolute',
        left: 0,
        top: 0,
        // slight alteration to spec spacing to match visual spec result
        transform: 'translate(0, 24px) scale(1)'
      },

      /* Styles applied to the root element if `margin="dense"`. */
      marginDense: {
        // Compensation for the `Input.inputDense` style.
        transform: 'translate(0, 21px) scale(1)'
      },

      /* Styles applied to the `input` element if `shrink={true}`. */
      shrink: {
        transform: 'translate(0, 1.5px) scale(0.75)',
        transformOrigin: 'top left'
      },

      /* Styles applied to the `input` element if `disableAnimation={false}`. */
      animated: {
        transition: theme.transitions.create(['color', 'transform'], {
          duration: theme.transitions.duration.shorter,
          easing: theme.transitions.easing.easeOut
        })
      },

      /* Styles applied to the root element if `variant="filled"`. */
      filled: {
        // Chrome's autofill feature gives the input field a yellow background.
        // Since the input field is behind the label in the HTML tree,
        // the input field is drawn last and hides the label with an opaque background color.
        // zIndex: 1 will raise the label above opaque background-colors of input.
        zIndex: 1,
        pointerEvents: 'none',
        transform: 'translate(12px, 20px) scale(1)',
        '&$marginDense': {
          transform: 'translate(12px, 17px) scale(1)'
        },
        '&$shrink': {
          transform: 'translate(12px, 10px) scale(0.75)',
          '&$marginDense': {
            transform: 'translate(12px, 7px) scale(0.75)'
          }
        }
      },

      /* Styles applied to the root element if `variant="outlined"`. */
      outlined: {
        // see comment above on filled.zIndex
        zIndex: 1,
        pointerEvents: 'none',
        transform: 'translate(14px, 20px) scale(1)',
        '&$marginDense': {
          transform: 'translate(14px, 12px) scale(1)'
        },
        '&$shrink': {
          transform: 'translate(14px, -6px) scale(0.75)'
        }
      }
    };
  };
  var InputLabel = /*#__PURE__*/React__namespace.forwardRef(function InputLabel(props, ref) {
    var classes = props.classes,
        className = props.className,
        _props$disableAnimati = props.disableAnimation,
        disableAnimation = _props$disableAnimati === void 0 ? false : _props$disableAnimati;
        props.margin;
        var shrinkProp = props.shrink;
        props.variant;
        var other = _objectWithoutProperties(props, ["classes", "className", "disableAnimation", "margin", "shrink", "variant"]);

    var muiFormControl = useFormControl();
    var shrink = shrinkProp;

    if (typeof shrink === 'undefined' && muiFormControl) {
      shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
    }

    var fcs = formControlState({
      props: props,
      muiFormControl: muiFormControl,
      states: ['margin', 'variant']
    });
    return /*#__PURE__*/React__namespace.createElement(FormLabel$1, _extends$1({
      "data-shrink": shrink,
      className: clsx(classes.root, className, muiFormControl && classes.formControl, !disableAnimation && classes.animated, shrink && classes.shrink, fcs.margin === 'dense' && classes.marginDense, {
        'filled': classes.filled,
        'outlined': classes.outlined
      }[fcs.variant]),
      classes: {
        focused: classes.focused,
        disabled: classes.disabled,
        error: classes.error,
        required: classes.required,
        asterisk: classes.asterisk
      },
      ref: ref
    }, other));
  });
  InputLabel.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * The contents of the `InputLabel`.
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * The color of the component. It supports those theme colors that make sense for this component.
     */
    color: PropTypes.oneOf(['primary', 'secondary']),

    /**
     * If `true`, the transition animation is disabled.
     */
    disableAnimation: PropTypes.bool,

    /**
     * If `true`, apply disabled class.
     */
    disabled: PropTypes.bool,

    /**
     * If `true`, the label will be displayed in an error state.
     */
    error: PropTypes.bool,

    /**
     * If `true`, the input of this label is focused.
     */
    focused: PropTypes.bool,

    /**
     * If `dense`, will adjust vertical spacing. This is normally obtained via context from
     * FormControl.
     */
    margin: PropTypes.oneOf(['dense']),

    /**
     * if `true`, the label will indicate that the input is required.
     */
    required: PropTypes.bool,

    /**
     * If `true`, the label is shrunk.
     */
    shrink: PropTypes.bool,

    /**
     * The variant to use.
     */
    variant: PropTypes.oneOf(['filled', 'outlined', 'standard'])
  } ;
  var InputLabel$1 = withStyles(styles$d, {
    name: 'MuiInputLabel'
  })(InputLabel);

  var styles$c = {
    /* Styles applied to the root element. */
    root: {
      display: 'inline-flex',
      flexDirection: 'column',
      position: 'relative',
      // Reset fieldset default style.
      minWidth: 0,
      padding: 0,
      margin: 0,
      border: 0,
      verticalAlign: 'top' // Fix alignment issue on Safari.

    },

    /* Styles applied to the root element if `margin="normal"`. */
    marginNormal: {
      marginTop: 16,
      marginBottom: 8
    },

    /* Styles applied to the root element if `margin="dense"`. */
    marginDense: {
      marginTop: 8,
      marginBottom: 4
    },

    /* Styles applied to the root element if `fullWidth={true}`. */
    fullWidth: {
      width: '100%'
    }
  };
  /**
   * Provides context such as filled/focused/error/required for form inputs.
   * Relying on the context provides high flexibility and ensures that the state always stays
   * consistent across the children of the `FormControl`.
   * This context is used by the following components:
   *
   *  - FormLabel
   *  - FormHelperText
   *  - Input
   *  - InputLabel
   *
   * You can find one composition example below and more going to [the demos](/components/text-fields/#components).
   *
   * ```jsx
   * <FormControl>
   *   <InputLabel htmlFor="my-input">Email address</InputLabel>
   *   <Input id="my-input" aria-describedby="my-helper-text" />
   *   <FormHelperText id="my-helper-text">We'll never share your email.</FormHelperText>
   * </FormControl>
   * ```
   *
   * Only one input can be used within a FormControl.
   */

  var FormControl = /*#__PURE__*/React__namespace.forwardRef(function FormControl(props, ref) {
    var children = props.children,
        classes = props.classes,
        className = props.className,
        _props$color = props.color,
        color = _props$color === void 0 ? 'primary' : _props$color,
        _props$component = props.component,
        Component = _props$component === void 0 ? 'div' : _props$component,
        _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled,
        _props$error = props.error,
        error = _props$error === void 0 ? false : _props$error,
        _props$fullWidth = props.fullWidth,
        fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
        visuallyFocused = props.focused,
        _props$hiddenLabel = props.hiddenLabel,
        hiddenLabel = _props$hiddenLabel === void 0 ? false : _props$hiddenLabel,
        _props$margin = props.margin,
        margin = _props$margin === void 0 ? 'none' : _props$margin,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        size = props.size,
        _props$variant = props.variant,
        variant = _props$variant === void 0 ? 'standard' : _props$variant,
        other = _objectWithoutProperties(props, ["children", "classes", "className", "color", "component", "disabled", "error", "fullWidth", "focused", "hiddenLabel", "margin", "required", "size", "variant"]);

    var _React$useState = React__namespace.useState(function () {
      // We need to iterate through the children and find the Input in order
      // to fully support server-side rendering.
      var initialAdornedStart = false;

      if (children) {
        React__namespace.Children.forEach(children, function (child) {
          if (!isMuiElement(child, ['Input', 'Select'])) {
            return;
          }

          var input = isMuiElement(child, ['Select']) ? child.props.input : child;

          if (input && isAdornedStart(input.props)) {
            initialAdornedStart = true;
          }
        });
      }

      return initialAdornedStart;
    }),
        adornedStart = _React$useState[0],
        setAdornedStart = _React$useState[1];

    var _React$useState2 = React__namespace.useState(function () {
      // We need to iterate through the children and find the Input in order
      // to fully support server-side rendering.
      var initialFilled = false;

      if (children) {
        React__namespace.Children.forEach(children, function (child) {
          if (!isMuiElement(child, ['Input', 'Select'])) {
            return;
          }

          if (isFilled(child.props, true)) {
            initialFilled = true;
          }
        });
      }

      return initialFilled;
    }),
        filled = _React$useState2[0],
        setFilled = _React$useState2[1];

    var _React$useState3 = React__namespace.useState(false),
        _focused = _React$useState3[0],
        setFocused = _React$useState3[1];

    var focused = visuallyFocused !== undefined ? visuallyFocused : _focused;

    if (disabled && focused) {
      setFocused(false);
    }

    var registerEffect;

    {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      var registeredInput = React__namespace.useRef(false);

      registerEffect = function registerEffect() {
        if (registeredInput.current) {
          console.error(['Material-UI: There are multiple InputBase components inside a FormControl.', 'This is not supported. It might cause infinite rendering loops.', 'Only use one InputBase.'].join('\n'));
        }

        registeredInput.current = true;
        return function () {
          registeredInput.current = false;
        };
      };
    }

    var onFilled = React__namespace.useCallback(function () {
      setFilled(true);
    }, []);
    var onEmpty = React__namespace.useCallback(function () {
      setFilled(false);
    }, []);
    var childContext = {
      adornedStart: adornedStart,
      setAdornedStart: setAdornedStart,
      color: color,
      disabled: disabled,
      error: error,
      filled: filled,
      focused: focused,
      fullWidth: fullWidth,
      hiddenLabel: hiddenLabel,
      margin: (size === 'small' ? 'dense' : undefined) || margin,
      onBlur: function onBlur() {
        setFocused(false);
      },
      onEmpty: onEmpty,
      onFilled: onFilled,
      onFocus: function onFocus() {
        setFocused(true);
      },
      registerEffect: registerEffect,
      required: required,
      variant: variant
    };
    return /*#__PURE__*/React__namespace.createElement(FormControlContext$1.Provider, {
      value: childContext
    }, /*#__PURE__*/React__namespace.createElement(Component, _extends$1({
      className: clsx(classes.root, className, margin !== 'none' && classes["margin".concat(capitalize(margin))], fullWidth && classes.fullWidth),
      ref: ref
    }, other), children));
  });
  FormControl.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * The contents of the form control.
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * The color of the component. It supports those theme colors that make sense for this component.
     */
    color: PropTypes.oneOf(['primary', 'secondary']),

    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: PropTypes
    /* @typescript-to-proptypes-ignore */
    .elementType,

    /**
     * If `true`, the label, input and helper text should be displayed in a disabled state.
     */
    disabled: PropTypes.bool,

    /**
     * If `true`, the label should be displayed in an error state.
     */
    error: PropTypes.bool,

    /**
     * If `true`, the component will be displayed in focused state.
     */
    focused: PropTypes.bool,

    /**
     * If `true`, the component will take up the full width of its container.
     */
    fullWidth: PropTypes.bool,

    /**
     * If `true`, the label will be hidden.
     * This is used to increase density for a `FilledInput`.
     * Be sure to add `aria-label` to the `input` element.
     */
    hiddenLabel: PropTypes.bool,

    /**
     * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
     */
    margin: PropTypes.oneOf(['dense', 'none', 'normal']),

    /**
     * If `true`, the label will indicate that the input is required.
     */
    required: PropTypes.bool,

    /**
     * The size of the text field.
     */
    size: PropTypes.oneOf(['medium', 'small']),

    /**
     * The variant to use.
     */
    variant: PropTypes.oneOf(['filled', 'outlined', 'standard'])
  } ;
  var FormControl$1 = withStyles(styles$c, {
    name: 'MuiFormControl'
  })(FormControl);

  var styles$b = function styles(theme) {
    return {
      /* Styles applied to the root element. */
      root: _extends$1({
        color: theme.palette.text.secondary
      }, theme.typography.caption, {
        textAlign: 'left',
        marginTop: 3,
        margin: 0,
        '&$disabled': {
          color: theme.palette.text.disabled
        },
        '&$error': {
          color: theme.palette.error.main
        }
      }),

      /* Pseudo-class applied to the root element if `error={true}`. */
      error: {},

      /* Pseudo-class applied to the root element if `disabled={true}`. */
      disabled: {},

      /* Styles applied to the root element if `margin="dense"`. */
      marginDense: {
        marginTop: 4
      },

      /* Styles applied to the root element if `variant="filled"` or `variant="outlined"`. */
      contained: {
        marginLeft: 14,
        marginRight: 14
      },

      /* Pseudo-class applied to the root element if `focused={true}`. */
      focused: {},

      /* Pseudo-class applied to the root element if `filled={true}`. */
      filled: {},

      /* Pseudo-class applied to the root element if `required={true}`. */
      required: {}
    };
  };
  var FormHelperText = /*#__PURE__*/React__namespace.forwardRef(function FormHelperText(props, ref) {
    var children = props.children,
        classes = props.classes,
        className = props.className,
        _props$component = props.component,
        Component = _props$component === void 0 ? 'p' : _props$component;
        props.disabled;
        props.error;
        props.filled;
        props.focused;
        props.margin;
        props.required;
        props.variant;
        var other = _objectWithoutProperties(props, ["children", "classes", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"]);

    var muiFormControl = useFormControl();
    var fcs = formControlState({
      props: props,
      muiFormControl: muiFormControl,
      states: ['variant', 'margin', 'disabled', 'error', 'filled', 'focused', 'required']
    });
    return /*#__PURE__*/React__namespace.createElement(Component, _extends$1({
      className: clsx(classes.root, (fcs.variant === 'filled' || fcs.variant === 'outlined') && classes.contained, className, fcs.disabled && classes.disabled, fcs.error && classes.error, fcs.filled && classes.filled, fcs.focused && classes.focused, fcs.required && classes.required, fcs.margin === 'dense' && classes.marginDense),
      ref: ref
    }, other), children === ' ' ?
    /*#__PURE__*/
    // eslint-disable-next-line react/no-danger
    React__namespace.createElement("span", {
      dangerouslySetInnerHTML: {
        __html: '&#8203;'
      }
    }) : children);
  });
  FormHelperText.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * The content of the component.
     *
     * If `' '` is provided, the component reserves one line height for displaying a future message.
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: PropTypes
    /* @typescript-to-proptypes-ignore */
    .elementType,

    /**
     * If `true`, the helper text should be displayed in a disabled state.
     */
    disabled: PropTypes.bool,

    /**
     * If `true`, helper text should be displayed in an error state.
     */
    error: PropTypes.bool,

    /**
     * If `true`, the helper text should use filled classes key.
     */
    filled: PropTypes.bool,

    /**
     * If `true`, the helper text should use focused classes key.
     */
    focused: PropTypes.bool,

    /**
     * If `dense`, will adjust vertical spacing. This is normally obtained via context from
     * FormControl.
     */
    margin: PropTypes.oneOf(['dense']),

    /**
     * If `true`, the helper text should use required classes key.
     */
    required: PropTypes.bool,

    /**
     * The variant to use.
     */
    variant: PropTypes.oneOf(['filled', 'outlined', 'standard'])
  } ;
  var FormHelperText$1 = withStyles(styles$b, {
    name: 'MuiFormHelperText'
  })(FormHelperText);

  // A change of the browser zoom change the scrollbar size.
  // Credit https://github.com/twbs/bootstrap/blob/3ffe3a5d82f6f561b82ff78d82b32a7d14aed558/js/src/modal.js#L512-L519
  function getScrollbarSize() {
    var scrollDiv = document.createElement('div');
    scrollDiv.style.width = '99px';
    scrollDiv.style.height = '99px';
    scrollDiv.style.position = 'absolute';
    scrollDiv.style.top = '-9999px';
    scrollDiv.style.overflow = 'scroll';
    document.body.appendChild(scrollDiv);
    var scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    return scrollbarSize;
  }

  function isOverflowing(container) {
    var doc = ownerDocument(container);

    if (doc.body === container) {
      return ownerWindow(doc).innerWidth > doc.documentElement.clientWidth;
    }

    return container.scrollHeight > container.clientHeight;
  }

  function ariaHidden(node, show) {
    if (show) {
      node.setAttribute('aria-hidden', 'true');
    } else {
      node.removeAttribute('aria-hidden');
    }
  }

  function getPaddingRight(node) {
    return parseInt(window.getComputedStyle(node)['padding-right'], 10) || 0;
  }

  function ariaHiddenSiblings(container, mountNode, currentNode) {
    var nodesToExclude = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    var show = arguments.length > 4 ? arguments[4] : undefined;
    var blacklist = [mountNode, currentNode].concat(_toConsumableArray(nodesToExclude));
    var blacklistTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE'];
    [].forEach.call(container.children, function (node) {
      if (node.nodeType === 1 && blacklist.indexOf(node) === -1 && blacklistTagNames.indexOf(node.tagName) === -1) {
        ariaHidden(node, show);
      }
    });
  }

  function findIndexOf(containerInfo, callback) {
    var idx = -1;
    containerInfo.some(function (item, index) {
      if (callback(item)) {
        idx = index;
        return true;
      }

      return false;
    });
    return idx;
  }

  function handleContainer(containerInfo, props) {
    var restoreStyle = [];
    var restorePaddings = [];
    var container = containerInfo.container;
    var fixedNodes;

    if (!props.disableScrollLock) {
      if (isOverflowing(container)) {
        // Compute the size before applying overflow hidden to avoid any scroll jumps.
        var scrollbarSize = getScrollbarSize();
        restoreStyle.push({
          value: container.style.paddingRight,
          key: 'padding-right',
          el: container
        }); // Use computed style, here to get the real padding to add our scrollbar width.

        container.style['padding-right'] = "".concat(getPaddingRight(container) + scrollbarSize, "px"); // .mui-fixed is a global helper.

        fixedNodes = ownerDocument(container).querySelectorAll('.mui-fixed');
        [].forEach.call(fixedNodes, function (node) {
          restorePaddings.push(node.style.paddingRight);
          node.style.paddingRight = "".concat(getPaddingRight(node) + scrollbarSize, "px");
        });
      } // Improve Gatsby support
      // https://css-tricks.com/snippets/css/force-vertical-scrollbar/


      var parent = container.parentElement;
      var scrollContainer = parent.nodeName === 'HTML' && window.getComputedStyle(parent)['overflow-y'] === 'scroll' ? parent : container; // Block the scroll even if no scrollbar is visible to account for mobile keyboard
      // screensize shrink.

      restoreStyle.push({
        value: scrollContainer.style.overflow,
        key: 'overflow',
        el: scrollContainer
      });
      scrollContainer.style.overflow = 'hidden';
    }

    var restore = function restore() {
      if (fixedNodes) {
        [].forEach.call(fixedNodes, function (node, i) {
          if (restorePaddings[i]) {
            node.style.paddingRight = restorePaddings[i];
          } else {
            node.style.removeProperty('padding-right');
          }
        });
      }

      restoreStyle.forEach(function (_ref) {
        var value = _ref.value,
            el = _ref.el,
            key = _ref.key;

        if (value) {
          el.style.setProperty(key, value);
        } else {
          el.style.removeProperty(key);
        }
      });
    };

    return restore;
  }

  function getHiddenSiblings(container) {
    var hiddenSiblings = [];
    [].forEach.call(container.children, function (node) {
      if (node.getAttribute && node.getAttribute('aria-hidden') === 'true') {
        hiddenSiblings.push(node);
      }
    });
    return hiddenSiblings;
  }
  /**
   * @ignore - do not document.
   *
   * Proper state management for containers and the modals in those containers.
   * Simplified, but inspired by react-overlay's ModalManager class.
   * Used by the Modal to ensure proper styling of containers.
   */


  var ModalManager = /*#__PURE__*/function () {
    function ModalManager() {
      _classCallCheck(this, ModalManager); // this.modals[modalIndex] = modal


      this.modals = []; // this.containers[containerIndex] = {
      //   modals: [],
      //   container,
      //   restore: null,
      // }

      this.containers = [];
    }

    _createClass(ModalManager, [{
      key: "add",
      value: function add(modal, container) {
        var modalIndex = this.modals.indexOf(modal);

        if (modalIndex !== -1) {
          return modalIndex;
        }

        modalIndex = this.modals.length;
        this.modals.push(modal); // If the modal we are adding is already in the DOM.

        if (modal.modalRef) {
          ariaHidden(modal.modalRef, false);
        }

        var hiddenSiblingNodes = getHiddenSiblings(container);
        ariaHiddenSiblings(container, modal.mountNode, modal.modalRef, hiddenSiblingNodes, true);
        var containerIndex = findIndexOf(this.containers, function (item) {
          return item.container === container;
        });

        if (containerIndex !== -1) {
          this.containers[containerIndex].modals.push(modal);
          return modalIndex;
        }

        this.containers.push({
          modals: [modal],
          container: container,
          restore: null,
          hiddenSiblingNodes: hiddenSiblingNodes
        });
        return modalIndex;
      }
    }, {
      key: "mount",
      value: function mount(modal, props) {
        var containerIndex = findIndexOf(this.containers, function (item) {
          return item.modals.indexOf(modal) !== -1;
        });
        var containerInfo = this.containers[containerIndex];

        if (!containerInfo.restore) {
          containerInfo.restore = handleContainer(containerInfo, props);
        }
      }
    }, {
      key: "remove",
      value: function remove(modal) {
        var modalIndex = this.modals.indexOf(modal);

        if (modalIndex === -1) {
          return modalIndex;
        }

        var containerIndex = findIndexOf(this.containers, function (item) {
          return item.modals.indexOf(modal) !== -1;
        });
        var containerInfo = this.containers[containerIndex];
        containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
        this.modals.splice(modalIndex, 1); // If that was the last modal in a container, clean up the container.

        if (containerInfo.modals.length === 0) {
          // The modal might be closed before it had the chance to be mounted in the DOM.
          if (containerInfo.restore) {
            containerInfo.restore();
          }

          if (modal.modalRef) {
            // In case the modal wasn't in the DOM yet.
            ariaHidden(modal.modalRef, true);
          }

          ariaHiddenSiblings(containerInfo.container, modal.mountNode, modal.modalRef, containerInfo.hiddenSiblingNodes, false);
          this.containers.splice(containerIndex, 1);
        } else {
          // Otherwise make sure the next top modal is visible to a screen reader.
          var nextTop = containerInfo.modals[containerInfo.modals.length - 1]; // as soon as a modal is adding its modalRef is undefined. it can't set
          // aria-hidden because the dom element doesn't exist either
          // when modal was unmounted before modalRef gets null

          if (nextTop.modalRef) {
            ariaHidden(nextTop.modalRef, false);
          }
        }

        return modalIndex;
      }
    }, {
      key: "isTopModal",
      value: function isTopModal(modal) {
        return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
      }
    }]);

    return ModalManager;
  }();

  /* eslint-disable consistent-return, jsx-a11y/no-noninteractive-tabindex, camelcase */
  /**
   * Utility component that locks focus inside the component.
   */

  function Unstable_TrapFocus(props) {
    var children = props.children,
        _props$disableAutoFoc = props.disableAutoFocus,
        disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc,
        _props$disableEnforce = props.disableEnforceFocus,
        disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce,
        _props$disableRestore = props.disableRestoreFocus,
        disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore,
        getDoc = props.getDoc,
        isEnabled = props.isEnabled,
        open = props.open;
    var ignoreNextEnforceFocus = React__namespace.useRef();
    var sentinelStart = React__namespace.useRef(null);
    var sentinelEnd = React__namespace.useRef(null);
    var nodeToRestore = React__namespace.useRef();
    var rootRef = React__namespace.useRef(null); // can be removed once we drop support for non ref forwarding class components

    var handleOwnRef = React__namespace.useCallback(function (instance) {
      // #StrictMode ready
      rootRef.current = ReactDOM__namespace.findDOMNode(instance);
    }, []);
    var handleRef = useForkRef(children.ref, handleOwnRef);
    var prevOpenRef = React__namespace.useRef();
    React__namespace.useEffect(function () {
      prevOpenRef.current = open;
    }, [open]);

    if (!prevOpenRef.current && open && typeof window !== 'undefined') {
      // WARNING: Potentially unsafe in concurrent mode.
      // The way the read on `nodeToRestore` is setup could make this actually safe.
      // Say we render `open={false}` -> `open={true}` but never commit.
      // We have now written a state that wasn't committed. But no committed effect
      // will read this wrong value. We only read from `nodeToRestore` in effects
      // that were committed on `open={true}`
      // WARNING: Prevents the instance from being garbage collected. Should only
      // hold a weak ref.
      nodeToRestore.current = getDoc().activeElement;
    }

    React__namespace.useEffect(function () {
      if (!open) {
        return;
      }

      var doc = ownerDocument(rootRef.current); // We might render an empty child.

      if (!disableAutoFocus && rootRef.current && !rootRef.current.contains(doc.activeElement)) {
        if (!rootRef.current.hasAttribute('tabIndex')) {
          {
            console.error(['Material-UI: The modal content node does not accept focus.', 'For the benefit of assistive technologies, ' + 'the tabIndex of the node is being set to "-1".'].join('\n'));
          }

          rootRef.current.setAttribute('tabIndex', -1);
        }

        rootRef.current.focus();
      }

      var contain = function contain() {
        var rootElement = rootRef.current; // Cleanup functions are executed lazily in React 17.
        // Contain can be called between the component being unmounted and its cleanup function being run.

        if (rootElement === null) {
          return;
        }

        if (!doc.hasFocus() || disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
          ignoreNextEnforceFocus.current = false;
          return;
        }

        if (rootRef.current && !rootRef.current.contains(doc.activeElement)) {
          rootRef.current.focus();
        }
      };

      var loopFocus = function loopFocus(event) {
        // 9 = Tab
        if (disableEnforceFocus || !isEnabled() || event.keyCode !== 9) {
          return;
        } // Make sure the next tab starts from the right place.


        if (doc.activeElement === rootRef.current) {
          // We need to ignore the next contain as
          // it will try to move the focus back to the rootRef element.
          ignoreNextEnforceFocus.current = true;

          if (event.shiftKey) {
            sentinelEnd.current.focus();
          } else {
            sentinelStart.current.focus();
          }
        }
      };

      doc.addEventListener('focus', contain, true);
      doc.addEventListener('keydown', loopFocus, true); // With Edge, Safari and Firefox, no focus related events are fired when the focused area stops being a focused area
      // e.g. https://bugzilla.mozilla.org/show_bug.cgi?id=559561.
      //
      // The whatwg spec defines how the browser should behave but does not explicitly mention any events:
      // https://html.spec.whatwg.org/multipage/interaction.html#focus-fixup-rule.

      var interval = setInterval(function () {
        contain();
      }, 50);
      return function () {
        clearInterval(interval);
        doc.removeEventListener('focus', contain, true);
        doc.removeEventListener('keydown', loopFocus, true); // restoreLastFocus()

        if (!disableRestoreFocus) {
          // In IE 11 it is possible for document.activeElement to be null resulting
          // in nodeToRestore.current being null.
          // Not all elements in IE 11 have a focus method.
          // Once IE 11 support is dropped the focus() call can be unconditional.
          if (nodeToRestore.current && nodeToRestore.current.focus) {
            nodeToRestore.current.focus();
          }

          nodeToRestore.current = null;
        }
      };
    }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open]);
    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement("div", {
      tabIndex: 0,
      ref: sentinelStart,
      "data-test": "sentinelStart"
    }), /*#__PURE__*/React__namespace.cloneElement(children, {
      ref: handleRef
    }), /*#__PURE__*/React__namespace.createElement("div", {
      tabIndex: 0,
      ref: sentinelEnd,
      "data-test": "sentinelEnd"
    }));
  }

  Unstable_TrapFocus.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * A single child content element.
     */
    children: PropTypes.node,

    /**
     * If `true`, the trap focus will not automatically shift focus to itself when it opens, and
     * replace it to the last focused element when it closes.
     * This also works correctly with any trap focus children that have the `disableAutoFocus` prop.
     *
     * Generally this should never be set to `true` as it makes the trap focus less
     * accessible to assistive technologies, like screen readers.
     */
    disableAutoFocus: PropTypes.bool,

    /**
     * If `true`, the trap focus will not prevent focus from leaving the trap focus while open.
     *
     * Generally this should never be set to `true` as it makes the trap focus less
     * accessible to assistive technologies, like screen readers.
     */
    disableEnforceFocus: PropTypes.bool,

    /**
     * If `true`, the trap focus will not restore focus to previously focused element once
     * trap focus is hidden.
     */
    disableRestoreFocus: PropTypes.bool,

    /**
     * Return the document to consider.
     * We use it to implement the restore focus between different browser documents.
     */
    getDoc: PropTypes.func.isRequired,

    /**
     * Do we still want to enforce the focus?
     * This prop helps nesting TrapFocus elements.
     */
    isEnabled: PropTypes.func.isRequired,

    /**
     * If `true`, focus will be locked.
     */
    open: PropTypes.bool.isRequired
  } ;

  {
    // eslint-disable-next-line
    Unstable_TrapFocus['propTypes' + ''] = exactProp(Unstable_TrapFocus.propTypes);
  }

  var styles$a = {
    /* Styles applied to the root element. */
    root: {
      zIndex: -1,
      position: 'fixed',
      right: 0,
      bottom: 0,
      top: 0,
      left: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      WebkitTapHighlightColor: 'transparent'
    },

    /* Styles applied to the root element if `invisible={true}`. */
    invisible: {
      backgroundColor: 'transparent'
    }
  };
  /**
   * @ignore - internal component.
   */

  var SimpleBackdrop = /*#__PURE__*/React__namespace.forwardRef(function SimpleBackdrop(props, ref) {
    var _props$invisible = props.invisible,
        invisible = _props$invisible === void 0 ? false : _props$invisible,
        open = props.open,
        other = _objectWithoutProperties(props, ["invisible", "open"]);

    return open ? /*#__PURE__*/React__namespace.createElement("div", _extends$1({
      "aria-hidden": true,
      ref: ref
    }, other, {
      style: _extends$1({}, styles$a.root, invisible ? styles$a.invisible : {}, other.style)
    })) : null;
  });
  SimpleBackdrop.propTypes = {
    /**
     * If `true`, the backdrop is invisible.
     * It can be used when rendering a popover or a custom select component.
     */
    invisible: PropTypes.bool,

    /**
     * If `true`, the backdrop is open.
     */
    open: PropTypes.bool.isRequired
  } ;
  var SimpleBackdrop$1 = SimpleBackdrop;

  function getContainer(container) {
    container = typeof container === 'function' ? container() : container;
    return ReactDOM__namespace.findDOMNode(container);
  }

  function getHasTransition(props) {
    return props.children ? props.children.props.hasOwnProperty('in') : false;
  } // A modal manager used to track and manage the state of open Modals.
  // Modals don't open on the server so this won't conflict with concurrent requests.


  var defaultManager = new ModalManager();
  var styles$9 = function styles(theme) {
    return {
      /* Styles applied to the root element. */
      root: {
        position: 'fixed',
        zIndex: theme.zIndex.modal,
        right: 0,
        bottom: 0,
        top: 0,
        left: 0
      },

      /* Styles applied to the root element if the `Modal` has exited. */
      hidden: {
        visibility: 'hidden'
      }
    };
  };
  /**
   * Modal is a lower-level construct that is leveraged by the following components:
   *
   * - [Dialog](/api/dialog/)
   * - [Drawer](/api/drawer/)
   * - [Menu](/api/menu/)
   * - [Popover](/api/popover/)
   *
   * If you are creating a modal dialog, you probably want to use the [Dialog](/api/dialog/) component
   * rather than directly using Modal.
   *
   * This component shares many concepts with [react-overlays](https://react-bootstrap.github.io/react-overlays/#modals).
   */

  var Modal = /*#__PURE__*/React__namespace.forwardRef(function Modal(inProps, ref) {
    var theme = useTheme$1();
    var props = getThemeProps({
      name: 'MuiModal',
      props: _extends$1({}, inProps),
      theme: theme
    });

    var _props$BackdropCompon = props.BackdropComponent,
        BackdropComponent = _props$BackdropCompon === void 0 ? SimpleBackdrop$1 : _props$BackdropCompon,
        BackdropProps = props.BackdropProps,
        children = props.children,
        _props$closeAfterTran = props.closeAfterTransition,
        closeAfterTransition = _props$closeAfterTran === void 0 ? false : _props$closeAfterTran,
        container = props.container,
        _props$disableAutoFoc = props.disableAutoFocus,
        disableAutoFocus = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc,
        _props$disableBackdro = props.disableBackdropClick,
        disableBackdropClick = _props$disableBackdro === void 0 ? false : _props$disableBackdro,
        _props$disableEnforce = props.disableEnforceFocus,
        disableEnforceFocus = _props$disableEnforce === void 0 ? false : _props$disableEnforce,
        _props$disableEscapeK = props.disableEscapeKeyDown,
        disableEscapeKeyDown = _props$disableEscapeK === void 0 ? false : _props$disableEscapeK,
        _props$disablePortal = props.disablePortal,
        disablePortal = _props$disablePortal === void 0 ? false : _props$disablePortal,
        _props$disableRestore = props.disableRestoreFocus,
        disableRestoreFocus = _props$disableRestore === void 0 ? false : _props$disableRestore,
        _props$disableScrollL = props.disableScrollLock,
        disableScrollLock = _props$disableScrollL === void 0 ? false : _props$disableScrollL,
        _props$hideBackdrop = props.hideBackdrop,
        hideBackdrop = _props$hideBackdrop === void 0 ? false : _props$hideBackdrop,
        _props$keepMounted = props.keepMounted,
        keepMounted = _props$keepMounted === void 0 ? false : _props$keepMounted,
        _props$manager = props.manager,
        manager = _props$manager === void 0 ? defaultManager : _props$manager,
        onBackdropClick = props.onBackdropClick,
        onClose = props.onClose,
        onEscapeKeyDown = props.onEscapeKeyDown,
        onRendered = props.onRendered,
        open = props.open,
        other = _objectWithoutProperties(props, ["BackdropComponent", "BackdropProps", "children", "closeAfterTransition", "container", "disableAutoFocus", "disableBackdropClick", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onEscapeKeyDown", "onRendered", "open"]);

    var _React$useState = React__namespace.useState(true),
        exited = _React$useState[0],
        setExited = _React$useState[1];

    var modal = React__namespace.useRef({});
    var mountNodeRef = React__namespace.useRef(null);
    var modalRef = React__namespace.useRef(null);
    var handleRef = useForkRef(modalRef, ref);
    var hasTransition = getHasTransition(props);

    var getDoc = function getDoc() {
      return ownerDocument(mountNodeRef.current);
    };

    var getModal = function getModal() {
      modal.current.modalRef = modalRef.current;
      modal.current.mountNode = mountNodeRef.current;
      return modal.current;
    };

    var handleMounted = function handleMounted() {
      manager.mount(getModal(), {
        disableScrollLock: disableScrollLock
      }); // Fix a bug on Chrome where the scroll isn't initially 0.

      modalRef.current.scrollTop = 0;
    };

    var handleOpen = useEventCallback(function () {
      var resolvedContainer = getContainer(container) || getDoc().body;
      manager.add(getModal(), resolvedContainer); // The element was already mounted.

      if (modalRef.current) {
        handleMounted();
      }
    });
    var isTopModal = React__namespace.useCallback(function () {
      return manager.isTopModal(getModal());
    }, [manager]);
    var handlePortalRef = useEventCallback(function (node) {
      mountNodeRef.current = node;

      if (!node) {
        return;
      }

      if (onRendered) {
        onRendered();
      }

      if (open && isTopModal()) {
        handleMounted();
      } else {
        ariaHidden(modalRef.current, true);
      }
    });
    var handleClose = React__namespace.useCallback(function () {
      manager.remove(getModal());
    }, [manager]);
    React__namespace.useEffect(function () {
      return function () {
        handleClose();
      };
    }, [handleClose]);
    React__namespace.useEffect(function () {
      if (open) {
        handleOpen();
      } else if (!hasTransition || !closeAfterTransition) {
        handleClose();
      }
    }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);

    if (!keepMounted && !open && (!hasTransition || exited)) {
      return null;
    }

    var handleEnter = function handleEnter() {
      setExited(false);
    };

    var handleExited = function handleExited() {
      setExited(true);

      if (closeAfterTransition) {
        handleClose();
      }
    };

    var handleBackdropClick = function handleBackdropClick(event) {
      if (event.target !== event.currentTarget) {
        return;
      }

      if (onBackdropClick) {
        onBackdropClick(event);
      }

      if (!disableBackdropClick && onClose) {
        onClose(event, 'backdropClick');
      }
    };

    var handleKeyDown = function handleKeyDown(event) {
      // The handler doesn't take event.defaultPrevented into account:
      //
      // event.preventDefault() is meant to stop default behaviours like
      // clicking a checkbox to check it, hitting a button to submit a form,
      // and hitting left arrow to move the cursor in a text input etc.
      // Only special HTML elements have these default behaviors.
      if (event.key !== 'Escape' || !isTopModal()) {
        return;
      }

      if (onEscapeKeyDown) {
        onEscapeKeyDown(event);
      }

      if (!disableEscapeKeyDown) {
        // Swallow the event, in case someone is listening for the escape key on the body.
        event.stopPropagation();

        if (onClose) {
          onClose(event, 'escapeKeyDown');
        }
      }
    };

    var inlineStyle = styles$9(theme || {
      zIndex: zIndex$1
    });
    var childProps = {};

    if (children.props.tabIndex === undefined) {
      childProps.tabIndex = children.props.tabIndex || '-1';
    } // It's a Transition like component


    if (hasTransition) {
      childProps.onEnter = createChainedFunction(handleEnter, children.props.onEnter);
      childProps.onExited = createChainedFunction(handleExited, children.props.onExited);
    }

    return /*#__PURE__*/React__namespace.createElement(Portal$1, {
      ref: handlePortalRef,
      container: container,
      disablePortal: disablePortal
    }, /*#__PURE__*/React__namespace.createElement("div", _extends$1({
      ref: handleRef,
      onKeyDown: handleKeyDown,
      role: "presentation"
    }, other, {
      style: _extends$1({}, inlineStyle.root, !open && exited ? inlineStyle.hidden : {}, other.style)
    }), hideBackdrop ? null : /*#__PURE__*/React__namespace.createElement(BackdropComponent, _extends$1({
      open: open,
      onClick: handleBackdropClick
    }, BackdropProps)), /*#__PURE__*/React__namespace.createElement(Unstable_TrapFocus, {
      disableEnforceFocus: disableEnforceFocus,
      disableAutoFocus: disableAutoFocus,
      disableRestoreFocus: disableRestoreFocus,
      getDoc: getDoc,
      isEnabled: isTopModal,
      open: open
    }, /*#__PURE__*/React__namespace.cloneElement(children, childProps))));
  });
  Modal.propTypes = {
    /**
     * A backdrop component. This prop enables custom backdrop rendering.
     */
    BackdropComponent: PropTypes.elementType,

    /**
     * Props applied to the [`Backdrop`](/api/backdrop/) element.
     */
    BackdropProps: PropTypes.object,

    /**
     * A single child content element.
     */
    children: elementAcceptingRef$1.isRequired,

    /**
     * When set to true the Modal waits until a nested Transition is completed before closing.
     */
    closeAfterTransition: PropTypes.bool,

    /**
     * A HTML element, component instance, or function that returns either.
     * The `container` will have the portal children appended to it.
     *
     * By default, it uses the body of the top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: PropTypes
    /* @typescript-to-proptypes-ignore */
    .oneOfType([HTMLElementType, PropTypes.instanceOf(React__namespace.Component), PropTypes.func]),

    /**
     * If `true`, the modal will not automatically shift focus to itself when it opens, and
     * replace it to the last focused element when it closes.
     * This also works correctly with any modal children that have the `disableAutoFocus` prop.
     *
     * Generally this should never be set to `true` as it makes the modal less
     * accessible to assistive technologies, like screen readers.
     */
    disableAutoFocus: PropTypes.bool,

    /**
     * If `true`, clicking the backdrop will not fire `onClose`.
     */
    disableBackdropClick: deprecatedPropType(PropTypes.bool, 'Use the onClose prop with the `reason` argument to filter the `backdropClick` events.'),

    /**
     * If `true`, the modal will not prevent focus from leaving the modal while open.
     *
     * Generally this should never be set to `true` as it makes the modal less
     * accessible to assistive technologies, like screen readers.
     */
    disableEnforceFocus: PropTypes.bool,

    /**
     * If `true`, hitting escape will not fire `onClose`.
     */
    disableEscapeKeyDown: PropTypes.bool,

    /**
     * Disable the portal behavior.
     * The children stay within it's parent DOM hierarchy.
     */
    disablePortal: PropTypes.bool,

    /**
     * If `true`, the modal will not restore focus to previously focused element once
     * modal is hidden.
     */
    disableRestoreFocus: PropTypes.bool,

    /**
     * Disable the scroll lock behavior.
     */
    disableScrollLock: PropTypes.bool,

    /**
     * If `true`, the backdrop is not rendered.
     */
    hideBackdrop: PropTypes.bool,

    /**
     * Always keep the children in the DOM.
     * This prop can be useful in SEO situation or
     * when you want to maximize the responsiveness of the Modal.
     */
    keepMounted: PropTypes.bool,

    /**
     * @ignore
     */
    manager: PropTypes.object,

    /**
     * Callback fired when the backdrop is clicked.
     */
    onBackdropClick: deprecatedPropType(PropTypes.func, 'Use the onClose prop with the `reason` argument to handle the `backdropClick` events.'),

    /**
     * Callback fired when the component requests to be closed.
     * The `reason` parameter can optionally be used to control the response to `onClose`.
     *
     * @param {object} event The event source of the callback.
     * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
     */
    onClose: PropTypes.func,

    /**
     * Callback fired when the escape key is pressed,
     * `disableEscapeKeyDown` is false and the modal is in focus.
     */
    onEscapeKeyDown: deprecatedPropType(PropTypes.func, 'Use the onClose prop with the `reason` argument to handle the `escapeKeyDown` events.'),

    /**
     * Callback fired once the children has been mounted into the `container`.
     * It signals that the `open={true}` prop took effect.
     *
     * This prop will be removed in v5, the ref can be used instead.
     */
    onRendered: deprecatedPropType(PropTypes.func, 'Use the ref instead.'),

    /**
     * If `true`, the modal is open.
     */
    open: PropTypes.bool.isRequired
  } ;
  var Modal$1 = Modal;

  var reflow = function reflow(node) {
    return node.scrollTop;
  };
  function getTransitionProps(props, options) {
    var timeout = props.timeout,
        _props$style = props.style,
        style = _props$style === void 0 ? {} : _props$style;
    return {
      duration: style.transitionDuration || typeof timeout === 'number' ? timeout : timeout[options.mode] || 0,
      delay: style.transitionDelay
    };
  }

  function getScale(value) {
    return "scale(".concat(value, ", ").concat(Math.pow(value, 2), ")");
  }

  var styles$8 = {
    entering: {
      opacity: 1,
      transform: getScale(1)
    },
    entered: {
      opacity: 1,
      transform: 'none'
    }
  };
  /**
   * The Grow transition is used by the [Tooltip](/components/tooltips/) and
   * [Popover](/components/popover/) components.
   * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
   */

  var Grow = /*#__PURE__*/React__namespace.forwardRef(function Grow(props, ref) {
    var children = props.children,
        _props$disableStrictM = props.disableStrictModeCompat,
        disableStrictModeCompat = _props$disableStrictM === void 0 ? false : _props$disableStrictM,
        inProp = props.in,
        onEnter = props.onEnter,
        onEntered = props.onEntered,
        onEntering = props.onEntering,
        onExit = props.onExit,
        onExited = props.onExited,
        onExiting = props.onExiting,
        style = props.style,
        _props$timeout = props.timeout,
        timeout = _props$timeout === void 0 ? 'auto' : _props$timeout,
        _props$TransitionComp = props.TransitionComponent,
        TransitionComponent = _props$TransitionComp === void 0 ? Transition$1 : _props$TransitionComp,
        other = _objectWithoutProperties(props, ["children", "disableStrictModeCompat", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"]);

    var timer = React__namespace.useRef();
    var autoTimeout = React__namespace.useRef();
    var theme = useTheme();
    var enableStrictModeCompat = theme.unstable_strictMode && !disableStrictModeCompat;
    var nodeRef = React__namespace.useRef(null);
    var foreignRef = useForkRef(children.ref, ref);
    var handleRef = useForkRef(enableStrictModeCompat ? nodeRef : undefined, foreignRef);

    var normalizedTransitionCallback = function normalizedTransitionCallback(callback) {
      return function (nodeOrAppearing, maybeAppearing) {
        if (callback) {
          var _ref = enableStrictModeCompat ? [nodeRef.current, nodeOrAppearing] : [nodeOrAppearing, maybeAppearing],
              _ref2 = _slicedToArray(_ref, 2),
              node = _ref2[0],
              isAppearing = _ref2[1]; // onEnterXxx and onExitXxx callbacks have a different arguments.length value.


          if (isAppearing === undefined) {
            callback(node);
          } else {
            callback(node, isAppearing);
          }
        }
      };
    };

    var handleEntering = normalizedTransitionCallback(onEntering);
    var handleEnter = normalizedTransitionCallback(function (node, isAppearing) {
      reflow(node); // So the animation always start from the start.

      var _getTransitionProps = getTransitionProps({
        style: style,
        timeout: timeout
      }, {
        mode: 'enter'
      }),
          transitionDuration = _getTransitionProps.duration,
          delay = _getTransitionProps.delay;

      var duration;

      if (timeout === 'auto') {
        duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
        autoTimeout.current = duration;
      } else {
        duration = transitionDuration;
      }

      node.style.transition = [theme.transitions.create('opacity', {
        duration: duration,
        delay: delay
      }), theme.transitions.create('transform', {
        duration: duration * 0.666,
        delay: delay
      })].join(',');

      if (onEnter) {
        onEnter(node, isAppearing);
      }
    });
    var handleEntered = normalizedTransitionCallback(onEntered);
    var handleExiting = normalizedTransitionCallback(onExiting);
    var handleExit = normalizedTransitionCallback(function (node) {
      var _getTransitionProps2 = getTransitionProps({
        style: style,
        timeout: timeout
      }, {
        mode: 'exit'
      }),
          transitionDuration = _getTransitionProps2.duration,
          delay = _getTransitionProps2.delay;

      var duration;

      if (timeout === 'auto') {
        duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
        autoTimeout.current = duration;
      } else {
        duration = transitionDuration;
      }

      node.style.transition = [theme.transitions.create('opacity', {
        duration: duration,
        delay: delay
      }), theme.transitions.create('transform', {
        duration: duration * 0.666,
        delay: delay || duration * 0.333
      })].join(',');
      node.style.opacity = '0';
      node.style.transform = getScale(0.75);

      if (onExit) {
        onExit(node);
      }
    });
    var handleExited = normalizedTransitionCallback(onExited);

    var addEndListener = function addEndListener(nodeOrNext, maybeNext) {
      var next = enableStrictModeCompat ? nodeOrNext : maybeNext;

      if (timeout === 'auto') {
        timer.current = setTimeout(next, autoTimeout.current || 0);
      }
    };

    React__namespace.useEffect(function () {
      return function () {
        clearTimeout(timer.current);
      };
    }, []);
    return /*#__PURE__*/React__namespace.createElement(TransitionComponent, _extends$1({
      appear: true,
      in: inProp,
      nodeRef: enableStrictModeCompat ? nodeRef : undefined,
      onEnter: handleEnter,
      onEntered: handleEntered,
      onEntering: handleEntering,
      onExit: handleExit,
      onExited: handleExited,
      onExiting: handleExiting,
      addEndListener: addEndListener,
      timeout: timeout === 'auto' ? null : timeout
    }, other), function (state, childProps) {
      return /*#__PURE__*/React__namespace.cloneElement(children, _extends$1({
        style: _extends$1({
          opacity: 0,
          transform: getScale(0.75),
          visibility: state === 'exited' && !inProp ? 'hidden' : undefined
        }, styles$8[state], style, children.props.style),
        ref: handleRef
      }, childProps));
    });
  });
  Grow.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * A single child content element.
     */
    children: PropTypes.element,

    /**
     * Enable this prop if you encounter 'Function components cannot be given refs',
     * use `unstable_createStrictModeTheme`,
     * and can't forward the ref in the child component.
     */
    disableStrictModeCompat: PropTypes.bool,

    /**
     * If `true`, show the component; triggers the enter or exit animation.
     */
    in: PropTypes.bool,

    /**
     * @ignore
     */
    onEnter: PropTypes.func,

    /**
     * @ignore
     */
    onEntered: PropTypes.func,

    /**
     * @ignore
     */
    onEntering: PropTypes.func,

    /**
     * @ignore
     */
    onExit: PropTypes.func,

    /**
     * @ignore
     */
    onExited: PropTypes.func,

    /**
     * @ignore
     */
    onExiting: PropTypes.func,

    /**
     * @ignore
     */
    style: PropTypes.object,

    /**
     * The duration for the transition, in milliseconds.
     * You may specify a single timeout for all transitions, or individually with an object.
     *
     * Set to 'auto' to automatically calculate transition time based on height.
     */
    timeout: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number, PropTypes.shape({
      appear: PropTypes.number,
      enter: PropTypes.number,
      exit: PropTypes.number
    })])
  } ;
  Grow.muiSupportAuto = true;
  var Grow$1 = Grow;

  function getOffsetTop(rect, vertical) {
    var offset = 0;

    if (typeof vertical === 'number') {
      offset = vertical;
    } else if (vertical === 'center') {
      offset = rect.height / 2;
    } else if (vertical === 'bottom') {
      offset = rect.height;
    }

    return offset;
  }
  function getOffsetLeft(rect, horizontal) {
    var offset = 0;

    if (typeof horizontal === 'number') {
      offset = horizontal;
    } else if (horizontal === 'center') {
      offset = rect.width / 2;
    } else if (horizontal === 'right') {
      offset = rect.width;
    }

    return offset;
  }

  function getTransformOriginValue(transformOrigin) {
    return [transformOrigin.horizontal, transformOrigin.vertical].map(function (n) {
      return typeof n === 'number' ? "".concat(n, "px") : n;
    }).join(' ');
  } // Sum the scrollTop between two elements.


  function getScrollParent(parent, child) {
    var element = child;
    var scrollTop = 0;

    while (element && element !== parent) {
      element = element.parentElement;
      scrollTop += element.scrollTop;
    }

    return scrollTop;
  }

  function getAnchorEl(anchorEl) {
    return typeof anchorEl === 'function' ? anchorEl() : anchorEl;
  }

  var styles$7 = {
    /* Styles applied to the root element. */
    root: {},

    /* Styles applied to the `Paper` component. */
    paper: {
      position: 'absolute',
      overflowY: 'auto',
      overflowX: 'hidden',
      // So we see the popover when it's empty.
      // It's most likely on issue on userland.
      minWidth: 16,
      minHeight: 16,
      maxWidth: 'calc(100% - 32px)',
      maxHeight: 'calc(100% - 32px)',
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0
    }
  };
  var Popover = /*#__PURE__*/React__namespace.forwardRef(function Popover(props, ref) {
    var action = props.action,
        anchorEl = props.anchorEl,
        _props$anchorOrigin = props.anchorOrigin,
        anchorOrigin = _props$anchorOrigin === void 0 ? {
      vertical: 'top',
      horizontal: 'left'
    } : _props$anchorOrigin,
        anchorPosition = props.anchorPosition,
        _props$anchorReferenc = props.anchorReference,
        anchorReference = _props$anchorReferenc === void 0 ? 'anchorEl' : _props$anchorReferenc,
        children = props.children,
        classes = props.classes,
        className = props.className,
        containerProp = props.container,
        _props$elevation = props.elevation,
        elevation = _props$elevation === void 0 ? 8 : _props$elevation,
        getContentAnchorEl = props.getContentAnchorEl,
        _props$marginThreshol = props.marginThreshold,
        marginThreshold = _props$marginThreshol === void 0 ? 16 : _props$marginThreshol,
        onEnter = props.onEnter,
        onEntered = props.onEntered,
        onEntering = props.onEntering,
        onExit = props.onExit,
        onExited = props.onExited,
        onExiting = props.onExiting,
        open = props.open,
        _props$PaperProps = props.PaperProps,
        PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps,
        _props$transformOrigi = props.transformOrigin,
        transformOrigin = _props$transformOrigi === void 0 ? {
      vertical: 'top',
      horizontal: 'left'
    } : _props$transformOrigi,
        _props$TransitionComp = props.TransitionComponent,
        TransitionComponent = _props$TransitionComp === void 0 ? Grow$1 : _props$TransitionComp,
        _props$transitionDura = props.transitionDuration,
        transitionDurationProp = _props$transitionDura === void 0 ? 'auto' : _props$transitionDura,
        _props$TransitionProp = props.TransitionProps,
        TransitionProps = _props$TransitionProp === void 0 ? {} : _props$TransitionProp,
        other = _objectWithoutProperties(props, ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "classes", "className", "container", "elevation", "getContentAnchorEl", "marginThreshold", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "open", "PaperProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps"]);

    var paperRef = React__namespace.useRef(); // Returns the top/left offset of the position
    // to attach to on the anchor element (or body if none is provided)

    var getAnchorOffset = React__namespace.useCallback(function (contentAnchorOffset) {
      if (anchorReference === 'anchorPosition') {
        {
          if (!anchorPosition) {
            console.error('Material-UI: You need to provide a `anchorPosition` prop when using ' + '<Popover anchorReference="anchorPosition" />.');
          }
        }

        return anchorPosition;
      }

      var resolvedAnchorEl = getAnchorEl(anchorEl); // If an anchor element wasn't provided, just use the parent body element of this Popover

      var anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
      var anchorRect = anchorElement.getBoundingClientRect();

      {
        var box = anchorElement.getBoundingClientRect();

        if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          console.warn(['Material-UI: The `anchorEl` prop provided to the component is invalid.', 'The anchor element should be part of the document layout.', "Make sure the element is present in the document or that it's not display none."].join('\n'));
        }
      }

      var anchorVertical = contentAnchorOffset === 0 ? anchorOrigin.vertical : 'center';
      return {
        top: anchorRect.top + getOffsetTop(anchorRect, anchorVertical),
        left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
      };
    }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]); // Returns the vertical offset of inner content to anchor the transform on if provided

    var getContentAnchorOffset = React__namespace.useCallback(function (element) {
      var contentAnchorOffset = 0;

      if (getContentAnchorEl && anchorReference === 'anchorEl') {
        var contentAnchorEl = getContentAnchorEl(element);

        if (contentAnchorEl && element.contains(contentAnchorEl)) {
          var scrollTop = getScrollParent(element, contentAnchorEl);
          contentAnchorOffset = contentAnchorEl.offsetTop + contentAnchorEl.clientHeight / 2 - scrollTop || 0;
        } // != the default value


        {
          if (anchorOrigin.vertical !== 'top') {
            console.error(['Material-UI: You can not change the default `anchorOrigin.vertical` value ', 'when also providing the `getContentAnchorEl` prop to the popover component.', 'Only use one of the two props.', 'Set `getContentAnchorEl` to `null | undefined`' + ' or leave `anchorOrigin.vertical` unchanged.'].join('\n'));
          }
        }
      }

      return contentAnchorOffset;
    }, [anchorOrigin.vertical, anchorReference, getContentAnchorEl]); // Return the base transform origin using the element
    // and taking the content anchor offset into account if in use

    var getTransformOrigin = React__namespace.useCallback(function (elemRect) {
      var contentAnchorOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return {
        vertical: getOffsetTop(elemRect, transformOrigin.vertical) + contentAnchorOffset,
        horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
      };
    }, [transformOrigin.horizontal, transformOrigin.vertical]);
    var getPositioningStyle = React__namespace.useCallback(function (element) {
      // Check if the parent has requested anchoring on an inner content node
      var contentAnchorOffset = getContentAnchorOffset(element);
      var elemRect = {
        width: element.offsetWidth,
        height: element.offsetHeight
      }; // Get the transform origin point on the element itself

      var elemTransformOrigin = getTransformOrigin(elemRect, contentAnchorOffset);

      if (anchorReference === 'none') {
        return {
          top: null,
          left: null,
          transformOrigin: getTransformOriginValue(elemTransformOrigin)
        };
      } // Get the offset of of the anchoring element


      var anchorOffset = getAnchorOffset(contentAnchorOffset); // Calculate element positioning

      var top = anchorOffset.top - elemTransformOrigin.vertical;
      var left = anchorOffset.left - elemTransformOrigin.horizontal;
      var bottom = top + elemRect.height;
      var right = left + elemRect.width; // Use the parent window of the anchorEl if provided

      var containerWindow = ownerWindow(getAnchorEl(anchorEl)); // Window thresholds taking required margin into account

      var heightThreshold = containerWindow.innerHeight - marginThreshold;
      var widthThreshold = containerWindow.innerWidth - marginThreshold; // Check if the vertical axis needs shifting

      if (top < marginThreshold) {
        var diff = top - marginThreshold;
        top -= diff;
        elemTransformOrigin.vertical += diff;
      } else if (bottom > heightThreshold) {
        var _diff = bottom - heightThreshold;

        top -= _diff;
        elemTransformOrigin.vertical += _diff;
      }

      {
        if (elemRect.height > heightThreshold && elemRect.height && heightThreshold) {
          console.error(['Material-UI: The popover component is too tall.', "Some part of it can not be seen on the screen (".concat(elemRect.height - heightThreshold, "px)."), 'Please consider adding a `max-height` to improve the user-experience.'].join('\n'));
        }
      } // Check if the horizontal axis needs shifting


      if (left < marginThreshold) {
        var _diff2 = left - marginThreshold;

        left -= _diff2;
        elemTransformOrigin.horizontal += _diff2;
      } else if (right > widthThreshold) {
        var _diff3 = right - widthThreshold;

        left -= _diff3;
        elemTransformOrigin.horizontal += _diff3;
      }

      return {
        top: "".concat(Math.round(top), "px"),
        left: "".concat(Math.round(left), "px"),
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }, [anchorEl, anchorReference, getAnchorOffset, getContentAnchorOffset, getTransformOrigin, marginThreshold]);
    var setPositioningStyles = React__namespace.useCallback(function () {
      var element = paperRef.current;

      if (!element) {
        return;
      }

      var positioning = getPositioningStyle(element);

      if (positioning.top !== null) {
        element.style.top = positioning.top;
      }

      if (positioning.left !== null) {
        element.style.left = positioning.left;
      }

      element.style.transformOrigin = positioning.transformOrigin;
    }, [getPositioningStyle]);

    var handleEntering = function handleEntering(element, isAppearing) {
      if (onEntering) {
        onEntering(element, isAppearing);
      }

      setPositioningStyles();
    };

    var handlePaperRef = React__namespace.useCallback(function (instance) {
      // #StrictMode ready
      paperRef.current = ReactDOM__namespace.findDOMNode(instance);
    }, []);
    React__namespace.useEffect(function () {
      if (open) {
        setPositioningStyles();
      }
    });
    React__namespace.useImperativeHandle(action, function () {
      return open ? {
        updatePosition: function updatePosition() {
          setPositioningStyles();
        }
      } : null;
    }, [open, setPositioningStyles]);
    React__namespace.useEffect(function () {
      if (!open) {
        return undefined;
      }

      var handleResize = debounce(function () {
        setPositioningStyles();
      });
      window.addEventListener('resize', handleResize);
      return function () {
        handleResize.clear();
        window.removeEventListener('resize', handleResize);
      };
    }, [open, setPositioningStyles]);
    var transitionDuration = transitionDurationProp;

    if (transitionDurationProp === 'auto' && !TransitionComponent.muiSupportAuto) {
      transitionDuration = undefined;
    } // If the container prop is provided, use that
    // If the anchorEl prop is provided, use its parent body element as the container
    // If neither are provided let the Modal take care of choosing the container


    var container = containerProp || (anchorEl ? ownerDocument(getAnchorEl(anchorEl)).body : undefined);
    return /*#__PURE__*/React__namespace.createElement(Modal$1, _extends$1({
      container: container,
      open: open,
      ref: ref,
      BackdropProps: {
        invisible: true
      },
      className: clsx(classes.root, className)
    }, other), /*#__PURE__*/React__namespace.createElement(TransitionComponent, _extends$1({
      appear: true,
      in: open,
      onEnter: onEnter,
      onEntered: onEntered,
      onExit: onExit,
      onExited: onExited,
      onExiting: onExiting,
      timeout: transitionDuration
    }, TransitionProps, {
      onEntering: createChainedFunction(handleEntering, TransitionProps.onEntering)
    }), /*#__PURE__*/React__namespace.createElement(Paper$1, _extends$1({
      elevation: elevation,
      ref: handlePaperRef
    }, PaperProps, {
      className: clsx(classes.paper, PaperProps.className)
    }), children)));
  });
  Popover.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * A ref for imperative actions.
     * It currently only supports updatePosition() action.
     */
    action: refType$1,

    /**
     * A HTML element, or a function that returns it.
     * It's used to set the position of the popover.
     */
    anchorEl: chainPropTypes(PropTypes.oneOfType([HTMLElementType, PropTypes.func]), function (props) {
      if (props.open && (!props.anchorReference || props.anchorReference === 'anchorEl')) {
        var resolvedAnchorEl = getAnchorEl(props.anchorEl);

        if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
          var box = resolvedAnchorEl.getBoundingClientRect();

          if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
            return new Error(['Material-UI: The `anchorEl` prop provided to the component is invalid.', 'The anchor element should be part of the document layout.', "Make sure the element is present in the document or that it's not display none."].join('\n'));
          }
        } else {
          return new Error(['Material-UI: The `anchorEl` prop provided to the component is invalid.', "It should be an Element instance but it's `".concat(resolvedAnchorEl, "` instead.")].join('\n'));
        }
      }

      return null;
    }),

    /**
     * This is the point on the anchor where the popover's
     * `anchorEl` will attach to. This is not used when the
     * anchorReference is 'anchorPosition'.
     *
     * Options:
     * vertical: [top, center, bottom];
     * horizontal: [left, center, right].
     */
    anchorOrigin: PropTypes.shape({
      horizontal: PropTypes.oneOfType([PropTypes.oneOf(['center', 'left', 'right']), PropTypes.number]).isRequired,
      vertical: PropTypes.oneOfType([PropTypes.oneOf(['bottom', 'center', 'top']), PropTypes.number]).isRequired
    }),

    /**
     * This is the position that may be used
     * to set the position of the popover.
     * The coordinates are relative to
     * the application's client area.
     */
    anchorPosition: PropTypes.shape({
      left: PropTypes.number.isRequired,
      top: PropTypes.number.isRequired
    }),

    /**
     * This determines which anchor prop to refer to to set
     * the position of the popover.
     */
    anchorReference: PropTypes.oneOf(['anchorEl', 'anchorPosition', 'none']),

    /**
     * The content of the component.
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * A HTML element, component instance, or function that returns either.
     * The `container` will passed to the Modal component.
     *
     * By default, it uses the body of the anchorEl's top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: PropTypes
    /* @typescript-to-proptypes-ignore */
    .oneOfType([HTMLElementType, PropTypes.instanceOf(React__namespace.Component), PropTypes.func]),

    /**
     * The elevation of the popover.
     */
    elevation: PropTypes.number,

    /**
     * This function is called in order to retrieve the content anchor element.
     * It's the opposite of the `anchorEl` prop.
     * The content anchor element should be an element inside the popover.
     * It's used to correctly scroll and set the position of the popover.
     * The positioning strategy tries to make the content anchor element just above the
     * anchor element.
     */
    getContentAnchorEl: PropTypes.func,

    /**
     * Specifies how close to the edge of the window the popover can appear.
     */
    marginThreshold: PropTypes.number,

    /**
     * Callback fired when the component requests to be closed.
     */
    onClose: PropTypes.func,

    /**
     * Callback fired before the component is entering.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onEnter: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

    /**
     * Callback fired when the component has entered.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onEntered: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

    /**
     * Callback fired when the component is entering.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onEntering: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

    /**
     * Callback fired before the component is exiting.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onExit: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

    /**
     * Callback fired when the component has exited.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onExited: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

    /**
     * Callback fired when the component is exiting.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onExiting: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

    /**
     * If `true`, the popover is visible.
     */
    open: PropTypes.bool.isRequired,

    /**
     * Props applied to the [`Paper`](/api/paper/) element.
     */
    PaperProps: PropTypes
    /* @typescript-to-proptypes-ignore */
    .shape({
      component: elementTypeAcceptingRef$1
    }),

    /**
     * This is the point on the popover which
     * will attach to the anchor's origin.
     *
     * Options:
     * vertical: [top, center, bottom, x(px)];
     * horizontal: [left, center, right, x(px)].
     */
    transformOrigin: PropTypes.shape({
      horizontal: PropTypes.oneOfType([PropTypes.oneOf(['center', 'left', 'right']), PropTypes.number]).isRequired,
      vertical: PropTypes.oneOfType([PropTypes.oneOf(['bottom', 'center', 'top']), PropTypes.number]).isRequired
    }),

    /**
     * The component used for the transition.
     * [Follow this guide](/components/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
     */
    TransitionComponent: PropTypes.elementType,

    /**
     * Set to 'auto' to automatically calculate transition time based on height.
     */
    transitionDuration: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number, PropTypes.shape({
      appear: PropTypes.number,
      enter: PropTypes.number,
      exit: PropTypes.number
    })]),

    /**
     * Props applied to the [`Transition`](http://reactcommunity.org/react-transition-group/transition#Transition-props) element.
     */
    TransitionProps: PropTypes.object
  } ;
  var Popover$1 = withStyles(styles$7, {
    name: 'MuiPopover'
  })(Popover);

  /**
   * @ignore - internal component.
   */

  var ListContext = React__namespace.createContext({});

  {
    ListContext.displayName = 'ListContext';
  }

  var ListContext$1 = ListContext;

  var styles$6 = {
    /* Styles applied to the root element. */
    root: {
      listStyle: 'none',
      margin: 0,
      padding: 0,
      position: 'relative'
    },

    /* Styles applied to the root element if `disablePadding={false}`. */
    padding: {
      paddingTop: 8,
      paddingBottom: 8
    },

    /* Styles applied to the root element if dense. */
    dense: {},

    /* Styles applied to the root element if a `subheader` is provided. */
    subheader: {
      paddingTop: 0
    }
  };
  var List = /*#__PURE__*/React__namespace.forwardRef(function List(props, ref) {
    var children = props.children,
        classes = props.classes,
        className = props.className,
        _props$component = props.component,
        Component = _props$component === void 0 ? 'ul' : _props$component,
        _props$dense = props.dense,
        dense = _props$dense === void 0 ? false : _props$dense,
        _props$disablePadding = props.disablePadding,
        disablePadding = _props$disablePadding === void 0 ? false : _props$disablePadding,
        subheader = props.subheader,
        other = _objectWithoutProperties(props, ["children", "classes", "className", "component", "dense", "disablePadding", "subheader"]);

    var context = React__namespace.useMemo(function () {
      return {
        dense: dense
      };
    }, [dense]);
    return /*#__PURE__*/React__namespace.createElement(ListContext$1.Provider, {
      value: context
    }, /*#__PURE__*/React__namespace.createElement(Component, _extends$1({
      className: clsx(classes.root, className, dense && classes.dense, !disablePadding && classes.padding, subheader && classes.subheader),
      ref: ref
    }, other), subheader, children));
  });
  List.propTypes = {
    /**
     * The content of the component.
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object.isRequired,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: PropTypes
    /* @typescript-to-proptypes-ignore */
    .elementType,

    /**
     * If `true`, compact vertical padding designed for keyboard and mouse input will be used for
     * the list and list items.
     * The prop is available to descendant components as the `dense` context.
     */
    dense: PropTypes.bool,

    /**
     * If `true`, vertical padding will be removed from the list.
     */
    disablePadding: PropTypes.bool,

    /**
     * The content of the subheader, normally `ListSubheader`.
     */
    subheader: PropTypes.node
  } ;
  var List$1 = withStyles(styles$6, {
    name: 'MuiList'
  })(List);

  function nextItem(list, item, disableListWrap) {
    if (list === item) {
      return list.firstChild;
    }

    if (item && item.nextElementSibling) {
      return item.nextElementSibling;
    }

    return disableListWrap ? null : list.firstChild;
  }

  function previousItem(list, item, disableListWrap) {
    if (list === item) {
      return disableListWrap ? list.firstChild : list.lastChild;
    }

    if (item && item.previousElementSibling) {
      return item.previousElementSibling;
    }

    return disableListWrap ? null : list.lastChild;
  }

  function textCriteriaMatches(nextFocus, textCriteria) {
    if (textCriteria === undefined) {
      return true;
    }

    var text = nextFocus.innerText;

    if (text === undefined) {
      // jsdom doesn't support innerText
      text = nextFocus.textContent;
    }

    text = text.trim().toLowerCase();

    if (text.length === 0) {
      return false;
    }

    if (textCriteria.repeating) {
      return text[0] === textCriteria.keys[0];
    }

    return text.indexOf(textCriteria.keys.join('')) === 0;
  }

  function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
    var wrappedOnce = false;
    var nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);

    while (nextFocus) {
      // Prevent infinite loop.
      if (nextFocus === list.firstChild) {
        if (wrappedOnce) {
          return;
        }

        wrappedOnce = true;
      } // Same logic as useAutocomplete.js


      var nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true';

      if (!nextFocus.hasAttribute('tabindex') || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
        // Move to the next element.
        nextFocus = traversalFunction(list, nextFocus, disableListWrap);
      } else {
        nextFocus.focus();
        return;
      }
    }
  }

  var useEnhancedEffect = typeof window === 'undefined' ? React__namespace.useEffect : React__namespace.useLayoutEffect;
  /**
   * A permanently displayed menu following https://www.w3.org/TR/wai-aria-practices/#menubutton.
   * It's exposed to help customization of the [`Menu`](/api/menu/) component. If you
   * use it separately you need to move focus into the component manually. Once
   * the focus is placed inside the component it is fully keyboard accessible.
   */

  var MenuList = /*#__PURE__*/React__namespace.forwardRef(function MenuList(props, ref) {
    var actions = props.actions,
        _props$autoFocus = props.autoFocus,
        autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,
        _props$autoFocusItem = props.autoFocusItem,
        autoFocusItem = _props$autoFocusItem === void 0 ? false : _props$autoFocusItem,
        children = props.children,
        className = props.className,
        _props$disabledItemsF = props.disabledItemsFocusable,
        disabledItemsFocusable = _props$disabledItemsF === void 0 ? false : _props$disabledItemsF,
        _props$disableListWra = props.disableListWrap,
        disableListWrap = _props$disableListWra === void 0 ? false : _props$disableListWra,
        onKeyDown = props.onKeyDown,
        _props$variant = props.variant,
        variant = _props$variant === void 0 ? 'selectedMenu' : _props$variant,
        other = _objectWithoutProperties(props, ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"]);

    var listRef = React__namespace.useRef(null);
    var textCriteriaRef = React__namespace.useRef({
      keys: [],
      repeating: true,
      previousKeyMatched: true,
      lastTime: null
    });
    useEnhancedEffect(function () {
      if (autoFocus) {
        listRef.current.focus();
      }
    }, [autoFocus]);
    React__namespace.useImperativeHandle(actions, function () {
      return {
        adjustStyleForScrollbar: function adjustStyleForScrollbar(containerElement, theme) {
          // Let's ignore that piece of logic if users are already overriding the width
          // of the menu.
          var noExplicitWidth = !listRef.current.style.width;

          if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
            var scrollbarSize = "".concat(getScrollbarSize(), "px");
            listRef.current.style[theme.direction === 'rtl' ? 'paddingLeft' : 'paddingRight'] = scrollbarSize;
            listRef.current.style.width = "calc(100% + ".concat(scrollbarSize, ")");
          }

          return listRef.current;
        }
      };
    }, []);

    var handleKeyDown = function handleKeyDown(event) {
      var list = listRef.current;
      var key = event.key;
      /**
       * @type {Element} - will always be defined since we are in a keydown handler
       * attached to an element. A keydown event is either dispatched to the activeElement
       * or document.body or document.documentElement. Only the first case will
       * trigger this specific handler.
       */

      var currentFocus = ownerDocument(list).activeElement;

      if (key === 'ArrowDown') {
        // Prevent scroll of the page
        event.preventDefault();
        moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
      } else if (key === 'ArrowUp') {
        event.preventDefault();
        moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
      } else if (key === 'Home') {
        event.preventDefault();
        moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
      } else if (key === 'End') {
        event.preventDefault();
        moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
      } else if (key.length === 1) {
        var criteria = textCriteriaRef.current;
        var lowerKey = key.toLowerCase();
        var currTime = performance.now();

        if (criteria.keys.length > 0) {
          // Reset
          if (currTime - criteria.lastTime > 500) {
            criteria.keys = [];
            criteria.repeating = true;
            criteria.previousKeyMatched = true;
          } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
            criteria.repeating = false;
          }
        }

        criteria.lastTime = currTime;
        criteria.keys.push(lowerKey);
        var keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);

        if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {
          event.preventDefault();
        } else {
          criteria.previousKeyMatched = false;
        }
      }

      if (onKeyDown) {
        onKeyDown(event);
      }
    };

    var handleOwnRef = React__namespace.useCallback(function (instance) {
      // #StrictMode ready
      listRef.current = ReactDOM__namespace.findDOMNode(instance);
    }, []);
    var handleRef = useForkRef(handleOwnRef, ref);
    /**
     * the index of the item should receive focus
     * in a `variant="selectedMenu"` it's the first `selected` item
     * otherwise it's the very first item.
     */

    var activeItemIndex = -1; // since we inject focus related props into children we have to do a lookahead
    // to check if there is a `selected` item. We're looking for the last `selected`
    // item and use the first valid item as a fallback

    React__namespace.Children.forEach(children, function (child, index) {
      if (! /*#__PURE__*/React__namespace.isValidElement(child)) {
        return;
      }

      {
        if (reactIs$1.exports.isFragment(child)) {
          console.error(["Material-UI: The Menu component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
        }
      }

      if (!child.props.disabled) {
        if (variant === 'selectedMenu' && child.props.selected) {
          activeItemIndex = index;
        } else if (activeItemIndex === -1) {
          activeItemIndex = index;
        }
      }
    });
    var items = React__namespace.Children.map(children, function (child, index) {
      if (index === activeItemIndex) {
        var newChildProps = {};

        if (autoFocusItem) {
          newChildProps.autoFocus = true;
        }

        if (child.props.tabIndex === undefined && variant === 'selectedMenu') {
          newChildProps.tabIndex = 0;
        }

        return /*#__PURE__*/React__namespace.cloneElement(child, newChildProps);
      }

      return child;
    });
    return /*#__PURE__*/React__namespace.createElement(List$1, _extends$1({
      role: "menu",
      ref: handleRef,
      className: className,
      onKeyDown: handleKeyDown,
      tabIndex: autoFocus ? 0 : -1
    }, other), items);
  });
  MenuList.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * If `true`, will focus the `[role="menu"]` container and move into tab order.
     */
    autoFocus: PropTypes.bool,

    /**
     * If `true`, will focus the first menuitem if `variant="menu"` or selected item
     * if `variant="selectedMenu"`.
     */
    autoFocusItem: PropTypes.bool,

    /**
     * MenuList contents, normally `MenuItem`s.
     */
    children: PropTypes.node,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * If `true`, will allow focus on disabled items.
     */
    disabledItemsFocusable: PropTypes.bool,

    /**
     * If `true`, the menu items will not wrap focus.
     */
    disableListWrap: PropTypes.bool,

    /**
     * @ignore
     */
    onKeyDown: PropTypes.func,

    /**
     * The variant to use. Use `menu` to prevent selected items from impacting the initial focus
     * and the vertical alignment relative to the anchor element.
     */
    variant: PropTypes.oneOf(['menu', 'selectedMenu'])
  } ;
  var MenuList$1 = MenuList;

  var RTL_ORIGIN = {
    vertical: 'top',
    horizontal: 'right'
  };
  var LTR_ORIGIN = {
    vertical: 'top',
    horizontal: 'left'
  };
  var styles$5 = {
    /* Styles applied to the `Paper` component. */
    paper: {
      // specZ: The maximum height of a simple menu should be one or more rows less than the view
      // height. This ensures a tapable area outside of the simple menu with which to dismiss
      // the menu.
      maxHeight: 'calc(100% - 96px)',
      // Add iOS momentum scrolling.
      WebkitOverflowScrolling: 'touch'
    },

    /* Styles applied to the `List` component via `MenuList`. */
    list: {
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0
    }
  };
  var Menu = /*#__PURE__*/React__namespace.forwardRef(function Menu(props, ref) {
    var _props$autoFocus = props.autoFocus,
        autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus,
        children = props.children,
        classes = props.classes,
        _props$disableAutoFoc = props.disableAutoFocusItem,
        disableAutoFocusItem = _props$disableAutoFoc === void 0 ? false : _props$disableAutoFoc,
        _props$MenuListProps = props.MenuListProps,
        MenuListProps = _props$MenuListProps === void 0 ? {} : _props$MenuListProps,
        onClose = props.onClose,
        onEnteringProp = props.onEntering,
        open = props.open,
        _props$PaperProps = props.PaperProps,
        PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps,
        PopoverClasses = props.PopoverClasses,
        _props$transitionDura = props.transitionDuration,
        transitionDuration = _props$transitionDura === void 0 ? 'auto' : _props$transitionDura,
        _props$TransitionProp = props.TransitionProps;
    _props$TransitionProp = _props$TransitionProp === void 0 ? {} : _props$TransitionProp;

    var onEntering = _props$TransitionProp.onEntering,
        TransitionProps = _objectWithoutProperties(_props$TransitionProp, ["onEntering"]),
        _props$variant = props.variant,
        variant = _props$variant === void 0 ? 'selectedMenu' : _props$variant,
        other = _objectWithoutProperties(props, ["autoFocus", "children", "classes", "disableAutoFocusItem", "MenuListProps", "onClose", "onEntering", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant"]);

    var theme = useTheme();
    var autoFocusItem = autoFocus && !disableAutoFocusItem && open;
    var menuListActionsRef = React__namespace.useRef(null);
    var contentAnchorRef = React__namespace.useRef(null);

    var getContentAnchorEl = function getContentAnchorEl() {
      return contentAnchorRef.current;
    };

    var handleEntering = function handleEntering(element, isAppearing) {
      if (menuListActionsRef.current) {
        menuListActionsRef.current.adjustStyleForScrollbar(element, theme);
      }

      if (onEnteringProp) {
        onEnteringProp(element, isAppearing);
      }

      if (onEntering) {
        onEntering(element, isAppearing);
      }
    };

    var handleListKeyDown = function handleListKeyDown(event) {
      if (event.key === 'Tab') {
        event.preventDefault();

        if (onClose) {
          onClose(event, 'tabKeyDown');
        }
      }
    };
    /**
     * the index of the item should receive focus
     * in a `variant="selectedMenu"` it's the first `selected` item
     * otherwise it's the very first item.
     */


    var activeItemIndex = -1; // since we inject focus related props into children we have to do a lookahead
    // to check if there is a `selected` item. We're looking for the last `selected`
    // item and use the first valid item as a fallback

    React__namespace.Children.map(children, function (child, index) {
      if (! /*#__PURE__*/React__namespace.isValidElement(child)) {
        return;
      }

      {
        if (reactIs$1.exports.isFragment(child)) {
          console.error(["Material-UI: The Menu component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
        }
      }

      if (!child.props.disabled) {
        if (variant !== "menu" && child.props.selected) {
          activeItemIndex = index;
        } else if (activeItemIndex === -1) {
          activeItemIndex = index;
        }
      }
    });
    var items = React__namespace.Children.map(children, function (child, index) {
      if (index === activeItemIndex) {
        return /*#__PURE__*/React__namespace.cloneElement(child, {
          ref: function ref(instance) {
            // #StrictMode ready
            contentAnchorRef.current = ReactDOM__namespace.findDOMNode(instance);
            setRef(child.ref, instance);
          }
        });
      }

      return child;
    });
    return /*#__PURE__*/React__namespace.createElement(Popover$1, _extends$1({
      getContentAnchorEl: getContentAnchorEl,
      classes: PopoverClasses,
      onClose: onClose,
      TransitionProps: _extends$1({
        onEntering: handleEntering
      }, TransitionProps),
      anchorOrigin: theme.direction === 'rtl' ? RTL_ORIGIN : LTR_ORIGIN,
      transformOrigin: theme.direction === 'rtl' ? RTL_ORIGIN : LTR_ORIGIN,
      PaperProps: _extends$1({}, PaperProps, {
        classes: _extends$1({}, PaperProps.classes, {
          root: classes.paper
        })
      }),
      open: open,
      ref: ref,
      transitionDuration: transitionDuration
    }, other), /*#__PURE__*/React__namespace.createElement(MenuList$1, _extends$1({
      onKeyDown: handleListKeyDown,
      actions: menuListActionsRef,
      autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
      autoFocusItem: autoFocusItem,
      variant: variant
    }, MenuListProps, {
      className: clsx(classes.list, MenuListProps.className)
    }), items));
  });
  Menu.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * A HTML element, or a function that returns it.
     * It's used to set the position of the menu.
     */
    anchorEl: PropTypes
    /* @typescript-to-proptypes-ignore */
    .oneOfType([HTMLElementType, PropTypes.func]),

    /**
     * If `true` (Default) will focus the `[role="menu"]` if no focusable child is found. Disabled
     * children are not focusable. If you set this prop to `false` focus will be placed
     * on the parent modal container. This has severe accessibility implications
     * and should only be considered if you manage focus otherwise.
     */
    autoFocus: PropTypes.bool,

    /**
     * Menu contents, normally `MenuItem`s.
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * When opening the menu will not focus the active item but the `[role="menu"]`
     * unless `autoFocus` is also set to `false`. Not using the default means not
     * following WAI-ARIA authoring practices. Please be considerate about possible
     * accessibility implications.
     */
    disableAutoFocusItem: PropTypes.bool,

    /**
     * Props applied to the [`MenuList`](/api/menu-list/) element.
     */
    MenuListProps: PropTypes.object,

    /**
     * Callback fired when the component requests to be closed.
     *
     * @param {object} event The event source of the callback.
     * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`, `"tabKeyDown"`.
     */
    onClose: PropTypes.func,

    /**
     * Callback fired before the Menu enters.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onEnter: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

    /**
     * Callback fired when the Menu has entered.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onEntered: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

    /**
     * Callback fired when the Menu is entering.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onEntering: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

    /**
     * Callback fired before the Menu exits.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onExit: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

    /**
     * Callback fired when the Menu has exited.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onExited: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

    /**
     * Callback fired when the Menu is exiting.
     * @deprecated Use the `TransitionProps` prop instead.
     */
    onExiting: deprecatedPropType(PropTypes.func, 'Use the `TransitionProps` prop instead.'),

    /**
     * If `true`, the menu is visible.
     */
    open: PropTypes.bool.isRequired,

    /**
     * @ignore
     */
    PaperProps: PropTypes.object,

    /**
     * `classes` prop applied to the [`Popover`](/api/popover/) element.
     */
    PopoverClasses: PropTypes.object,

    /**
     * The length of the transition in `ms`, or 'auto'
     */
    transitionDuration: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number, PropTypes.shape({
      appear: PropTypes.number,
      enter: PropTypes.number,
      exit: PropTypes.number
    })]),

    /**
     * Props applied to the transition element.
     * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition) component.
     */
    TransitionProps: PropTypes.object,

    /**
     * The variant to use. Use `menu` to prevent selected items from impacting the initial focus
     * and the vertical alignment relative to the anchor element.
     */
    variant: PropTypes.oneOf(['menu', 'selectedMenu'])
  } ;
  var Menu$1 = withStyles(styles$5, {
    name: 'MuiMenu'
  })(Menu);

  function areEqualValues(a, b) {
    if (_typeof$1(b) === 'object' && b !== null) {
      return a === b;
    }

    return String(a) === String(b);
  }

  function isEmpty(display) {
    return display == null || typeof display === 'string' && !display.trim();
  }
  /**
   * @ignore - internal component.
   */


  var SelectInput = /*#__PURE__*/React__namespace.forwardRef(function SelectInput(props, ref) {
    var ariaLabel = props['aria-label'],
        autoFocus = props.autoFocus,
        autoWidth = props.autoWidth,
        children = props.children,
        classes = props.classes,
        className = props.className,
        defaultValue = props.defaultValue,
        disabled = props.disabled,
        displayEmpty = props.displayEmpty,
        IconComponent = props.IconComponent,
        inputRefProp = props.inputRef,
        labelId = props.labelId,
        _props$MenuProps = props.MenuProps,
        MenuProps = _props$MenuProps === void 0 ? {} : _props$MenuProps,
        multiple = props.multiple,
        name = props.name,
        onBlur = props.onBlur,
        onChange = props.onChange,
        onClose = props.onClose,
        onFocus = props.onFocus,
        onOpen = props.onOpen,
        openProp = props.open,
        readOnly = props.readOnly,
        renderValue = props.renderValue,
        _props$SelectDisplayP = props.SelectDisplayProps,
        SelectDisplayProps = _props$SelectDisplayP === void 0 ? {} : _props$SelectDisplayP,
        tabIndexProp = props.tabIndex;
        props.type;
        var valueProp = props.value,
        _props$variant = props.variant,
        variant = _props$variant === void 0 ? 'standard' : _props$variant,
        other = _objectWithoutProperties(props, ["aria-label", "autoFocus", "autoWidth", "children", "classes", "className", "defaultValue", "disabled", "displayEmpty", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"]);

    var _useControlled = useControlled({
      controlled: valueProp,
      default: defaultValue,
      name: 'Select'
    }),
        _useControlled2 = _slicedToArray(_useControlled, 2),
        value = _useControlled2[0],
        setValue = _useControlled2[1];

    var inputRef = React__namespace.useRef(null);

    var _React$useState = React__namespace.useState(null),
        displayNode = _React$useState[0],
        setDisplayNode = _React$useState[1];

    var _React$useRef = React__namespace.useRef(openProp != null),
        isOpenControlled = _React$useRef.current;

    var _React$useState2 = React__namespace.useState(),
        menuMinWidthState = _React$useState2[0],
        setMenuMinWidthState = _React$useState2[1];

    var _React$useState3 = React__namespace.useState(false),
        openState = _React$useState3[0],
        setOpenState = _React$useState3[1];

    var handleRef = useForkRef(ref, inputRefProp);
    React__namespace.useImperativeHandle(handleRef, function () {
      return {
        focus: function focus() {
          displayNode.focus();
        },
        node: inputRef.current,
        value: value
      };
    }, [displayNode, value]);
    React__namespace.useEffect(function () {
      if (autoFocus && displayNode) {
        displayNode.focus();
      }
    }, [autoFocus, displayNode]);
    React__namespace.useEffect(function () {
      if (displayNode) {
        var label = ownerDocument(displayNode).getElementById(labelId);

        if (label) {
          var handler = function handler() {
            if (getSelection().isCollapsed) {
              displayNode.focus();
            }
          };

          label.addEventListener('click', handler);
          return function () {
            label.removeEventListener('click', handler);
          };
        }
      }

      return undefined;
    }, [labelId, displayNode]);

    var update = function update(open, event) {
      if (open) {
        if (onOpen) {
          onOpen(event);
        }
      } else if (onClose) {
        onClose(event);
      }

      if (!isOpenControlled) {
        setMenuMinWidthState(autoWidth ? null : displayNode.clientWidth);
        setOpenState(open);
      }
    };

    var handleMouseDown = function handleMouseDown(event) {
      // Ignore everything but left-click
      if (event.button !== 0) {
        return;
      } // Hijack the default focus behavior.


      event.preventDefault();
      displayNode.focus();
      update(true, event);
    };

    var handleClose = function handleClose(event) {
      update(false, event);
    };

    var childrenArray = React__namespace.Children.toArray(children); // Support autofill.

    var handleChange = function handleChange(event) {
      var index = childrenArray.map(function (child) {
        return child.props.value;
      }).indexOf(event.target.value);

      if (index === -1) {
        return;
      }

      var child = childrenArray[index];
      setValue(child.props.value);

      if (onChange) {
        onChange(event, child);
      }
    };

    var handleItemClick = function handleItemClick(child) {
      return function (event) {
        if (!multiple) {
          update(false, event);
        }

        var newValue;

        if (multiple) {
          newValue = Array.isArray(value) ? value.slice() : [];
          var itemIndex = value.indexOf(child.props.value);

          if (itemIndex === -1) {
            newValue.push(child.props.value);
          } else {
            newValue.splice(itemIndex, 1);
          }
        } else {
          newValue = child.props.value;
        }

        if (child.props.onClick) {
          child.props.onClick(event);
        }

        if (value === newValue) {
          return;
        }

        setValue(newValue);

        if (onChange) {
          event.persist(); // Preact support, target is read only property on a native event.

          Object.defineProperty(event, 'target', {
            writable: true,
            value: {
              value: newValue,
              name: name
            }
          });
          onChange(event, child);
        }
      };
    };

    var handleKeyDown = function handleKeyDown(event) {
      if (!readOnly) {
        var validKeys = [' ', 'ArrowUp', 'ArrowDown', // The native select doesn't respond to enter on MacOS, but it's recommended by
        // https://www.w3.org/TR/wai-aria-practices/examples/listbox/listbox-collapsible.html
        'Enter'];

        if (validKeys.indexOf(event.key) !== -1) {
          event.preventDefault();
          update(true, event);
        }
      }
    };

    var open = displayNode !== null && (isOpenControlled ? openProp : openState);

    var handleBlur = function handleBlur(event) {
      // if open event.stopImmediatePropagation
      if (!open && onBlur) {
        event.persist(); // Preact support, target is read only property on a native event.

        Object.defineProperty(event, 'target', {
          writable: true,
          value: {
            value: value,
            name: name
          }
        });
        onBlur(event);
      }
    };

    delete other['aria-invalid'];
    var display;
    var displaySingle;
    var displayMultiple = [];
    var computeDisplay = false;
    var foundMatch = false; // No need to display any value if the field is empty.

    if (isFilled({
      value: value
    }) || displayEmpty) {
      if (renderValue) {
        display = renderValue(value);
      } else {
        computeDisplay = true;
      }
    }

    var items = childrenArray.map(function (child) {
      if (! /*#__PURE__*/React__namespace.isValidElement(child)) {
        return null;
      }

      {
        if (reactIs$1.exports.isFragment(child)) {
          console.error(["Material-UI: The Select component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
        }
      }

      var selected;

      if (multiple) {
        if (!Array.isArray(value)) {
          throw new Error("Material-UI: The `value` prop must be an array when using the `Select` component with `multiple`." );
        }

        selected = value.some(function (v) {
          return areEqualValues(v, child.props.value);
        });

        if (selected && computeDisplay) {
          displayMultiple.push(child.props.children);
        }
      } else {
        selected = areEqualValues(value, child.props.value);

        if (selected && computeDisplay) {
          displaySingle = child.props.children;
        }
      }

      if (selected) {
        foundMatch = true;
      }

      return /*#__PURE__*/React__namespace.cloneElement(child, {
        'aria-selected': selected ? 'true' : undefined,
        onClick: handleItemClick(child),
        onKeyUp: function onKeyUp(event) {
          if (event.key === ' ') {
            // otherwise our MenuItems dispatches a click event
            // it's not behavior of the native <option> and causes
            // the select to close immediately since we open on space keydown
            event.preventDefault();
          }

          if (child.props.onKeyUp) {
            child.props.onKeyUp(event);
          }
        },
        role: 'option',
        selected: selected,
        value: undefined,
        // The value is most likely not a valid HTML attribute.
        'data-value': child.props.value // Instead, we provide it as a data attribute.

      });
    });

    {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React__namespace.useEffect(function () {
        if (!foundMatch && !multiple && value !== '') {
          var values = childrenArray.map(function (child) {
            return child.props.value;
          });
          console.warn(["Material-UI: You have provided an out-of-range value `".concat(value, "` for the select ").concat(name ? "(name=\"".concat(name, "\") ") : '', "component."), "Consider providing a value that matches one of the available options or ''.", "The available values are ".concat(values.filter(function (x) {
            return x != null;
          }).map(function (x) {
            return "`".concat(x, "`");
          }).join(', ') || '""', ".")].join('\n'));
        }
      }, [foundMatch, childrenArray, multiple, name, value]);
    }

    if (computeDisplay) {
      display = multiple ? displayMultiple.join(', ') : displaySingle;
    } // Avoid performing a layout computation in the render method.


    var menuMinWidth = menuMinWidthState;

    if (!autoWidth && isOpenControlled && displayNode) {
      menuMinWidth = displayNode.clientWidth;
    }

    var tabIndex;

    if (typeof tabIndexProp !== 'undefined') {
      tabIndex = tabIndexProp;
    } else {
      tabIndex = disabled ? null : 0;
    }

    var buttonId = SelectDisplayProps.id || (name ? "mui-component-select-".concat(name) : undefined);
    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement("div", _extends$1({
      className: clsx(classes.root, // TODO v5: merge root and select
      classes.select, classes.selectMenu, classes[variant], className, disabled && classes.disabled),
      ref: setDisplayNode,
      tabIndex: tabIndex,
      role: "button",
      "aria-disabled": disabled ? 'true' : undefined,
      "aria-expanded": open ? 'true' : undefined,
      "aria-haspopup": "listbox",
      "aria-label": ariaLabel,
      "aria-labelledby": [labelId, buttonId].filter(Boolean).join(' ') || undefined,
      onKeyDown: handleKeyDown,
      onMouseDown: disabled || readOnly ? null : handleMouseDown,
      onBlur: handleBlur,
      onFocus: onFocus
    }, SelectDisplayProps, {
      // The id is required for proper a11y
      id: buttonId
    }), isEmpty(display) ?
    /*#__PURE__*/
    // eslint-disable-next-line react/no-danger
    React__namespace.createElement("span", {
      dangerouslySetInnerHTML: {
        __html: '&#8203;'
      }
    }) : display), /*#__PURE__*/React__namespace.createElement("input", _extends$1({
      value: Array.isArray(value) ? value.join(',') : value,
      name: name,
      ref: inputRef,
      "aria-hidden": true,
      onChange: handleChange,
      tabIndex: -1,
      className: classes.nativeInput,
      autoFocus: autoFocus
    }, other)), /*#__PURE__*/React__namespace.createElement(IconComponent, {
      className: clsx(classes.icon, classes["icon".concat(capitalize(variant))], open && classes.iconOpen, disabled && classes.disabled)
    }), /*#__PURE__*/React__namespace.createElement(Menu$1, _extends$1({
      id: "menu-".concat(name || ''),
      anchorEl: displayNode,
      open: open,
      onClose: handleClose
    }, MenuProps, {
      MenuListProps: _extends$1({
        'aria-labelledby': labelId,
        role: 'listbox',
        disableListWrap: true
      }, MenuProps.MenuListProps),
      PaperProps: _extends$1({}, MenuProps.PaperProps, {
        style: _extends$1({
          minWidth: menuMinWidth
        }, MenuProps.PaperProps != null ? MenuProps.PaperProps.style : null)
      })
    }), items));
  });
  SelectInput.propTypes = {
    /**
     * @ignore
     */
    'aria-label': PropTypes.string,

    /**
     * @ignore
     */
    autoFocus: PropTypes.bool,

    /**
     * If `true`, the width of the popover will automatically be set according to the items inside the
     * menu, otherwise it will be at least the width of the select input.
     */
    autoWidth: PropTypes.bool,

    /**
     * The option elements to populate the select with.
     * Can be some `<MenuItem>` elements.
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object.isRequired,

    /**
     * The CSS class name of the select element.
     */
    className: PropTypes.string,

    /**
     * The default element value. Use when the component is not controlled.
     */
    defaultValue: PropTypes.any,

    /**
     * If `true`, the select will be disabled.
     */
    disabled: PropTypes.bool,

    /**
     * If `true`, the selected item is displayed even if its value is empty.
     */
    displayEmpty: PropTypes.bool,

    /**
     * The icon that displays the arrow.
     */
    IconComponent: PropTypes.elementType.isRequired,

    /**
     * Imperative handle implementing `{ value: T, node: HTMLElement, focus(): void }`
     * Equivalent to `ref`
     */
    inputRef: refType$1,

    /**
     * The ID of an element that acts as an additional label. The Select will
     * be labelled by the additional label and the selected value.
     */
    labelId: PropTypes.string,

    /**
     * Props applied to the [`Menu`](/api/menu/) element.
     */
    MenuProps: PropTypes.object,

    /**
     * If `true`, `value` must be an array and the menu will support multiple selections.
     */
    multiple: PropTypes.bool,

    /**
     * Name attribute of the `select` or hidden `input` element.
     */
    name: PropTypes.string,

    /**
     * @ignore
     */
    onBlur: PropTypes.func,

    /**
     * Callback function fired when a menu item is selected.
     *
     * @param {object} event The event source of the callback.
     * You can pull out the new value by accessing `event.target.value` (any).
     * @param {object} [child] The react element that was selected.
     */
    onChange: PropTypes.func,

    /**
     * Callback fired when the component requests to be closed.
     * Use in controlled mode (see open).
     *
     * @param {object} event The event source of the callback.
     */
    onClose: PropTypes.func,

    /**
     * @ignore
     */
    onFocus: PropTypes.func,

    /**
     * Callback fired when the component requests to be opened.
     * Use in controlled mode (see open).
     *
     * @param {object} event The event source of the callback.
     */
    onOpen: PropTypes.func,

    /**
     * Control `select` open state.
     */
    open: PropTypes.bool,

    /**
     * @ignore
     */
    readOnly: PropTypes.bool,

    /**
     * Render the selected value.
     *
     * @param {any} value The `value` provided to the component.
     * @returns {ReactNode}
     */
    renderValue: PropTypes.func,

    /**
     * Props applied to the clickable div element.
     */
    SelectDisplayProps: PropTypes.object,

    /**
     * @ignore
     */
    tabIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * @ignore
     */
    type: PropTypes.any,

    /**
     * The input value.
     */
    value: PropTypes.any,

    /**
     * The variant to use.
     */
    variant: PropTypes.oneOf(['standard', 'outlined', 'filled'])
  } ;
  var SelectInput$1 = SelectInput;

  /**
   * @ignore - internal component.
   */

  var ArrowDropDownIcon = createSvgIcon( /*#__PURE__*/React__namespace.createElement("path", {
    d: "M7 10l5 5 5-5z"
  }), 'ArrowDropDown');

  /**
   * @ignore - internal component.
   */

  var NativeSelectInput = /*#__PURE__*/React__namespace.forwardRef(function NativeSelectInput(props, ref) {
    var classes = props.classes,
        className = props.className,
        disabled = props.disabled,
        IconComponent = props.IconComponent,
        inputRef = props.inputRef,
        _props$variant = props.variant,
        variant = _props$variant === void 0 ? 'standard' : _props$variant,
        other = _objectWithoutProperties(props, ["classes", "className", "disabled", "IconComponent", "inputRef", "variant"]);

    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement("select", _extends$1({
      className: clsx(classes.root, // TODO v5: merge root and select
      classes.select, classes[variant], className, disabled && classes.disabled),
      disabled: disabled,
      ref: inputRef || ref
    }, other)), props.multiple ? null : /*#__PURE__*/React__namespace.createElement(IconComponent, {
      className: clsx(classes.icon, classes["icon".concat(capitalize(variant))], disabled && classes.disabled)
    }));
  });
  NativeSelectInput.propTypes = {
    /**
     * The option elements to populate the select with.
     * Can be some `<option>` elements.
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object.isRequired,

    /**
     * The CSS class name of the select element.
     */
    className: PropTypes.string,

    /**
     * If `true`, the select will be disabled.
     */
    disabled: PropTypes.bool,

    /**
     * The icon that displays the arrow.
     */
    IconComponent: PropTypes.elementType.isRequired,

    /**
     * Use that prop to pass a ref to the native select element.
     * @deprecated
     */
    inputRef: refType$1,

    /**
     * @ignore
     */
    multiple: PropTypes.bool,

    /**
     * Name attribute of the `select` or hidden `input` element.
     */
    name: PropTypes.string,

    /**
     * Callback function fired when a menu item is selected.
     *
     * @param {object} event The event source of the callback.
     * You can pull out the new value by accessing `event.target.value` (string).
     */
    onChange: PropTypes.func,

    /**
     * The input value.
     */
    value: PropTypes.any,

    /**
     * The variant to use.
     */
    variant: PropTypes.oneOf(['standard', 'outlined', 'filled'])
  } ;
  var NativeSelectInput$1 = NativeSelectInput;

  var styles$4 = function styles(theme) {
    return {
      /* Styles applied to the select component `root` class. */
      root: {},

      /* Styles applied to the select component `select` class. */
      select: {
        '-moz-appearance': 'none',
        // Reset
        '-webkit-appearance': 'none',
        // Reset
        // When interacting quickly, the text can end up selected.
        // Native select can't be selected either.
        userSelect: 'none',
        borderRadius: 0,
        // Reset
        minWidth: 16,
        // So it doesn't collapse.
        cursor: 'pointer',
        '&:focus': {
          // Show that it's not an text input
          backgroundColor: theme.palette.type === 'light' ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)',
          borderRadius: 0 // Reset Chrome style

        },
        // Remove IE 11 arrow
        '&::-ms-expand': {
          display: 'none'
        },
        '&$disabled': {
          cursor: 'default'
        },
        '&[multiple]': {
          height: 'auto'
        },
        '&:not([multiple]) option, &:not([multiple]) optgroup': {
          backgroundColor: theme.palette.background.paper
        },
        '&&': {
          paddingRight: 24
        }
      },

      /* Styles applied to the select component if `variant="filled"`. */
      filled: {
        '&&': {
          paddingRight: 32
        }
      },

      /* Styles applied to the select component if `variant="outlined"`. */
      outlined: {
        borderRadius: theme.shape.borderRadius,
        '&&': {
          paddingRight: 32
        }
      },

      /* Styles applied to the select component `selectMenu` class. */
      selectMenu: {
        height: 'auto',
        // Resets for multpile select with chips
        minHeight: '1.1876em',
        // Required for select\text-field height consistency
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap',
        overflow: 'hidden'
      },

      /* Pseudo-class applied to the select component `disabled` class. */
      disabled: {},

      /* Styles applied to the icon component. */
      icon: {
        // We use a position absolute over a flexbox in order to forward the pointer events
        // to the input and to support wrapping tags..
        position: 'absolute',
        right: 0,
        top: 'calc(50% - 12px)',
        // Center vertically
        pointerEvents: 'none',
        // Don't block pointer events on the select under the icon.
        color: theme.palette.action.active,
        '&$disabled': {
          color: theme.palette.action.disabled
        }
      },

      /* Styles applied to the icon component if the popup is open. */
      iconOpen: {
        transform: 'rotate(180deg)'
      },

      /* Styles applied to the icon component if `variant="filled"`. */
      iconFilled: {
        right: 7
      },

      /* Styles applied to the icon component if `variant="outlined"`. */
      iconOutlined: {
        right: 7
      },

      /* Styles applied to the underlying native input component. */
      nativeInput: {
        bottom: 0,
        left: 0,
        position: 'absolute',
        opacity: 0,
        pointerEvents: 'none',
        width: '100%'
      }
    };
  };
  var defaultInput = /*#__PURE__*/React__namespace.createElement(Input$1, null);
  /**
   * An alternative to `<Select native />` with a much smaller bundle size footprint.
   */

  var NativeSelect = /*#__PURE__*/React__namespace.forwardRef(function NativeSelect(props, ref) {
    var children = props.children,
        classes = props.classes,
        _props$IconComponent = props.IconComponent,
        IconComponent = _props$IconComponent === void 0 ? ArrowDropDownIcon : _props$IconComponent,
        _props$input = props.input,
        input = _props$input === void 0 ? defaultInput : _props$input,
        inputProps = props.inputProps;
        props.variant;
        var other = _objectWithoutProperties(props, ["children", "classes", "IconComponent", "input", "inputProps", "variant"]);

    var muiFormControl = useFormControl();
    var fcs = formControlState({
      props: props,
      muiFormControl: muiFormControl,
      states: ['variant']
    });
    return /*#__PURE__*/React__namespace.cloneElement(input, _extends$1({
      // Most of the logic is implemented in `NativeSelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent: NativeSelectInput$1,
      inputProps: _extends$1({
        children: children,
        classes: classes,
        IconComponent: IconComponent,
        variant: fcs.variant,
        type: undefined
      }, inputProps, input ? input.props.inputProps : {}),
      ref: ref
    }, other));
  });
  NativeSelect.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * The option elements to populate the select with.
     * Can be some `<option>` elements.
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * The icon that displays the arrow.
     */
    IconComponent: PropTypes.elementType,

    /**
     * An `Input` element; does not have to be a material-ui specific `Input`.
     */
    input: PropTypes.element,

    /**
     * Attributes applied to the `select` element.
     */
    inputProps: PropTypes.object,

    /**
     * Callback function fired when a menu item is selected.
     *
     * @param {object} event The event source of the callback.
     * You can pull out the new value by accessing `event.target.value` (string).
     */
    onChange: PropTypes.func,

    /**
     * The input value. The DOM API casts this to a string.
     */
    value: PropTypes.any,

    /**
     * The variant to use.
     */
    variant: PropTypes.oneOf(['filled', 'outlined', 'standard'])
  } ;
  NativeSelect.muiName = 'Select';
  withStyles(styles$4, {
    name: 'MuiNativeSelect'
  })(NativeSelect);

  var styles$3 = styles$4;

  var _ref = /*#__PURE__*/React__namespace.createElement(Input$1, null);

  var _ref2 = /*#__PURE__*/React__namespace.createElement(FilledInput$1, null);

  var Select = /*#__PURE__*/React__namespace.forwardRef(function Select(props, ref) {
    var _props$autoWidth = props.autoWidth,
        autoWidth = _props$autoWidth === void 0 ? false : _props$autoWidth,
        children = props.children,
        classes = props.classes,
        _props$displayEmpty = props.displayEmpty,
        displayEmpty = _props$displayEmpty === void 0 ? false : _props$displayEmpty,
        _props$IconComponent = props.IconComponent,
        IconComponent = _props$IconComponent === void 0 ? ArrowDropDownIcon : _props$IconComponent,
        id = props.id,
        input = props.input,
        inputProps = props.inputProps,
        label = props.label,
        labelId = props.labelId,
        _props$labelWidth = props.labelWidth,
        labelWidth = _props$labelWidth === void 0 ? 0 : _props$labelWidth,
        MenuProps = props.MenuProps,
        _props$multiple = props.multiple,
        multiple = _props$multiple === void 0 ? false : _props$multiple,
        _props$native = props.native,
        native = _props$native === void 0 ? false : _props$native,
        onClose = props.onClose,
        onOpen = props.onOpen,
        open = props.open,
        renderValue = props.renderValue,
        SelectDisplayProps = props.SelectDisplayProps,
        _props$variant = props.variant,
        variantProps = _props$variant === void 0 ? 'standard' : _props$variant,
        other = _objectWithoutProperties(props, ["autoWidth", "children", "classes", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "labelWidth", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"]);

    var inputComponent = native ? NativeSelectInput$1 : SelectInput$1;
    var muiFormControl = useFormControl();
    var fcs = formControlState({
      props: props,
      muiFormControl: muiFormControl,
      states: ['variant']
    });
    var variant = fcs.variant || variantProps;
    var InputComponent = input || {
      standard: _ref,
      outlined: /*#__PURE__*/React__namespace.createElement(OutlinedInput$1, {
        label: label,
        labelWidth: labelWidth
      }),
      filled: _ref2
    }[variant];
    return /*#__PURE__*/React__namespace.cloneElement(InputComponent, _extends$1({
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent: inputComponent,
      inputProps: _extends$1({
        children: children,
        IconComponent: IconComponent,
        variant: variant,
        type: undefined,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple: multiple
      }, native ? {
        id: id
      } : {
        autoWidth: autoWidth,
        displayEmpty: displayEmpty,
        labelId: labelId,
        MenuProps: MenuProps,
        onClose: onClose,
        onOpen: onOpen,
        open: open,
        renderValue: renderValue,
        SelectDisplayProps: _extends$1({
          id: id
        }, SelectDisplayProps)
      }, inputProps, {
        classes: inputProps ? mergeClasses({
          baseClasses: classes,
          newClasses: inputProps.classes,
          Component: Select
        }) : classes
      }, input ? input.props.inputProps : {}),
      ref: ref
    }, other));
  });
  Select.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * If `true`, the width of the popover will automatically be set according to the items inside the
     * menu, otherwise it will be at least the width of the select input.
     */
    autoWidth: PropTypes.bool,

    /**
     * The option elements to populate the select with.
     * Can be some `MenuItem` when `native` is false and `option` when `native` is true.
     *
     * The `MenuItem` elements **must** be direct descendants when `native` is false.
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * The default element value. Use when the component is not controlled.
     */
    defaultValue: PropTypes.any,

    /**
     * If `true`, a value is displayed even if no items are selected.
     *
     * In order to display a meaningful value, a function should be passed to the `renderValue` prop which returns the value to be displayed when no items are selected.
     * You can only use it when the `native` prop is `false` (default).
     */
    displayEmpty: PropTypes.bool,

    /**
     * The icon that displays the arrow.
     */
    IconComponent: PropTypes.elementType,

    /**
     * The `id` of the wrapper element or the `select` element when `native`.
     */
    id: PropTypes.string,

    /**
     * An `Input` element; does not have to be a material-ui specific `Input`.
     */
    input: PropTypes.element,

    /**
     * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
     * When `native` is `true`, the attributes are applied on the `select` element.
     */
    inputProps: PropTypes.object,

    /**
     * See [OutlinedInput#label](/api/outlined-input/#props)
     */
    label: PropTypes.node,

    /**
     * The ID of an element that acts as an additional label. The Select will
     * be labelled by the additional label and the selected value.
     */
    labelId: PropTypes.string,

    /**
     * See [OutlinedInput#label](/api/outlined-input/#props)
     */
    labelWidth: PropTypes.number,

    /**
     * Props applied to the [`Menu`](/api/menu/) element.
     */
    MenuProps: PropTypes.object,

    /**
     * If `true`, `value` must be an array and the menu will support multiple selections.
     */
    multiple: PropTypes.bool,

    /**
     * If `true`, the component will be using a native `select` element.
     */
    native: PropTypes.bool,

    /**
     * Callback function fired when a menu item is selected.
     *
     * @param {object} event The event source of the callback.
     * You can pull out the new value by accessing `event.target.value` (any).
     * @param {object} [child] The react element that was selected when `native` is `false` (default).
     */
    onChange: PropTypes.func,

    /**
     * Callback fired when the component requests to be closed.
     * Use in controlled mode (see open).
     *
     * @param {object} event The event source of the callback.
     */
    onClose: PropTypes.func,

    /**
     * Callback fired when the component requests to be opened.
     * Use in controlled mode (see open).
     *
     * @param {object} event The event source of the callback.
     */
    onOpen: PropTypes.func,

    /**
     * Control `select` open state.
     * You can only use it when the `native` prop is `false` (default).
     */
    open: PropTypes.bool,

    /**
     * Render the selected value.
     * You can only use it when the `native` prop is `false` (default).
     *
     * @param {any} value The `value` provided to the component.
     * @returns {ReactNode}
     */
    renderValue: PropTypes.func,

    /**
     * Props applied to the clickable div element.
     */
    SelectDisplayProps: PropTypes.object,

    /**
     * The input value. Providing an empty string will select no options.
     * This prop is required when the `native` prop is `false` (default).
     * Set to an empty string `''` if you don't want any of the available options to be selected.
     *
     * If the value is an object it must have reference equality with the option in order to be selected.
     * If the value is not an object, the string representation must match with the string representation of the option in order to be selected.
     */
    value: PropTypes.any,

    /**
     * The variant to use.
     */
    variant: PropTypes.oneOf(['filled', 'outlined', 'standard'])
  } ;
  Select.muiName = 'Select';
  var Select$1 = withStyles(styles$3, {
    name: 'MuiSelect'
  })(Select);

  var variantComponent = {
    standard: Input$1,
    filled: FilledInput$1,
    outlined: OutlinedInput$1
  };
  var styles$2 = {
    /* Styles applied to the root element. */
    root: {}
  };
  /**
   * The `TextField` is a convenience wrapper for the most common cases (80%).
   * It cannot be all things to all people, otherwise the API would grow out of control.
   *
   * ## Advanced Configuration
   *
   * It's important to understand that the text field is a simple abstraction
   * on top of the following components:
   *
   * - [FormControl](/api/form-control/)
   * - [InputLabel](/api/input-label/)
   * - [FilledInput](/api/filled-input/)
   * - [OutlinedInput](/api/outlined-input/)
   * - [Input](/api/input/)
   * - [FormHelperText](/api/form-helper-text/)
   *
   * If you wish to alter the props applied to the `input` element, you can do so as follows:
   *
   * ```jsx
   * const inputProps = {
   *   step: 300,
   * };
   *
   * return <TextField id="time" type="time" inputProps={inputProps} />;
   * ```
   *
   * For advanced cases, please look at the source of TextField by clicking on the
   * "Edit this page" button above. Consider either:
   *
   * - using the upper case props for passing values directly to the components
   * - using the underlying components directly as shown in the demos
   */

  var TextField = /*#__PURE__*/React__namespace.forwardRef(function TextField(props, ref) {
    var autoComplete = props.autoComplete,
        _props$autoFocus = props.autoFocus,
        autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,
        children = props.children,
        classes = props.classes,
        className = props.className,
        _props$color = props.color,
        color = _props$color === void 0 ? 'primary' : _props$color,
        defaultValue = props.defaultValue,
        _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled,
        _props$error = props.error,
        error = _props$error === void 0 ? false : _props$error,
        FormHelperTextProps = props.FormHelperTextProps,
        _props$fullWidth = props.fullWidth,
        fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth,
        helperText = props.helperText,
        hiddenLabel = props.hiddenLabel,
        id = props.id,
        InputLabelProps = props.InputLabelProps,
        inputProps = props.inputProps,
        InputProps = props.InputProps,
        inputRef = props.inputRef,
        label = props.label,
        _props$multiline = props.multiline,
        multiline = _props$multiline === void 0 ? false : _props$multiline,
        name = props.name,
        onBlur = props.onBlur,
        onChange = props.onChange,
        onFocus = props.onFocus,
        placeholder = props.placeholder,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        rows = props.rows,
        rowsMax = props.rowsMax,
        maxRows = props.maxRows,
        minRows = props.minRows,
        _props$select = props.select,
        select = _props$select === void 0 ? false : _props$select,
        SelectProps = props.SelectProps,
        type = props.type,
        value = props.value,
        _props$variant = props.variant,
        variant = _props$variant === void 0 ? 'standard' : _props$variant,
        other = _objectWithoutProperties(props, ["autoComplete", "autoFocus", "children", "classes", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "hiddenLabel", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "rowsMax", "maxRows", "minRows", "select", "SelectProps", "type", "value", "variant"]);

    {
      if (select && !children) {
        console.error('Material-UI: `children` must be passed when using the `TextField` component with `select`.');
      }
    }

    var InputMore = {};

    if (variant === 'outlined') {
      if (InputLabelProps && typeof InputLabelProps.shrink !== 'undefined') {
        InputMore.notched = InputLabelProps.shrink;
      }

      if (label) {
        var _InputLabelProps$requ;

        var displayRequired = (_InputLabelProps$requ = InputLabelProps === null || InputLabelProps === void 0 ? void 0 : InputLabelProps.required) !== null && _InputLabelProps$requ !== void 0 ? _InputLabelProps$requ : required;
        InputMore.label = /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, label, displayRequired && "\xA0*");
      }
    }

    if (select) {
      // unset defaults from textbox inputs
      if (!SelectProps || !SelectProps.native) {
        InputMore.id = undefined;
      }

      InputMore['aria-describedby'] = undefined;
    }

    var helperTextId = helperText && id ? "".concat(id, "-helper-text") : undefined;
    var inputLabelId = label && id ? "".concat(id, "-label") : undefined;
    var InputComponent = variantComponent[variant];
    var InputElement = /*#__PURE__*/React__namespace.createElement(InputComponent, _extends$1({
      "aria-describedby": helperTextId,
      autoComplete: autoComplete,
      autoFocus: autoFocus,
      defaultValue: defaultValue,
      fullWidth: fullWidth,
      multiline: multiline,
      name: name,
      rows: rows,
      rowsMax: rowsMax,
      maxRows: maxRows,
      minRows: minRows,
      type: type,
      value: value,
      id: id,
      inputRef: inputRef,
      onBlur: onBlur,
      onChange: onChange,
      onFocus: onFocus,
      placeholder: placeholder,
      inputProps: inputProps
    }, InputMore, InputProps));
    return /*#__PURE__*/React__namespace.createElement(FormControl$1, _extends$1({
      className: clsx(classes.root, className),
      disabled: disabled,
      error: error,
      fullWidth: fullWidth,
      hiddenLabel: hiddenLabel,
      ref: ref,
      required: required,
      color: color,
      variant: variant
    }, other), label && /*#__PURE__*/React__namespace.createElement(InputLabel$1, _extends$1({
      htmlFor: id,
      id: inputLabelId
    }, InputLabelProps), label), select ? /*#__PURE__*/React__namespace.createElement(Select$1, _extends$1({
      "aria-describedby": helperTextId,
      id: id,
      labelId: inputLabelId,
      value: value,
      input: InputElement
    }, SelectProps), children) : InputElement, helperText && /*#__PURE__*/React__namespace.createElement(FormHelperText$1, _extends$1({
      id: helperTextId
    }, FormHelperTextProps), helperText));
  });
  TextField.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * This prop helps users to fill forms faster, especially on mobile devices.
     * The name can be confusing, as it's more like an autofill.
     * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
     */
    autoComplete: PropTypes.string,

    /**
     * If `true`, the `input` element will be focused during the first mount.
     */
    autoFocus: PropTypes.bool,

    /**
     * @ignore
     */
    children: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * The color of the component. It supports those theme colors that make sense for this component.
     */
    color: PropTypes.oneOf(['primary', 'secondary']),

    /**
     * The default value of the `input` element.
     */
    defaultValue: PropTypes.any,

    /**
     * If `true`, the `input` element will be disabled.
     */
    disabled: PropTypes.bool,

    /**
     * If `true`, the label will be displayed in an error state.
     */
    error: PropTypes.bool,

    /**
     * Props applied to the [`FormHelperText`](/api/form-helper-text/) element.
     */
    FormHelperTextProps: PropTypes.object,

    /**
     * If `true`, the input will take up the full width of its container.
     */
    fullWidth: PropTypes.bool,

    /**
     * The helper text content.
     */
    helperText: PropTypes.node,

    /**
     * @ignore
     */
    hiddenLabel: PropTypes.bool,

    /**
     * The id of the `input` element.
     * Use this prop to make `label` and `helperText` accessible for screen readers.
     */
    id: PropTypes.string,

    /**
     * Props applied to the [`InputLabel`](/api/input-label/) element.
     */
    InputLabelProps: PropTypes.object,

    /**
     * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
     */
    inputProps: PropTypes.object,

    /**
     * Props applied to the Input element.
     * It will be a [`FilledInput`](/api/filled-input/),
     * [`OutlinedInput`](/api/outlined-input/) or [`Input`](/api/input/)
     * component depending on the `variant` prop value.
     */
    InputProps: PropTypes.object,

    /**
     * Pass a ref to the `input` element.
     */
    inputRef: refType$1,

    /**
     * The label content.
     */
    label: PropTypes.node,

    /**
     * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
     */
    margin: PropTypes.oneOf(['dense', 'none', 'normal']),

    /**
     * Maximum number of rows to display when multiline option is set to true.
     */
    maxRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * Minimum number of rows to display.
     */
    minRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * If `true`, a textarea element will be rendered instead of an input.
     */
    multiline: PropTypes.bool,

    /**
     * Name attribute of the `input` element.
     */
    name: PropTypes.string,

    /**
     * @ignore
     */
    onBlur: PropTypes.func,

    /**
     * Callback fired when the value is changed.
     *
     * @param {object} event The event source of the callback.
     * You can pull out the new value by accessing `event.target.value` (string).
     */
    onChange: PropTypes.func,

    /**
     * @ignore
     */
    onFocus: PropTypes.func,

    /**
     * The short hint displayed in the input before the user enters a value.
     */
    placeholder: PropTypes.string,

    /**
     * If `true`, the label is displayed as required and the `input` element` will be required.
     */
    required: PropTypes.bool,

    /**
     * Number of rows to display when multiline option is set to true.
     * @deprecated Use `minRows` instead.
     */
    rows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * Maximum number of rows to display.
     * @deprecated Use `maxRows` instead.
     */
    rowsMax: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * Render a [`Select`](/api/select/) element while passing the Input element to `Select` as `input` parameter.
     * If this option is set you must pass the options of the select as children.
     */
    select: PropTypes.bool,

    /**
     * Props applied to the [`Select`](/api/select/) element.
     */
    SelectProps: PropTypes.object,

    /**
     * The size of the text field.
     */
    size: PropTypes.oneOf(['medium', 'small']),

    /**
     * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
     */
    type: PropTypes.string,

    /**
     * The value of the `input` element, required for a controlled component.
     */
    value: PropTypes.any,

    /**
     * The variant to use.
     */
    variant: PropTypes.oneOf(['filled', 'outlined', 'standard'])
  } ;
  var TextField$1 = withStyles(styles$2, {
    name: 'MuiTextField'
  })(TextField);

  var styles$1 = {
    root: {
      padding: 9
    },
    checked: {},
    disabled: {},
    input: {
      cursor: 'inherit',
      position: 'absolute',
      opacity: 0,
      width: '100%',
      height: '100%',
      top: 0,
      left: 0,
      margin: 0,
      padding: 0,
      zIndex: 1
    }
  };
  /**
   * @ignore - internal component.
   */

  var SwitchBase = /*#__PURE__*/React__namespace.forwardRef(function SwitchBase(props, ref) {
    var autoFocus = props.autoFocus,
        checkedProp = props.checked,
        checkedIcon = props.checkedIcon,
        classes = props.classes,
        className = props.className,
        defaultChecked = props.defaultChecked,
        disabledProp = props.disabled,
        icon = props.icon,
        id = props.id,
        inputProps = props.inputProps,
        inputRef = props.inputRef,
        name = props.name,
        onBlur = props.onBlur,
        onChange = props.onChange,
        onFocus = props.onFocus,
        readOnly = props.readOnly,
        required = props.required,
        tabIndex = props.tabIndex,
        type = props.type,
        value = props.value,
        other = _objectWithoutProperties(props, ["autoFocus", "checked", "checkedIcon", "classes", "className", "defaultChecked", "disabled", "icon", "id", "inputProps", "inputRef", "name", "onBlur", "onChange", "onFocus", "readOnly", "required", "tabIndex", "type", "value"]);

    var _useControlled = useControlled({
      controlled: checkedProp,
      default: Boolean(defaultChecked),
      name: 'SwitchBase',
      state: 'checked'
    }),
        _useControlled2 = _slicedToArray(_useControlled, 2),
        checked = _useControlled2[0],
        setCheckedState = _useControlled2[1];

    var muiFormControl = useFormControl();

    var handleFocus = function handleFocus(event) {
      if (onFocus) {
        onFocus(event);
      }

      if (muiFormControl && muiFormControl.onFocus) {
        muiFormControl.onFocus(event);
      }
    };

    var handleBlur = function handleBlur(event) {
      if (onBlur) {
        onBlur(event);
      }

      if (muiFormControl && muiFormControl.onBlur) {
        muiFormControl.onBlur(event);
      }
    };

    var handleInputChange = function handleInputChange(event) {
      var newChecked = event.target.checked;
      setCheckedState(newChecked);

      if (onChange) {
        // TODO v5: remove the second argument.
        onChange(event, newChecked);
      }
    };

    var disabled = disabledProp;

    if (muiFormControl) {
      if (typeof disabled === 'undefined') {
        disabled = muiFormControl.disabled;
      }
    }

    var hasLabelFor = type === 'checkbox' || type === 'radio';
    return /*#__PURE__*/React__namespace.createElement(IconButton$1, _extends$1({
      component: "span",
      className: clsx(classes.root, className, checked && classes.checked, disabled && classes.disabled),
      disabled: disabled,
      tabIndex: null,
      role: undefined,
      onFocus: handleFocus,
      onBlur: handleBlur,
      ref: ref
    }, other), /*#__PURE__*/React__namespace.createElement("input", _extends$1({
      autoFocus: autoFocus,
      checked: checkedProp,
      defaultChecked: defaultChecked,
      className: classes.input,
      disabled: disabled,
      id: hasLabelFor && id,
      name: name,
      onChange: handleInputChange,
      readOnly: readOnly,
      ref: inputRef,
      required: required,
      tabIndex: tabIndex,
      type: type,
      value: value
    }, inputProps)), checked ? checkedIcon : icon);
  }); // NB: If changed, please update Checkbox, Switch and Radio
  // so that the API documentation is updated.

  SwitchBase.propTypes = {
    /**
     * If `true`, the `input` element will be focused during the first mount.
     */
    autoFocus: PropTypes.bool,

    /**
     * If `true`, the component is checked.
     */
    checked: PropTypes.bool,

    /**
     * The icon to display when the component is checked.
     */
    checkedIcon: PropTypes.node.isRequired,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object.isRequired,

    /**
     * @ignore
     */
    className: PropTypes.string,

    /**
     * @ignore
     */
    defaultChecked: PropTypes.bool,

    /**
     * If `true`, the switch will be disabled.
     */
    disabled: PropTypes.bool,

    /**
     * The icon to display when the component is unchecked.
     */
    icon: PropTypes.node.isRequired,

    /**
     * The id of the `input` element.
     */
    id: PropTypes.string,

    /**
     * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
     */
    inputProps: PropTypes.object,

    /**
     * Pass a ref to the `input` element.
     */
    inputRef: refType$1,

    /*
     * @ignore
     */
    name: PropTypes.string,

    /**
     * @ignore
     */
    onBlur: PropTypes.func,

    /**
     * Callback fired when the state is changed.
     *
     * @param {object} event The event source of the callback.
     * You can pull out the new checked state by accessing `event.target.checked` (boolean).
     */
    onChange: PropTypes.func,

    /**
     * @ignore
     */
    onFocus: PropTypes.func,

    /**
     * It prevents the user from changing the value of the field
     * (not from interacting with the field).
     */
    readOnly: PropTypes.bool,

    /**
     * If `true`, the `input` element will be required.
     */
    required: PropTypes.bool,

    /**
     * @ignore
     */
    tabIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    /**
     * The input component prop `type`.
     */
    type: PropTypes.string.isRequired,

    /**
     * The value of the component.
     */
    value: PropTypes.any
  } ;
  var SwitchBase$1 = withStyles(styles$1, {
    name: 'PrivateSwitchBase'
  })(SwitchBase);

  /**
   * @ignore - internal component.
   */

  var CheckBoxOutlineBlankIcon = createSvgIcon( /*#__PURE__*/React__namespace.createElement("path", {
    d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
  }), 'CheckBoxOutlineBlank');

  /**
   * @ignore - internal component.
   */

  var CheckBoxIcon = createSvgIcon( /*#__PURE__*/React__namespace.createElement("path", {
    d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
  }), 'CheckBox');

  /**
   * @ignore - internal component.
   */

  var IndeterminateCheckBoxIcon = createSvgIcon( /*#__PURE__*/React__namespace.createElement("path", {
    d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
  }), 'IndeterminateCheckBox');

  var styles = function styles(theme) {
    return {
      /* Styles applied to the root element. */
      root: {
        color: theme.palette.text.secondary
      },

      /* Pseudo-class applied to the root element if `checked={true}`. */
      checked: {},

      /* Pseudo-class applied to the root element if `disabled={true}`. */
      disabled: {},

      /* Pseudo-class applied to the root element if `indeterminate={true}`. */
      indeterminate: {},

      /* Styles applied to the root element if `color="primary"`. */
      colorPrimary: {
        '&$checked': {
          color: theme.palette.primary.main,
          '&:hover': {
            backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: 'transparent'
            }
          }
        },
        '&$disabled': {
          color: theme.palette.action.disabled
        }
      },

      /* Styles applied to the root element if `color="secondary"`. */
      colorSecondary: {
        '&$checked': {
          color: theme.palette.secondary.main,
          '&:hover': {
            backgroundColor: alpha(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
            // Reset on touch devices, it doesn't add specificity
            '@media (hover: none)': {
              backgroundColor: 'transparent'
            }
          }
        },
        '&$disabled': {
          color: theme.palette.action.disabled
        }
      }
    };
  };
  var defaultCheckedIcon = /*#__PURE__*/React__namespace.createElement(CheckBoxIcon, null);
  var defaultIcon = /*#__PURE__*/React__namespace.createElement(CheckBoxOutlineBlankIcon, null);
  var defaultIndeterminateIcon = /*#__PURE__*/React__namespace.createElement(IndeterminateCheckBoxIcon, null);
  var Checkbox = /*#__PURE__*/React__namespace.forwardRef(function Checkbox(props, ref) {
    var _props$checkedIcon = props.checkedIcon,
        checkedIcon = _props$checkedIcon === void 0 ? defaultCheckedIcon : _props$checkedIcon,
        classes = props.classes,
        _props$color = props.color,
        color = _props$color === void 0 ? 'secondary' : _props$color,
        _props$icon = props.icon,
        iconProp = _props$icon === void 0 ? defaultIcon : _props$icon,
        _props$indeterminate = props.indeterminate,
        indeterminate = _props$indeterminate === void 0 ? false : _props$indeterminate,
        _props$indeterminateI = props.indeterminateIcon,
        indeterminateIconProp = _props$indeterminateI === void 0 ? defaultIndeterminateIcon : _props$indeterminateI,
        inputProps = props.inputProps,
        _props$size = props.size,
        size = _props$size === void 0 ? 'medium' : _props$size,
        other = _objectWithoutProperties(props, ["checkedIcon", "classes", "color", "icon", "indeterminate", "indeterminateIcon", "inputProps", "size"]);

    var icon = indeterminate ? indeterminateIconProp : iconProp;
    var indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon;
    return /*#__PURE__*/React__namespace.createElement(SwitchBase$1, _extends$1({
      type: "checkbox",
      classes: {
        root: clsx(classes.root, classes["color".concat(capitalize(color))], indeterminate && classes.indeterminate),
        checked: classes.checked,
        disabled: classes.disabled
      },
      color: color,
      inputProps: _extends$1({
        'data-indeterminate': indeterminate
      }, inputProps),
      icon: /*#__PURE__*/React__namespace.cloneElement(icon, {
        fontSize: icon.props.fontSize === undefined && size === "small" ? size : icon.props.fontSize
      }),
      checkedIcon: /*#__PURE__*/React__namespace.cloneElement(indeterminateIcon, {
        fontSize: indeterminateIcon.props.fontSize === undefined && size === "small" ? size : indeterminateIcon.props.fontSize
      }),
      ref: ref
    }, other));
  });
  Checkbox.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // |     To update them edit the d.ts file and run "yarn proptypes"     |
    // ----------------------------------------------------------------------

    /**
     * If `true`, the component is checked.
     */
    checked: PropTypes.bool,

    /**
     * The icon to display when the component is checked.
     */
    checkedIcon: PropTypes.node,

    /**
     * Override or extend the styles applied to the component.
     * See [CSS API](#css) below for more details.
     */
    classes: PropTypes.object,

    /**
     * The color of the component. It supports those theme colors that make sense for this component.
     */
    color: PropTypes.oneOf(['default', 'primary', 'secondary']),

    /**
     * If `true`, the checkbox will be disabled.
     */
    disabled: PropTypes.bool,

    /**
     * If `true`, the ripple effect will be disabled.
     */
    disableRipple: PropTypes.bool,

    /**
     * The icon to display when the component is unchecked.
     */
    icon: PropTypes.node,

    /**
     * The id of the `input` element.
     */
    id: PropTypes.string,

    /**
     * If `true`, the component appears indeterminate.
     * This does not set the native input element to indeterminate due
     * to inconsistent behavior across browsers.
     * However, we set a `data-indeterminate` attribute on the input.
     */
    indeterminate: PropTypes.bool,

    /**
     * The icon to display when the component is indeterminate.
     */
    indeterminateIcon: PropTypes.node,

    /**
     * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
     */
    inputProps: PropTypes.object,

    /**
     * Pass a ref to the `input` element.
     */
    inputRef: refType$1,

    /**
     * Callback fired when the state is changed.
     *
     * @param {object} event The event source of the callback.
     * You can pull out the new checked state by accessing `event.target.checked` (boolean).
     */
    onChange: PropTypes.func,

    /**
     * If `true`, the `input` element will be required.
     */
    required: PropTypes.bool,

    /**
     * The size of the checkbox.
     * `small` is equivalent to the dense checkbox styling.
     */
    size: PropTypes.oneOf(['medium', 'small']),

    /**
     * The value of the component. The DOM API casts this to a string.
     * The browser uses "on" as the default value.
     */
    value: PropTypes.any
  } ;
  var Checkbox$1 = withStyles(styles, {
    name: 'MuiCheckbox'
  })(Checkbox);

  class AutocompleteUI extends React.Component {
    render() {
      return React.createElement(Autocomplete$1, {
        key: this.props.key,
        multiple: this.props.multiple,
        size: "small",
        disabled: this.props.disabled,
        filterSelectedOptions: this.props.filterSelectedOptions,
        disableCloseOnSelect: this.props.disableCloseOnSelect,
        options: this.props.options,
        value: this.props.value,
        getOptionLabel: option => option.title,
        onChange: this.props.onChange,
        noOptionsText: this.props.noOptionsText,
        limitTags: this.props.limitTags,
        onOpen: this.props.onOpen,
        loading: this.props.loading,
        loadingText: this.props.loadingText,
        onInputChange: this.props.onInputChange,
        getOptionSelected: (option, value) => option.title === value.title && option.key === value.key,
        renderOption: (option, {
          selected
        }) => React.createElement(React.Fragment, null, this.props.showCheckboxes ? React.createElement(Checkbox$1, {
          checked: selected
        }) : null, option.title),
        renderInput: params => React.createElement(TextField$1, _extends$2({}, params, {
          variant: this.props.variant,
          label: this.props.label,
          placeholder: this.props.placeholder
        }))
      });
    }

  }

  class AutocompleteMultiselect extends React.Component {
    constructor(props) {
      super(props);

      _defineProperty$1(this, "inputChange", (event, value, reason) => {
        if (this.props.searchAfterXChars.value === undefined || value.length >= this.props.searchAfterXChars.value) {
          this.showToFewCharsText = false;
          const timeStamp = event.timeStamp;
          this.latestInputChange = timeStamp; //Check if no other inputchange will be done

          setTimeout((timeStamp, value, reason) => {
            if (this.latestInputChange === timeStamp) {
              if (this.props.searchValue) {
                this.props.searchValue.setValue(value);
              }

              if (this.props.onInputChangeAction && this.props.onInputChangeAction.canExecute) {
                this.props.onInputChangeAction.execute();
              }
            }
          }, this.props.onInputChangeDelay.value, timeStamp, value, reason);
        } else {
          this.showToFewCharsText = true;
        }

        this.loading = true; // make sure to rerender the widget

        this.setState({
          updateDate: new Date()
        });
      });

      this.state = {
        updateDate: null
      };
      this.autoCompleteKey = 0;
      this.onChange = this.changeValues.bind(this);
      this.onOpenDropdown = this.openDropdown.bind(this);
      this.onInputChange = this.inputChange.bind(this);
      this.options = [];
      this.optionsSelected = []; // Array for multiselect, otherwise object

      this.initialized = false; // Initialize to true to make sure data is retrieved when initializing widget

      this.refreshData = true;
      this.loading = true;
      this.showToFewCharsText = false;
      this.latestInputChange = undefined;
    }

    componentDidUpdate(prevProps) {
      let refreshState = false; // Refresh the data if the refreshAttribute has been set to true

      if (prevProps.refreshAttribute && this.props.refreshAttribute.value && !prevProps.refreshAttribute.value) {
        this.props.refreshAttribute.setValue(false);
        this.autoCompleteKey++; // Make sure data and state will be refreshed

        this.refreshData = true;
        refreshState = true;
      } // Check if data sourse or attribute is used


      if (this.props.JSONAttribute) {
        if (this.props.JSONAttribute.status === "available") {
          // check if the items has been changed or data needs to be refreshed
          if (this.refreshData || this.props.JSONAttribute !== prevProps.JSONAttribute) {
            let dataParsed = []; // parse the json

            if (this.props.JSONAttribute.value && this.props.JSONAttribute.value !== "") {
              dataParsed = JSON.parse(this.props.JSONAttribute.value);
            } // if data needs to be refreshed, reset defaults


            if (this.refreshData) {
              const defaultValue = dataParsed.filter(option => option.default);

              if (this.props.multiple) {
                this.optionsSelected = defaultValue;
              } else {
                this.optionsSelected = defaultValue[0] === undefined ? null : defaultValue[0];
              }
            } else {
              // If custom search is used, it can be that some options are not in the JSON
              // Add these options to make sure the defaults are in, they will be filtered out if not applicable to input value
              if (this.props.onInputChangeAction) {
                const optionsSelectedNotInList = this.optionsSelected.filter(selectedOption => {
                  return dataParsed.find(option => option.title === selectedOption.title && option.key === selectedOption.key) === undefined;
                });
                dataParsed = dataParsed.concat(optionsSelectedNotInList);
              } else {
                if (this.props.multiple) {
                  // Else check if optionSelected are still available. This is done since it can be the case that the options have been changed.
                  this.optionsSelected = this.optionsSelected.filter(selectedOption => {
                    return dataParsed.find(option => option.title === selectedOption.title && option.key === selectedOption.key) !== undefined;
                  });
                } else if (this.optionsSelected !== null) {
                  this.optionsSelected = dataParsed.find(option => option.title === this.optionsSelected.title && option.key === this.optionsSelected.key);
                }

                if (this.optionsSelected === undefined) {
                  this.optionsSelected = null;
                }
              }
            }

            this.options = dataParsed;
            refreshState = true;
            this.initialized = true;
            this.refreshData = false; // Store response in responseAttribute

            this.props.responseAttribute.setValue(JSON.stringify(this.optionsSelected));
            this.loading = false;
          }
        }
      } else if (this.props.dataSourceOptions !== prevProps.dataSourceOptions) {
        // Check if the datasource has been loaded
        if (this.props.dataSourceOptions.status === 'available') {
          // If the items have been changed or if date needs to be refreshed, change the options
          if (this.refreshData || this.props.dataSourceOptions.items !== prevProps.dataSourceOptions.items) {
            let warningGiven = false;
            const multiSelect = this.props.multiple;
            let optionsSelected = multiSelect ? [] : null;
            let defaultSelectedString = undefined; // Map the options and get the selected ones

            this.options = this.props.dataSourceOptions.items.map(item => {
              const optionTitle = this.props.titleAttr.get(item).value;
              const option = {
                title: optionTitle
              }; //If key is used, add key to the option

              if (this.props.keyAttr) {
                option.key = this.props.keyAttr.get(item).value;
              } // If data needs to be refreshed, get default options


              if (this.refreshData) {
                // If string is not yet filled, fill with either the json or with null
                if (defaultSelectedString === undefined) {
                  if (this.props.defaultSelectedStringAttr !== undefined) {
                    try {
                      defaultSelectedString = JSON.parse(this.props.defaultSelectedStringAttr.value);
                      ;
                    } catch (e) {
                      defaultSelectedString = [];
                    }
                  } else {
                    // set to null to not check this for every item again
                    defaultSelectedString = null;
                  }
                }

                let isItemDefaultSelected = false; // Items can be set to default selected in two ways: defaultSelectedStringAttr prop or defaultSelectedAttr prop on an item. If the first option is chosen, the prop on the item is ignored.

                if (defaultSelectedString !== null) {
                  isItemDefaultSelected = defaultSelectedString.indexOf(optionTitle) !== -1;
                } else {
                  isItemDefaultSelected = this.props.defaultSelectedAttr && this.props.defaultSelectedAttr.get(item).value;
                }

                if (isItemDefaultSelected) {
                  if (multiSelect) {
                    optionsSelected.push(option);
                  } else {
                    if (optionsSelected === null) {
                      optionsSelected = option;
                    } else {
                      if (!warningGiven) {
                        console.warn("Autocomplete Multiselect: Multiple options are set as default for a single select. First option is set as the selected one.");
                        warningGiven = true;
                      }
                    }
                  }
                }
              } else {
                // Else check if option is selected (based on the title). This is done since it can be the case that the options have been changed.
                if (multiSelect) {
                  if (this.optionsSelected.find(option => option.title === optionTitle)) {
                    optionsSelected.push(option);
                  }
                } else if (this.optionsSelected !== null) {
                  if (this.optionsSelected.title === optionTitle) {
                    optionsSelected = option;
                  }
                }
              }

              return option;
            });
            refreshState = true;
            this.initialized = true;
            this.refreshData = false;
            this.optionsSelected = optionsSelected; // Store response in responseAttribute

            this.props.responseAttribute.setValue(JSON.stringify(optionsSelected));
            this.loading = false;
          }
        }
      }

      if (refreshState) {
        this.setState({
          updateDate: new Date()
        });
      }
    }
    /**
     * Function called when a new value is selected or value(s) are deselected. 
     * 
     * @param {*} event - the event that triggered this action
     * @param {*} newValue - the new value of the dropdown
     * @param {*} reason - the reason that this action is triggered, either select-option, remove-option, create-option, blur or clear
     * @param {*} details - more details about the option for which this event is triggered
     */


    changeValues(event, newValue, reason, details) {
      // Store response in responseAttribute and call on change action
      this.props.responseAttribute.setValue(JSON.stringify(newValue));

      if (this.props.onChangeAction && this.props.onChangeAction.canExecute) {
        this.props.onChangeAction.execute();
      } // Update the widget with the new values selected


      this.optionsSelected = newValue;
      this.setState({
        updateDate: new Date()
      });
    }
    /**
     * Function calles when dropdown is opened
     */


    openDropdown() {
      let setLoading = false; // check if enough chars are filled

      if (this.props.onInputChangeAction) {
        if (this.props.searchAfterXChars.value && this.props.searchAfterXChars.value > 0) {
          this.showToFewCharsText = true;
          setLoading = true;
        }
      }

      if (this.props.onOpenAction && this.props.onOpenAction.canExecute) {
        this.props.onOpenAction.execute();
        setLoading = true;
      }

      if (setLoading) {
        // Rerender widget
        this.loading = true;
        this.setState({
          updateDate: new Date()
        });
      }
    }
    /**
     * Function called when a the input value changes
     * 
     * @param {*} event - the event that triggered this action
     * @param {*} value - the new value of the input
     * @param {*} reason - the reason that this action is triggered, either input, clear or reset
     */


    render() {
      // Do not render the widget if it is not initialized yet
      if (!this.initialized) {
        return '';
      } // If the disabled property is not filled, the widget will be editable


      let disabled = this.props.editable ? !this.props.editable.value : false; // Check if user has rights on response attribute

      if (!disabled && this.props.responseAttribute.readOnly) {
        console.warn('Autocomplete Multiselect: User has no rights to change the response attribute.');
        disabled = true;
      }

      const noOptionsText = this.props.noOptionsText ? this.props.noOptionsText.value : undefined;
      const placeholder = this.props.placeholder ? this.props.placeholder.value : undefined;
      const limitTags = this.props.limitTags > 0 ? this.props.limitTags : undefined;
      const label = this.props.label ? this.props.label.value : undefined; // Following options only used when json attribute is used

      let onOpen = undefined;
      let onInputChange = undefined;
      let loading = undefined;
      let loadingText = undefined;
      let options = this.options;

      if (this.props.JSONAttribute) {
        onOpen = this.onOpenDropdown;

        if (this.props.onInputChangeAction) {
          onInputChange = this.onInputChange;
        }

        loading = this.loading; // set loading text, if to few chars are filled use this text.

        if (this.showToFewCharsText) {
          loadingText = this.props.searchAfterXCharsText ? this.props.searchAfterXCharsText.value : "Enter at least " + this.props.searchAfterXChars.value + " characters";
        } else {
          loadingText = this.props.loadingText ? this.props.loadingText.value : undefined;
        } // if component is loading, hide options


        if (this.loading) {
          options = [];
        }
      }

      return React.createElement(AutocompleteUI, {
        key: this.autoCompleteKey,
        multiple: this.props.multiple,
        disabled: disabled,
        disableCloseOnSelect: this.props.disableCloseOnSelect,
        options: options,
        value: this.optionsSelected,
        onChange: this.onChange,
        noOptionsText: noOptionsText,
        limitTags: limitTags,
        showCheckboxes: this.props.showCheckboxes,
        variant: this.props.variant,
        label: label,
        placeholder: placeholder,
        filterSelectedOptions: this.props.filterSelectedOptions,
        onOpen: onOpen,
        loading: loading,
        loadingText: loadingText,
        onInputChange: onInputChange
      });
    }

  }

  return AutocompleteMultiselect;

}));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXV0b2NvbXBsZXRlTXVsdGlzZWxlY3QuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1pbmplY3QvZGlzdC9zdHlsZS1pbmplY3QuZXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllcy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm0uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3V0aWxzL2VzbS9jaGFpblByb3BUeXBlcy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3V0aWxzL2VzbS9kZWVwbWVyZ2UuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3V0aWxzL2VzbS9lbGVtZW50QWNjZXB0aW5nUmVmLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS91dGlscy9lc20vZWxlbWVudFR5cGVBY2NlcHRpbmdSZWYuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3V0aWxzL2VzbS9leGFjdFByb3AuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3V0aWxzL2VzbS9nZXREaXNwbGF5TmFtZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvdXRpbHMvZXNtL0hUTUxFbGVtZW50VHlwZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvdXRpbHMvZXNtL3JlZlR5cGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3N0eWxlcy9jb2xvck1hbmlwdWxhdG9yLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9zdHlsZXMvY3JlYXRlQnJlYWtwb2ludHMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3N0eWxlcy9jcmVhdGVNaXhpbnMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL2NvbG9ycy9jb21tb24uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL2NvbG9ycy9ncmV5LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9jb2xvcnMvaW5kaWdvLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9jb2xvcnMvcGluay5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vY29sb3JzL3JlZC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vY29sb3JzL29yYW5nZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vY29sb3JzL2JsdWUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL2NvbG9ycy9ncmVlbi5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vc3R5bGVzL2NyZWF0ZVBhbGV0dGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3N0eWxlcy9jcmVhdGVUeXBvZ3JhcGh5LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9zdHlsZXMvc2hhZG93cy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vc3R5bGVzL3NoYXBlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9zeXN0ZW0vZXNtL3Jlc3BvbnNpdmVQcm9wVHlwZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheUxpa2VUb0FycmF5LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aG91dEhvbGVzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhIb2xlcy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVJlc3QuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3lzdGVtL2VzbS9zcGFjaW5nLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9zdHlsZXMvY3JlYXRlU3BhY2luZy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vc3R5bGVzL3RyYW5zaXRpb25zLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9zdHlsZXMvekluZGV4LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9zdHlsZXMvY3JlYXRlVGhlbWUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N0eWxlcy9lc20vVGhlbWVQcm92aWRlci9uZXN0ZWQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N0eWxlcy9lc20vY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUvY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N0eWxlcy9lc20vZ2V0VGhlbWVQcm9wcy9nZXRUaGVtZVByb3BzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Rpbnktd2FybmluZy9kaXN0L3Rpbnktd2FybmluZy5lc20uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaXMtaW4tYnJvd3Nlci9kaXN0L21vZHVsZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zZXRQcm90b3R5cGVPZi5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qc3MvZGlzdC9qc3MuZXNtLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tcnVsZS12YWx1ZS1mdW5jdGlvbi9kaXN0L2pzcy1wbHVnaW4tcnVsZS12YWx1ZS1mdW5jdGlvbi5lc20uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvanNzLXBsdWdpbi1nbG9iYWwvZGlzdC9qc3MtcGx1Z2luLWdsb2JhbC5lc20uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvanNzLXBsdWdpbi1uZXN0ZWQvZGlzdC9qc3MtcGx1Z2luLW5lc3RlZC5lc20uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaHlwaGVuYXRlLXN0eWxlLW5hbWUvaW5kZXguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvanNzLXBsdWdpbi1jYW1lbC1jYXNlL2Rpc3QvanNzLXBsdWdpbi1jYW1lbC1jYXNlLmVzbS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLWRlZmF1bHQtdW5pdC9kaXN0L2pzcy1wbHVnaW4tZGVmYXVsdC11bml0LmVzbS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtdmVuZG9yL2Rpc3QvY3NzLXZlbmRvci5lc20uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvanNzLXBsdWdpbi12ZW5kb3ItcHJlZml4ZXIvZGlzdC9qc3MtcGx1Z2luLXZlbmRvci1wcmVmaXhlci5lc20uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvanNzLXBsdWdpbi1wcm9wcy1zb3J0L2Rpc3QvanNzLXBsdWdpbi1wcm9wcy1zb3J0LmVzbS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3R5bGVzL2VzbS9qc3NQcmVzZXQvanNzUHJlc2V0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9zdHlsZXMvZXNtL21lcmdlQ2xhc3Nlcy9tZXJnZUNsYXNzZXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N0eWxlcy9lc20vbWFrZVN0eWxlcy9tdWx0aUtleVN0b3JlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9zdHlsZXMvZXNtL3VzZVRoZW1lL1RoZW1lQ29udGV4dC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3R5bGVzL2VzbS91c2VUaGVtZS91c2VUaGVtZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3R5bGVzL2VzbS9TdHlsZXNQcm92aWRlci9TdHlsZXNQcm92aWRlci5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3R5bGVzL2VzbS9tYWtlU3R5bGVzL2luZGV4Q291bnRlci5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3R5bGVzL2VzbS9nZXRTdHlsZXNDcmVhdG9yL25vb3BUaGVtZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvc3R5bGVzL2VzbS9nZXRTdHlsZXNDcmVhdG9yL2dldFN0eWxlc0NyZWF0b3IuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL3N0eWxlcy9lc20vbWFrZVN0eWxlcy9tYWtlU3R5bGVzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2Rpc3QvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MuY2pzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9zdHlsZXMvZXNtL3dpdGhTdHlsZXMvd2l0aFN0eWxlcy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vc3R5bGVzL2RlZmF1bHRUaGVtZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vc3R5bGVzL3VzZVRoZW1lLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9zdHlsZXMvd2l0aFN0eWxlcy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3BwZXIuanMvZGlzdC9lc20vcG9wcGVyLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy9kZXByZWNhdGVkUHJvcFR5cGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3V0aWxzL3NldFJlZi5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdXRpbHMvdXNlRm9ya1JlZi5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vUG9ydGFsL1BvcnRhbC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdXRpbHMvY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9Qb3BwZXIvUG9wcGVyLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy9jYXBpdGFsaXplLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9MaXN0U3ViaGVhZGVyL0xpc3RTdWJoZWFkZXIuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL1BhcGVyL1BhcGVyLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy91c2VFdmVudENhbGxiYWNrLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy91c2VJc0ZvY3VzVmlzaWJsZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS9jb25maWcuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9lc20vdXRpbHMvUHJvcFR5cGVzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvZXNtL1RyYW5zaXRpb25Hcm91cENvbnRleHQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9lc20vVHJhbnNpdGlvbi5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS91dGlscy9DaGlsZE1hcHBpbmcuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9lc20vVHJhbnNpdGlvbkdyb3VwLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9CdXR0b25CYXNlL1JpcHBsZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vQnV0dG9uQmFzZS9Ub3VjaFJpcHBsZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vQnV0dG9uQmFzZS9CdXR0b25CYXNlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9JY29uQnV0dG9uL0ljb25CdXR0b24uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL1N2Z0ljb24vU3ZnSWNvbi5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdXRpbHMvY3JlYXRlU3ZnSWNvbi5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vaW50ZXJuYWwvc3ZnLWljb25zL0NhbmNlbC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdXRpbHMvdW5zdXBwb3J0ZWRQcm9wLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9DaGlwL0NoaXAuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3V0aWxzL2RlYm91bmNlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy9pc011aUVsZW1lbnQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3V0aWxzL293bmVyRG9jdW1lbnQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL3V0aWxzL293bmVyV2luZG93LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy91c2VDb250cm9sbGVkLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy91bnN0YWJsZV91c2VJZC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvbGFiL2VzbS9pbnRlcm5hbC9zdmctaWNvbnMvQ2xvc2UuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2xhYi9lc20vaW50ZXJuYWwvc3ZnLWljb25zL0Fycm93RHJvcERvd24uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2xhYi9lc20vdXNlQXV0b2NvbXBsZXRlL3VzZUF1dG9jb21wbGV0ZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvbGFiL2VzbS9BdXRvY29tcGxldGUvQXV0b2NvbXBsZXRlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9Gb3JtQ29udHJvbC9mb3JtQ29udHJvbFN0YXRlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9Gb3JtQ29udHJvbC9Gb3JtQ29udHJvbENvbnRleHQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL1RleHRhcmVhQXV0b3NpemUvVGV4dGFyZWFBdXRvc2l6ZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vSW5wdXRCYXNlL3V0aWxzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9JbnB1dEJhc2UvSW5wdXRCYXNlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9JbnB1dC9JbnB1dC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vRmlsbGVkSW5wdXQvRmlsbGVkSW5wdXQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL091dGxpbmVkSW5wdXQvTm90Y2hlZE91dGxpbmUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL091dGxpbmVkSW5wdXQvT3V0bGluZWRJbnB1dC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vRm9ybUNvbnRyb2wvdXNlRm9ybUNvbnRyb2wuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0Zvcm1MYWJlbC9Gb3JtTGFiZWwuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0lucHV0TGFiZWwvSW5wdXRMYWJlbC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vRm9ybUNvbnRyb2wvRm9ybUNvbnRyb2wuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0Zvcm1IZWxwZXJUZXh0L0Zvcm1IZWxwZXJUZXh0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS91dGlscy9nZXRTY3JvbGxiYXJTaXplLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9Nb2RhbC9Nb2RhbE1hbmFnZXIuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL1Vuc3RhYmxlX1RyYXBGb2N1cy9VbnN0YWJsZV9UcmFwRm9jdXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL01vZGFsL1NpbXBsZUJhY2tkcm9wLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9Nb2RhbC9Nb2RhbC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vdHJhbnNpdGlvbnMvdXRpbHMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0dyb3cvR3Jvdy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vUG9wb3Zlci9Qb3BvdmVyLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9MaXN0L0xpc3RDb250ZXh0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9MaXN0L0xpc3QuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL01lbnVMaXN0L01lbnVMaXN0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9NZW51L01lbnUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL1NlbGVjdC9TZWxlY3RJbnB1dC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vaW50ZXJuYWwvc3ZnLWljb25zL0Fycm93RHJvcERvd24uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL05hdGl2ZVNlbGVjdC9OYXRpdmVTZWxlY3RJbnB1dC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vTmF0aXZlU2VsZWN0L05hdGl2ZVNlbGVjdC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vU2VsZWN0L1NlbGVjdC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vVGV4dEZpZWxkL1RleHRGaWVsZC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vaW50ZXJuYWwvU3dpdGNoQmFzZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9lc20vaW50ZXJuYWwvc3ZnLWljb25zL0NoZWNrQm94T3V0bGluZUJsYW5rLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2VzbS9pbnRlcm5hbC9zdmctaWNvbnMvQ2hlY2tCb3guanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL2ludGVybmFsL3N2Zy1pY29ucy9JbmRldGVybWluYXRlQ2hlY2tCb3guanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvZXNtL0NoZWNrYm94L0NoZWNrYm94LmpzIiwiLi4vLi4vLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvQXV0b2NvbXBsZXRlVUkuanN4IiwiLi4vLi4vLi4vLi4vLi4vc3JjL0F1dG9jb21wbGV0ZU11bHRpc2VsZWN0LmpzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBzdHlsZUluamVjdChjc3MsIHJlZikge1xuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gIHZhciBpbnNlcnRBdCA9IHJlZi5pbnNlcnRBdDtcblxuICBpZiAoIWNzcyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybjsgfVxuXG4gIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcblxuICBpZiAoaW5zZXJ0QXQgPT09ICd0b3AnKSB7XG4gICAgaWYgKGhlYWQuZmlyc3RDaGlsZCkge1xuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGUsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0eWxlSW5qZWN0O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwiaW1wb3J0IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIi4vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59IiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxuLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9SRVNQT05ERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9TQ09QRV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUpO1xufVxuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BPUlRBTF9UWVBFO1xufVxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG59XG5cbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAnICtcbiAgICAgICAgICAgIGxvY2F0aW9uICsgJyBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJyArIHR5cGVvZiBlcnJvciArICcuICcgK1xuICAgICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArXG4gICAgICAgICAgICAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnRmFpbGVkICcgKyBsb2NhdGlvbiArICcgdHlwZTogJyArIGVycm9yLm1lc3NhZ2UgKyAoc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlc2V0cyB3YXJuaW5nIGNhY2hlIHdoZW4gdGVzdGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgcHJvcCBvbiBgJyArIGNvbXBvbmVudE5hbWUgICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudCB0eXBlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMuICcgK1xuICAgICAgICAgICAgJ0EgY29tbW9uIG1pc3Rha2UgaXMgdG8gd3JpdGUgb25lT2YoeCwgeSwgeikgaW5zdGVhZCBvZiBvbmVPZihbeCwgeSwgel0pLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzLCBmdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBTdHJpbmcocHJvcFZhbHVlKSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAoaGFzKHByb3BWYWx1ZSwga2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cbiAgICAgIC8vIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIiwiZnVuY3Rpb24gdG9WYWwobWl4KSB7XG5cdHZhciBrLCB5LCBzdHI9Jyc7XG5cblx0aWYgKHR5cGVvZiBtaXggPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBtaXggPT09ICdudW1iZXInKSB7XG5cdFx0c3RyICs9IG1peDtcblx0fSBlbHNlIGlmICh0eXBlb2YgbWl4ID09PSAnb2JqZWN0Jykge1xuXHRcdGlmIChBcnJheS5pc0FycmF5KG1peCkpIHtcblx0XHRcdGZvciAoaz0wOyBrIDwgbWl4Lmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdGlmIChtaXhba10pIHtcblx0XHRcdFx0XHRpZiAoeSA9IHRvVmFsKG1peFtrXSkpIHtcblx0XHRcdFx0XHRcdHN0ciAmJiAoc3RyICs9ICcgJyk7XG5cdFx0XHRcdFx0XHRzdHIgKz0geTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChrIGluIG1peCkge1xuXHRcdFx0XHRpZiAobWl4W2tdKSB7XG5cdFx0XHRcdFx0c3RyICYmIChzdHIgKz0gJyAnKTtcblx0XHRcdFx0XHRzdHIgKz0gaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcblx0dmFyIGk9MCwgdG1wLCB4LCBzdHI9Jyc7XG5cdHdoaWxlIChpIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdGlmICh0bXAgPSBhcmd1bWVudHNbaSsrXSkge1xuXHRcdFx0aWYgKHggPSB0b1ZhbCh0bXApKSB7XG5cdFx0XHRcdHN0ciAmJiAoc3RyICs9ICcgJyk7XG5cdFx0XHRcdHN0ciArPSB4XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzdHI7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjaGFpblByb3BUeXBlcyhwcm9wVHlwZTEsIHByb3BUeXBlMikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICAgIHJldHVybiBwcm9wVHlwZTEuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpIHx8IHByb3BUeXBlMi5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF90eXBlb2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZlwiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoaXRlbSkge1xuICByZXR1cm4gaXRlbSAmJiBfdHlwZW9mKGl0ZW0pID09PSAnb2JqZWN0JyAmJiBpdGVtLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHtcbiAgICBjbG9uZTogdHJ1ZVxuICB9O1xuICB2YXIgb3V0cHV0ID0gb3B0aW9ucy5jbG9uZSA/IF9leHRlbmRzKHt9LCB0YXJnZXQpIDogdGFyZ2V0O1xuXG4gIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8vIEF2b2lkIHByb3RvdHlwZSBwb2xsdXRpb25cbiAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pICYmIGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgb3V0cHV0W2tleV0gPSBkZWVwbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufSIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2hhaW5Qcm9wVHlwZXMgZnJvbSAnLi9jaGFpblByb3BUeXBlcyc7XG5cbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQoZWxlbWVudFR5cGUpIHtcbiAgLy8gZWxlbWVudFR5cGUucHJvdG90eXBlPy5pc1JlYWN0Q29tcG9uZW50XG4gIHZhciBfZWxlbWVudFR5cGUkcHJvdG90eXAgPSBlbGVtZW50VHlwZS5wcm90b3R5cGUsXG4gICAgICBwcm90b3R5cGUgPSBfZWxlbWVudFR5cGUkcHJvdG90eXAgPT09IHZvaWQgMCA/IHt9IDogX2VsZW1lbnRUeXBlJHByb3RvdHlwO1xuICByZXR1cm4gQm9vbGVhbihwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGFjY2VwdGluZ1JlZihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgdmFyIGVsZW1lbnQgPSBwcm9wc1twcm9wTmFtZV07XG4gIHZhciBzYWZlUHJvcE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHdhcm5pbmdIaW50O1xuICB2YXIgZWxlbWVudFR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIC8qKlxuICAgKiBCbGFja2xpc3RpbmcgaW5zdGVhZCBvZiB3aGl0ZWxpc3RpbmdcbiAgICpcbiAgICogQmxhY2tsaXN0aW5nIHdpbGwgbWlzcyBzb21lIGNvbXBvbmVudHMsIHN1Y2ggYXMgUmVhY3QuRnJhZ21lbnQuIFRob3NlIHdpbGwgYXQgbGVhc3RcbiAgICogdHJpZ2dlciBhIHdhcm5pbmcgaW4gUmVhY3QuXG4gICAqIFdlIGNhbid0IHdoaXRlbGlzdCBiZWNhdXNlIHRoZXJlIGlzIG5vIHNhZmUgd2F5IHRvIGRldGVjdCBSZWFjdC5mb3J3YXJkUmVmXG4gICAqIG9yIGNsYXNzIGNvbXBvbmVudHMuIFwiU2FmZVwiIG1lYW5zIHRoZXJlJ3Mgbm8gcHVibGljIEFQSS5cbiAgICpcbiAgICovXG5cbiAgaWYgKHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNDbGFzc0NvbXBvbmVudChlbGVtZW50VHlwZSkpIHtcbiAgICB3YXJuaW5nSGludCA9ICdEaWQgeW91IGFjY2lkZW50YWxseSB1c2UgYSBwbGFpbiBmdW5jdGlvbiBjb21wb25lbnQgZm9yIGFuIGVsZW1lbnQgaW5zdGVhZD8nO1xuICB9XG5cbiAgaWYgKHdhcm5pbmdIaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiSW52YWxpZCBcIi5jb25jYXQobG9jYXRpb24sIFwiIGBcIikuY29uY2F0KHNhZmVQcm9wTmFtZSwgXCJgIHN1cHBsaWVkIHRvIGBcIikuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiYC4gXCIpICsgXCJFeHBlY3RlZCBhbiBlbGVtZW50IHRoYXQgY2FuIGhvbGQgYSByZWYuIFwiLmNvbmNhdCh3YXJuaW5nSGludCwgXCIgXCIpICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSBodHRwczovL21hdGVyaWFsLXVpLmNvbS9yL2NhdmVhdC13aXRoLXJlZnMtZ3VpZGUnKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgZWxlbWVudEFjY2VwdGluZ1JlZiA9IGNoYWluUHJvcFR5cGVzKFByb3BUeXBlcy5lbGVtZW50LCBhY2NlcHRpbmdSZWYpO1xuZWxlbWVudEFjY2VwdGluZ1JlZi5pc1JlcXVpcmVkID0gY2hhaW5Qcm9wVHlwZXMoUHJvcFR5cGVzLmVsZW1lbnQuaXNSZXF1aXJlZCwgYWNjZXB0aW5nUmVmKTtcbmV4cG9ydCBkZWZhdWx0IGVsZW1lbnRBY2NlcHRpbmdSZWY7IiwiaW1wb3J0ICogYXMgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNoYWluUHJvcFR5cGVzIGZyb20gJy4vY2hhaW5Qcm9wVHlwZXMnO1xuXG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KGVsZW1lbnRUeXBlKSB7XG4gIC8vIGVsZW1lbnRUeXBlLnByb3RvdHlwZT8uaXNSZWFjdENvbXBvbmVudFxuICB2YXIgX2VsZW1lbnRUeXBlJHByb3RvdHlwID0gZWxlbWVudFR5cGUucHJvdG90eXBlLFxuICAgICAgcHJvdG90eXBlID0gX2VsZW1lbnRUeXBlJHByb3RvdHlwID09PSB2b2lkIDAgPyB7fSA6IF9lbGVtZW50VHlwZSRwcm90b3R5cDtcbiAgcmV0dXJuIEJvb2xlYW4ocHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBlbGVtZW50VHlwZUFjY2VwdGluZ1JlZihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgdmFyIHNhZmVQcm9wTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciB3YXJuaW5nSGludDtcbiAgLyoqXG4gICAqIEJsYWNrbGlzdGluZyBpbnN0ZWFkIG9mIHdoaXRlbGlzdGluZ1xuICAgKlxuICAgKiBCbGFja2xpc3Rpbmcgd2lsbCBtaXNzIHNvbWUgY29tcG9uZW50cywgc3VjaCBhcyBSZWFjdC5GcmFnbWVudC4gVGhvc2Ugd2lsbCBhdCBsZWFzdFxuICAgKiB0cmlnZ2VyIGEgd2FybmluZyBpbiBSZWFjdC5cbiAgICogV2UgY2FuJ3Qgd2hpdGVsaXN0IGJlY2F1c2UgdGhlcmUgaXMgbm8gc2FmZSB3YXkgdG8gZGV0ZWN0IFJlYWN0LmZvcndhcmRSZWZcbiAgICogb3IgY2xhc3MgY29tcG9uZW50cy4gXCJTYWZlXCIgbWVhbnMgdGhlcmUncyBubyBwdWJsaWMgQVBJLlxuICAgKlxuICAgKi9cblxuICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNDbGFzc0NvbXBvbmVudChwcm9wVmFsdWUpKSB7XG4gICAgd2FybmluZ0hpbnQgPSAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcHJvdmlkZSBhIHBsYWluIGZ1bmN0aW9uIGNvbXBvbmVudCBpbnN0ZWFkPyc7XG4gIH1cblxuICBpZiAod2FybmluZ0hpbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJJbnZhbGlkIFwiLmNvbmNhdChsb2NhdGlvbiwgXCIgYFwiKS5jb25jYXQoc2FmZVByb3BOYW1lLCBcImAgc3VwcGxpZWQgdG8gYFwiKS5jb25jYXQoY29tcG9uZW50TmFtZSwgXCJgLiBcIikgKyBcIkV4cGVjdGVkIGFuIGVsZW1lbnQgdHlwZSB0aGF0IGNhbiBob2xkIGEgcmVmLiBcIi5jb25jYXQod2FybmluZ0hpbnQsIFwiIFwiKSArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgaHR0cHM6Ly9tYXRlcmlhbC11aS5jb20vci9jYXZlYXQtd2l0aC1yZWZzLWd1aWRlJyk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2hhaW5Qcm9wVHlwZXMoUHJvcFR5cGVzLmVsZW1lbnRUeXBlLCBlbGVtZW50VHlwZUFjY2VwdGluZ1JlZik7IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuLy8gVGhpcyBtb2R1bGUgaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2FpcmJuYi9wcm9wLXR5cGVzLWV4YWN0IHJlcG9zaXRvcnkuXG4vLyBIb3dldmVyLCBpbiBvcmRlciB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBkZXBlbmRlbmNpZXMgYW5kIHRvIHJlbW92ZSBzb21lIGV4dHJhIHNhZmUgY2hlY2tzXG4vLyB0aGUgbW9kdWxlIHdhcyBmb3JrZWQuXG4vLyBPbmx5IGV4cG9ydGVkIGZvciB0ZXN0IHB1cnBvc2VzLlxuZXhwb3J0IHZhciBzcGVjaWFsUHJvcGVydHkgPSBcImV4YWN0LXByb3A6IFxcdTIwMEJcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4YWN0UHJvcChwcm9wVHlwZXMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gcHJvcFR5cGVzO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBwcm9wVHlwZXMsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgc3BlY2lhbFByb3BlcnR5LCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgdW5zdXBwb3J0ZWRQcm9wcyA9IE9iamVjdC5rZXlzKHByb3BzKS5maWx0ZXIoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAhcHJvcFR5cGVzLmhhc093blByb3BlcnR5KHByb3ApO1xuICAgIH0pO1xuXG4gICAgaWYgKHVuc3VwcG9ydGVkUHJvcHMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIlRoZSBmb2xsb3dpbmcgcHJvcHMgYXJlIG5vdCBzdXBwb3J0ZWQ6IFwiLmNvbmNhdCh1bnN1cHBvcnRlZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICByZXR1cm4gXCJgXCIuY29uY2F0KHByb3AsIFwiYFwiKTtcbiAgICAgIH0pLmpvaW4oJywgJyksIFwiLiBQbGVhc2UgcmVtb3ZlIHRoZW0uXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSkpO1xufSIsImltcG9ydCBfdHlwZW9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2ZcIjtcbmltcG9ydCB7IEZvcndhcmRSZWYsIE1lbW8gfSBmcm9tICdyZWFjdC1pcyc7IC8vIFNpbXBsaWZpZWQgcG9seWZpbGwgZm9yIElFIDExIHN1cHBvcnRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9KYW1lc01HcmVlbmUvRnVuY3Rpb24ubmFtZS9ibG9iLzU4YjMxNGQ0YTk4MzExMGMzNjgyZjEyMjhmODQ1ZDM5Y2NjYTE4MTcvRnVuY3Rpb24ubmFtZS5qcyNMM1xuXG52YXIgZm5OYW1lTWF0Y2hSZWdleCA9IC9eXFxzKmZ1bmN0aW9uKD86XFxzfFxccypcXC9cXCouKlxcKlxcL1xccyopKyhbXihcXHMvXSopXFxzKi87XG5leHBvcnQgZnVuY3Rpb24gZ2V0RnVuY3Rpb25OYW1lKGZuKSB7XG4gIHZhciBtYXRjaCA9IFwiXCIuY29uY2F0KGZuKS5tYXRjaChmbk5hbWVNYXRjaFJlZ2V4KTtcbiAgdmFyIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgcmV0dXJuIG5hbWUgfHwgJyc7XG59XG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGZhbGxiYWNrXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uQ29tcG9uZW50TmFtZShDb21wb25lbnQpIHtcbiAgdmFyIGZhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgcmV0dXJuIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCBnZXRGdW5jdGlvbk5hbWUoQ29tcG9uZW50KSB8fCBmYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBnZXRGdW5jdGlvbkNvbXBvbmVudE5hbWUoaW5uZXJUeXBlKTtcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IFwiXCIuY29uY2F0KHdyYXBwZXJOYW1lLCBcIihcIikuY29uY2F0KGZ1bmN0aW9uTmFtZSwgXCIpXCIpIDogd3JhcHBlck5hbWUpO1xufVxuLyoqXG4gKiBjaGVycnktcGljayBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi83NjliMWYyNzBlMTI1MWQ5ZGJkY2UwZmNiZDllOTJlNTAyZDA1OWI4L3BhY2thZ2VzL3NoYXJlZC9nZXRDb21wb25lbnROYW1lLmpzXG4gKiBvcmlnaW5hbGx5IGZvcmtlZCBmcm9tIHJlY29tcG9zZS9nZXREaXNwbGF5TmFtZSB3aXRoIGFkZGVkIElFIDExIHN1cHBvcnRcbiAqXG4gKiBAcGFyYW0ge1JlYWN0LlJlYWN0VHlwZX0gQ29tcG9uZW50XG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoQ29tcG9uZW50KSB7XG4gIGlmIChDb21wb25lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIENvbXBvbmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gQ29tcG9uZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZ2V0RnVuY3Rpb25Db21wb25lbnROYW1lKENvbXBvbmVudCwgJ0NvbXBvbmVudCcpO1xuICB9XG5cbiAgaWYgKF90eXBlb2YoQ29tcG9uZW50KSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKENvbXBvbmVudC4kJHR5cGVvZikge1xuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUoQ29tcG9uZW50LCBDb21wb25lbnQucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIE1lbW86XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZShDb21wb25lbnQsIENvbXBvbmVudC50eXBlLCAnbWVtbycpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSFRNTEVsZW1lbnRUeXBlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgdmFyIHNhZmVQcm9wTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChwcm9wVmFsdWUgJiYgcHJvcFZhbHVlLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIkludmFsaWQgXCIuY29uY2F0KGxvY2F0aW9uLCBcIiBgXCIpLmNvbmNhdChzYWZlUHJvcE5hbWUsIFwiYCBzdXBwbGllZCB0byBgXCIpLmNvbmNhdChjb21wb25lbnROYW1lLCBcImAuIFwiKSArIFwiRXhwZWN0ZWQgYW4gSFRNTEVsZW1lbnQuXCIpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbnZhciByZWZUeXBlID0gUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5vYmplY3RdKTtcbmV4cG9ydCBkZWZhdWx0IHJlZlR5cGU7IiwiaW1wb3J0IHsgZm9ybWF0TXVpRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRNdWlFcnJvck1lc3NhZ2UgfSBmcm9tIFwiQG1hdGVyaWFsLXVpL3V0aWxzXCI7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5cbi8qKlxuICogUmV0dXJucyBhIG51bWJlciB3aG9zZSB2YWx1ZSBpcyBsaW1pdGVkIHRvIHRoZSBnaXZlbiByYW5nZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNsYW1wZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIGxvd2VyIGJvdW5kYXJ5IG9mIHRoZSBvdXRwdXQgcmFuZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSBvdXRwdXQgcmFuZ2VcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEEgbnVtYmVyIGluIHRoZSByYW5nZSBbbWluLCBtYXhdXG4gKi9cbmZ1bmN0aW9uIGNsYW1wKHZhbHVlKSB7XG4gIHZhciBtaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHZhciBtYXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodmFsdWUgPCBtaW4gfHwgdmFsdWUgPiBtYXgpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJNYXRlcmlhbC1VSTogVGhlIHZhbHVlIHByb3ZpZGVkIFwiLmNvbmNhdCh2YWx1ZSwgXCIgaXMgb3V0IG9mIHJhbmdlIFtcIikuY29uY2F0KG1pbiwgXCIsIFwiKS5jb25jYXQobWF4LCBcIl0uXCIpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCB2YWx1ZSksIG1heCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgY29sb3IgZnJvbSBDU1MgaGV4IGZvcm1hdCB0byBDU1MgcmdiIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgLSBIZXggY29sb3IsIGkuZS4gI25ubiBvciAjbm5ubm5uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIENTUyByZ2IgY29sb3Igc3RyaW5nXG4gKi9cblxuXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9SZ2IoY29sb3IpIHtcbiAgY29sb3IgPSBjb2xvci5zdWJzdHIoMSk7XG4gIHZhciByZSA9IG5ldyBSZWdFeHAoXCIuezEsXCIuY29uY2F0KGNvbG9yLmxlbmd0aCA+PSA2ID8gMiA6IDEsIFwifVwiKSwgJ2cnKTtcbiAgdmFyIGNvbG9ycyA9IGNvbG9yLm1hdGNoKHJlKTtcblxuICBpZiAoY29sb3JzICYmIGNvbG9yc1swXS5sZW5ndGggPT09IDEpIHtcbiAgICBjb2xvcnMgPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gbiArIG47XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gY29sb3JzID8gXCJyZ2JcIi5jb25jYXQoY29sb3JzLmxlbmd0aCA9PT0gNCA/ICdhJyA6ICcnLCBcIihcIikuY29uY2F0KGNvbG9ycy5tYXAoZnVuY3Rpb24gKG4sIGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4IDwgMyA/IHBhcnNlSW50KG4sIDE2KSA6IE1hdGgucm91bmQocGFyc2VJbnQobiwgMTYpIC8gMjU1ICogMTAwMCkgLyAxMDAwO1xuICB9KS5qb2luKCcsICcpLCBcIilcIikgOiAnJztcbn1cblxuZnVuY3Rpb24gaW50VG9IZXgoaW50KSB7XG4gIHZhciBoZXggPSBpbnQudG9TdHJpbmcoMTYpO1xuICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gMSA/IFwiMFwiLmNvbmNhdChoZXgpIDogaGV4O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIGNvbG9yIGZyb20gQ1NTIHJnYiBmb3JtYXQgdG8gQ1NTIGhleCBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gUkdCIGNvbG9yLCBpLmUuIHJnYihuLCBuLCBuKVxuICogQHJldHVybnMge3N0cmluZ30gQSBDU1MgcmdiIGNvbG9yIHN0cmluZywgaS5lLiAjbm5ubm5uXG4gKi9cblxuXG5leHBvcnQgZnVuY3Rpb24gcmdiVG9IZXgoY29sb3IpIHtcbiAgLy8gSWRlbXBvdGVudFxuICBpZiAoY29sb3IuaW5kZXhPZignIycpID09PSAwKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgdmFyIF9kZWNvbXBvc2VDb2xvciA9IGRlY29tcG9zZUNvbG9yKGNvbG9yKSxcbiAgICAgIHZhbHVlcyA9IF9kZWNvbXBvc2VDb2xvci52YWx1ZXM7XG5cbiAgcmV0dXJuIFwiI1wiLmNvbmNhdCh2YWx1ZXMubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIGludFRvSGV4KG4pO1xuICB9KS5qb2luKCcnKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgY29sb3IgZnJvbSBoc2wgZm9ybWF0IHRvIHJnYiBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gSFNMIGNvbG9yIHZhbHVlc1xuICogQHJldHVybnMge3N0cmluZ30gcmdiIGNvbG9yIHZhbHVlc1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBoc2xUb1JnYihjb2xvcikge1xuICBjb2xvciA9IGRlY29tcG9zZUNvbG9yKGNvbG9yKTtcbiAgdmFyIF9jb2xvciA9IGNvbG9yLFxuICAgICAgdmFsdWVzID0gX2NvbG9yLnZhbHVlcztcbiAgdmFyIGggPSB2YWx1ZXNbMF07XG4gIHZhciBzID0gdmFsdWVzWzFdIC8gMTAwO1xuICB2YXIgbCA9IHZhbHVlc1syXSAvIDEwMDtcbiAgdmFyIGEgPSBzICogTWF0aC5taW4obCwgMSAtIGwpO1xuXG4gIHZhciBmID0gZnVuY3Rpb24gZihuKSB7XG4gICAgdmFyIGsgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IChuICsgaCAvIDMwKSAlIDEyO1xuICAgIHJldHVybiBsIC0gYSAqIE1hdGgubWF4KE1hdGgubWluKGsgLSAzLCA5IC0gaywgMSksIC0xKTtcbiAgfTtcblxuICB2YXIgdHlwZSA9ICdyZ2InO1xuICB2YXIgcmdiID0gW01hdGgucm91bmQoZigwKSAqIDI1NSksIE1hdGgucm91bmQoZig4KSAqIDI1NSksIE1hdGgucm91bmQoZig0KSAqIDI1NSldO1xuXG4gIGlmIChjb2xvci50eXBlID09PSAnaHNsYScpIHtcbiAgICB0eXBlICs9ICdhJztcbiAgICByZ2IucHVzaCh2YWx1ZXNbM10pO1xuICB9XG5cbiAgcmV0dXJuIHJlY29tcG9zZUNvbG9yKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHZhbHVlczogcmdiXG4gIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSB0eXBlIGFuZCB2YWx1ZXMgb2YgYSBjb2xvci5cbiAqXG4gKiBOb3RlOiBEb2VzIG5vdCBzdXBwb3J0IHJnYiAlIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgLSBDU1MgY29sb3IsIGkuZS4gb25lIG9mOiAjbm5uLCAjbm5ubm5uLCByZ2IoKSwgcmdiYSgpLCBoc2woKSwgaHNsYSgpXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIEEgTVVJIGNvbG9yIG9iamVjdDoge3R5cGU6IHN0cmluZywgdmFsdWVzOiBudW1iZXJbXX1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGVjb21wb3NlQ29sb3IoY29sb3IpIHtcbiAgLy8gSWRlbXBvdGVudFxuICBpZiAoY29sb3IudHlwZSkge1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG4gIGlmIChjb2xvci5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHJldHVybiBkZWNvbXBvc2VDb2xvcihoZXhUb1JnYihjb2xvcikpO1xuICB9XG5cbiAgdmFyIG1hcmtlciA9IGNvbG9yLmluZGV4T2YoJygnKTtcbiAgdmFyIHR5cGUgPSBjb2xvci5zdWJzdHJpbmcoMCwgbWFya2VyKTtcblxuICBpZiAoWydyZ2InLCAncmdiYScsICdoc2wnLCAnaHNsYSddLmluZGV4T2YodHlwZSkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiTWF0ZXJpYWwtVUk6IFVuc3VwcG9ydGVkIGBcIi5jb25jYXQoY29sb3IsIFwiYCBjb2xvci5cXG5XZSBzdXBwb3J0IHRoZSBmb2xsb3dpbmcgZm9ybWF0czogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKS5cIikgOiBfZm9ybWF0TXVpRXJyb3JNZXNzYWdlKDMsIGNvbG9yKSk7XG4gIH1cblxuICB2YXIgdmFsdWVzID0gY29sb3Iuc3Vic3RyaW5nKG1hcmtlciArIDEsIGNvbG9yLmxlbmd0aCAtIDEpLnNwbGl0KCcsJyk7XG4gIHZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHZhbHVlczogdmFsdWVzXG4gIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEgY29sb3Igb2JqZWN0IHdpdGggdHlwZSBhbmQgdmFsdWVzIHRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb2xvciAtIERlY29tcG9zZWQgY29sb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvci50eXBlIC0gT25lIG9mOiAncmdiJywgJ3JnYmEnLCAnaHNsJywgJ2hzbGEnXG4gKiBAcGFyYW0ge2FycmF5fSBjb2xvci52YWx1ZXMgLSBbbixuLG5dIG9yIFtuLG4sbixuXVxuICogQHJldHVybnMge3N0cmluZ30gQSBDU1MgY29sb3Igc3RyaW5nXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJlY29tcG9zZUNvbG9yKGNvbG9yKSB7XG4gIHZhciB0eXBlID0gY29sb3IudHlwZTtcbiAgdmFyIHZhbHVlcyA9IGNvbG9yLnZhbHVlcztcblxuICBpZiAodHlwZS5pbmRleE9mKCdyZ2InKSAhPT0gLTEpIHtcbiAgICAvLyBPbmx5IGNvbnZlcnQgdGhlIGZpcnN0IDMgdmFsdWVzIHRvIGludCAoaS5lLiBub3QgYWxwaGEpXG4gICAgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAobiwgaSkge1xuICAgICAgcmV0dXJuIGkgPCAzID8gcGFyc2VJbnQobiwgMTApIDogbjtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlLmluZGV4T2YoJ2hzbCcpICE9PSAtMSkge1xuICAgIHZhbHVlc1sxXSA9IFwiXCIuY29uY2F0KHZhbHVlc1sxXSwgXCIlXCIpO1xuICAgIHZhbHVlc1syXSA9IFwiXCIuY29uY2F0KHZhbHVlc1syXSwgXCIlXCIpO1xuICB9XG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KHR5cGUsIFwiKFwiKS5jb25jYXQodmFsdWVzLmpvaW4oJywgJyksIFwiKVwiKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY29udHJhc3QgcmF0aW8gYmV0d2VlbiB0d28gY29sb3JzLlxuICpcbiAqIEZvcm11bGE6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAtVEVDSFMvRzE3Lmh0bWwjRzE3LXRlc3RzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvcmVncm91bmQgLSBDU1MgY29sb3IsIGkuZS4gb25lIG9mOiAjbm5uLCAjbm5ubm5uLCByZ2IoKSwgcmdiYSgpLCBoc2woKSwgaHNsYSgpXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFja2dyb3VuZCAtIENTUyBjb2xvciwgaS5lLiBvbmUgb2Y6ICNubm4sICNubm5ubm4sIHJnYigpLCByZ2JhKCksIGhzbCgpLCBoc2xhKClcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEEgY29udHJhc3QgcmF0aW8gdmFsdWUgaW4gdGhlIHJhbmdlIDAgLSAyMS5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udHJhc3RSYXRpbyhmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKSB7XG4gIHZhciBsdW1BID0gZ2V0THVtaW5hbmNlKGZvcmVncm91bmQpO1xuICB2YXIgbHVtQiA9IGdldEx1bWluYW5jZShiYWNrZ3JvdW5kKTtcbiAgcmV0dXJuIChNYXRoLm1heChsdW1BLCBsdW1CKSArIDAuMDUpIC8gKE1hdGgubWluKGx1bUEsIGx1bUIpICsgMC4wNSk7XG59XG4vKipcbiAqIFRoZSByZWxhdGl2ZSBicmlnaHRuZXNzIG9mIGFueSBwb2ludCBpbiBhIGNvbG9yIHNwYWNlLFxuICogbm9ybWFsaXplZCB0byAwIGZvciBkYXJrZXN0IGJsYWNrIGFuZCAxIGZvciBsaWdodGVzdCB3aGl0ZS5cbiAqXG4gKiBGb3JtdWxhOiBodHRwczovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0cxNy5odG1sI0cxNy10ZXN0c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIENTUyBjb2xvciwgaS5lLiBvbmUgb2Y6ICNubm4sICNubm5ubm4sIHJnYigpLCByZ2JhKCksIGhzbCgpLCBoc2xhKClcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByZWxhdGl2ZSBicmlnaHRuZXNzIG9mIHRoZSBjb2xvciBpbiB0aGUgcmFuZ2UgMCAtIDFcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0THVtaW5hbmNlKGNvbG9yKSB7XG4gIGNvbG9yID0gZGVjb21wb3NlQ29sb3IoY29sb3IpO1xuICB2YXIgcmdiID0gY29sb3IudHlwZSA9PT0gJ2hzbCcgPyBkZWNvbXBvc2VDb2xvcihoc2xUb1JnYihjb2xvcikpLnZhbHVlcyA6IGNvbG9yLnZhbHVlcztcbiAgcmdiID0gcmdiLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFsIC89IDI1NTsgLy8gbm9ybWFsaXplZFxuXG4gICAgcmV0dXJuIHZhbCA8PSAwLjAzOTI4ID8gdmFsIC8gMTIuOTIgOiBNYXRoLnBvdygodmFsICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gIH0pOyAvLyBUcnVuY2F0ZSBhdCAzIGRpZ2l0c1xuXG4gIHJldHVybiBOdW1iZXIoKDAuMjEyNiAqIHJnYlswXSArIDAuNzE1MiAqIHJnYlsxXSArIDAuMDcyMiAqIHJnYlsyXSkudG9GaXhlZCgzKSk7XG59XG4vKipcbiAqIERhcmtlbiBvciBsaWdodGVuIGEgY29sb3IsIGRlcGVuZGluZyBvbiBpdHMgbHVtaW5hbmNlLlxuICogTGlnaHQgY29sb3JzIGFyZSBkYXJrZW5lZCwgZGFyayBjb2xvcnMgYXJlIGxpZ2h0ZW5lZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgLSBDU1MgY29sb3IsIGkuZS4gb25lIG9mOiAjbm5uLCAjbm5ubm5uLCByZ2IoKSwgcmdiYSgpLCBoc2woKSwgaHNsYSgpXG4gKiBAcGFyYW0ge251bWJlcn0gY29lZmZpY2llbnQ9MC4xNSAtIG11bHRpcGxpZXIgaW4gdGhlIHJhbmdlIDAgLSAxXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIENTUyBjb2xvciBzdHJpbmcuIEhleCBpbnB1dCB2YWx1ZXMgYXJlIHJldHVybmVkIGFzIHJnYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlbXBoYXNpemUoY29sb3IpIHtcbiAgdmFyIGNvZWZmaWNpZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwLjE1O1xuICByZXR1cm4gZ2V0THVtaW5hbmNlKGNvbG9yKSA+IDAuNSA/IGRhcmtlbihjb2xvciwgY29lZmZpY2llbnQpIDogbGlnaHRlbihjb2xvciwgY29lZmZpY2llbnQpO1xufVxudmFyIHdhcm5lZE9uY2UgPSBmYWxzZTtcbi8qKlxuICogU2V0IHRoZSBhYnNvbHV0ZSB0cmFuc3BhcmVuY3kgb2YgYSBjb2xvci5cbiAqIEFueSBleGlzdGluZyBhbHBoYSB2YWx1ZXMgYXJlIG92ZXJ3cml0dGVuLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIENTUyBjb2xvciwgaS5lLiBvbmUgb2Y6ICNubm4sICNubm5ubm4sIHJnYigpLCByZ2JhKCksIGhzbCgpLCBoc2xhKClcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlIHRvIHNldCB0aGUgYWxwaGEgY2hhbm5lbCB0byBpbiB0aGUgcmFuZ2UgMCAtMVxuICogQHJldHVybnMge3N0cmluZ30gQSBDU1MgY29sb3Igc3RyaW5nLiBIZXggaW5wdXQgdmFsdWVzIGFyZSByZXR1cm5lZCBhcyByZ2JcbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogVXNlIGBpbXBvcnQgeyBhbHBoYSB9IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL3N0eWxlcydgIGluc3RlYWQuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZhZGUoY29sb3IsIHZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKCF3YXJuZWRPbmNlKSB7XG4gICAgICB3YXJuZWRPbmNlID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydNYXRlcmlhbC1VSTogVGhlIGBmYWRlYCBjb2xvciB1dGlsaXR5IHdhcyByZW5hbWVkIHRvIGBhbHBoYWAgdG8gYmV0dGVyIGRlc2NyaWJlIGl0cyBmdW5jdGlvbmFsaXR5LicsICcnLCBcIllvdSBzaG91bGQgdXNlIGBpbXBvcnQgeyBhbHBoYSB9IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL3N0eWxlcydgXCJdLmpvaW4oJ1xcbicpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYWxwaGEoY29sb3IsIHZhbHVlKTtcbn1cbi8qKlxuICogU2V0IHRoZSBhYnNvbHV0ZSB0cmFuc3BhcmVuY3kgb2YgYSBjb2xvci5cbiAqIEFueSBleGlzdGluZyBhbHBoYSB2YWx1ZSBpcyBvdmVyd3JpdHRlbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgLSBDU1MgY29sb3IsIGkuZS4gb25lIG9mOiAjbm5uLCAjbm5ubm5uLCByZ2IoKSwgcmdiYSgpLCBoc2woKSwgaHNsYSgpXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB2YWx1ZSB0byBzZXQgdGhlIGFscGhhIGNoYW5uZWwgdG8gaW4gdGhlIHJhbmdlIDAtMVxuICogQHJldHVybnMge3N0cmluZ30gQSBDU1MgY29sb3Igc3RyaW5nLiBIZXggaW5wdXQgdmFsdWVzIGFyZSByZXR1cm5lZCBhcyByZ2JcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWxwaGEoY29sb3IsIHZhbHVlKSB7XG4gIGNvbG9yID0gZGVjb21wb3NlQ29sb3IoY29sb3IpO1xuICB2YWx1ZSA9IGNsYW1wKHZhbHVlKTtcblxuICBpZiAoY29sb3IudHlwZSA9PT0gJ3JnYicgfHwgY29sb3IudHlwZSA9PT0gJ2hzbCcpIHtcbiAgICBjb2xvci50eXBlICs9ICdhJztcbiAgfVxuXG4gIGNvbG9yLnZhbHVlc1szXSA9IHZhbHVlO1xuICByZXR1cm4gcmVjb21wb3NlQ29sb3IoY29sb3IpO1xufVxuLyoqXG4gKiBEYXJrZW5zIGEgY29sb3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKVxuICogQHBhcmFtIHtudW1iZXJ9IGNvZWZmaWNpZW50IC0gbXVsdGlwbGllciBpbiB0aGUgcmFuZ2UgMCAtIDFcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZy4gSGV4IGlucHV0IHZhbHVlcyBhcmUgcmV0dXJuZWQgYXMgcmdiXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRhcmtlbihjb2xvciwgY29lZmZpY2llbnQpIHtcbiAgY29sb3IgPSBkZWNvbXBvc2VDb2xvcihjb2xvcik7XG4gIGNvZWZmaWNpZW50ID0gY2xhbXAoY29lZmZpY2llbnQpO1xuXG4gIGlmIChjb2xvci50eXBlLmluZGV4T2YoJ2hzbCcpICE9PSAtMSkge1xuICAgIGNvbG9yLnZhbHVlc1syXSAqPSAxIC0gY29lZmZpY2llbnQ7XG4gIH0gZWxzZSBpZiAoY29sb3IudHlwZS5pbmRleE9mKCdyZ2InKSAhPT0gLTEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkgKz0gMSkge1xuICAgICAgY29sb3IudmFsdWVzW2ldICo9IDEgLSBjb2VmZmljaWVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVjb21wb3NlQ29sb3IoY29sb3IpO1xufVxuLyoqXG4gKiBMaWdodGVucyBhIGNvbG9yLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIENTUyBjb2xvciwgaS5lLiBvbmUgb2Y6ICNubm4sICNubm5ubm4sIHJnYigpLCByZ2JhKCksIGhzbCgpLCBoc2xhKClcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2VmZmljaWVudCAtIG11bHRpcGxpZXIgaW4gdGhlIHJhbmdlIDAgLSAxXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIENTUyBjb2xvciBzdHJpbmcuIEhleCBpbnB1dCB2YWx1ZXMgYXJlIHJldHVybmVkIGFzIHJnYlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsaWdodGVuKGNvbG9yLCBjb2VmZmljaWVudCkge1xuICBjb2xvciA9IGRlY29tcG9zZUNvbG9yKGNvbG9yKTtcbiAgY29lZmZpY2llbnQgPSBjbGFtcChjb2VmZmljaWVudCk7XG5cbiAgaWYgKGNvbG9yLnR5cGUuaW5kZXhPZignaHNsJykgIT09IC0xKSB7XG4gICAgY29sb3IudmFsdWVzWzJdICs9ICgxMDAgLSBjb2xvci52YWx1ZXNbMl0pICogY29lZmZpY2llbnQ7XG4gIH0gZWxzZSBpZiAoY29sb3IudHlwZS5pbmRleE9mKCdyZ2InKSAhPT0gLTEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkgKz0gMSkge1xuICAgICAgY29sb3IudmFsdWVzW2ldICs9ICgyNTUgLSBjb2xvci52YWx1ZXNbaV0pICogY29lZmZpY2llbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlY29tcG9zZUNvbG9yKGNvbG9yKTtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG4vLyBTb3J0ZWQgQVNDIGJ5IHNpemUuIFRoYXQncyBpbXBvcnRhbnQuXG4vLyBJdCBjYW4ndCBiZSBjb25maWd1cmVkIGFzIGl0J3MgdXNlZCBzdGF0aWNhbGx5IGZvciBwcm9wVHlwZXMuXG5leHBvcnQgdmFyIGtleXMgPSBbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ107IC8vIEtlZXAgaW4gbWluZCB0aGF0IEBtZWRpYSBpcyBpbmNsdXNpdmUgYnkgdGhlIENTUyBzcGVjaWZpY2F0aW9uLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVCcmVha3BvaW50cyhicmVha3BvaW50cykge1xuICB2YXIgX2JyZWFrcG9pbnRzJHZhbHVlcyA9IGJyZWFrcG9pbnRzLnZhbHVlcyxcbiAgICAgIHZhbHVlcyA9IF9icmVha3BvaW50cyR2YWx1ZXMgPT09IHZvaWQgMCA/IHtcbiAgICB4czogMCxcbiAgICBzbTogNjAwLFxuICAgIG1kOiA5NjAsXG4gICAgbGc6IDEyODAsXG4gICAgeGw6IDE5MjBcbiAgfSA6IF9icmVha3BvaW50cyR2YWx1ZXMsXG4gICAgICBfYnJlYWtwb2ludHMkdW5pdCA9IGJyZWFrcG9pbnRzLnVuaXQsXG4gICAgICB1bml0ID0gX2JyZWFrcG9pbnRzJHVuaXQgPT09IHZvaWQgMCA/ICdweCcgOiBfYnJlYWtwb2ludHMkdW5pdCxcbiAgICAgIF9icmVha3BvaW50cyRzdGVwID0gYnJlYWtwb2ludHMuc3RlcCxcbiAgICAgIHN0ZXAgPSBfYnJlYWtwb2ludHMkc3RlcCA9PT0gdm9pZCAwID8gNSA6IF9icmVha3BvaW50cyRzdGVwLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoYnJlYWtwb2ludHMsIFtcInZhbHVlc1wiLCBcInVuaXRcIiwgXCJzdGVwXCJdKTtcblxuICBmdW5jdGlvbiB1cChrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSB0eXBlb2YgdmFsdWVzW2tleV0gPT09ICdudW1iZXInID8gdmFsdWVzW2tleV0gOiBrZXk7XG4gICAgcmV0dXJuIFwiQG1lZGlhIChtaW4td2lkdGg6XCIuY29uY2F0KHZhbHVlKS5jb25jYXQodW5pdCwgXCIpXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZG93bihrZXkpIHtcbiAgICB2YXIgZW5kSW5kZXggPSBrZXlzLmluZGV4T2Yoa2V5KSArIDE7XG4gICAgdmFyIHVwcGVyYm91bmQgPSB2YWx1ZXNba2V5c1tlbmRJbmRleF1dO1xuXG4gICAgaWYgKGVuZEluZGV4ID09PSBrZXlzLmxlbmd0aCkge1xuICAgICAgLy8geGwgZG93biBhcHBsaWVzIHRvIGFsbCBzaXplc1xuICAgICAgcmV0dXJuIHVwKCd4cycpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHR5cGVvZiB1cHBlcmJvdW5kID09PSAnbnVtYmVyJyAmJiBlbmRJbmRleCA+IDAgPyB1cHBlcmJvdW5kIDoga2V5O1xuICAgIHJldHVybiBcIkBtZWRpYSAobWF4LXdpZHRoOlwiLmNvbmNhdCh2YWx1ZSAtIHN0ZXAgLyAxMDApLmNvbmNhdCh1bml0LCBcIilcIik7XG4gIH1cblxuICBmdW5jdGlvbiBiZXR3ZWVuKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgZW5kSW5kZXggPSBrZXlzLmluZGV4T2YoZW5kKTtcblxuICAgIGlmIChlbmRJbmRleCA9PT0ga2V5cy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gdXAoc3RhcnQpO1xuICAgIH1cblxuICAgIHJldHVybiBcIkBtZWRpYSAobWluLXdpZHRoOlwiLmNvbmNhdCh0eXBlb2YgdmFsdWVzW3N0YXJ0XSA9PT0gJ251bWJlcicgPyB2YWx1ZXNbc3RhcnRdIDogc3RhcnQpLmNvbmNhdCh1bml0LCBcIikgYW5kIFwiKSArIFwiKG1heC13aWR0aDpcIi5jb25jYXQoKGVuZEluZGV4ICE9PSAtMSAmJiB0eXBlb2YgdmFsdWVzW2tleXNbZW5kSW5kZXggKyAxXV0gPT09ICdudW1iZXInID8gdmFsdWVzW2tleXNbZW5kSW5kZXggKyAxXV0gOiBlbmQpIC0gc3RlcCAvIDEwMCkuY29uY2F0KHVuaXQsIFwiKVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubHkoa2V5KSB7XG4gICAgcmV0dXJuIGJldHdlZW4oa2V5LCBrZXkpO1xuICB9XG5cbiAgdmFyIHdhcm5lZE9uY2UgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3aWR0aChrZXkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCF3YXJuZWRPbmNlKSB7XG4gICAgICAgIHdhcm5lZE9uY2UgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLndhcm4oW1wiTWF0ZXJpYWwtVUk6IFRoZSBgdGhlbWUuYnJlYWtwb2ludHMud2lkdGhgIHV0aWxpdHkgaXMgZGVwcmVjYXRlZCBiZWNhdXNlIGl0J3MgcmVkdW5kYW50LlwiLCAnVXNlIHRoZSBgdGhlbWUuYnJlYWtwb2ludHMudmFsdWVzYCBpbnN0ZWFkLiddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzW2tleV07XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIGtleXM6IGtleXMsXG4gICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgdXA6IHVwLFxuICAgIGRvd246IGRvd24sXG4gICAgYmV0d2VlbjogYmV0d2VlbixcbiAgICBvbmx5OiBvbmx5LFxuICAgIHdpZHRoOiB3aWR0aFxuICB9LCBvdGhlcik7XG59IiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlTWl4aW5zKGJyZWFrcG9pbnRzLCBzcGFjaW5nLCBtaXhpbnMpIHtcbiAgdmFyIF90b29sYmFyO1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgZ3V0dGVyczogZnVuY3Rpb24gZ3V0dGVycygpIHtcbiAgICAgIHZhciBzdHlsZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgY29uc29sZS53YXJuKFsnTWF0ZXJpYWwtVUk6IHRoZW1lLm1peGlucy5ndXR0ZXJzKCkgaXMgZGVwcmVjYXRlZC4nLCAnWW91IGNhbiB1c2UgdGhlIHNvdXJjZSBvZiB0aGUgbWl4aW4gZGlyZWN0bHk6JywgXCJcXG4gICAgICBwYWRkaW5nTGVmdDogdGhlbWUuc3BhY2luZygyKSxcXG4gICAgICBwYWRkaW5nUmlnaHQ6IHRoZW1lLnNwYWNpbmcoMiksXFxuICAgICAgW3RoZW1lLmJyZWFrcG9pbnRzLnVwKCdzbScpXToge1xcbiAgICAgICAgcGFkZGluZ0xlZnQ6IHRoZW1lLnNwYWNpbmcoMyksXFxuICAgICAgICBwYWRkaW5nUmlnaHQ6IHRoZW1lLnNwYWNpbmcoMyksXFxuICAgICAgfSxcXG4gICAgICBcIl0uam9pbignXFxuJykpO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgcGFkZGluZ0xlZnQ6IHNwYWNpbmcoMiksXG4gICAgICAgIHBhZGRpbmdSaWdodDogc3BhY2luZygyKVxuICAgICAgfSwgc3R5bGVzLCBfZGVmaW5lUHJvcGVydHkoe30sIGJyZWFrcG9pbnRzLnVwKCdzbScpLCBfZXh0ZW5kcyh7XG4gICAgICAgIHBhZGRpbmdMZWZ0OiBzcGFjaW5nKDMpLFxuICAgICAgICBwYWRkaW5nUmlnaHQ6IHNwYWNpbmcoMylcbiAgICAgIH0sIHN0eWxlc1ticmVha3BvaW50cy51cCgnc20nKV0pKSk7XG4gICAgfSxcbiAgICB0b29sYmFyOiAoX3Rvb2xiYXIgPSB7XG4gICAgICBtaW5IZWlnaHQ6IDU2XG4gICAgfSwgX2RlZmluZVByb3BlcnR5KF90b29sYmFyLCBcIlwiLmNvbmNhdChicmVha3BvaW50cy51cCgneHMnKSwgXCIgYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKVwiKSwge1xuICAgICAgbWluSGVpZ2h0OiA0OFxuICAgIH0pLCBfZGVmaW5lUHJvcGVydHkoX3Rvb2xiYXIsIGJyZWFrcG9pbnRzLnVwKCdzbScpLCB7XG4gICAgICBtaW5IZWlnaHQ6IDY0XG4gICAgfSksIF90b29sYmFyKVxuICB9LCBtaXhpbnMpO1xufSIsInZhciBjb21tb24gPSB7XG4gIGJsYWNrOiAnIzAwMCcsXG4gIHdoaXRlOiAnI2ZmZidcbn07XG5leHBvcnQgZGVmYXVsdCBjb21tb247IiwidmFyIGdyZXkgPSB7XG4gIDUwOiAnI2ZhZmFmYScsXG4gIDEwMDogJyNmNWY1ZjUnLFxuICAyMDA6ICcjZWVlZWVlJyxcbiAgMzAwOiAnI2UwZTBlMCcsXG4gIDQwMDogJyNiZGJkYmQnLFxuICA1MDA6ICcjOWU5ZTllJyxcbiAgNjAwOiAnIzc1NzU3NScsXG4gIDcwMDogJyM2MTYxNjEnLFxuICA4MDA6ICcjNDI0MjQyJyxcbiAgOTAwOiAnIzIxMjEyMScsXG4gIEExMDA6ICcjZDVkNWQ1JyxcbiAgQTIwMDogJyNhYWFhYWEnLFxuICBBNDAwOiAnIzMwMzAzMCcsXG4gIEE3MDA6ICcjNjE2MTYxJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGdyZXk7IiwidmFyIGluZGlnbyA9IHtcbiAgNTA6ICcjZThlYWY2JyxcbiAgMTAwOiAnI2M1Y2FlOScsXG4gIDIwMDogJyM5ZmE4ZGEnLFxuICAzMDA6ICcjNzk4NmNiJyxcbiAgNDAwOiAnIzVjNmJjMCcsXG4gIDUwMDogJyMzZjUxYjUnLFxuICA2MDA6ICcjMzk0OWFiJyxcbiAgNzAwOiAnIzMwM2Y5ZicsXG4gIDgwMDogJyMyODM1OTMnLFxuICA5MDA6ICcjMWEyMzdlJyxcbiAgQTEwMDogJyM4YzllZmYnLFxuICBBMjAwOiAnIzUzNmRmZScsXG4gIEE0MDA6ICcjM2Q1YWZlJyxcbiAgQTcwMDogJyMzMDRmZmUnXG59O1xuZXhwb3J0IGRlZmF1bHQgaW5kaWdvOyIsInZhciBwaW5rID0ge1xuICA1MDogJyNmY2U0ZWMnLFxuICAxMDA6ICcjZjhiYmQwJyxcbiAgMjAwOiAnI2Y0OGZiMScsXG4gIDMwMDogJyNmMDYyOTInLFxuICA0MDA6ICcjZWM0MDdhJyxcbiAgNTAwOiAnI2U5MWU2MycsXG4gIDYwMDogJyNkODFiNjAnLFxuICA3MDA6ICcjYzIxODViJyxcbiAgODAwOiAnI2FkMTQ1NycsXG4gIDkwMDogJyM4ODBlNGYnLFxuICBBMTAwOiAnI2ZmODBhYicsXG4gIEEyMDA6ICcjZmY0MDgxJyxcbiAgQTQwMDogJyNmNTAwNTcnLFxuICBBNzAwOiAnI2M1MTE2Midcbn07XG5leHBvcnQgZGVmYXVsdCBwaW5rOyIsInZhciByZWQgPSB7XG4gIDUwOiAnI2ZmZWJlZScsXG4gIDEwMDogJyNmZmNkZDInLFxuICAyMDA6ICcjZWY5YTlhJyxcbiAgMzAwOiAnI2U1NzM3MycsXG4gIDQwMDogJyNlZjUzNTAnLFxuICA1MDA6ICcjZjQ0MzM2JyxcbiAgNjAwOiAnI2U1MzkzNScsXG4gIDcwMDogJyNkMzJmMmYnLFxuICA4MDA6ICcjYzYyODI4JyxcbiAgOTAwOiAnI2I3MWMxYycsXG4gIEExMDA6ICcjZmY4YTgwJyxcbiAgQTIwMDogJyNmZjUyNTInLFxuICBBNDAwOiAnI2ZmMTc0NCcsXG4gIEE3MDA6ICcjZDUwMDAwJ1xufTtcbmV4cG9ydCBkZWZhdWx0IHJlZDsiLCJ2YXIgb3JhbmdlID0ge1xuICA1MDogJyNmZmYzZTAnLFxuICAxMDA6ICcjZmZlMGIyJyxcbiAgMjAwOiAnI2ZmY2M4MCcsXG4gIDMwMDogJyNmZmI3NGQnLFxuICA0MDA6ICcjZmZhNzI2JyxcbiAgNTAwOiAnI2ZmOTgwMCcsXG4gIDYwMDogJyNmYjhjMDAnLFxuICA3MDA6ICcjZjU3YzAwJyxcbiAgODAwOiAnI2VmNmMwMCcsXG4gIDkwMDogJyNlNjUxMDAnLFxuICBBMTAwOiAnI2ZmZDE4MCcsXG4gIEEyMDA6ICcjZmZhYjQwJyxcbiAgQTQwMDogJyNmZjkxMDAnLFxuICBBNzAwOiAnI2ZmNmQwMCdcbn07XG5leHBvcnQgZGVmYXVsdCBvcmFuZ2U7IiwidmFyIGJsdWUgPSB7XG4gIDUwOiAnI2UzZjJmZCcsXG4gIDEwMDogJyNiYmRlZmInLFxuICAyMDA6ICcjOTBjYWY5JyxcbiAgMzAwOiAnIzY0YjVmNicsXG4gIDQwMDogJyM0MmE1ZjUnLFxuICA1MDA6ICcjMjE5NmYzJyxcbiAgNjAwOiAnIzFlODhlNScsXG4gIDcwMDogJyMxOTc2ZDInLFxuICA4MDA6ICcjMTU2NWMwJyxcbiAgOTAwOiAnIzBkNDdhMScsXG4gIEExMDA6ICcjODJiMWZmJyxcbiAgQTIwMDogJyM0NDhhZmYnLFxuICBBNDAwOiAnIzI5NzlmZicsXG4gIEE3MDA6ICcjMjk2MmZmJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGJsdWU7IiwidmFyIGdyZWVuID0ge1xuICA1MDogJyNlOGY1ZTknLFxuICAxMDA6ICcjYzhlNmM5JyxcbiAgMjAwOiAnI2E1ZDZhNycsXG4gIDMwMDogJyM4MWM3ODQnLFxuICA0MDA6ICcjNjZiYjZhJyxcbiAgNTAwOiAnIzRjYWY1MCcsXG4gIDYwMDogJyM0M2EwNDcnLFxuICA3MDA6ICcjMzg4ZTNjJyxcbiAgODAwOiAnIzJlN2QzMicsXG4gIDkwMDogJyMxYjVlMjAnLFxuICBBMTAwOiAnI2I5ZjZjYScsXG4gIEEyMDA6ICcjNjlmMGFlJyxcbiAgQTQwMDogJyMwMGU2NzYnLFxuICBBNzAwOiAnIzAwYzg1Mydcbn07XG5leHBvcnQgZGVmYXVsdCBncmVlbjsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBmb3JtYXRNdWlFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdE11aUVycm9yTWVzc2FnZSB9IGZyb20gXCJAbWF0ZXJpYWwtdWkvdXRpbHNcIjtcbmltcG9ydCB7IGRlZXBtZXJnZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgY29tbW9uIGZyb20gJy4uL2NvbG9ycy9jb21tb24nO1xuaW1wb3J0IGdyZXkgZnJvbSAnLi4vY29sb3JzL2dyZXknO1xuaW1wb3J0IGluZGlnbyBmcm9tICcuLi9jb2xvcnMvaW5kaWdvJztcbmltcG9ydCBwaW5rIGZyb20gJy4uL2NvbG9ycy9waW5rJztcbmltcG9ydCByZWQgZnJvbSAnLi4vY29sb3JzL3JlZCc7XG5pbXBvcnQgb3JhbmdlIGZyb20gJy4uL2NvbG9ycy9vcmFuZ2UnO1xuaW1wb3J0IGJsdWUgZnJvbSAnLi4vY29sb3JzL2JsdWUnO1xuaW1wb3J0IGdyZWVuIGZyb20gJy4uL2NvbG9ycy9ncmVlbic7XG5pbXBvcnQgeyBkYXJrZW4sIGdldENvbnRyYXN0UmF0aW8sIGxpZ2h0ZW4gfSBmcm9tICcuL2NvbG9yTWFuaXB1bGF0b3InO1xuZXhwb3J0IHZhciBsaWdodCA9IHtcbiAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIHN0eWxlIHRoZSB0ZXh0LlxuICB0ZXh0OiB7XG4gICAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHRleHQuXG4gICAgcHJpbWFyeTogJ3JnYmEoMCwgMCwgMCwgMC44NyknLFxuICAgIC8vIFNlY29uZGFyeSB0ZXh0LlxuICAgIHNlY29uZGFyeTogJ3JnYmEoMCwgMCwgMCwgMC41NCknLFxuICAgIC8vIERpc2FibGVkIHRleHQgaGF2ZSBldmVuIGxvd2VyIHZpc3VhbCBwcm9taW5lbmNlLlxuICAgIGRpc2FibGVkOiAncmdiYSgwLCAwLCAwLCAwLjM4KScsXG4gICAgLy8gVGV4dCBoaW50cy5cbiAgICBoaW50OiAncmdiYSgwLCAwLCAwLCAwLjM4KSdcbiAgfSxcbiAgLy8gVGhlIGNvbG9yIHVzZWQgdG8gZGl2aWRlIGRpZmZlcmVudCBlbGVtZW50cy5cbiAgZGl2aWRlcjogJ3JnYmEoMCwgMCwgMCwgMC4xMiknLFxuICAvLyBUaGUgYmFja2dyb3VuZCBjb2xvcnMgdXNlZCB0byBzdHlsZSB0aGUgc3VyZmFjZXMuXG4gIC8vIENvbnNpc3RlbmN5IGJldHdlZW4gdGhlc2UgdmFsdWVzIGlzIGltcG9ydGFudC5cbiAgYmFja2dyb3VuZDoge1xuICAgIHBhcGVyOiBjb21tb24ud2hpdGUsXG4gICAgZGVmYXVsdDogZ3JleVs1MF1cbiAgfSxcbiAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIHN0eWxlIHRoZSBhY3Rpb24gZWxlbWVudHMuXG4gIGFjdGlvbjoge1xuICAgIC8vIFRoZSBjb2xvciBvZiBhbiBhY3RpdmUgYWN0aW9uIGxpa2UgYW4gaWNvbiBidXR0b24uXG4gICAgYWN0aXZlOiAncmdiYSgwLCAwLCAwLCAwLjU0KScsXG4gICAgLy8gVGhlIGNvbG9yIG9mIGFuIGhvdmVyZWQgYWN0aW9uLlxuICAgIGhvdmVyOiAncmdiYSgwLCAwLCAwLCAwLjA0KScsXG4gICAgaG92ZXJPcGFjaXR5OiAwLjA0LFxuICAgIC8vIFRoZSBjb2xvciBvZiBhIHNlbGVjdGVkIGFjdGlvbi5cbiAgICBzZWxlY3RlZDogJ3JnYmEoMCwgMCwgMCwgMC4wOCknLFxuICAgIHNlbGVjdGVkT3BhY2l0eTogMC4wOCxcbiAgICAvLyBUaGUgY29sb3Igb2YgYSBkaXNhYmxlZCBhY3Rpb24uXG4gICAgZGlzYWJsZWQ6ICdyZ2JhKDAsIDAsIDAsIDAuMjYpJyxcbiAgICAvLyBUaGUgYmFja2dyb3VuZCBjb2xvciBvZiBhIGRpc2FibGVkIGFjdGlvbi5cbiAgICBkaXNhYmxlZEJhY2tncm91bmQ6ICdyZ2JhKDAsIDAsIDAsIDAuMTIpJyxcbiAgICBkaXNhYmxlZE9wYWNpdHk6IDAuMzgsXG4gICAgZm9jdXM6ICdyZ2JhKDAsIDAsIDAsIDAuMTIpJyxcbiAgICBmb2N1c09wYWNpdHk6IDAuMTIsXG4gICAgYWN0aXZhdGVkT3BhY2l0eTogMC4xMlxuICB9XG59O1xuZXhwb3J0IHZhciBkYXJrID0ge1xuICB0ZXh0OiB7XG4gICAgcHJpbWFyeTogY29tbW9uLndoaXRlLFxuICAgIHNlY29uZGFyeTogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43KScsXG4gICAgZGlzYWJsZWQ6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSknLFxuICAgIGhpbnQ6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSknLFxuICAgIGljb246ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSknXG4gIH0sXG4gIGRpdmlkZXI6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTIpJyxcbiAgYmFja2dyb3VuZDoge1xuICAgIHBhcGVyOiBncmV5WzgwMF0sXG4gICAgZGVmYXVsdDogJyMzMDMwMzAnXG4gIH0sXG4gIGFjdGlvbjoge1xuICAgIGFjdGl2ZTogY29tbW9uLndoaXRlLFxuICAgIGhvdmVyOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjA4KScsXG4gICAgaG92ZXJPcGFjaXR5OiAwLjA4LFxuICAgIHNlbGVjdGVkOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjE2KScsXG4gICAgc2VsZWN0ZWRPcGFjaXR5OiAwLjE2LFxuICAgIGRpc2FibGVkOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpJyxcbiAgICBkaXNhYmxlZEJhY2tncm91bmQ6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTIpJyxcbiAgICBkaXNhYmxlZE9wYWNpdHk6IDAuMzgsXG4gICAgZm9jdXM6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTIpJyxcbiAgICBmb2N1c09wYWNpdHk6IDAuMTIsXG4gICAgYWN0aXZhdGVkT3BhY2l0eTogMC4yNFxuICB9XG59O1xuXG5mdW5jdGlvbiBhZGRMaWdodE9yRGFyayhpbnRlbnQsIGRpcmVjdGlvbiwgc2hhZGUsIHRvbmFsT2Zmc2V0KSB7XG4gIHZhciB0b25hbE9mZnNldExpZ2h0ID0gdG9uYWxPZmZzZXQubGlnaHQgfHwgdG9uYWxPZmZzZXQ7XG4gIHZhciB0b25hbE9mZnNldERhcmsgPSB0b25hbE9mZnNldC5kYXJrIHx8IHRvbmFsT2Zmc2V0ICogMS41O1xuXG4gIGlmICghaW50ZW50W2RpcmVjdGlvbl0pIHtcbiAgICBpZiAoaW50ZW50Lmhhc093blByb3BlcnR5KHNoYWRlKSkge1xuICAgICAgaW50ZW50W2RpcmVjdGlvbl0gPSBpbnRlbnRbc2hhZGVdO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnbGlnaHQnKSB7XG4gICAgICBpbnRlbnQubGlnaHQgPSBsaWdodGVuKGludGVudC5tYWluLCB0b25hbE9mZnNldExpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2RhcmsnKSB7XG4gICAgICBpbnRlbnQuZGFyayA9IGRhcmtlbihpbnRlbnQubWFpbiwgdG9uYWxPZmZzZXREYXJrKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlUGFsZXR0ZShwYWxldHRlKSB7XG4gIHZhciBfcGFsZXR0ZSRwcmltYXJ5ID0gcGFsZXR0ZS5wcmltYXJ5LFxuICAgICAgcHJpbWFyeSA9IF9wYWxldHRlJHByaW1hcnkgPT09IHZvaWQgMCA/IHtcbiAgICBsaWdodDogaW5kaWdvWzMwMF0sXG4gICAgbWFpbjogaW5kaWdvWzUwMF0sXG4gICAgZGFyazogaW5kaWdvWzcwMF1cbiAgfSA6IF9wYWxldHRlJHByaW1hcnksXG4gICAgICBfcGFsZXR0ZSRzZWNvbmRhcnkgPSBwYWxldHRlLnNlY29uZGFyeSxcbiAgICAgIHNlY29uZGFyeSA9IF9wYWxldHRlJHNlY29uZGFyeSA9PT0gdm9pZCAwID8ge1xuICAgIGxpZ2h0OiBwaW5rLkEyMDAsXG4gICAgbWFpbjogcGluay5BNDAwLFxuICAgIGRhcms6IHBpbmsuQTcwMFxuICB9IDogX3BhbGV0dGUkc2Vjb25kYXJ5LFxuICAgICAgX3BhbGV0dGUkZXJyb3IgPSBwYWxldHRlLmVycm9yLFxuICAgICAgZXJyb3IgPSBfcGFsZXR0ZSRlcnJvciA9PT0gdm9pZCAwID8ge1xuICAgIGxpZ2h0OiByZWRbMzAwXSxcbiAgICBtYWluOiByZWRbNTAwXSxcbiAgICBkYXJrOiByZWRbNzAwXVxuICB9IDogX3BhbGV0dGUkZXJyb3IsXG4gICAgICBfcGFsZXR0ZSR3YXJuaW5nID0gcGFsZXR0ZS53YXJuaW5nLFxuICAgICAgd2FybmluZyA9IF9wYWxldHRlJHdhcm5pbmcgPT09IHZvaWQgMCA/IHtcbiAgICBsaWdodDogb3JhbmdlWzMwMF0sXG4gICAgbWFpbjogb3JhbmdlWzUwMF0sXG4gICAgZGFyazogb3JhbmdlWzcwMF1cbiAgfSA6IF9wYWxldHRlJHdhcm5pbmcsXG4gICAgICBfcGFsZXR0ZSRpbmZvID0gcGFsZXR0ZS5pbmZvLFxuICAgICAgaW5mbyA9IF9wYWxldHRlJGluZm8gPT09IHZvaWQgMCA/IHtcbiAgICBsaWdodDogYmx1ZVszMDBdLFxuICAgIG1haW46IGJsdWVbNTAwXSxcbiAgICBkYXJrOiBibHVlWzcwMF1cbiAgfSA6IF9wYWxldHRlJGluZm8sXG4gICAgICBfcGFsZXR0ZSRzdWNjZXNzID0gcGFsZXR0ZS5zdWNjZXNzLFxuICAgICAgc3VjY2VzcyA9IF9wYWxldHRlJHN1Y2Nlc3MgPT09IHZvaWQgMCA/IHtcbiAgICBsaWdodDogZ3JlZW5bMzAwXSxcbiAgICBtYWluOiBncmVlbls1MDBdLFxuICAgIGRhcms6IGdyZWVuWzcwMF1cbiAgfSA6IF9wYWxldHRlJHN1Y2Nlc3MsXG4gICAgICBfcGFsZXR0ZSR0eXBlID0gcGFsZXR0ZS50eXBlLFxuICAgICAgdHlwZSA9IF9wYWxldHRlJHR5cGUgPT09IHZvaWQgMCA/ICdsaWdodCcgOiBfcGFsZXR0ZSR0eXBlLFxuICAgICAgX3BhbGV0dGUkY29udHJhc3RUaHJlID0gcGFsZXR0ZS5jb250cmFzdFRocmVzaG9sZCxcbiAgICAgIGNvbnRyYXN0VGhyZXNob2xkID0gX3BhbGV0dGUkY29udHJhc3RUaHJlID09PSB2b2lkIDAgPyAzIDogX3BhbGV0dGUkY29udHJhc3RUaHJlLFxuICAgICAgX3BhbGV0dGUkdG9uYWxPZmZzZXQgPSBwYWxldHRlLnRvbmFsT2Zmc2V0LFxuICAgICAgdG9uYWxPZmZzZXQgPSBfcGFsZXR0ZSR0b25hbE9mZnNldCA9PT0gdm9pZCAwID8gMC4yIDogX3BhbGV0dGUkdG9uYWxPZmZzZXQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwYWxldHRlLCBbXCJwcmltYXJ5XCIsIFwic2Vjb25kYXJ5XCIsIFwiZXJyb3JcIiwgXCJ3YXJuaW5nXCIsIFwiaW5mb1wiLCBcInN1Y2Nlc3NcIiwgXCJ0eXBlXCIsIFwiY29udHJhc3RUaHJlc2hvbGRcIiwgXCJ0b25hbE9mZnNldFwiXSk7IC8vIFVzZSB0aGUgc2FtZSBsb2dpYyBhc1xuICAvLyBCb290c3RyYXA6IGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iLzFkNmUzNzEwZGQ0NDdkZTFhMjAwZjI5ZThmYTUyMWY4YTA5MDhmNzAvc2Nzcy9fZnVuY3Rpb25zLnNjc3MjTDU5XG4gIC8vIGFuZCBtYXRlcmlhbC1jb21wb25lbnRzLXdlYiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL2FjNDZiODg2M2M0ZGFiOWZjMjJjNGM2NjJkYzZiZDFiNjVkZDY1MmYvcGFja2FnZXMvbWRjLXRoZW1lL19mdW5jdGlvbnMuc2NzcyNMNTRcblxuXG4gIGZ1bmN0aW9uIGdldENvbnRyYXN0VGV4dChiYWNrZ3JvdW5kKSB7XG4gICAgdmFyIGNvbnRyYXN0VGV4dCA9IGdldENvbnRyYXN0UmF0aW8oYmFja2dyb3VuZCwgZGFyay50ZXh0LnByaW1hcnkpID49IGNvbnRyYXN0VGhyZXNob2xkID8gZGFyay50ZXh0LnByaW1hcnkgOiBsaWdodC50ZXh0LnByaW1hcnk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGNvbnRyYXN0ID0gZ2V0Q29udHJhc3RSYXRpbyhiYWNrZ3JvdW5kLCBjb250cmFzdFRleHQpO1xuXG4gICAgICBpZiAoY29udHJhc3QgPCAzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoW1wiTWF0ZXJpYWwtVUk6IFRoZSBjb250cmFzdCByYXRpbyBvZiBcIi5jb25jYXQoY29udHJhc3QsIFwiOjEgZm9yIFwiKS5jb25jYXQoY29udHJhc3RUZXh0LCBcIiBvbiBcIikuY29uY2F0KGJhY2tncm91bmQpLCAnZmFsbHMgYmVsb3cgdGhlIFdDQUcgcmVjb21tZW5kZWQgYWJzb2x1dGUgbWluaW11bSBjb250cmFzdCByYXRpbyBvZiAzOjEuJywgJ2h0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI3Zpc3VhbC1hdWRpby1jb250cmFzdC1jb250cmFzdCddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udHJhc3RUZXh0O1xuICB9XG5cbiAgdmFyIGF1Z21lbnRDb2xvciA9IGZ1bmN0aW9uIGF1Z21lbnRDb2xvcihjb2xvcikge1xuICAgIHZhciBtYWluU2hhZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDUwMDtcbiAgICB2YXIgbGlnaHRTaGFkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMzAwO1xuICAgIHZhciBkYXJrU2hhZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDcwMDtcbiAgICBjb2xvciA9IF9leHRlbmRzKHt9LCBjb2xvcik7XG5cbiAgICBpZiAoIWNvbG9yLm1haW4gJiYgY29sb3JbbWFpblNoYWRlXSkge1xuICAgICAgY29sb3IubWFpbiA9IGNvbG9yW21haW5TaGFkZV07XG4gICAgfVxuXG4gICAgaWYgKCFjb2xvci5tYWluKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJNYXRlcmlhbC1VSTogVGhlIGNvbG9yIHByb3ZpZGVkIHRvIGF1Z21lbnRDb2xvcihjb2xvcikgaXMgaW52YWxpZC5cXG5UaGUgY29sb3Igb2JqZWN0IG5lZWRzIHRvIGhhdmUgYSBgbWFpbmAgcHJvcGVydHkgb3IgYSBgXCIuY29uY2F0KG1haW5TaGFkZSwgXCJgIHByb3BlcnR5LlwiKSA6IF9mb3JtYXRNdWlFcnJvck1lc3NhZ2UoNCwgbWFpblNoYWRlKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb2xvci5tYWluICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiTWF0ZXJpYWwtVUk6IFRoZSBjb2xvciBwcm92aWRlZCB0byBhdWdtZW50Q29sb3IoY29sb3IpIGlzIGludmFsaWQuXFxuYGNvbG9yLm1haW5gIHNob3VsZCBiZSBhIHN0cmluZywgYnV0IGBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkoY29sb3IubWFpbiksIFwiYCB3YXMgcHJvdmlkZWQgaW5zdGVhZC5cXG5cXG5EaWQgeW91IGludGVuZCB0byB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgYXBwcm9hY2hlcz9cXG5cXG5pbXBvcnQge1xceEEwZ3JlZW4gfSBmcm9tIFxcXCJAbWF0ZXJpYWwtdWkvY29yZS9jb2xvcnNcXFwiO1xcblxcbmNvbnN0IHRoZW1lMSA9IGNyZWF0ZVRoZW1lKHsgcGFsZXR0ZToge1xcbiAgcHJpbWFyeTogZ3JlZW4sXFxufSB9KTtcXG5cXG5jb25zdCB0aGVtZTIgPSBjcmVhdGVUaGVtZSh7IHBhbGV0dGU6IHtcXG4gIHByaW1hcnk6IHsgbWFpbjogZ3JlZW5bNTAwXSB9LFxcbn0gfSk7XCIpIDogX2Zvcm1hdE11aUVycm9yTWVzc2FnZSg1LCBKU09OLnN0cmluZ2lmeShjb2xvci5tYWluKSkpO1xuICAgIH1cblxuICAgIGFkZExpZ2h0T3JEYXJrKGNvbG9yLCAnbGlnaHQnLCBsaWdodFNoYWRlLCB0b25hbE9mZnNldCk7XG4gICAgYWRkTGlnaHRPckRhcmsoY29sb3IsICdkYXJrJywgZGFya1NoYWRlLCB0b25hbE9mZnNldCk7XG5cbiAgICBpZiAoIWNvbG9yLmNvbnRyYXN0VGV4dCkge1xuICAgICAgY29sb3IuY29udHJhc3RUZXh0ID0gZ2V0Q29udHJhc3RUZXh0KGNvbG9yLm1haW4pO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xvcjtcbiAgfTtcblxuICB2YXIgdHlwZXMgPSB7XG4gICAgZGFyazogZGFyayxcbiAgICBsaWdodDogbGlnaHRcbiAgfTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICghdHlwZXNbdHlwZV0pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJNYXRlcmlhbC1VSTogVGhlIHBhbGV0dGUgdHlwZSBgXCIuY29uY2F0KHR5cGUsIFwiYCBpcyBub3Qgc3VwcG9ydGVkLlwiKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBhbGV0dGVPdXRwdXQgPSBkZWVwbWVyZ2UoX2V4dGVuZHMoe1xuICAgIC8vIEEgY29sbGVjdGlvbiBvZiBjb21tb24gY29sb3JzLlxuICAgIGNvbW1vbjogY29tbW9uLFxuICAgIC8vIFRoZSBwYWxldHRlIHR5cGUsIGNhbiBiZSBsaWdodCBvciBkYXJrLlxuICAgIHR5cGU6IHR5cGUsXG4gICAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIHJlcHJlc2VudCBwcmltYXJ5IGludGVyZmFjZSBlbGVtZW50cyBmb3IgYSB1c2VyLlxuICAgIHByaW1hcnk6IGF1Z21lbnRDb2xvcihwcmltYXJ5KSxcbiAgICAvLyBUaGUgY29sb3JzIHVzZWQgdG8gcmVwcmVzZW50IHNlY29uZGFyeSBpbnRlcmZhY2UgZWxlbWVudHMgZm9yIGEgdXNlci5cbiAgICBzZWNvbmRhcnk6IGF1Z21lbnRDb2xvcihzZWNvbmRhcnksICdBNDAwJywgJ0EyMDAnLCAnQTcwMCcpLFxuICAgIC8vIFRoZSBjb2xvcnMgdXNlZCB0byByZXByZXNlbnQgaW50ZXJmYWNlIGVsZW1lbnRzIHRoYXQgdGhlIHVzZXIgc2hvdWxkIGJlIG1hZGUgYXdhcmUgb2YuXG4gICAgZXJyb3I6IGF1Z21lbnRDb2xvcihlcnJvciksXG4gICAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIHJlcHJlc2VudCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgYWN0aW9ucyBvciBpbXBvcnRhbnQgbWVzc2FnZXMuXG4gICAgd2FybmluZzogYXVnbWVudENvbG9yKHdhcm5pbmcpLFxuICAgIC8vIFRoZSBjb2xvcnMgdXNlZCB0byBwcmVzZW50IGluZm9ybWF0aW9uIHRvIHRoZSB1c2VyIHRoYXQgaXMgbmV1dHJhbCBhbmQgbm90IG5lY2Vzc2FyaWx5IGltcG9ydGFudC5cbiAgICBpbmZvOiBhdWdtZW50Q29sb3IoaW5mbyksXG4gICAgLy8gVGhlIGNvbG9ycyB1c2VkIHRvIGluZGljYXRlIHRoZSBzdWNjZXNzZnVsIGNvbXBsZXRpb24gb2YgYW4gYWN0aW9uIHRoYXQgdXNlciB0cmlnZ2VyZWQuXG4gICAgc3VjY2VzczogYXVnbWVudENvbG9yKHN1Y2Nlc3MpLFxuICAgIC8vIFRoZSBncmV5IGNvbG9ycy5cbiAgICBncmV5OiBncmV5LFxuICAgIC8vIFVzZWQgYnkgYGdldENvbnRyYXN0VGV4dCgpYCB0byBtYXhpbWl6ZSB0aGUgY29udHJhc3QgYmV0d2VlblxuICAgIC8vIHRoZSBiYWNrZ3JvdW5kIGFuZCB0aGUgdGV4dC5cbiAgICBjb250cmFzdFRocmVzaG9sZDogY29udHJhc3RUaHJlc2hvbGQsXG4gICAgLy8gVGFrZXMgYSBiYWNrZ3JvdW5kIGNvbG9yIGFuZCByZXR1cm5zIHRoZSB0ZXh0IGNvbG9yIHRoYXQgbWF4aW1pemVzIHRoZSBjb250cmFzdC5cbiAgICBnZXRDb250cmFzdFRleHQ6IGdldENvbnRyYXN0VGV4dCxcbiAgICAvLyBHZW5lcmF0ZSBhIHJpY2ggY29sb3Igb2JqZWN0LlxuICAgIGF1Z21lbnRDb2xvcjogYXVnbWVudENvbG9yLFxuICAgIC8vIFVzZWQgYnkgdGhlIGZ1bmN0aW9ucyBiZWxvdyB0byBzaGlmdCBhIGNvbG9yJ3MgbHVtaW5hbmNlIGJ5IGFwcHJveGltYXRlbHlcbiAgICAvLyB0d28gaW5kZXhlcyB3aXRoaW4gaXRzIHRvbmFsIHBhbGV0dGUuXG4gICAgLy8gRS5nLiwgc2hpZnQgZnJvbSBSZWQgNTAwIHRvIFJlZCAzMDAgb3IgUmVkIDcwMC5cbiAgICB0b25hbE9mZnNldDogdG9uYWxPZmZzZXRcbiAgfSwgdHlwZXNbdHlwZV0pLCBvdGhlcik7XG4gIHJldHVybiBwYWxldHRlT3V0cHV0O1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCB7IGRlZXBtZXJnZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5cbmZ1bmN0aW9uIHJvdW5kKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMWU1KSAvIDFlNTtcbn1cblxudmFyIHdhcm5lZE9uY2UgPSBmYWxzZTtcblxuZnVuY3Rpb24gcm91bmRXaXRoRGVwcmVjYXRpb25XYXJuaW5nKHZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKCF3YXJuZWRPbmNlKSB7XG4gICAgICBjb25zb2xlLndhcm4oWydNYXRlcmlhbC1VSTogVGhlIGB0aGVtZS50eXBvZ3JhcGh5LnJvdW5kYCBoZWxwZXIgaXMgZGVwcmVjYXRlZC4nLCAnSGVhZCB0byBodHRwczovL21hdGVyaWFsLXVpLmNvbS9yL21pZ3JhdGlvbi12NC8jdGhlbWUgZm9yIGEgbWlncmF0aW9uIHBhdGguJ10uam9pbignXFxuJykpO1xuICAgICAgd2FybmVkT25jZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJvdW5kKHZhbHVlKTtcbn1cblxudmFyIGNhc2VBbGxDYXBzID0ge1xuICB0ZXh0VHJhbnNmb3JtOiAndXBwZXJjYXNlJ1xufTtcbnZhciBkZWZhdWx0Rm9udEZhbWlseSA9ICdcIlJvYm90b1wiLCBcIkhlbHZldGljYVwiLCBcIkFyaWFsXCIsIHNhbnMtc2VyaWYnO1xuLyoqXG4gKiBAc2VlIEBsaW5re2h0dHBzOi8vbWF0ZXJpYWwuaW8vZGVzaWduL3R5cG9ncmFwaHkvdGhlLXR5cGUtc3lzdGVtLmh0bWx9XG4gKiBAc2VlIEBsaW5re2h0dHBzOi8vbWF0ZXJpYWwuaW8vZGVzaWduL3R5cG9ncmFwaHkvdW5kZXJzdGFuZGluZy10eXBvZ3JhcGh5Lmh0bWx9XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlVHlwb2dyYXBoeShwYWxldHRlLCB0eXBvZ3JhcGh5KSB7XG4gIHZhciBfcmVmID0gdHlwZW9mIHR5cG9ncmFwaHkgPT09ICdmdW5jdGlvbicgPyB0eXBvZ3JhcGh5KHBhbGV0dGUpIDogdHlwb2dyYXBoeSxcbiAgICAgIF9yZWYkZm9udEZhbWlseSA9IF9yZWYuZm9udEZhbWlseSxcbiAgICAgIGZvbnRGYW1pbHkgPSBfcmVmJGZvbnRGYW1pbHkgPT09IHZvaWQgMCA/IGRlZmF1bHRGb250RmFtaWx5IDogX3JlZiRmb250RmFtaWx5LFxuICAgICAgX3JlZiRmb250U2l6ZSA9IF9yZWYuZm9udFNpemUsXG4gICAgICBmb250U2l6ZSA9IF9yZWYkZm9udFNpemUgPT09IHZvaWQgMCA/IDE0IDogX3JlZiRmb250U2l6ZSxcbiAgICAgIF9yZWYkZm9udFdlaWdodExpZ2h0ID0gX3JlZi5mb250V2VpZ2h0TGlnaHQsXG4gICAgICBmb250V2VpZ2h0TGlnaHQgPSBfcmVmJGZvbnRXZWlnaHRMaWdodCA9PT0gdm9pZCAwID8gMzAwIDogX3JlZiRmb250V2VpZ2h0TGlnaHQsXG4gICAgICBfcmVmJGZvbnRXZWlnaHRSZWd1bGEgPSBfcmVmLmZvbnRXZWlnaHRSZWd1bGFyLFxuICAgICAgZm9udFdlaWdodFJlZ3VsYXIgPSBfcmVmJGZvbnRXZWlnaHRSZWd1bGEgPT09IHZvaWQgMCA/IDQwMCA6IF9yZWYkZm9udFdlaWdodFJlZ3VsYSxcbiAgICAgIF9yZWYkZm9udFdlaWdodE1lZGl1bSA9IF9yZWYuZm9udFdlaWdodE1lZGl1bSxcbiAgICAgIGZvbnRXZWlnaHRNZWRpdW0gPSBfcmVmJGZvbnRXZWlnaHRNZWRpdW0gPT09IHZvaWQgMCA/IDUwMCA6IF9yZWYkZm9udFdlaWdodE1lZGl1bSxcbiAgICAgIF9yZWYkZm9udFdlaWdodEJvbGQgPSBfcmVmLmZvbnRXZWlnaHRCb2xkLFxuICAgICAgZm9udFdlaWdodEJvbGQgPSBfcmVmJGZvbnRXZWlnaHRCb2xkID09PSB2b2lkIDAgPyA3MDAgOiBfcmVmJGZvbnRXZWlnaHRCb2xkLFxuICAgICAgX3JlZiRodG1sRm9udFNpemUgPSBfcmVmLmh0bWxGb250U2l6ZSxcbiAgICAgIGh0bWxGb250U2l6ZSA9IF9yZWYkaHRtbEZvbnRTaXplID09PSB2b2lkIDAgPyAxNiA6IF9yZWYkaHRtbEZvbnRTaXplLFxuICAgICAgYWxsVmFyaWFudHMgPSBfcmVmLmFsbFZhcmlhbnRzLFxuICAgICAgcHhUb1JlbTIgPSBfcmVmLnB4VG9SZW0sXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJmb250RmFtaWx5XCIsIFwiZm9udFNpemVcIiwgXCJmb250V2VpZ2h0TGlnaHRcIiwgXCJmb250V2VpZ2h0UmVndWxhclwiLCBcImZvbnRXZWlnaHRNZWRpdW1cIiwgXCJmb250V2VpZ2h0Qm9sZFwiLCBcImh0bWxGb250U2l6ZVwiLCBcImFsbFZhcmlhbnRzXCIsIFwicHhUb1JlbVwiXSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIGZvbnRTaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgY29uc29sZS5lcnJvcignTWF0ZXJpYWwtVUk6IGBmb250U2l6ZWAgaXMgcmVxdWlyZWQgdG8gYmUgYSBudW1iZXIuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBodG1sRm9udFNpemUgIT09ICdudW1iZXInKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNYXRlcmlhbC1VSTogYGh0bWxGb250U2l6ZWAgaXMgcmVxdWlyZWQgdG8gYmUgYSBudW1iZXIuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvZWYgPSBmb250U2l6ZSAvIDE0O1xuXG4gIHZhciBweFRvUmVtID0gcHhUb1JlbTIgfHwgZnVuY3Rpb24gKHNpemUpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoc2l6ZSAvIGh0bWxGb250U2l6ZSAqIGNvZWYsIFwicmVtXCIpO1xuICB9O1xuXG4gIHZhciBidWlsZFZhcmlhbnQgPSBmdW5jdGlvbiBidWlsZFZhcmlhbnQoZm9udFdlaWdodCwgc2l6ZSwgbGluZUhlaWdodCwgbGV0dGVyU3BhY2luZywgY2FzaW5nKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHksXG4gICAgICBmb250V2VpZ2h0OiBmb250V2VpZ2h0LFxuICAgICAgZm9udFNpemU6IHB4VG9SZW0oc2l6ZSksXG4gICAgICAvLyBVbml0bGVzcyBmb2xsb3dpbmcgaHR0cHM6Ly9tZXllcndlYi5jb20vZXJpYy90aG91Z2h0cy8yMDA2LzAyLzA4L3VuaXRsZXNzLWxpbmUtaGVpZ2h0cy9cbiAgICAgIGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHRcbiAgICB9LCBmb250RmFtaWx5ID09PSBkZWZhdWx0Rm9udEZhbWlseSA/IHtcbiAgICAgIGxldHRlclNwYWNpbmc6IFwiXCIuY29uY2F0KHJvdW5kKGxldHRlclNwYWNpbmcgLyBzaXplKSwgXCJlbVwiKVxuICAgIH0gOiB7fSwgY2FzaW5nLCBhbGxWYXJpYW50cyk7XG4gIH07XG5cbiAgdmFyIHZhcmlhbnRzID0ge1xuICAgIGgxOiBidWlsZFZhcmlhbnQoZm9udFdlaWdodExpZ2h0LCA5NiwgMS4xNjcsIC0xLjUpLFxuICAgIGgyOiBidWlsZFZhcmlhbnQoZm9udFdlaWdodExpZ2h0LCA2MCwgMS4yLCAtMC41KSxcbiAgICBoMzogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRSZWd1bGFyLCA0OCwgMS4xNjcsIDApLFxuICAgIGg0OiBidWlsZFZhcmlhbnQoZm9udFdlaWdodFJlZ3VsYXIsIDM0LCAxLjIzNSwgMC4yNSksXG4gICAgaDU6IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0UmVndWxhciwgMjQsIDEuMzM0LCAwKSxcbiAgICBoNjogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRNZWRpdW0sIDIwLCAxLjYsIDAuMTUpLFxuICAgIHN1YnRpdGxlMTogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRSZWd1bGFyLCAxNiwgMS43NSwgMC4xNSksXG4gICAgc3VidGl0bGUyOiBidWlsZFZhcmlhbnQoZm9udFdlaWdodE1lZGl1bSwgMTQsIDEuNTcsIDAuMSksXG4gICAgYm9keTE6IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0UmVndWxhciwgMTYsIDEuNSwgMC4xNSksXG4gICAgYm9keTI6IGJ1aWxkVmFyaWFudChmb250V2VpZ2h0UmVndWxhciwgMTQsIDEuNDMsIDAuMTUpLFxuICAgIGJ1dHRvbjogYnVpbGRWYXJpYW50KGZvbnRXZWlnaHRNZWRpdW0sIDE0LCAxLjc1LCAwLjQsIGNhc2VBbGxDYXBzKSxcbiAgICBjYXB0aW9uOiBidWlsZFZhcmlhbnQoZm9udFdlaWdodFJlZ3VsYXIsIDEyLCAxLjY2LCAwLjQpLFxuICAgIG92ZXJsaW5lOiBidWlsZFZhcmlhbnQoZm9udFdlaWdodFJlZ3VsYXIsIDEyLCAyLjY2LCAxLCBjYXNlQWxsQ2FwcylcbiAgfTtcbiAgcmV0dXJuIGRlZXBtZXJnZShfZXh0ZW5kcyh7XG4gICAgaHRtbEZvbnRTaXplOiBodG1sRm9udFNpemUsXG4gICAgcHhUb1JlbTogcHhUb1JlbSxcbiAgICByb3VuZDogcm91bmRXaXRoRGVwcmVjYXRpb25XYXJuaW5nLFxuICAgIC8vIFRPRE8gdjU6IHJlbW92ZVxuICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHksXG4gICAgZm9udFNpemU6IGZvbnRTaXplLFxuICAgIGZvbnRXZWlnaHRMaWdodDogZm9udFdlaWdodExpZ2h0LFxuICAgIGZvbnRXZWlnaHRSZWd1bGFyOiBmb250V2VpZ2h0UmVndWxhcixcbiAgICBmb250V2VpZ2h0TWVkaXVtOiBmb250V2VpZ2h0TWVkaXVtLFxuICAgIGZvbnRXZWlnaHRCb2xkOiBmb250V2VpZ2h0Qm9sZFxuICB9LCB2YXJpYW50cyksIG90aGVyLCB7XG4gICAgY2xvbmU6IGZhbHNlIC8vIE5vIG5lZWQgdG8gY2xvbmUgZGVlcFxuXG4gIH0pO1xufSIsInZhciBzaGFkb3dLZXlVbWJyYU9wYWNpdHkgPSAwLjI7XG52YXIgc2hhZG93S2V5UGVudW1icmFPcGFjaXR5ID0gMC4xNDtcbnZhciBzaGFkb3dBbWJpZW50U2hhZG93T3BhY2l0eSA9IDAuMTI7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNoYWRvdygpIHtcbiAgcmV0dXJuIFtcIlwiLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIFwicHggXCIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0sIFwicHggXCIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0sIFwicHggXCIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoIDw9IDMgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbM10sIFwicHggcmdiYSgwLDAsMCxcIikuY29uY2F0KHNoYWRvd0tleVVtYnJhT3BhY2l0eSwgXCIpXCIpLCBcIlwiLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoIDw9IDQgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbNF0sIFwicHggXCIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoIDw9IDUgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbNV0sIFwicHggXCIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoIDw9IDYgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbNl0sIFwicHggXCIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoIDw9IDcgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbN10sIFwicHggcmdiYSgwLDAsMCxcIikuY29uY2F0KHNoYWRvd0tleVBlbnVtYnJhT3BhY2l0eSwgXCIpXCIpLCBcIlwiLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoIDw9IDggPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbOF0sIFwicHggXCIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoIDw9IDkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbOV0sIFwicHggXCIpLmNvbmNhdChhcmd1bWVudHMubGVuZ3RoIDw9IDEwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzEwXSwgXCJweCBcIikuY29uY2F0KGFyZ3VtZW50cy5sZW5ndGggPD0gMTEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMTFdLCBcInB4IHJnYmEoMCwwLDAsXCIpLmNvbmNhdChzaGFkb3dBbWJpZW50U2hhZG93T3BhY2l0eSwgXCIpXCIpXS5qb2luKCcsJyk7XG59IC8vIFZhbHVlcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvYmU4NzQ3Zjk0NTc0NjY5Y2I1ZTdhZGQxYTdjNTRmYTQxYTg5Y2VjNy9wYWNrYWdlcy9tZGMtZWxldmF0aW9uL192YXJpYWJsZXMuc2Nzc1xuXG5cbnZhciBzaGFkb3dzID0gWydub25lJywgY3JlYXRlU2hhZG93KDAsIDIsIDEsIC0xLCAwLCAxLCAxLCAwLCAwLCAxLCAzLCAwKSwgY3JlYXRlU2hhZG93KDAsIDMsIDEsIC0yLCAwLCAyLCAyLCAwLCAwLCAxLCA1LCAwKSwgY3JlYXRlU2hhZG93KDAsIDMsIDMsIC0yLCAwLCAzLCA0LCAwLCAwLCAxLCA4LCAwKSwgY3JlYXRlU2hhZG93KDAsIDIsIDQsIC0xLCAwLCA0LCA1LCAwLCAwLCAxLCAxMCwgMCksIGNyZWF0ZVNoYWRvdygwLCAzLCA1LCAtMSwgMCwgNSwgOCwgMCwgMCwgMSwgMTQsIDApLCBjcmVhdGVTaGFkb3coMCwgMywgNSwgLTEsIDAsIDYsIDEwLCAwLCAwLCAxLCAxOCwgMCksIGNyZWF0ZVNoYWRvdygwLCA0LCA1LCAtMiwgMCwgNywgMTAsIDEsIDAsIDIsIDE2LCAxKSwgY3JlYXRlU2hhZG93KDAsIDUsIDUsIC0zLCAwLCA4LCAxMCwgMSwgMCwgMywgMTQsIDIpLCBjcmVhdGVTaGFkb3coMCwgNSwgNiwgLTMsIDAsIDksIDEyLCAxLCAwLCAzLCAxNiwgMiksIGNyZWF0ZVNoYWRvdygwLCA2LCA2LCAtMywgMCwgMTAsIDE0LCAxLCAwLCA0LCAxOCwgMyksIGNyZWF0ZVNoYWRvdygwLCA2LCA3LCAtNCwgMCwgMTEsIDE1LCAxLCAwLCA0LCAyMCwgMyksIGNyZWF0ZVNoYWRvdygwLCA3LCA4LCAtNCwgMCwgMTIsIDE3LCAyLCAwLCA1LCAyMiwgNCksIGNyZWF0ZVNoYWRvdygwLCA3LCA4LCAtNCwgMCwgMTMsIDE5LCAyLCAwLCA1LCAyNCwgNCksIGNyZWF0ZVNoYWRvdygwLCA3LCA5LCAtNCwgMCwgMTQsIDIxLCAyLCAwLCA1LCAyNiwgNCksIGNyZWF0ZVNoYWRvdygwLCA4LCA5LCAtNSwgMCwgMTUsIDIyLCAyLCAwLCA2LCAyOCwgNSksIGNyZWF0ZVNoYWRvdygwLCA4LCAxMCwgLTUsIDAsIDE2LCAyNCwgMiwgMCwgNiwgMzAsIDUpLCBjcmVhdGVTaGFkb3coMCwgOCwgMTEsIC01LCAwLCAxNywgMjYsIDIsIDAsIDYsIDMyLCA1KSwgY3JlYXRlU2hhZG93KDAsIDksIDExLCAtNSwgMCwgMTgsIDI4LCAyLCAwLCA3LCAzNCwgNiksIGNyZWF0ZVNoYWRvdygwLCA5LCAxMiwgLTYsIDAsIDE5LCAyOSwgMiwgMCwgNywgMzYsIDYpLCBjcmVhdGVTaGFkb3coMCwgMTAsIDEzLCAtNiwgMCwgMjAsIDMxLCAzLCAwLCA4LCAzOCwgNyksIGNyZWF0ZVNoYWRvdygwLCAxMCwgMTMsIC02LCAwLCAyMSwgMzMsIDMsIDAsIDgsIDQwLCA3KSwgY3JlYXRlU2hhZG93KDAsIDEwLCAxNCwgLTYsIDAsIDIyLCAzNSwgMywgMCwgOCwgNDIsIDcpLCBjcmVhdGVTaGFkb3coMCwgMTEsIDE0LCAtNywgMCwgMjMsIDM2LCAzLCAwLCA5LCA0NCwgOCksIGNyZWF0ZVNoYWRvdygwLCAxMSwgMTUsIC03LCAwLCAyNCwgMzgsIDMsIDAsIDksIDQ2LCA4KV07XG5leHBvcnQgZGVmYXVsdCBzaGFkb3dzOyIsInZhciBzaGFwZSA9IHtcbiAgYm9yZGVyUmFkaXVzOiA0XG59O1xuZXhwb3J0IGRlZmF1bHQgc2hhcGU7IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbnZhciByZXNwb25zaXZlUHJvcFR5cGUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmFycmF5XSkgOiB7fTtcbmV4cG9ydCBkZWZhdWx0IHJlc3BvbnNpdmVQcm9wVHlwZTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59IiwiaW1wb3J0IGFycmF5TGlrZVRvQXJyYXkgZnJvbSBcIi4vYXJyYXlMaWtlVG9BcnJheS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn0iLCJpbXBvcnQgYXJyYXlMaWtlVG9BcnJheSBmcm9tIFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59IiwiaW1wb3J0IGFycmF5V2l0aG91dEhvbGVzIGZyb20gXCIuL2FycmF5V2l0aG91dEhvbGVzLmpzXCI7XG5pbXBvcnQgaXRlcmFibGVUb0FycmF5IGZyb20gXCIuL2l0ZXJhYmxlVG9BcnJheS5qc1wiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCI7XG5pbXBvcnQgbm9uSXRlcmFibGVTcHJlYWQgZnJvbSBcIi4vbm9uSXRlcmFibGVTcHJlYWQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn0iLCJpbXBvcnQgYXJyYXlXaXRoSG9sZXMgZnJvbSBcIi4vYXJyYXlXaXRoSG9sZXMuanNcIjtcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXlMaW1pdCBmcm9tIFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1wiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCI7XG5pbXBvcnQgbm9uSXRlcmFibGVSZXN0IGZyb20gXCIuL25vbkl0ZXJhYmxlUmVzdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn0iLCJpbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCByZXNwb25zaXZlUHJvcFR5cGUgZnJvbSAnLi9yZXNwb25zaXZlUHJvcFR5cGUnO1xuaW1wb3J0IHsgaGFuZGxlQnJlYWtwb2ludHMgfSBmcm9tICcuL2JyZWFrcG9pbnRzJztcbmltcG9ydCBtZXJnZSBmcm9tICcuL21lcmdlJztcbmltcG9ydCBtZW1vaXplIGZyb20gJy4vbWVtb2l6ZSc7XG52YXIgcHJvcGVydGllcyA9IHtcbiAgbTogJ21hcmdpbicsXG4gIHA6ICdwYWRkaW5nJ1xufTtcbnZhciBkaXJlY3Rpb25zID0ge1xuICB0OiAnVG9wJyxcbiAgcjogJ1JpZ2h0JyxcbiAgYjogJ0JvdHRvbScsXG4gIGw6ICdMZWZ0JyxcbiAgeDogWydMZWZ0JywgJ1JpZ2h0J10sXG4gIHk6IFsnVG9wJywgJ0JvdHRvbSddXG59O1xudmFyIGFsaWFzZXMgPSB7XG4gIG1hcmdpblg6ICdteCcsXG4gIG1hcmdpblk6ICdteScsXG4gIHBhZGRpbmdYOiAncHgnLFxuICBwYWRkaW5nWTogJ3B5J1xufTsgLy8gbWVtb2l6ZSgpIGltcGFjdDpcbi8vIEZyb20gMzAwLDAwMCBvcHMvc2VjXG4vLyBUbyAzNTAsMDAwIG9wcy9zZWNcblxudmFyIGdldENzc1Byb3BlcnRpZXMgPSBtZW1vaXplKGZ1bmN0aW9uIChwcm9wKSB7XG4gIC8vIEl0J3Mgbm90IGEgc2hvcnRoYW5kIG5vdGF0aW9uLlxuICBpZiAocHJvcC5sZW5ndGggPiAyKSB7XG4gICAgaWYgKGFsaWFzZXNbcHJvcF0pIHtcbiAgICAgIHByb3AgPSBhbGlhc2VzW3Byb3BdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvcCRzcGxpdCA9IHByb3Auc3BsaXQoJycpLFxuICAgICAgX3Byb3Akc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX3Byb3Akc3BsaXQsIDIpLFxuICAgICAgYSA9IF9wcm9wJHNwbGl0MlswXSxcbiAgICAgIGIgPSBfcHJvcCRzcGxpdDJbMV07XG5cbiAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1thXTtcbiAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvbnNbYl0gfHwgJyc7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRpcmVjdGlvbikgPyBkaXJlY3Rpb24ubWFwKGZ1bmN0aW9uIChkaXIpIHtcbiAgICByZXR1cm4gcHJvcGVydHkgKyBkaXI7XG4gIH0pIDogW3Byb3BlcnR5ICsgZGlyZWN0aW9uXTtcbn0pO1xudmFyIHNwYWNpbmdLZXlzID0gWydtJywgJ210JywgJ21yJywgJ21iJywgJ21sJywgJ214JywgJ215JywgJ3AnLCAncHQnLCAncHInLCAncGInLCAncGwnLCAncHgnLCAncHknLCAnbWFyZ2luJywgJ21hcmdpblRvcCcsICdtYXJnaW5SaWdodCcsICdtYXJnaW5Cb3R0b20nLCAnbWFyZ2luTGVmdCcsICdtYXJnaW5YJywgJ21hcmdpblknLCAncGFkZGluZycsICdwYWRkaW5nVG9wJywgJ3BhZGRpbmdSaWdodCcsICdwYWRkaW5nQm90dG9tJywgJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdYJywgJ3BhZGRpbmdZJ107XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVW5hcnlTcGFjaW5nKHRoZW1lKSB7XG4gIHZhciB0aGVtZVNwYWNpbmcgPSB0aGVtZS5zcGFjaW5nIHx8IDg7XG5cbiAgaWYgKHR5cGVvZiB0aGVtZVNwYWNpbmcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhYnMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWJzICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNYXRlcmlhbC1VSTogRXhwZWN0ZWQgc3BhY2luZyBhcmd1bWVudCB0byBiZSBhIG51bWJlciwgZ290IFwiLmNvbmNhdChhYnMsIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoZW1lU3BhY2luZyAqIGFicztcbiAgICB9O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodGhlbWVTcGFjaW5nKSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYWJzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoYWJzID4gdGhlbWVTcGFjaW5nLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFtcIk1hdGVyaWFsLVVJOiBUaGUgdmFsdWUgcHJvdmlkZWQgKFwiLmNvbmNhdChhYnMsIFwiKSBvdmVyZmxvd3MuXCIpLCBcIlRoZSBzdXBwb3J0ZWQgdmFsdWVzIGFyZTogXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHRoZW1lU3BhY2luZyksIFwiLlwiKSwgXCJcIi5jb25jYXQoYWJzLCBcIiA+IFwiKS5jb25jYXQodGhlbWVTcGFjaW5nLmxlbmd0aCAtIDEsIFwiLCB5b3UgbmVlZCB0byBhZGQgdGhlIG1pc3NpbmcgdmFsdWVzLlwiKV0uam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGVtZVNwYWNpbmdbYWJzXTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0aGVtZVNwYWNpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdGhlbWVTcGFjaW5nO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKFtcIk1hdGVyaWFsLVVJOiBUaGUgYHRoZW1lLnNwYWNpbmdgIHZhbHVlIChcIi5jb25jYXQodGhlbWVTcGFjaW5nLCBcIikgaXMgaW52YWxpZC5cIiksICdJdCBzaG91bGQgYmUgYSBudW1iZXIsIGFuIGFycmF5IG9yIGEgZnVuY3Rpb24uJ10uam9pbignXFxuJykpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSh0cmFuc2Zvcm1lciwgcHJvcFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAnc3RyaW5nJyB8fCBwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBwcm9wVmFsdWU7XG4gIH1cblxuICB2YXIgYWJzID0gTWF0aC5hYnMocHJvcFZhbHVlKTtcbiAgdmFyIHRyYW5zZm9ybWVkID0gdHJhbnNmb3JtZXIoYWJzKTtcblxuICBpZiAocHJvcFZhbHVlID49IDApIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIHRyYW5zZm9ybWVkID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiAtdHJhbnNmb3JtZWQ7XG4gIH1cblxuICByZXR1cm4gXCItXCIuY29uY2F0KHRyYW5zZm9ybWVkKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3R5bGVGcm9tUHJvcFZhbHVlKGNzc1Byb3BlcnRpZXMsIHRyYW5zZm9ybWVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocHJvcFZhbHVlKSB7XG4gICAgcmV0dXJuIGNzc1Byb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNzc1Byb3BlcnR5KSB7XG4gICAgICBhY2NbY3NzUHJvcGVydHldID0gZ2V0VmFsdWUodHJhbnNmb3JtZXIsIHByb3BWYWx1ZSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3BhY2luZyhwcm9wcykge1xuICB2YXIgdGhlbWUgPSBwcm9wcy50aGVtZTtcbiAgdmFyIHRyYW5zZm9ybWVyID0gY3JlYXRlVW5hcnlTcGFjaW5nKHRoZW1lKTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHByb3BzKS5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAvLyBVc2luZyBhIGhhc2ggY29tcHV0YXRpb24gb3ZlciBhbiBhcnJheSBpdGVyYXRpb24gY291bGQgYmUgZmFzdGVyLCBidXQgd2l0aCBvbmx5IDI4IGl0ZW1zLFxuICAgIC8vIGl0J3MgZG9lc24ndCB3b3J0aCB0aGUgYnVuZGxlIHNpemUuXG4gICAgaWYgKHNwYWNpbmdLZXlzLmluZGV4T2YocHJvcCkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY3NzUHJvcGVydGllcyA9IGdldENzc1Byb3BlcnRpZXMocHJvcCk7XG4gICAgdmFyIHN0eWxlRnJvbVByb3BWYWx1ZSA9IGdldFN0eWxlRnJvbVByb3BWYWx1ZShjc3NQcm9wZXJ0aWVzLCB0cmFuc2Zvcm1lcik7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BdO1xuICAgIHJldHVybiBoYW5kbGVCcmVha3BvaW50cyhwcm9wcywgcHJvcFZhbHVlLCBzdHlsZUZyb21Qcm9wVmFsdWUpO1xuICB9KS5yZWR1Y2UobWVyZ2UsIHt9KTtcbn1cblxuc3BhY2luZy5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gc3BhY2luZ0tleXMucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuICBvYmpba2V5XSA9IHJlc3BvbnNpdmVQcm9wVHlwZTtcbiAgcmV0dXJuIG9iajtcbn0sIHt9KSA6IHt9O1xuc3BhY2luZy5maWx0ZXJQcm9wcyA9IHNwYWNpbmdLZXlzO1xuZXhwb3J0IGRlZmF1bHQgc3BhY2luZzsiLCJpbXBvcnQgeyBjcmVhdGVVbmFyeVNwYWNpbmcgfSBmcm9tICdAbWF0ZXJpYWwtdWkvc3lzdGVtJztcbnZhciB3YXJuT25jZTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVNwYWNpbmcoKSB7XG4gIHZhciBzcGFjaW5nSW5wdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDg7XG5cbiAgLy8gQWxyZWFkeSB0cmFuc2Zvcm1lZC5cbiAgaWYgKHNwYWNpbmdJbnB1dC5tdWkpIHtcbiAgICByZXR1cm4gc3BhY2luZ0lucHV0O1xuICB9IC8vIE1hdGVyaWFsIERlc2lnbiBsYXlvdXRzIGFyZSB2aXN1YWxseSBiYWxhbmNlZC4gTW9zdCBtZWFzdXJlbWVudHMgYWxpZ24gdG8gYW4gOGRwIGdyaWQgYXBwbGllZCwgd2hpY2ggYWxpZ25zIGJvdGggc3BhY2luZyBhbmQgdGhlIG92ZXJhbGwgbGF5b3V0LlxuICAvLyBTbWFsbGVyIGNvbXBvbmVudHMsIHN1Y2ggYXMgaWNvbnMgYW5kIHR5cGUsIGNhbiBhbGlnbiB0byBhIDRkcCBncmlkLlxuICAvLyBodHRwczovL21hdGVyaWFsLmlvL2Rlc2lnbi9sYXlvdXQvdW5kZXJzdGFuZGluZy1sYXlvdXQuaHRtbCN1c2FnZVxuXG5cbiAgdmFyIHRyYW5zZm9ybSA9IGNyZWF0ZVVuYXJ5U3BhY2luZyh7XG4gICAgc3BhY2luZzogc3BhY2luZ0lucHV0XG4gIH0pO1xuXG4gIHZhciBzcGFjaW5nID0gZnVuY3Rpb24gc3BhY2luZygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghKGFyZ3MubGVuZ3RoIDw9IDQpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNYXRlcmlhbC1VSTogVG9vIG1hbnkgYXJndW1lbnRzIHByb3ZpZGVkLCBleHBlY3RlZCBiZXR3ZWVuIDAgYW5kIDQsIGdvdCBcIi5jb25jYXQoYXJncy5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm0oMSk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtKGFyZ3NbMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBhcmdzLm1hcChmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudDtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dHB1dCA9IHRyYW5zZm9ybShhcmd1bWVudCk7XG4gICAgICByZXR1cm4gdHlwZW9mIG91dHB1dCA9PT0gJ251bWJlcicgPyBcIlwiLmNvbmNhdChvdXRwdXQsIFwicHhcIikgOiBvdXRwdXQ7XG4gICAgfSkuam9pbignICcpO1xuICB9OyAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0byByZW1vdmUgaW4gdjUuXG5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3BhY2luZywgJ3VuaXQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoIXdhcm5PbmNlIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFsnTWF0ZXJpYWwtVUk6IHRoZW1lLnNwYWNpbmcudW5pdCB1c2FnZSBoYXMgYmVlbiBkZXByZWNhdGVkLicsICdJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdjUuJywgJ1lvdSBjYW4gcmVwbGFjZSBgdGhlbWUuc3BhY2luZy51bml0ICogeWAgd2l0aCBgdGhlbWUuc3BhY2luZyh5KWAuJywgJycsICdZb3UgY2FuIHVzZSB0aGUgYGh0dHBzOi8vZ2l0aHViLmNvbS9tdWktb3JnL21hdGVyaWFsLXVpL3RyZWUvbWFzdGVyL3BhY2thZ2VzL21hdGVyaWFsLXVpLWNvZGVtb2QvUkVBRE1FLm1kI3RoZW1lLXNwYWNpbmctYXBpYCBtaWdyYXRpb24gaGVscGVyIHRvIG1ha2UgdGhlIHByb2Nlc3Mgc21vb3RoZXIuJ10uam9pbignXFxuJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2Fybk9uY2UgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3BhY2luZ0lucHV0O1xuICAgIH1cbiAgfSk7XG4gIHNwYWNpbmcubXVpID0gdHJ1ZTtcbiAgcmV0dXJuIHNwYWNpbmc7XG59IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbi8vIEZvbGxvdyBodHRwczovL21hdGVyaWFsLmdvb2dsZS5jb20vbW90aW9uL2R1cmF0aW9uLWVhc2luZy5odG1sI2R1cmF0aW9uLWVhc2luZy1uYXR1cmFsLWVhc2luZy1jdXJ2ZXNcbi8vIHRvIGxlYXJuIHRoZSBjb250ZXh0IGluIHdoaWNoIGVhY2ggZWFzaW5nIHNob3VsZCBiZSB1c2VkLlxuZXhwb3J0IHZhciBlYXNpbmcgPSB7XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgY29tbW9uIGVhc2luZyBjdXJ2ZS5cbiAgZWFzZUluT3V0OiAnY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKScsXG4gIC8vIE9iamVjdHMgZW50ZXIgdGhlIHNjcmVlbiBhdCBmdWxsIHZlbG9jaXR5IGZyb20gb2ZmLXNjcmVlbiBhbmRcbiAgLy8gc2xvd2x5IGRlY2VsZXJhdGUgdG8gYSByZXN0aW5nIHBvaW50LlxuICBlYXNlT3V0OiAnY3ViaWMtYmV6aWVyKDAuMCwgMCwgMC4yLCAxKScsXG4gIC8vIE9iamVjdHMgbGVhdmUgdGhlIHNjcmVlbiBhdCBmdWxsIHZlbG9jaXR5LiBUaGV5IGRvIG5vdCBkZWNlbGVyYXRlIHdoZW4gb2ZmLXNjcmVlbi5cbiAgZWFzZUluOiAnY3ViaWMtYmV6aWVyKDAuNCwgMCwgMSwgMSknLFxuICAvLyBUaGUgc2hhcnAgY3VydmUgaXMgdXNlZCBieSBvYmplY3RzIHRoYXQgbWF5IHJldHVybiB0byB0aGUgc2NyZWVuIGF0IGFueSB0aW1lLlxuICBzaGFycDogJ2N1YmljLWJlemllcigwLjQsIDAsIDAuNiwgMSknXG59OyAvLyBGb2xsb3cgaHR0cHM6Ly9tYXRlcmlhbC5pby9ndWlkZWxpbmVzL21vdGlvbi9kdXJhdGlvbi1lYXNpbmcuaHRtbCNkdXJhdGlvbi1lYXNpbmctY29tbW9uLWR1cmF0aW9uc1xuLy8gdG8gbGVhcm4gd2hlbiB1c2Ugd2hhdCB0aW1pbmdcblxuZXhwb3J0IHZhciBkdXJhdGlvbiA9IHtcbiAgc2hvcnRlc3Q6IDE1MCxcbiAgc2hvcnRlcjogMjAwLFxuICBzaG9ydDogMjUwLFxuICAvLyBtb3N0IGJhc2ljIHJlY29tbWVuZGVkIHRpbWluZ1xuICBzdGFuZGFyZDogMzAwLFxuICAvLyB0aGlzIGlzIHRvIGJlIHVzZWQgaW4gY29tcGxleCBhbmltYXRpb25zXG4gIGNvbXBsZXg6IDM3NSxcbiAgLy8gcmVjb21tZW5kZWQgd2hlbiBzb21ldGhpbmcgaXMgZW50ZXJpbmcgc2NyZWVuXG4gIGVudGVyaW5nU2NyZWVuOiAyMjUsXG4gIC8vIHJlY29tbWVuZGVkIHdoZW4gc29tZXRoaW5nIGlzIGxlYXZpbmcgc2NyZWVuXG4gIGxlYXZpbmdTY3JlZW46IDE5NVxufTtcblxuZnVuY3Rpb24gZm9ybWF0TXMobWlsbGlzZWNvbmRzKSB7XG4gIHJldHVybiBcIlwiLmNvbmNhdChNYXRoLnJvdW5kKG1pbGxpc2Vjb25kcyksIFwibXNcIik7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0ucHJvcFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtLmR1cmF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0uZWFzaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW0uZGVsYXlcbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZWFzaW5nOiBlYXNpbmcsXG4gIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbJ2FsbCddO1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBfb3B0aW9ucyRkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICAgIGR1cmF0aW9uT3B0aW9uID0gX29wdGlvbnMkZHVyYXRpb24gPT09IHZvaWQgMCA/IGR1cmF0aW9uLnN0YW5kYXJkIDogX29wdGlvbnMkZHVyYXRpb24sXG4gICAgICAgIF9vcHRpb25zJGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nLFxuICAgICAgICBlYXNpbmdPcHRpb24gPSBfb3B0aW9ucyRlYXNpbmcgPT09IHZvaWQgMCA/IGVhc2luZy5lYXNlSW5PdXQgOiBfb3B0aW9ucyRlYXNpbmcsXG4gICAgICAgIF9vcHRpb25zJGRlbGF5ID0gb3B0aW9ucy5kZWxheSxcbiAgICAgICAgZGVsYXkgPSBfb3B0aW9ucyRkZWxheSA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJGRlbGF5LFxuICAgICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvcHRpb25zLCBbXCJkdXJhdGlvblwiLCBcImVhc2luZ1wiLCBcImRlbGF5XCJdKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICAgIH07XG5cbiAgICAgIHZhciBpc051bWJlciA9IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgICAgfTtcblxuICAgICAgaWYgKCFpc1N0cmluZyhwcm9wcykgJiYgIUFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ01hdGVyaWFsLVVJOiBBcmd1bWVudCBcInByb3BzXCIgbXVzdCBiZSBhIHN0cmluZyBvciBBcnJheS4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc051bWJlcihkdXJhdGlvbk9wdGlvbikgJiYgIWlzU3RyaW5nKGR1cmF0aW9uT3B0aW9uKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTWF0ZXJpYWwtVUk6IEFyZ3VtZW50IFxcXCJkdXJhdGlvblxcXCIgbXVzdCBiZSBhIG51bWJlciBvciBhIHN0cmluZyBidXQgZm91bmQgXCIuY29uY2F0KGR1cmF0aW9uT3B0aW9uLCBcIi5cIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzU3RyaW5nKGVhc2luZ09wdGlvbikpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTWF0ZXJpYWwtVUk6IEFyZ3VtZW50IFwiZWFzaW5nXCIgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc051bWJlcihkZWxheSkgJiYgIWlzU3RyaW5nKGRlbGF5KSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdNYXRlcmlhbC1VSTogQXJndW1lbnQgXCJkZWxheVwiIG11c3QgYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyhvdGhlcikubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNYXRlcmlhbC1VSTogVW5yZWNvZ25pemVkIGFyZ3VtZW50KHMpIFtcIi5jb25jYXQoT2JqZWN0LmtleXMob3RoZXIpLmpvaW4oJywnKSwgXCJdLlwiKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHByb3BzKSA/IHByb3BzIDogW3Byb3BzXSkubWFwKGZ1bmN0aW9uIChhbmltYXRlZFByb3ApIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChhbmltYXRlZFByb3AsIFwiIFwiKS5jb25jYXQodHlwZW9mIGR1cmF0aW9uT3B0aW9uID09PSAnc3RyaW5nJyA/IGR1cmF0aW9uT3B0aW9uIDogZm9ybWF0TXMoZHVyYXRpb25PcHRpb24pLCBcIiBcIikuY29uY2F0KGVhc2luZ09wdGlvbiwgXCIgXCIpLmNvbmNhdCh0eXBlb2YgZGVsYXkgPT09ICdzdHJpbmcnID8gZGVsYXkgOiBmb3JtYXRNcyhkZWxheSkpO1xuICAgIH0pLmpvaW4oJywnKTtcbiAgfSxcbiAgZ2V0QXV0b0hlaWdodER1cmF0aW9uOiBmdW5jdGlvbiBnZXRBdXRvSGVpZ2h0RHVyYXRpb24oaGVpZ2h0KSB7XG4gICAgaWYgKCFoZWlnaHQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBjb25zdGFudCA9IGhlaWdodCAvIDM2OyAvLyBodHRwczovL3d3dy53b2xmcmFtYWxwaGEuY29tL2lucHV0Lz9pPSg0KyUyQisxNSsqKyh4KyUyRiszNispKyoqKzAuMjUrJTJCKyh4KyUyRiszNikrJTJGKzUpKyorMTBcblxuICAgIHJldHVybiBNYXRoLnJvdW5kKCg0ICsgMTUgKiBNYXRoLnBvdyhjb25zdGFudCwgMC4yNSkgKyBjb25zdGFudCAvIDUpICogMTApO1xuICB9XG59OyIsIi8vIFdlIG5lZWQgdG8gY2VudHJhbGl6ZSB0aGUgekluZGV4IGRlZmluaXRpb25zIGFzIHRoZXkgd29ya1xuLy8gbGlrZSBnbG9iYWwgdmFsdWVzIGluIHRoZSBicm93c2VyLlxudmFyIHpJbmRleCA9IHtcbiAgbW9iaWxlU3RlcHBlcjogMTAwMCxcbiAgc3BlZWREaWFsOiAxMDUwLFxuICBhcHBCYXI6IDExMDAsXG4gIGRyYXdlcjogMTIwMCxcbiAgbW9kYWw6IDEzMDAsXG4gIHNuYWNrYmFyOiAxNDAwLFxuICB0b29sdGlwOiAxNTAwXG59O1xuZXhwb3J0IGRlZmF1bHQgekluZGV4OyIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0IHsgZGVlcG1lcmdlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCBjcmVhdGVCcmVha3BvaW50cyBmcm9tICcuL2NyZWF0ZUJyZWFrcG9pbnRzJztcbmltcG9ydCBjcmVhdGVNaXhpbnMgZnJvbSAnLi9jcmVhdGVNaXhpbnMnO1xuaW1wb3J0IGNyZWF0ZVBhbGV0dGUgZnJvbSAnLi9jcmVhdGVQYWxldHRlJztcbmltcG9ydCBjcmVhdGVUeXBvZ3JhcGh5IGZyb20gJy4vY3JlYXRlVHlwb2dyYXBoeSc7XG5pbXBvcnQgc2hhZG93cyBmcm9tICcuL3NoYWRvd3MnO1xuaW1wb3J0IHNoYXBlIGZyb20gJy4vc2hhcGUnO1xuaW1wb3J0IGNyZWF0ZVNwYWNpbmcgZnJvbSAnLi9jcmVhdGVTcGFjaW5nJztcbmltcG9ydCB0cmFuc2l0aW9ucyBmcm9tICcuL3RyYW5zaXRpb25zJztcbmltcG9ydCB6SW5kZXggZnJvbSAnLi96SW5kZXgnO1xuXG5mdW5jdGlvbiBjcmVhdGVUaGVtZSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIHZhciBfb3B0aW9ucyRicmVha3BvaW50cyA9IG9wdGlvbnMuYnJlYWtwb2ludHMsXG4gICAgICBicmVha3BvaW50c0lucHV0ID0gX29wdGlvbnMkYnJlYWtwb2ludHMgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnMkYnJlYWtwb2ludHMsXG4gICAgICBfb3B0aW9ucyRtaXhpbnMgPSBvcHRpb25zLm1peGlucyxcbiAgICAgIG1peGluc0lucHV0ID0gX29wdGlvbnMkbWl4aW5zID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zJG1peGlucyxcbiAgICAgIF9vcHRpb25zJHBhbGV0dGUgPSBvcHRpb25zLnBhbGV0dGUsXG4gICAgICBwYWxldHRlSW5wdXQgPSBfb3B0aW9ucyRwYWxldHRlID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zJHBhbGV0dGUsXG4gICAgICBzcGFjaW5nSW5wdXQgPSBvcHRpb25zLnNwYWNpbmcsXG4gICAgICBfb3B0aW9ucyR0eXBvZ3JhcGh5ID0gb3B0aW9ucy50eXBvZ3JhcGh5LFxuICAgICAgdHlwb2dyYXBoeUlucHV0ID0gX29wdGlvbnMkdHlwb2dyYXBoeSA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9ucyR0eXBvZ3JhcGh5LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3B0aW9ucywgW1wiYnJlYWtwb2ludHNcIiwgXCJtaXhpbnNcIiwgXCJwYWxldHRlXCIsIFwic3BhY2luZ1wiLCBcInR5cG9ncmFwaHlcIl0pO1xuXG4gIHZhciBwYWxldHRlID0gY3JlYXRlUGFsZXR0ZShwYWxldHRlSW5wdXQpO1xuICB2YXIgYnJlYWtwb2ludHMgPSBjcmVhdGVCcmVha3BvaW50cyhicmVha3BvaW50c0lucHV0KTtcbiAgdmFyIHNwYWNpbmcgPSBjcmVhdGVTcGFjaW5nKHNwYWNpbmdJbnB1dCk7XG4gIHZhciBtdWlUaGVtZSA9IGRlZXBtZXJnZSh7XG4gICAgYnJlYWtwb2ludHM6IGJyZWFrcG9pbnRzLFxuICAgIGRpcmVjdGlvbjogJ2x0cicsXG4gICAgbWl4aW5zOiBjcmVhdGVNaXhpbnMoYnJlYWtwb2ludHMsIHNwYWNpbmcsIG1peGluc0lucHV0KSxcbiAgICBvdmVycmlkZXM6IHt9LFxuICAgIC8vIEluamVjdCBjdXN0b20gc3R5bGVzXG4gICAgcGFsZXR0ZTogcGFsZXR0ZSxcbiAgICBwcm9wczoge30sXG4gICAgLy8gUHJvdmlkZSBkZWZhdWx0IHByb3BzXG4gICAgc2hhZG93czogc2hhZG93cyxcbiAgICB0eXBvZ3JhcGh5OiBjcmVhdGVUeXBvZ3JhcGh5KHBhbGV0dGUsIHR5cG9ncmFwaHlJbnB1dCksXG4gICAgc3BhY2luZzogc3BhY2luZyxcbiAgICBzaGFwZTogc2hhcGUsXG4gICAgdHJhbnNpdGlvbnM6IHRyYW5zaXRpb25zLFxuICAgIHpJbmRleDogekluZGV4XG4gIH0sIG90aGVyKTtcblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBtdWlUaGVtZSA9IGFyZ3MucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGFyZ3VtZW50KSB7XG4gICAgcmV0dXJuIGRlZXBtZXJnZShhY2MsIGFyZ3VtZW50KTtcbiAgfSwgbXVpVGhlbWUpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIHBzZXVkb0NsYXNzZXMgPSBbJ2NoZWNrZWQnLCAnZGlzYWJsZWQnLCAnZXJyb3InLCAnZm9jdXNlZCcsICdmb2N1c1Zpc2libGUnLCAncmVxdWlyZWQnLCAnZXhwYW5kZWQnLCAnc2VsZWN0ZWQnXTtcblxuICAgIHZhciB0cmF2ZXJzZSA9IGZ1bmN0aW9uIHRyYXZlcnNlKG5vZGUsIHBhcmVudEtleSkge1xuICAgICAgdmFyIGRlcHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICAgICAgdmFyIGtleTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pbiwgbm8tcmVzdHJpY3RlZC1zeW50YXhcblxuICAgICAgZm9yIChrZXkgaW4gbm9kZSkge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2tleV07XG5cbiAgICAgICAgaWYgKGRlcHRoID09PSAxKSB7XG4gICAgICAgICAgaWYgKGtleS5pbmRleE9mKCdNdWknKSA9PT0gMCAmJiBjaGlsZCkge1xuICAgICAgICAgICAgdHJhdmVyc2UoY2hpbGQsIGtleSwgZGVwdGggKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHNldWRvQ2xhc3Nlcy5pbmRleE9mKGtleSkgIT09IC0xICYmIE9iamVjdC5rZXlzKGNoaWxkKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoW1wiTWF0ZXJpYWwtVUk6IFRoZSBgXCIuY29uY2F0KHBhcmVudEtleSwgXCJgIGNvbXBvbmVudCBpbmNyZWFzZXMgXCIpICsgXCJ0aGUgQ1NTIHNwZWNpZmljaXR5IG9mIHRoZSBgXCIuY29uY2F0KGtleSwgXCJgIGludGVybmFsIHN0YXRlLlwiKSwgJ1lvdSBjYW4gbm90IG92ZXJyaWRlIGl0IGxpa2UgdGhpczogJywgSlNPTi5zdHJpbmdpZnkobm9kZSwgbnVsbCwgMiksICcnLCAnSW5zdGVhZCwgeW91IG5lZWQgdG8gdXNlIHRoZSAkcnVsZU5hbWUgc3ludGF4OicsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgcm9vdDogX2RlZmluZVByb3BlcnR5KHt9LCBcIiYkXCIuY29uY2F0KGtleSksIGNoaWxkKVxuICAgICAgICAgICAgfSwgbnVsbCwgMiksICcnLCAnaHR0cHM6Ly9tYXRlcmlhbC11aS5jb20vci9wc2V1ZG8tY2xhc3Nlcy1ndWlkZSddLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICB9IC8vIFJlbW92ZSB0aGUgc3R5bGUgdG8gcHJldmVudCBnbG9iYWwgY29uZmxpY3RzLlxuXG5cbiAgICAgICAgICBub2RlW2tleV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0cmF2ZXJzZShtdWlUaGVtZS5vdmVycmlkZXMpO1xuICB9XG5cbiAgcmV0dXJuIG11aVRoZW1lO1xufVxuXG52YXIgd2FybmVkT25jZSA9IGZhbHNlO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU11aVRoZW1lKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICghd2FybmVkT25jZSkge1xuICAgICAgd2FybmVkT25jZSA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKFsnTWF0ZXJpYWwtVUk6IHRoZSBjcmVhdGVNdWlUaGVtZSBmdW5jdGlvbiB3YXMgcmVuYW1lZCB0byBjcmVhdGVUaGVtZS4nLCAnJywgXCJZb3Ugc2hvdWxkIHVzZSBgaW1wb3J0IHsgY3JlYXRlVGhlbWUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS9zdHlsZXMnYFwiXS5qb2luKCdcXG4nKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVRoZW1lLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVRoZW1lOyIsInZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG5leHBvcnQgZGVmYXVsdCBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdtdWkubmVzdGVkJykgOiAnX19USEVNRV9ORVNURURfXyc7IiwiaW1wb3J0IG5lc3RlZCBmcm9tICcuLi9UaGVtZVByb3ZpZGVyL25lc3RlZCc7XG4vKipcbiAqIFRoaXMgaXMgdGhlIGxpc3Qgb2YgdGhlIHN0eWxlIHJ1bGUgbmFtZSB3ZSB1c2UgYXMgZHJvcCBpbiByZXBsYWNlbWVudCBmb3IgdGhlIGJ1aWx0LWluXG4gKiBwc2V1ZG8gY2xhc3NlcyAoOmNoZWNrZWQsIDpkaXNhYmxlZCwgOmZvY3VzZWQsIGV0Yy4pLlxuICpcbiAqIFdoeSBkbyB0aGV5IGV4aXN0IGluIHRoZSBmaXJzdCBwbGFjZT9cbiAqIFRoZXNlIGNsYXNzZXMgYXJlIHVzZWQgYXQgYSBzcGVjaWZpY2l0eSBvZiAyLlxuICogSXQgYWxsb3dzIHRoZW0gdG8gb3ZlcnJpZGUgcHJldmlvdXNseSBkZWZpbmllZCBzdHlsZXMgYXMgd2VsbCBhc1xuICogYmVpbmcgdW50b3VjaGVkIGJ5IHNpbXBsZSB1c2VyIG92ZXJyaWRlcy5cbiAqL1xuXG52YXIgcHNldWRvQ2xhc3NlcyA9IFsnY2hlY2tlZCcsICdkaXNhYmxlZCcsICdlcnJvcicsICdmb2N1c2VkJywgJ2ZvY3VzVmlzaWJsZScsICdyZXF1aXJlZCcsICdleHBhbmRlZCcsICdzZWxlY3RlZCddOyAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZ2VuZXJhdGVzIHVuaXF1ZSBjbGFzcyBuYW1lcyBiYXNlZCBvbiBjb3VudGVycy5cbi8vIFdoZW4gbmV3IGdlbmVyYXRvciBmdW5jdGlvbiBpcyBjcmVhdGVkLCBydWxlIGNvdW50ZXIgaXMgcmVzZXQuXG4vLyBXZSBuZWVkIHRvIHJlc2V0IHRoZSBydWxlIGNvdW50ZXIgZm9yIFNTUiBmb3IgZWFjaCByZXF1ZXN0LlxuLy9cbi8vIEl0J3MgaW5zcGlyZWQgYnlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jc3NpbmpzL2pzcy9ibG9iLzRlNmEwNWRkM2Y3YjY1NzJmZGQzYWIyMTY4NjFkOWU0NDZjMjAzMzEvc3JjL3V0aWxzL2NyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lLmpzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lKCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBfb3B0aW9ucyRkaXNhYmxlR2xvYmEgPSBvcHRpb25zLmRpc2FibGVHbG9iYWwsXG4gICAgICBkaXNhYmxlR2xvYmFsID0gX29wdGlvbnMkZGlzYWJsZUdsb2JhID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGRpc2FibGVHbG9iYSxcbiAgICAgIF9vcHRpb25zJHByb2R1Y3Rpb25QciA9IG9wdGlvbnMucHJvZHVjdGlvblByZWZpeCxcbiAgICAgIHByb2R1Y3Rpb25QcmVmaXggPSBfb3B0aW9ucyRwcm9kdWN0aW9uUHIgPT09IHZvaWQgMCA/ICdqc3MnIDogX29wdGlvbnMkcHJvZHVjdGlvblByLFxuICAgICAgX29wdGlvbnMkc2VlZCA9IG9wdGlvbnMuc2VlZCxcbiAgICAgIHNlZWQgPSBfb3B0aW9ucyRzZWVkID09PSB2b2lkIDAgPyAnJyA6IF9vcHRpb25zJHNlZWQ7XG4gIHZhciBzZWVkUHJlZml4ID0gc2VlZCA9PT0gJycgPyAnJyA6IFwiXCIuY29uY2F0KHNlZWQsIFwiLVwiKTtcbiAgdmFyIHJ1bGVDb3VudGVyID0gMDtcblxuICB2YXIgZ2V0TmV4dENvdW50ZXJJZCA9IGZ1bmN0aW9uIGdldE5leHRDb3VudGVySWQoKSB7XG4gICAgcnVsZUNvdW50ZXIgKz0gMTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAocnVsZUNvdW50ZXIgPj0gMWUxMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oWydNYXRlcmlhbC1VSTogWW91IG1pZ2h0IGhhdmUgYSBtZW1vcnkgbGVhay4nLCAnVGhlIHJ1bGVDb3VudGVyIGlzIG5vdCBzdXBwb3NlZCB0byBncm93IHRoYXQgbXVjaC4nXS5qb2luKCcnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGVDb3VudGVyO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbiAocnVsZSwgc3R5bGVTaGVldCkge1xuICAgIHZhciBuYW1lID0gc3R5bGVTaGVldC5vcHRpb25zLm5hbWU7IC8vIElzIGEgZ2xvYmFsIHN0YXRpYyBNVUkgc3R5bGU/XG5cbiAgICBpZiAobmFtZSAmJiBuYW1lLmluZGV4T2YoJ011aScpID09PSAwICYmICFzdHlsZVNoZWV0Lm9wdGlvbnMubGluayAmJiAhZGlzYWJsZUdsb2JhbCkge1xuICAgICAgLy8gV2UgY2FuIHVzZSBhIHNob3J0aGFuZCBjbGFzcyBuYW1lLCB3ZSBuZXZlciB1c2UgdGhlIGtleXMgdG8gc3R5bGUgdGhlIGNvbXBvbmVudHMuXG4gICAgICBpZiAocHNldWRvQ2xhc3Nlcy5pbmRleE9mKHJ1bGUua2V5KSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFwiTXVpLVwiLmNvbmNhdChydWxlLmtleSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmVmaXggPSBcIlwiLmNvbmNhdChzZWVkUHJlZml4KS5jb25jYXQobmFtZSwgXCItXCIpLmNvbmNhdChydWxlLmtleSk7XG5cbiAgICAgIGlmICghc3R5bGVTaGVldC5vcHRpb25zLnRoZW1lW25lc3RlZF0gfHwgc2VlZCAhPT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHByZWZpeCwgXCItXCIpLmNvbmNhdChnZXROZXh0Q291bnRlcklkKCkpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQoc2VlZFByZWZpeCkuY29uY2F0KHByb2R1Y3Rpb25QcmVmaXgpLmNvbmNhdChnZXROZXh0Q291bnRlcklkKCkpO1xuICAgIH1cblxuICAgIHZhciBzdWZmaXggPSBcIlwiLmNvbmNhdChydWxlLmtleSwgXCItXCIpLmNvbmNhdChnZXROZXh0Q291bnRlcklkKCkpOyAvLyBIZWxwIHdpdGggZGVidWdnYWJpbGl0eS5cblxuICAgIGlmIChzdHlsZVNoZWV0Lm9wdGlvbnMuY2xhc3NOYW1lUHJlZml4KSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQoc2VlZFByZWZpeCkuY29uY2F0KHN0eWxlU2hlZXQub3B0aW9ucy5jbGFzc05hbWVQcmVmaXgsIFwiLVwiKS5jb25jYXQoc3VmZml4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoc2VlZFByZWZpeCkuY29uY2F0KHN1ZmZpeCk7XG4gIH07XG59IiwiLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFRoZW1lUHJvcHMocGFyYW1zKSB7XG4gIHZhciB0aGVtZSA9IHBhcmFtcy50aGVtZSxcbiAgICAgIG5hbWUgPSBwYXJhbXMubmFtZSxcbiAgICAgIHByb3BzID0gcGFyYW1zLnByb3BzO1xuXG4gIGlmICghdGhlbWUgfHwgIXRoZW1lLnByb3BzIHx8ICF0aGVtZS5wcm9wc1tuYW1lXSkge1xuICAgIHJldHVybiBwcm9wcztcbiAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHMsIGNvZGUgYm9ycm93IGZyb20gUmVhY3Qgc291cmNlLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi8xNWE4ZjAzMTgzOGE1NTNlNDFjMGI2NmViMWJjZjFkYTg0NDgxMDRkL3BhY2thZ2VzL3JlYWN0L3NyYy9SZWFjdEVsZW1lbnQuanMjTDIyMVxuXG5cbiAgdmFyIGRlZmF1bHRQcm9wcyA9IHRoZW1lLnByb3BzW25hbWVdO1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BzO1xufSIsInZhciBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFpc1Byb2R1Y3Rpb24pIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRleHQgPSBcIldhcm5pbmc6IFwiICsgbWVzc2FnZTtcblxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2Fybih0ZXh0KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhyb3cgRXJyb3IodGV4dCk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB3YXJuaW5nO1xuIiwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnQgdmFyIGlzQnJvd3NlciA9ICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yod2luZG93KSkgPT09IFwib2JqZWN0XCIgJiYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGRvY3VtZW50KSkgPT09ICdvYmplY3QnICYmIGRvY3VtZW50Lm5vZGVUeXBlID09PSA5O1xuXG5leHBvcnQgZGVmYXVsdCBpc0Jyb3dzZXI7XG4iLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59IiwiaW1wb3J0IHNldFByb3RvdHlwZU9mIGZyb20gXCIuL3NldFByb3RvdHlwZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCBpc0luQnJvd3NlciBmcm9tICdpcy1pbi1icm93c2VyJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3Rpbnktd2FybmluZyc7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzJztcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlJztcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZCc7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSc7XG5cbnZhciBwbGFpbk9iamVjdENvbnN0cnVyY3RvciA9IHt9LmNvbnN0cnVjdG9yO1xuZnVuY3Rpb24gY2xvbmVTdHlsZShzdHlsZSkge1xuICBpZiAoc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2Ygc3R5bGUgIT09ICdvYmplY3QnKSByZXR1cm4gc3R5bGU7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0eWxlKSkgcmV0dXJuIHN0eWxlLm1hcChjbG9uZVN0eWxlKTtcbiAgaWYgKHN0eWxlLmNvbnN0cnVjdG9yICE9PSBwbGFpbk9iamVjdENvbnN0cnVyY3RvcikgcmV0dXJuIHN0eWxlO1xuICB2YXIgbmV3U3R5bGUgPSB7fTtcblxuICBmb3IgKHZhciBuYW1lIGluIHN0eWxlKSB7XG4gICAgbmV3U3R5bGVbbmFtZV0gPSBjbG9uZVN0eWxlKHN0eWxlW25hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBuZXdTdHlsZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBydWxlIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgbmFtZSA9ICd1bm5hbWVkJztcbiAgfVxuXG4gIHZhciBqc3MgPSBvcHRpb25zLmpzcztcbiAgdmFyIGRlY2xDb3B5ID0gY2xvbmVTdHlsZShkZWNsKTtcbiAgdmFyIHJ1bGUgPSBqc3MucGx1Z2lucy5vbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbENvcHksIG9wdGlvbnMpO1xuICBpZiAocnVsZSkgcmV0dXJuIHJ1bGU7IC8vIEl0IGlzIGFuIGF0LXJ1bGUgYW5kIGl0IGhhcyBubyBpbnN0YW5jZS5cblxuICBpZiAobmFtZVswXSA9PT0gJ0AnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBVbmtub3duIHJ1bGUgXCIgKyBuYW1lKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgam9pbiA9IGZ1bmN0aW9uIGpvaW4odmFsdWUsIGJ5KSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gUmVtb3ZlICFpbXBvcnRhbnQgZnJvbSB0aGUgdmFsdWUsIGl0IHdpbGwgYmUgcmVhZGRlZCBsYXRlci5cbiAgICBpZiAodmFsdWVbaV0gPT09ICchaW1wb3J0YW50JykgYnJlYWs7XG4gICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9IGJ5O1xuICAgIHJlc3VsdCArPSB2YWx1ZVtpXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBKU1MgYXJyYXkgdmFsdWUgdG8gYSBDU1Mgc3RyaW5nLlxuICpcbiAqIGBtYXJnaW46IFtbJzVweCcsICcxMHB4J11dYCA+IGBtYXJnaW46IDVweCAxMHB4O2BcbiAqIGBib3JkZXI6IFsnMXB4JywgJzJweCddYCA+IGBib3JkZXI6IDFweCwgMnB4O2BcbiAqIGBtYXJnaW46IFtbJzVweCcsICcxMHB4J10sICchaW1wb3J0YW50J11gID4gYG1hcmdpbjogNXB4IDEwcHggIWltcG9ydGFudDtgXG4gKiBgY29sb3I6IFsncmVkJywgIWltcG9ydGFudF1gID4gYGNvbG9yOiByZWQgIWltcG9ydGFudDtgXG4gKi9cblxuXG52YXIgdG9Dc3NWYWx1ZSA9IGZ1bmN0aW9uIHRvQ3NzVmFsdWUodmFsdWUsIGlnbm9yZUltcG9ydGFudCkge1xuICBpZiAoaWdub3JlSW1wb3J0YW50ID09PSB2b2lkIDApIHtcbiAgICBpZ25vcmVJbXBvcnRhbnQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgdmFyIGNzc1ZhbHVlID0gJyc7IC8vIFN1cHBvcnQgc3BhY2Ugc2VwYXJhdGVkIHZhbHVlcyB2aWEgYFtbJzVweCcsICcxMHB4J11dYC5cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVbaV0gPT09ICchaW1wb3J0YW50JykgYnJlYWs7XG4gICAgICBpZiAoY3NzVmFsdWUpIGNzc1ZhbHVlICs9ICcsICc7XG4gICAgICBjc3NWYWx1ZSArPSBqb2luKHZhbHVlW2ldLCAnICcpO1xuICAgIH1cbiAgfSBlbHNlIGNzc1ZhbHVlID0gam9pbih2YWx1ZSwgJywgJyk7IC8vIEFkZCAhaW1wb3J0YW50LCBiZWNhdXNlIGl0IHdhcyBpZ25vcmVkLlxuXG5cbiAgaWYgKCFpZ25vcmVJbXBvcnRhbnQgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICchaW1wb3J0YW50Jykge1xuICAgIGNzc1ZhbHVlICs9ICcgIWltcG9ydGFudCc7XG4gIH1cblxuICByZXR1cm4gY3NzVmFsdWU7XG59O1xuXG5mdW5jdGlvbiBnZXRXaGl0ZXNwYWNlU3ltYm9scyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZm9ybWF0ID09PSBmYWxzZSkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lYnJlYWs6ICcnLFxuICAgICAgc3BhY2U6ICcnXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGluZWJyZWFrOiAnXFxuJyxcbiAgICBzcGFjZTogJyAnXG4gIH07XG59XG5cbi8qKlxuICogSW5kZW50IGEgc3RyaW5nLlxuICogaHR0cDovL2pzcGVyZi5jb20vYXJyYXktam9pbi12cy1mb3JcbiAqL1xuXG5mdW5jdGlvbiBpbmRlbnRTdHIoc3RyLCBpbmRlbnQpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBpbmRlbnQ7IGluZGV4KyspIHtcbiAgICByZXN1bHQgKz0gJyAgJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQgKyBzdHI7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgUnVsZSB0byBDU1Mgc3RyaW5nLlxuICovXG5cblxuZnVuY3Rpb24gdG9Dc3Moc2VsZWN0b3IsIHN0eWxlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICghc3R5bGUpIHJldHVybiByZXN1bHQ7XG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRpbmRlbnQgPSBfb3B0aW9ucy5pbmRlbnQsXG4gICAgICBpbmRlbnQgPSBfb3B0aW9ucyRpbmRlbnQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRpbmRlbnQ7XG4gIHZhciBmYWxsYmFja3MgPSBzdHlsZS5mYWxsYmFja3M7XG5cbiAgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSBmYWxzZSkge1xuICAgIGluZGVudCA9IC1JbmZpbml0eTtcbiAgfVxuXG4gIHZhciBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMgPSBnZXRXaGl0ZXNwYWNlU3ltYm9scyhvcHRpb25zKSxcbiAgICAgIGxpbmVicmVhayA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5saW5lYnJlYWssXG4gICAgICBzcGFjZSA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5zcGFjZTtcblxuICBpZiAoc2VsZWN0b3IpIGluZGVudCsrOyAvLyBBcHBseSBmYWxsYmFja3MgZmlyc3QuXG5cbiAgaWYgKGZhbGxiYWNrcykge1xuICAgIC8vIEFycmF5IHN5bnRheCB7ZmFsbGJhY2tzOiBbe3Byb3A6IHZhbHVlfV19XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmFsbGJhY2tzKSkge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGZhbGxiYWNrcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIGZhbGxiYWNrID0gZmFsbGJhY2tzW2luZGV4XTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGZhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZmFsbGJhY2tbcHJvcF07XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9IGxpbmVicmVhaztcbiAgICAgICAgICAgIHJlc3VsdCArPSBpbmRlbnRTdHIocHJvcCArIFwiOlwiICsgc3BhY2UgKyB0b0Nzc1ZhbHVlKHZhbHVlKSArIFwiO1wiLCBpbmRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPYmplY3Qgc3ludGF4IHtmYWxsYmFja3M6IHtwcm9wOiB2YWx1ZX19XG4gICAgICBmb3IgKHZhciBfcHJvcCBpbiBmYWxsYmFja3MpIHtcbiAgICAgICAgdmFyIF92YWx1ZSA9IGZhbGxiYWNrc1tfcHJvcF07XG5cbiAgICAgICAgaWYgKF92YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9IGxpbmVicmVhaztcbiAgICAgICAgICByZXN1bHQgKz0gaW5kZW50U3RyKF9wcm9wICsgXCI6XCIgKyBzcGFjZSArIHRvQ3NzVmFsdWUoX3ZhbHVlKSArIFwiO1wiLCBpbmRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX3Byb3AyIGluIHN0eWxlKSB7XG4gICAgdmFyIF92YWx1ZTIgPSBzdHlsZVtfcHJvcDJdO1xuXG4gICAgaWYgKF92YWx1ZTIgIT0gbnVsbCAmJiBfcHJvcDIgIT09ICdmYWxsYmFja3MnKSB7XG4gICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gbGluZWJyZWFrO1xuICAgICAgcmVzdWx0ICs9IGluZGVudFN0cihfcHJvcDIgKyBcIjpcIiArIHNwYWNlICsgdG9Dc3NWYWx1ZShfdmFsdWUyKSArIFwiO1wiLCBpbmRlbnQpO1xuICAgIH1cbiAgfSAvLyBBbGxvdyBlbXB0eSBzdHlsZSBpbiB0aGlzIGNhc2UsIGJlY2F1c2UgcHJvcGVydGllcyB3aWxsIGJlIGFkZGVkIGR5bmFtaWNhbGx5LlxuXG5cbiAgaWYgKCFyZXN1bHQgJiYgIW9wdGlvbnMuYWxsb3dFbXB0eSkgcmV0dXJuIHJlc3VsdDsgLy8gV2hlbiBydWxlIGlzIGJlaW5nIHN0cmluZ2lmaWVkIGJlZm9yZSBzZWxlY3RvciB3YXMgZGVmaW5lZC5cblxuICBpZiAoIXNlbGVjdG9yKSByZXR1cm4gcmVzdWx0O1xuICBpbmRlbnQtLTtcbiAgaWYgKHJlc3VsdCkgcmVzdWx0ID0gXCJcIiArIGxpbmVicmVhayArIHJlc3VsdCArIGxpbmVicmVhaztcbiAgcmV0dXJuIGluZGVudFN0cihcIlwiICsgc2VsZWN0b3IgKyBzcGFjZSArIFwie1wiICsgcmVzdWx0LCBpbmRlbnQpICsgaW5kZW50U3RyKCd9JywgaW5kZW50KTtcbn1cblxudmFyIGVzY2FwZVJlZ2V4ID0gLyhbW1xcXS4jKiQ+PCt+PXxeOigpLFwiJ2BcXHNdKS9nO1xudmFyIG5hdGl2ZUVzY2FwZSA9IHR5cGVvZiBDU1MgIT09ICd1bmRlZmluZWQnICYmIENTUy5lc2NhcGU7XG52YXIgZXNjYXBlID0gKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIG5hdGl2ZUVzY2FwZSA/IG5hdGl2ZUVzY2FwZShzdHIpIDogc3RyLnJlcGxhY2UoZXNjYXBlUmVnZXgsICdcXFxcJDEnKTtcbn0pO1xuXG52YXIgQmFzZVN0eWxlUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VTdHlsZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdzdHlsZSc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHZhciBzaGVldCA9IG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIFJlbmRlcmVyID0gb3B0aW9ucy5SZW5kZXJlcjtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICBpZiAoc2hlZXQpIHRoaXMucmVuZGVyZXIgPSBzaGVldC5yZW5kZXJlcjtlbHNlIGlmIChSZW5kZXJlcikgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcigpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IGEgc3R5bGUgcHJvcGVydHkuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IEJhc2VTdHlsZVJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5wcm9wID0gZnVuY3Rpb24gcHJvcChuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIC8vIEl0J3MgYSBnZXR0ZXIuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLnN0eWxlW25hbWVdOyAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGUgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkLlxuXG4gICAgdmFyIGZvcmNlID0gb3B0aW9ucyA/IG9wdGlvbnMuZm9yY2UgOiBmYWxzZTtcbiAgICBpZiAoIWZvcmNlICYmIHRoaXMuc3R5bGVbbmFtZV0gPT09IHZhbHVlKSByZXR1cm4gdGhpcztcbiAgICB2YXIgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLnByb2Nlc3MgIT09IGZhbHNlKSB7XG4gICAgICBuZXdWYWx1ZSA9IHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vbkNoYW5nZVZhbHVlKHZhbHVlLCBuYW1lLCB0aGlzKTtcbiAgICB9XG5cbiAgICB2YXIgaXNFbXB0eSA9IG5ld1ZhbHVlID09IG51bGwgfHwgbmV3VmFsdWUgPT09IGZhbHNlO1xuICAgIHZhciBpc0RlZmluZWQgPSBuYW1lIGluIHRoaXMuc3R5bGU7IC8vIFZhbHVlIGlzIGVtcHR5IGFuZCB3YXNuJ3QgZGVmaW5lZCBiZWZvcmUuXG5cbiAgICBpZiAoaXNFbXB0eSAmJiAhaXNEZWZpbmVkICYmICFmb3JjZSkgcmV0dXJuIHRoaXM7IC8vIFdlIGFyZSBnb2luZyB0byByZW1vdmUgdGhpcyB2YWx1ZS5cblxuICAgIHZhciByZW1vdmUgPSBpc0VtcHR5ICYmIGlzRGVmaW5lZDtcbiAgICBpZiAocmVtb3ZlKSBkZWxldGUgdGhpcy5zdHlsZVtuYW1lXTtlbHNlIHRoaXMuc3R5bGVbbmFtZV0gPSBuZXdWYWx1ZTsgLy8gUmVuZGVyYWJsZSBpcyBkZWZpbmVkIGlmIFN0eWxlU2hlZXQgb3B0aW9uIGBsaW5rYCBpcyB0cnVlLlxuXG4gICAgaWYgKHRoaXMucmVuZGVyYWJsZSAmJiB0aGlzLnJlbmRlcmVyKSB7XG4gICAgICBpZiAocmVtb3ZlKSB0aGlzLnJlbmRlcmVyLnJlbW92ZVByb3BlcnR5KHRoaXMucmVuZGVyYWJsZSwgbmFtZSk7ZWxzZSB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMucmVuZGVyYWJsZSwgbmFtZSwgbmV3VmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuXG4gICAgaWYgKHNoZWV0ICYmIHNoZWV0LmF0dGFjaGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAnW0pTU10gUnVsZSBpcyBub3QgbGlua2VkLiBNaXNzaW5nIHNoZWV0IG9wdGlvbiBcImxpbms6IHRydWVcIi4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gQmFzZVN0eWxlUnVsZTtcbn0oKTtcbnZhciBTdHlsZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlU3R5bGVSdWxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFN0eWxlUnVsZSwgX0Jhc2VTdHlsZVJ1bGUpO1xuXG4gIGZ1bmN0aW9uIFN0eWxlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQmFzZVN0eWxlUnVsZS5jYWxsKHRoaXMsIGtleSwgc3R5bGUsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgdmFyIHNlbGVjdG9yID0gb3B0aW9ucy5zZWxlY3RvcixcbiAgICAgICAgc2NvcGVkID0gb3B0aW9ucy5zY29wZWQsXG4gICAgICAgIHNoZWV0ID0gb3B0aW9ucy5zaGVldCxcbiAgICAgICAgZ2VuZXJhdGVJZCA9IG9wdGlvbnMuZ2VuZXJhdGVJZDtcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgX3RoaXMuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG4gICAgfSBlbHNlIGlmIChzY29wZWQgIT09IGZhbHNlKSB7XG4gICAgICBfdGhpcy5pZCA9IGdlbmVyYXRlSWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIHNoZWV0KTtcbiAgICAgIF90aGlzLnNlbGVjdG9yVGV4dCA9IFwiLlwiICsgZXNjYXBlKF90aGlzLmlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBzZWxlY3RvciBzdHJpbmcuXG4gICAqIEF0dGVudGlvbjogdXNlIHRoaXMgd2l0aCBjYXV0aW9uLiBNb3N0IGJyb3dzZXJzIGRpZG4ndCBpbXBsZW1lbnRcbiAgICogc2VsZWN0b3JUZXh0IHNldHRlciwgc28gdGhpcyBtYXkgcmVzdWx0IGluIHJlcmVuZGVyaW5nIG9mIGVudGlyZSBTdHlsZSBTaGVldC5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvMiA9IFN0eWxlUnVsZS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEFwcGx5IHJ1bGUgdG8gYW4gZWxlbWVudCBpbmxpbmUuXG4gICAqL1xuICBfcHJvdG8yLmFwcGx5VG8gPSBmdW5jdGlvbiBhcHBseVRvKHJlbmRlcmFibGUpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuXG4gICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICB2YXIganNvbiA9IHRoaXMudG9KU09OKCk7XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4ganNvbikge1xuICAgICAgICByZW5kZXJlci5zZXRQcm9wZXJ0eShyZW5kZXJhYmxlLCBwcm9wLCBqc29uW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBydWxlLlxuICAgKiBGYWxsYmFja3MgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAqIFVzZWZ1bCBmb3IgaW5saW5lIHN0eWxlcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICB2YXIganNvbiA9IHt9O1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnN0eWxlW3Byb3BdO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIGpzb25bcHJvcF0gPSB2YWx1ZTtlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkganNvbltwcm9wXSA9IHRvQ3NzVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBqc29uO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzIudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcbiAgICB2YXIgb3B0cyA9IGxpbmsgPyBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgYWxsb3dFbXB0eTogdHJ1ZVxuICAgIH0pIDogb3B0aW9ucztcbiAgICByZXR1cm4gdG9Dc3ModGhpcy5zZWxlY3RvclRleHQsIHRoaXMuc3R5bGUsIG9wdHMpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTdHlsZVJ1bGUsIFt7XG4gICAga2V5OiBcInNlbGVjdG9yXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChzZWxlY3RvciA9PT0gdGhpcy5zZWxlY3RvclRleHQpIHJldHVybjtcbiAgICAgIHRoaXMuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICAgIHJlbmRlcmFibGUgPSB0aGlzLnJlbmRlcmFibGU7XG4gICAgICBpZiAoIXJlbmRlcmFibGUgfHwgIXJlbmRlcmVyKSByZXR1cm47XG4gICAgICB2YXIgaGFzQ2hhbmdlZCA9IHJlbmRlcmVyLnNldFNlbGVjdG9yKHJlbmRlcmFibGUsIHNlbGVjdG9yKTsgLy8gSWYgc2VsZWN0b3Igc2V0dGVyIGlzIG5vdCBpbXBsZW1lbnRlZCwgcmVyZW5kZXIgdGhlIHJ1bGUuXG5cbiAgICAgIGlmICghaGFzQ2hhbmdlZCkge1xuICAgICAgICByZW5kZXJlci5yZXBsYWNlUnVsZShyZW5kZXJhYmxlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNlbGVjdG9yIHN0cmluZy5cbiAgICAgKi9cbiAgICAsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RvclRleHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0eWxlUnVsZTtcbn0oQmFzZVN0eWxlUnVsZSk7XG52YXIgcGx1Z2luU3R5bGVSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKGtleVswXSA9PT0gJ0AnIHx8IG9wdGlvbnMucGFyZW50ICYmIG9wdGlvbnMucGFyZW50LnR5cGUgPT09ICdrZXlmcmFtZXMnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFN0eWxlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGRlZmF1bHRUb1N0cmluZ09wdGlvbnMgPSB7XG4gIGluZGVudDogMSxcbiAgY2hpbGRyZW46IHRydWVcbn07XG52YXIgYXRSZWdFeHAgPSAvQChbXFx3LV0rKS87XG4vKipcbiAqIENvbmRpdGlvbmFsIHJ1bGUgZm9yIEBtZWRpYSwgQHN1cHBvcnRzXG4gKi9cblxudmFyIENvbmRpdGlvbmFsUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbmRpdGlvbmFsUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdjb25kaXRpb25hbCc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHZhciBhdE1hdGNoID0ga2V5Lm1hdGNoKGF0UmVnRXhwKTtcbiAgICB0aGlzLmF0ID0gYXRNYXRjaCA/IGF0TWF0Y2hbMV0gOiAndW5rbm93bic7IC8vIEtleSBtaWdodCBjb250YWluIGEgdW5pcXVlIHN1ZmZpeCBpbiBjYXNlIHRoZSBgbmFtZWAgcGFzc2VkIGJ5IHVzZXIgd2FzIGR1cGxpY2F0ZS5cblxuICAgIHRoaXMucXVlcnkgPSBvcHRpb25zLm5hbWUgfHwgXCJAXCIgKyB0aGlzLmF0O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5ydWxlcyA9IG5ldyBSdWxlTGlzdChfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgcGFyZW50OiB0aGlzXG4gICAgfSkpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlc1tuYW1lXSk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5wcm9jZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHJ1bGUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IENvbmRpdGlvbmFsUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFJ1bGUgPSBmdW5jdGlvbiBnZXRSdWxlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUsIHJ1biBwbHVnaW5zLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hZGRSdWxlID0gZnVuY3Rpb24gYWRkUnVsZShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHZhciBydWxlID0gdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGUsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMgPSBnZXRXaGl0ZXNwYWNlU3ltYm9scyhvcHRpb25zKSxcbiAgICAgICAgbGluZWJyZWFrID0gX2dldFdoaXRlc3BhY2VTeW1ib2xzLmxpbmVicmVhaztcblxuICAgIGlmIChvcHRpb25zLmluZGVudCA9PSBudWxsKSBvcHRpb25zLmluZGVudCA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnMuaW5kZW50O1xuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuID09IG51bGwpIG9wdGlvbnMuY2hpbGRyZW4gPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zLmNoaWxkcmVuO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeSArIFwiIHt9XCI7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ydWxlcy50b1N0cmluZyhvcHRpb25zKTtcbiAgICByZXR1cm4gY2hpbGRyZW4gPyB0aGlzLnF1ZXJ5ICsgXCIge1wiICsgbGluZWJyZWFrICsgY2hpbGRyZW4gKyBsaW5lYnJlYWsgKyBcIn1cIiA6ICcnO1xuICB9O1xuXG4gIHJldHVybiBDb25kaXRpb25hbFJ1bGU7XG59KCk7XG52YXIga2V5UmVnRXhwID0gL0BtZWRpYXxAc3VwcG9ydHNcXHMrLztcbnZhciBwbHVnaW5Db25kaXRpb25hbFJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGtleVJlZ0V4cC50ZXN0KGtleSkgPyBuZXcgQ29uZGl0aW9uYWxSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDEgPSB7XG4gIGluZGVudDogMSxcbiAgY2hpbGRyZW46IHRydWVcbn07XG52YXIgbmFtZVJlZ0V4cCA9IC9Aa2V5ZnJhbWVzXFxzKyhbXFx3LV0rKS87XG4vKipcbiAqIFJ1bGUgZm9yIEBrZXlmcmFtZXNcbiAqL1xuXG52YXIgS2V5ZnJhbWVzUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEtleWZyYW1lc1J1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAna2V5ZnJhbWVzJztcbiAgICB0aGlzLmF0ID0gJ0BrZXlmcmFtZXMnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB2YXIgbmFtZU1hdGNoID0ga2V5Lm1hdGNoKG5hbWVSZWdFeHApO1xuXG4gICAgaWYgKG5hbWVNYXRjaCAmJiBuYW1lTWF0Y2hbMV0pIHtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWVNYXRjaFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uYW1lID0gJ25vbmFtZSc7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIEJhZCBrZXlmcmFtZXMgbmFtZSBcIiArIGtleSkgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdGhpcy5rZXkgPSB0aGlzLnR5cGUgKyBcIi1cIiArIHRoaXMubmFtZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBzY29wZWQgPSBvcHRpb25zLnNjb3BlZCxcbiAgICAgICAgc2hlZXQgPSBvcHRpb25zLnNoZWV0LFxuICAgICAgICBnZW5lcmF0ZUlkID0gb3B0aW9ucy5nZW5lcmF0ZUlkO1xuICAgIHRoaXMuaWQgPSBzY29wZWQgPT09IGZhbHNlID8gdGhpcy5uYW1lIDogZXNjYXBlKGdlbmVyYXRlSWQodGhpcywgc2hlZXQpKTtcbiAgICB0aGlzLnJ1bGVzID0gbmV3IFJ1bGVMaXN0KF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGZyYW1lcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQobmFtZSwgZnJhbWVzW25hbWVdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgICBwYXJlbnQ6IHRoaXNcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gS2V5ZnJhbWVzUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDE7XG4gICAgfVxuXG4gICAgdmFyIF9nZXRXaGl0ZXNwYWNlU3ltYm9scyA9IGdldFdoaXRlc3BhY2VTeW1ib2xzKG9wdGlvbnMpLFxuICAgICAgICBsaW5lYnJlYWsgPSBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMubGluZWJyZWFrO1xuXG4gICAgaWYgKG9wdGlvbnMuaW5kZW50ID09IG51bGwpIG9wdGlvbnMuaW5kZW50ID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxLmluZGVudDtcbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PSBudWxsKSBvcHRpb25zLmNoaWxkcmVuID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxLmNoaWxkcmVuO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdCArIFwiIFwiICsgdGhpcy5pZCArIFwiIHt9XCI7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ydWxlcy50b1N0cmluZyhvcHRpb25zKTtcbiAgICBpZiAoY2hpbGRyZW4pIGNoaWxkcmVuID0gXCJcIiArIGxpbmVicmVhayArIGNoaWxkcmVuICsgbGluZWJyZWFrO1xuICAgIHJldHVybiB0aGlzLmF0ICsgXCIgXCIgKyB0aGlzLmlkICsgXCIge1wiICsgY2hpbGRyZW4gKyBcIn1cIjtcbiAgfTtcblxuICByZXR1cm4gS2V5ZnJhbWVzUnVsZTtcbn0oKTtcbnZhciBrZXlSZWdFeHAkMSA9IC9Aa2V5ZnJhbWVzXFxzKy87XG52YXIgcmVmUmVnRXhwID0gL1xcJChbXFx3LV0rKS9nO1xuXG52YXIgZmluZFJlZmVyZW5jZWRLZXlmcmFtZSA9IGZ1bmN0aW9uIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsLCBrZXlmcmFtZXMpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbC5yZXBsYWNlKHJlZlJlZ0V4cCwgZnVuY3Rpb24gKG1hdGNoLCBuYW1lKSB7XG4gICAgICBpZiAobmFtZSBpbiBrZXlmcmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIGtleWZyYW1lc1tuYW1lXTtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBSZWZlcmVuY2VkIGtleWZyYW1lcyBydWxlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQuXCIpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn07XG4vKipcbiAqIFJlcGxhY2UgdGhlIHJlZmVyZW5jZSBmb3IgYSBhbmltYXRpb24gbmFtZS5cbiAqL1xuXG5cbnZhciByZXBsYWNlUmVmID0gZnVuY3Rpb24gcmVwbGFjZVJlZihzdHlsZSwgcHJvcCwga2V5ZnJhbWVzKSB7XG4gIHZhciB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuICB2YXIgcmVmS2V5ZnJhbWUgPSBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbHVlLCBrZXlmcmFtZXMpO1xuXG4gIGlmIChyZWZLZXlmcmFtZSAhPT0gdmFsdWUpIHtcbiAgICBzdHlsZVtwcm9wXSA9IHJlZktleWZyYW1lO1xuICB9XG59O1xuXG52YXIgcGx1Z2luS2V5ZnJhbWVzUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5UmVnRXhwJDEudGVzdChrZXkpID8gbmV3IEtleWZyYW1lc1J1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIDogbnVsbDtcbiAgfSxcbiAgLy8gQW5pbWF0aW9uIG5hbWUgcmVmIHJlcGxhY2VyLlxuICBvblByb2Nlc3NTdHlsZTogZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJyB8fCAhc2hlZXQpIHJldHVybiBzdHlsZTtcbiAgICBpZiAoJ2FuaW1hdGlvbi1uYW1lJyBpbiBzdHlsZSkgcmVwbGFjZVJlZihzdHlsZSwgJ2FuaW1hdGlvbi1uYW1lJywgc2hlZXQua2V5ZnJhbWVzKTtcbiAgICBpZiAoJ2FuaW1hdGlvbicgaW4gc3R5bGUpIHJlcGxhY2VSZWYoc3R5bGUsICdhbmltYXRpb24nLCBzaGVldC5rZXlmcmFtZXMpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgb25DaGFuZ2VWYWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWwsIHByb3AsIHJ1bGUpIHtcbiAgICB2YXIgc2hlZXQgPSBydWxlLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICBpZiAoIXNoZWV0KSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICAgICAgcmV0dXJuIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsLCBzaGVldC5rZXlmcmFtZXMpO1xuXG4gICAgICBjYXNlICdhbmltYXRpb24tbmFtZSc6XG4gICAgICAgIHJldHVybiBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbCwgc2hlZXQua2V5ZnJhbWVzKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBLZXlmcmFtZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlU3R5bGVSdWxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKEtleWZyYW1lUnVsZSwgX0Jhc2VTdHlsZVJ1bGUpO1xuXG4gIGZ1bmN0aW9uIEtleWZyYW1lUnVsZSgpIHtcbiAgICByZXR1cm4gX0Jhc2VTdHlsZVJ1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEtleWZyYW1lUnVsZS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcbiAgICB2YXIgb3B0cyA9IGxpbmsgPyBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgYWxsb3dFbXB0eTogdHJ1ZVxuICAgIH0pIDogb3B0aW9ucztcbiAgICByZXR1cm4gdG9Dc3ModGhpcy5rZXksIHRoaXMuc3R5bGUsIG9wdHMpO1xuICB9O1xuXG4gIHJldHVybiBLZXlmcmFtZVJ1bGU7XG59KEJhc2VTdHlsZVJ1bGUpO1xudmFyIHBsdWdpbktleWZyYW1lUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC50eXBlID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgcmV0dXJuIG5ldyBLZXlmcmFtZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbnZhciBGb250RmFjZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb250RmFjZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdmb250LWZhY2UnO1xuICAgIHRoaXMuYXQgPSAnQGZvbnQtZmFjZSc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBGb250RmFjZVJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgX2dldFdoaXRlc3BhY2VTeW1ib2xzID0gZ2V0V2hpdGVzcGFjZVN5bWJvbHMob3B0aW9ucyksXG4gICAgICAgIGxpbmVicmVhayA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5saW5lYnJlYWs7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnN0eWxlKSkge1xuICAgICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5zdHlsZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc3RyICs9IHRvQ3NzKHRoaXMuYXQsIHRoaXMuc3R5bGVbaW5kZXhdKTtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVbaW5kZXggKyAxXSkgc3RyICs9IGxpbmVicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9Dc3ModGhpcy5hdCwgdGhpcy5zdHlsZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIEZvbnRGYWNlUnVsZTtcbn0oKTtcbnZhciBrZXlSZWdFeHAkMiA9IC9AZm9udC1mYWNlLztcbnZhciBwbHVnaW5Gb250RmFjZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5UmVnRXhwJDIudGVzdChrZXkpID8gbmV3IEZvbnRGYWNlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBWaWV3cG9ydFJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWaWV3cG9ydFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICd2aWV3cG9ydCc7XG4gICAgdGhpcy5hdCA9ICdAdmlld3BvcnQnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gVmlld3BvcnRSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRvQ3NzKHRoaXMua2V5LCB0aGlzLnN0eWxlLCBvcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4gVmlld3BvcnRSdWxlO1xufSgpO1xudmFyIHBsdWdpblZpZXdwb3J0UnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBrZXkgPT09ICdAdmlld3BvcnQnIHx8IGtleSA9PT0gJ0AtbXMtdmlld3BvcnQnID8gbmV3IFZpZXdwb3J0UnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBTaW1wbGVSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2ltcGxlUnVsZShrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ3NpbXBsZSc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cblxuICB2YXIgX3Byb3RvID0gU2ltcGxlUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpKSB7XG4gICAgICB2YXIgc3RyID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnZhbHVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzdHIgKz0gdGhpcy5rZXkgKyBcIiBcIiArIHRoaXMudmFsdWVbaW5kZXhdICsgXCI7XCI7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlW2luZGV4ICsgMV0pIHN0ciArPSAnXFxuJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5rZXkgKyBcIiBcIiArIHRoaXMudmFsdWUgKyBcIjtcIjtcbiAgfTtcblxuICByZXR1cm4gU2ltcGxlUnVsZTtcbn0oKTtcbnZhciBrZXlzTWFwID0ge1xuICAnQGNoYXJzZXQnOiB0cnVlLFxuICAnQGltcG9ydCc6IHRydWUsXG4gICdAbmFtZXNwYWNlJzogdHJ1ZVxufTtcbnZhciBwbHVnaW5TaW1wbGVSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGtleSBpbiBrZXlzTWFwID8gbmV3IFNpbXBsZVJ1bGUoa2V5LCB2YWx1ZSwgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgcGx1Z2lucyA9IFtwbHVnaW5TdHlsZVJ1bGUsIHBsdWdpbkNvbmRpdGlvbmFsUnVsZSwgcGx1Z2luS2V5ZnJhbWVzUnVsZSwgcGx1Z2luS2V5ZnJhbWVSdWxlLCBwbHVnaW5Gb250RmFjZVJ1bGUsIHBsdWdpblZpZXdwb3J0UnVsZSwgcGx1Z2luU2ltcGxlUnVsZV07XG5cbnZhciBkZWZhdWx0VXBkYXRlT3B0aW9ucyA9IHtcbiAgcHJvY2VzczogdHJ1ZVxufTtcbnZhciBmb3JjZVVwZGF0ZU9wdGlvbnMgPSB7XG4gIGZvcmNlOiB0cnVlLFxuICBwcm9jZXNzOiB0cnVlXG4gIC8qKlxuICAgKiBDb250YWlucyBydWxlcyBvYmplY3RzIGFuZCBhbGxvd3MgYWRkaW5nL3JlbW92aW5nIGV0Yy5cbiAgICogSXMgdXNlZCBmb3IgZS5nLiBieSBgU3R5bGVTaGVldGAgb3IgYENvbmRpdGlvbmFsUnVsZWAuXG4gICAqL1xuXG59O1xuXG52YXIgUnVsZUxpc3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvLyBSdWxlcyByZWdpc3RyeSBmb3IgYWNjZXNzIGJ5IC5nZXQoKSBtZXRob2QuXG4gIC8vIEl0IGNvbnRhaW5zIHRoZSBzYW1lIHJ1bGUgcmVnaXN0ZXJlZCBieSBuYW1lIGFuZCBieSBzZWxlY3Rvci5cbiAgLy8gT3JpZ2luYWwgc3R5bGVzIG9iamVjdC5cbiAgLy8gVXNlZCB0byBlbnN1cmUgY29ycmVjdCBydWxlcyBvcmRlci5cbiAgZnVuY3Rpb24gUnVsZUxpc3Qob3B0aW9ucykge1xuICAgIHRoaXMubWFwID0ge307XG4gICAgdGhpcy5yYXcgPSB7fTtcbiAgICB0aGlzLmluZGV4ID0gW107XG4gICAgdGhpcy5jb3VudGVyID0gMDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY2xhc3NlcyA9IG9wdGlvbnMuY2xhc3NlcztcbiAgICB0aGlzLmtleWZyYW1lcyA9IG9wdGlvbnMua2V5ZnJhbWVzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUuXG4gICAqXG4gICAqIFdpbGwgbm90IHJlbmRlciBhZnRlciBTdHlsZSBTaGVldCB3YXMgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFJ1bGVMaXN0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKG5hbWUsIGRlY2wsIHJ1bGVPcHRpb25zKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHBhcmVudCA9IF90aGlzJG9wdGlvbnMucGFyZW50LFxuICAgICAgICBzaGVldCA9IF90aGlzJG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIGpzcyA9IF90aGlzJG9wdGlvbnMuanNzLFxuICAgICAgICBSZW5kZXJlciA9IF90aGlzJG9wdGlvbnMuUmVuZGVyZXIsXG4gICAgICAgIGdlbmVyYXRlSWQgPSBfdGhpcyRvcHRpb25zLmdlbmVyYXRlSWQsXG4gICAgICAgIHNjb3BlZCA9IF90aGlzJG9wdGlvbnMuc2NvcGVkO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7XG4gICAgICBjbGFzc2VzOiB0aGlzLmNsYXNzZXMsXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIHNoZWV0OiBzaGVldCxcbiAgICAgIGpzczoganNzLFxuICAgICAgUmVuZGVyZXI6IFJlbmRlcmVyLFxuICAgICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZCxcbiAgICAgIHNjb3BlZDogc2NvcGVkLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGtleWZyYW1lczogdGhpcy5rZXlmcmFtZXMsXG4gICAgICBzZWxlY3RvcjogdW5kZWZpbmVkXG4gICAgfSwgcnVsZU9wdGlvbnMpOyAvLyBXaGVuIHVzZXIgdXNlcyAuY3JlYXRlU3R5bGVTaGVldCgpLCBkdXBsaWNhdGUgbmFtZXMgYXJlIG5vdCBwb3NzaWJsZSwgYnV0XG4gICAgLy8gYHNoZWV0LmFkZFJ1bGUoKWAgb3BlbnMgdGhlIGRvb3IgZm9yIGFueSBkdXBsaWNhdGUgcnVsZSBuYW1lLiBXaGVuIHRoaXMgaGFwcGVuc1xuICAgIC8vIHdlIG5lZWQgdG8gbWFrZSB0aGUga2V5IHVuaXF1ZSB3aXRoaW4gdGhpcyBSdWxlTGlzdCBpbnN0YW5jZSBzY29wZS5cblxuXG4gICAgdmFyIGtleSA9IG5hbWU7XG5cbiAgICBpZiAobmFtZSBpbiB0aGlzLnJhdykge1xuICAgICAga2V5ID0gbmFtZSArIFwiLWRcIiArIHRoaXMuY291bnRlcisrO1xuICAgIH0gLy8gV2UgbmVlZCB0byBzYXZlIHRoZSBvcmlnaW5hbCBkZWNsIGJlZm9yZSBjcmVhdGluZyB0aGUgcnVsZVxuICAgIC8vIGJlY2F1c2UgY2FjaGUgcGx1Z2luIG5lZWRzIHRvIHVzZSBpdCBhcyBhIGtleSB0byByZXR1cm4gYSBjYWNoZWQgcnVsZS5cblxuXG4gICAgdGhpcy5yYXdba2V5XSA9IGRlY2w7XG5cbiAgICBpZiAoa2V5IGluIHRoaXMuY2xhc3Nlcykge1xuICAgICAgLy8gRS5nLiBydWxlcyBpbnNpZGUgb2YgQG1lZGlhIGNvbnRhaW5lclxuICAgICAgb3B0aW9ucy5zZWxlY3RvciA9IFwiLlwiICsgZXNjYXBlKHRoaXMuY2xhc3Nlc1trZXldKTtcbiAgICB9XG5cbiAgICB2YXIgcnVsZSA9IGNyZWF0ZVJ1bGUoa2V5LCBkZWNsLCBvcHRpb25zKTtcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBudWxsO1xuICAgIHRoaXMucmVnaXN0ZXIocnVsZSk7XG4gICAgdmFyIGluZGV4ID0gb3B0aW9ucy5pbmRleCA9PT0gdW5kZWZpbmVkID8gdGhpcy5pbmRleC5sZW5ndGggOiBvcHRpb25zLmluZGV4O1xuICAgIHRoaXMuaW5kZXguc3BsaWNlKGluZGV4LCAwLCBydWxlKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBbbmFtZV07XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShydWxlKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyKHJ1bGUpO1xuICAgIGRlbGV0ZSB0aGlzLnJhd1tydWxlLmtleV07XG4gICAgdGhpcy5pbmRleC5zcGxpY2UodGhpcy5pbmRleC5pbmRleE9mKHJ1bGUpLCAxKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgIHJldHVybiB0aGlzLmluZGV4LmluZGV4T2YocnVsZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJ1biBgb25Qcm9jZXNzUnVsZSgpYCBwbHVnaW5zIG9uIGV2ZXJ5IHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgIHZhciBwbHVnaW5zID0gdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zOyAvLyBXZSBuZWVkIHRvIGNsb25lIGFycmF5IGJlY2F1c2UgaWYgd2UgbW9kaWZ5IHRoZSBpbmRleCBzb21ld2hlcmUgZWxzZSBkdXJpbmcgYSBsb29wXG4gICAgLy8gd2UgZW5kIHVwIHdpdGggdmVyeSBoYXJkLXRvLXRyYWNrLWRvd24gc2lkZSBlZmZlY3RzLlxuXG4gICAgdGhpcy5pbmRleC5zbGljZSgwKS5mb3JFYWNoKHBsdWdpbnMub25Qcm9jZXNzUnVsZSwgcGx1Z2lucyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgcnVsZSBpbiBgLm1hcGAsIGAuY2xhc3Nlc2AgYW5kIGAua2V5ZnJhbWVzYCBtYXBzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKHJ1bGUpIHtcbiAgICB0aGlzLm1hcFtydWxlLmtleV0gPSBydWxlO1xuXG4gICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBTdHlsZVJ1bGUpIHtcbiAgICAgIHRoaXMubWFwW3J1bGUuc2VsZWN0b3JdID0gcnVsZTtcbiAgICAgIGlmIChydWxlLmlkKSB0aGlzLmNsYXNzZXNbcnVsZS5rZXldID0gcnVsZS5pZDtcbiAgICB9IGVsc2UgaWYgKHJ1bGUgaW5zdGFuY2VvZiBLZXlmcmFtZXNSdWxlICYmIHRoaXMua2V5ZnJhbWVzKSB7XG4gICAgICB0aGlzLmtleWZyYW1lc1tydWxlLm5hbWVdID0gcnVsZS5pZDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51bnJlZ2lzdGVyID0gZnVuY3Rpb24gdW5yZWdpc3RlcihydWxlKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW3J1bGUua2V5XTtcblxuICAgIGlmIChydWxlIGluc3RhbmNlb2YgU3R5bGVSdWxlKSB7XG4gICAgICBkZWxldGUgdGhpcy5tYXBbcnVsZS5zZWxlY3Rvcl07XG4gICAgICBkZWxldGUgdGhpcy5jbGFzc2VzW3J1bGUua2V5XTtcbiAgICB9IGVsc2UgaWYgKHJ1bGUgaW5zdGFuY2VvZiBLZXlmcmFtZXNSdWxlKSB7XG4gICAgICBkZWxldGUgdGhpcy5rZXlmcmFtZXNbcnVsZS5uYW1lXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZnVuY3Rpb24gdmFsdWVzIHdpdGggYSBuZXcgZGF0YS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBuYW1lO1xuICAgIHZhciBkYXRhO1xuICAgIHZhciBvcHRpb25zO1xuXG4gICAgaWYgKHR5cGVvZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdO1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV07XG4gICAgICBuYW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgdGhpcy51cGRhdGVPbmUodGhpcy5tYXBbbmFtZV0sIGRhdGEsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5pbmRleC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdGhpcy51cGRhdGVPbmUodGhpcy5pbmRleFtpbmRleF0sIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZSBwbHVnaW5zLCB1cGRhdGUgcnVsZSBwcm9wcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlT25lID0gZnVuY3Rpb24gdXBkYXRlT25lKHJ1bGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdFVwZGF0ZU9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzJG9wdGlvbnMyID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBwbHVnaW5zID0gX3RoaXMkb3B0aW9uczIuanNzLnBsdWdpbnMsXG4gICAgICAgIHNoZWV0ID0gX3RoaXMkb3B0aW9uczIuc2hlZXQ7IC8vIEl0IGlzIGEgcnVsZXMgY29udGFpbmVyIGxpa2UgZm9yIGUuZy4gQ29uZGl0aW9uYWxSdWxlLlxuXG4gICAgaWYgKHJ1bGUucnVsZXMgaW5zdGFuY2VvZiBSdWxlTGlzdCkge1xuICAgICAgcnVsZS5ydWxlcy51cGRhdGUoZGF0YSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gcnVsZS5zdHlsZTtcbiAgICBwbHVnaW5zLm9uVXBkYXRlKGRhdGEsIHJ1bGUsIHNoZWV0LCBvcHRpb25zKTsgLy8gV2UgcmVseSBvbiBhIG5ldyBgc3R5bGVgIHJlZiBpbiBjYXNlIGl0IHdhcyBtdXRhdGVkIGR1cmluZyBvblVwZGF0ZSBob29rLlxuXG4gICAgaWYgKG9wdGlvbnMucHJvY2VzcyAmJiBzdHlsZSAmJiBzdHlsZSAhPT0gcnVsZS5zdHlsZSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBydW4gdGhlIHBsdWdpbnMgaW4gY2FzZSBuZXcgYHN0eWxlYCByZWxpZXMgb24gc3ludGF4IHBsdWdpbnMuXG4gICAgICBwbHVnaW5zLm9uUHJvY2Vzc1N0eWxlKHJ1bGUuc3R5bGUsIHJ1bGUsIHNoZWV0KTsgLy8gVXBkYXRlIGFuZCBhZGQgcHJvcHMuXG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gcnVsZS5zdHlsZSkge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gcnVsZS5zdHlsZVtwcm9wXTtcbiAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHN0eWxlW3Byb3BdOyAvLyBXZSBuZWVkIHRvIHVzZSBgZm9yY2U6IHRydWVgIGJlY2F1c2UgYHJ1bGUuc3R5bGVgIGhhcyBiZWVuIHVwZGF0ZWQgZHVyaW5nIG9uVXBkYXRlIGhvb2ssIHNvIGBydWxlLnByb3AoKWAgd2lsbCBub3QgdXBkYXRlIHRoZSBDU1NPTSBydWxlLlxuICAgICAgICAvLyBXZSBkbyB0aGlzIGNvbXBhcmlzb24gdG8gYXZvaWQgdW5uZWVkZWQgYHJ1bGUucHJvcCgpYCBjYWxscywgc2luY2Ugd2UgaGF2ZSB0aGUgb2xkIGBzdHlsZWAgb2JqZWN0IGhlcmUuXG5cbiAgICAgICAgaWYgKG5leHRWYWx1ZSAhPT0gcHJldlZhbHVlKSB7XG4gICAgICAgICAgcnVsZS5wcm9wKHByb3AsIG5leHRWYWx1ZSwgZm9yY2VVcGRhdGVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZW1vdmUgcHJvcHMuXG5cblxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gc3R5bGUpIHtcbiAgICAgICAgdmFyIF9uZXh0VmFsdWUgPSBydWxlLnN0eWxlW19wcm9wXTtcbiAgICAgICAgdmFyIF9wcmV2VmFsdWUgPSBzdHlsZVtfcHJvcF07IC8vIFdlIG5lZWQgdG8gdXNlIGBmb3JjZTogdHJ1ZWAgYmVjYXVzZSBgcnVsZS5zdHlsZWAgaGFzIGJlZW4gdXBkYXRlZCBkdXJpbmcgb25VcGRhdGUgaG9vaywgc28gYHJ1bGUucHJvcCgpYCB3aWxsIG5vdCB1cGRhdGUgdGhlIENTU09NIHJ1bGUuXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgY29tcGFyaXNvbiB0byBhdm9pZCB1bm5lZWRlZCBgcnVsZS5wcm9wKClgIGNhbGxzLCBzaW5jZSB3ZSBoYXZlIHRoZSBvbGQgYHN0eWxlYCBvYmplY3QgaGVyZS5cblxuICAgICAgICBpZiAoX25leHRWYWx1ZSA9PSBudWxsICYmIF9uZXh0VmFsdWUgIT09IF9wcmV2VmFsdWUpIHtcbiAgICAgICAgICBydWxlLnByb3AoX3Byb3AsIG51bGwsIGZvcmNlVXBkYXRlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgcnVsZXMgdG8gYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcblxuICAgIHZhciBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMgPSBnZXRXaGl0ZXNwYWNlU3ltYm9scyhvcHRpb25zKSxcbiAgICAgICAgbGluZWJyZWFrID0gX2dldFdoaXRlc3BhY2VTeW1ib2xzLmxpbmVicmVhaztcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmluZGV4Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLmluZGV4W2luZGV4XTtcbiAgICAgIHZhciBjc3MgPSBydWxlLnRvU3RyaW5nKG9wdGlvbnMpOyAvLyBObyBuZWVkIHRvIHJlbmRlciBhbiBlbXB0eSBydWxlLlxuXG4gICAgICBpZiAoIWNzcyAmJiAhbGluaykgY29udGludWU7XG4gICAgICBpZiAoc3RyKSBzdHIgKz0gbGluZWJyZWFrO1xuICAgICAgc3RyICs9IGNzcztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHJldHVybiBSdWxlTGlzdDtcbn0oKTtcblxudmFyIFN0eWxlU2hlZXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHlsZVNoZWV0KHN0eWxlcywgb3B0aW9ucykge1xuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlcGxveWVkID0gZmFsc2U7XG4gICAgdGhpcy5jbGFzc2VzID0ge307XG4gICAgdGhpcy5rZXlmcmFtZXMgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgc2hlZXQ6IHRoaXMsXG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBjbGFzc2VzOiB0aGlzLmNsYXNzZXMsXG4gICAgICBrZXlmcmFtZXM6IHRoaXMua2V5ZnJhbWVzXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5SZW5kZXJlcikge1xuICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBvcHRpb25zLlJlbmRlcmVyKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QodGhpcy5vcHRpb25zKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZXNbbmFtZV0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2ggcmVuZGVyYWJsZSB0byB0aGUgcmVuZGVyIHRyZWUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5hdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHJldHVybiB0aGlzO1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyLmF0dGFjaCgpO1xuICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlOyAvLyBPcmRlciBpcyBpbXBvcnRhbnQsIGJlY2F1c2Ugd2UgY2FuJ3QgdXNlIGluc2VydFJ1bGUgQVBJIGlmIHN0eWxlIGVsZW1lbnQgaXMgbm90IGF0dGFjaGVkLlxuXG4gICAgaWYgKCF0aGlzLmRlcGxveWVkKSB0aGlzLmRlcGxveSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgcmVuZGVyYWJsZSBmcm9tIHJlbmRlciB0cmVlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgaWYgKCF0aGlzLmF0dGFjaGVkKSByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5yZW5kZXJlcikgdGhpcy5yZW5kZXJlci5kZXRhY2goKTtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIHJ1bGUgdG8gdGhlIGN1cnJlbnQgc3R5bGVzaGVldC5cbiAgICogV2lsbCBpbnNlcnQgYSBydWxlIGFsc28gYWZ0ZXIgdGhlIHN0eWxlc2hlZXQgaGFzIGJlZW4gcmVuZGVyZWQgZmlyc3QgdGltZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZSA9IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWU7IC8vIFBsdWdpbnMgY2FuIGNyZWF0ZSBydWxlcy5cbiAgICAvLyBJbiBvcmRlciB0byBwcmVzZXJ2ZSB0aGUgcmlnaHQgb3JkZXIsIHdlIG5lZWQgdG8gcXVldWUgYWxsIGAuYWRkUnVsZWAgY2FsbHMsXG4gICAgLy8gd2hpY2ggaGFwcGVuIGFmdGVyIHRoZSBmaXJzdCBgcnVsZXMuYWRkKClgIGNhbGwuXG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhcXVldWUpIHRoaXMucXVldWUgPSBbXTtcbiAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIGRlY2wsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgaWYgKCF0aGlzLmRlcGxveWVkKSByZXR1cm4gcnVsZTsgLy8gRG9uJ3QgaW5zZXJ0IHJ1bGUgZGlyZWN0bHkgaWYgdGhlcmUgaXMgbm8gc3RyaW5naWZpZWQgdmVyc2lvbiB5ZXQuXG4gICAgICAvLyBJdCB3aWxsIGJlIGluc2VydGVkIGFsbCB0b2dldGhlciB3aGVuIC5hdHRhY2ggaXMgY2FsbGVkLlxuXG4gICAgICBpZiAocXVldWUpIHF1ZXVlLnB1c2gocnVsZSk7ZWxzZSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcblxuICAgICAgICBpZiAodGhpcy5xdWV1ZSkge1xuICAgICAgICAgIHRoaXMucXVldWUuZm9yRWFjaCh0aGlzLmluc2VydFJ1bGUsIHRoaXMpO1xuICAgICAgICAgIHRoaXMucXVldWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydWxlO1xuICAgIH0gLy8gV2UgY2FuJ3QgYWRkIHJ1bGVzIHRvIGEgZGV0YWNoZWQgc3R5bGUgbm9kZS5cbiAgICAvLyBXZSB3aWxsIHJlZGVwbG95IHRoZSBzaGVldCBvbmNlIHVzZXIgd2lsbCBhdHRhY2ggaXQuXG5cblxuICAgIHRoaXMuZGVwbG95ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IHJ1bGUgaW50byB0aGUgU3R5bGVTaGVldFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuaW5zZXJ0UnVsZShydWxlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgYWRkIHJ1bGVzLlxuICAgKiBXaWxsIHJlbmRlciBhbHNvIGFmdGVyIFN0eWxlIFNoZWV0IHdhcyByZW5kZXJlZCB0aGUgZmlyc3QgdGltZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZXMgPSBmdW5jdGlvbiBhZGRSdWxlcyhzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgYWRkZWQgPSBbXTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB2YXIgcnVsZSA9IHRoaXMuYWRkUnVsZShuYW1lLCBzdHlsZXNbbmFtZV0sIG9wdGlvbnMpO1xuICAgICAgaWYgKHJ1bGUpIGFkZGVkLnB1c2gocnVsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZGVkO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlIGJ5IG5hbWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldFJ1bGUgPSBmdW5jdGlvbiBnZXRSdWxlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHJ1bGUgYnkgbmFtZS5cbiAgICogUmV0dXJucyBgdHJ1ZWA6IGlmIHJ1bGUgaGFzIGJlZW4gZGVsZXRlZCBmcm9tIHRoZSBET00uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiBkZWxldGVSdWxlKG5hbWUpIHtcbiAgICB2YXIgcnVsZSA9IHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JyA/IG5hbWUgOiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcblxuICAgIGlmICghcnVsZSB8fCAvLyBTdHlsZSBzaGVldCB3YXMgY3JlYXRlZCB3aXRob3V0IGxpbms6IHRydWUgYW5kIGF0dGFjaGVkLCBpbiB0aGlzIGNhc2Ugd2VcbiAgICAvLyB3b24ndCBiZSBhYmxlIHRvIHJlbW92ZSB0aGUgQ1NTIHJ1bGUgZnJvbSB0aGUgRE9NLlxuICAgIHRoaXMuYXR0YWNoZWQgJiYgIXJ1bGUucmVuZGVyYWJsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucmVtb3ZlKHJ1bGUpO1xuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQgJiYgcnVsZS5yZW5kZXJhYmxlICYmIHRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmRlbGV0ZVJ1bGUocnVsZS5yZW5kZXJhYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmluZGV4T2YocnVsZSk7XG4gIH1cbiAgLyoqXG4gICAqIERlcGxveSBwdXJlIENTUyBzdHJpbmcgdG8gYSByZW5kZXJhYmxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXBsb3kgPSBmdW5jdGlvbiBkZXBsb3koKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHRoaXMucmVuZGVyZXIuZGVwbG95KCk7XG4gICAgdGhpcy5kZXBsb3llZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZnVuY3Rpb24gdmFsdWVzIHdpdGggYSBuZXcgZGF0YS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBfdGhpcyRydWxlcztcblxuICAgIChfdGhpcyRydWxlcyA9IHRoaXMucnVsZXMpLnVwZGF0ZS5hcHBseShfdGhpcyRydWxlcywgYXJndW1lbnRzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgc2luZ2xlIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZU9uZSA9IGZ1bmN0aW9uIHVwZGF0ZU9uZShydWxlLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgdGhpcy5ydWxlcy51cGRhdGVPbmUocnVsZSwgZGF0YSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgcnVsZXMgdG8gYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy50b1N0cmluZyhvcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4gU3R5bGVTaGVldDtcbn0oKTtcblxudmFyIFBsdWdpbnNSZWdpc3RyeSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBsdWdpbnNSZWdpc3RyeSgpIHtcbiAgICB0aGlzLnBsdWdpbnMgPSB7XG4gICAgICBpbnRlcm5hbDogW10sXG4gICAgICBleHRlcm5hbDogW11cbiAgICB9O1xuICAgIHRoaXMucmVnaXN0cnkgPSB7fTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQbHVnaW5zUmVnaXN0cnkucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBDYWxsIGBvbkNyZWF0ZVJ1bGVgIGhvb2tzIGFuZCByZXR1cm4gYW4gb2JqZWN0IGlmIHJldHVybmVkIGJ5IGEgaG9vay5cbiAgICovXG4gIF9wcm90by5vbkNyZWF0ZVJ1bGUgPSBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vbkNyZWF0ZVJ1bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBydWxlID0gdGhpcy5yZWdpc3RyeS5vbkNyZWF0ZVJ1bGVbaV0obmFtZSwgZGVjbCwgb3B0aW9ucyk7XG4gICAgICBpZiAocnVsZSkgcmV0dXJuIHJ1bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uUHJvY2Vzc1J1bGVgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblByb2Nlc3NSdWxlID0gZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlKSB7XG4gICAgaWYgKHJ1bGUuaXNQcm9jZXNzZWQpIHJldHVybjtcbiAgICB2YXIgc2hlZXQgPSBydWxlLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzUnVsZS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NSdWxlW2ldKHJ1bGUsIHNoZWV0KTtcbiAgICB9XG5cbiAgICBpZiAocnVsZS5zdHlsZSkgdGhpcy5vblByb2Nlc3NTdHlsZShydWxlLnN0eWxlLCBydWxlLCBzaGVldCk7XG4gICAgcnVsZS5pc1Byb2Nlc3NlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uUHJvY2Vzc1N0eWxlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25Qcm9jZXNzU3R5bGUgPSBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSwgc2hlZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJ1bGUuc3R5bGUgPSB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1N0eWxlW2ldKHJ1bGUuc3R5bGUsIHJ1bGUsIHNoZWV0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uUHJvY2Vzc1NoZWV0YCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25Qcm9jZXNzU2hlZXQgPSBmdW5jdGlvbiBvblByb2Nlc3NTaGVldChzaGVldCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NTaGVldC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NTaGVldFtpXShzaGVldCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBvblVwZGF0ZWAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uVXBkYXRlID0gZnVuY3Rpb24gb25VcGRhdGUoZGF0YSwgcnVsZSwgc2hlZXQsIG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucmVnaXN0cnkub25VcGRhdGVbaV0oZGF0YSwgcnVsZSwgc2hlZXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25DaGFuZ2VWYWx1ZWAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uQ2hhbmdlVmFsdWUgPSBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKHZhbHVlLCBwcm9wLCBydWxlKSB7XG4gICAgdmFyIHByb2Nlc3NlZFZhbHVlID0gdmFsdWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25DaGFuZ2VWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvY2Vzc2VkVmFsdWUgPSB0aGlzLnJlZ2lzdHJ5Lm9uQ2hhbmdlVmFsdWVbaV0ocHJvY2Vzc2VkVmFsdWUsIHByb3AsIHJ1bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9jZXNzZWRWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBwbHVnaW4uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVzZSA9IGZ1bmN0aW9uIHVzZShuZXdQbHVnaW4sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBxdWV1ZTogJ2V4dGVybmFsJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcGx1Z2lucyA9IHRoaXMucGx1Z2luc1tvcHRpb25zLnF1ZXVlXTsgLy8gQXZvaWRzIGFwcGx5aW5nIHNhbWUgcGx1Z2luIHR3aWNlLCBhdCBsZWFzdCBiYXNlZCBvbiByZWYuXG5cbiAgICBpZiAocGx1Z2lucy5pbmRleE9mKG5ld1BsdWdpbikgIT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGx1Z2lucy5wdXNoKG5ld1BsdWdpbik7XG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdLmNvbmNhdCh0aGlzLnBsdWdpbnMuZXh0ZXJuYWwsIHRoaXMucGx1Z2lucy5pbnRlcm5hbCkucmVkdWNlKGZ1bmN0aW9uIChyZWdpc3RyeSwgcGx1Z2luKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHBsdWdpbikge1xuICAgICAgICBpZiAobmFtZSBpbiByZWdpc3RyeSkge1xuICAgICAgICAgIHJlZ2lzdHJ5W25hbWVdLnB1c2gocGx1Z2luW25hbWVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFVua25vd24gaG9vayBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnaXN0cnk7XG4gICAgfSwge1xuICAgICAgb25DcmVhdGVSdWxlOiBbXSxcbiAgICAgIG9uUHJvY2Vzc1J1bGU6IFtdLFxuICAgICAgb25Qcm9jZXNzU3R5bGU6IFtdLFxuICAgICAgb25Qcm9jZXNzU2hlZXQ6IFtdLFxuICAgICAgb25DaGFuZ2VWYWx1ZTogW10sXG4gICAgICBvblVwZGF0ZTogW11cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gUGx1Z2luc1JlZ2lzdHJ5O1xufSgpO1xuXG4vKipcbiAqIFNoZWV0cyByZWdpc3RyeSB0byBhY2Nlc3MgYWxsIGluc3RhbmNlcyBpbiBvbmUgcGxhY2UuXG4gKi9cblxudmFyIFNoZWV0c1JlZ2lzdHJ5ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2hlZXRzUmVnaXN0cnkoKSB7XG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNoZWV0c1JlZ2lzdHJ5LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBTdHlsZSBTaGVldC5cbiAgICovXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoc2hlZXQpIHtcbiAgICB2YXIgcmVnaXN0cnkgPSB0aGlzLnJlZ2lzdHJ5O1xuICAgIHZhciBpbmRleCA9IHNoZWV0Lm9wdGlvbnMuaW5kZXg7XG4gICAgaWYgKHJlZ2lzdHJ5LmluZGV4T2Yoc2hlZXQpICE9PSAtMSkgcmV0dXJuO1xuXG4gICAgaWYgKHJlZ2lzdHJ5Lmxlbmd0aCA9PT0gMCB8fCBpbmRleCA+PSB0aGlzLmluZGV4KSB7XG4gICAgICByZWdpc3RyeS5wdXNoKHNoZWV0KTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZpbmQgYSBwb3NpdGlvbi5cblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlZ2lzdHJ5W2ldLm9wdGlvbnMuaW5kZXggPiBpbmRleCkge1xuICAgICAgICByZWdpc3RyeS5zcGxpY2UoaSwgMCwgc2hlZXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXNldCB0aGUgcmVnaXN0cnkuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYSBTdHlsZSBTaGVldC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHNoZWV0KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5yZWdpc3RyeS5pbmRleE9mKHNoZWV0KTtcbiAgICB0aGlzLnJlZ2lzdHJ5LnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgYWxsIGF0dGFjaGVkIHNoZWV0cyB0byBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoX3RlbXApIHtcbiAgICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICBhdHRhY2hlZCA9IF9yZWYuYXR0YWNoZWQsXG4gICAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJhdHRhY2hlZFwiXSk7XG5cbiAgICB2YXIgX2dldFdoaXRlc3BhY2VTeW1ib2xzID0gZ2V0V2hpdGVzcGFjZVN5bWJvbHMob3B0aW9ucyksXG4gICAgICAgIGxpbmVicmVhayA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5saW5lYnJlYWs7XG5cbiAgICB2YXIgY3NzID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzaGVldCA9IHRoaXMucmVnaXN0cnlbaV07XG5cbiAgICAgIGlmIChhdHRhY2hlZCAhPSBudWxsICYmIHNoZWV0LmF0dGFjaGVkICE9PSBhdHRhY2hlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNzcykgY3NzICs9IGxpbmVicmVhaztcbiAgICAgIGNzcyArPSBzaGVldC50b1N0cmluZyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTaGVldHNSZWdpc3RyeSwgW3tcbiAgICBrZXk6IFwiaW5kZXhcIixcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaGlnaGVzdCBpbmRleCBudW1iZXIuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5sZW5ndGggPT09IDAgPyAwIDogdGhpcy5yZWdpc3RyeVt0aGlzLnJlZ2lzdHJ5Lmxlbmd0aCAtIDFdLm9wdGlvbnMuaW5kZXg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNoZWV0c1JlZ2lzdHJ5O1xufSgpO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBnbG9iYWwgc2hlZXRzIHJlZ2lzdHJ5LiBPbmx5IERvbVJlbmRlcmVyIHdpbGwgYWRkIHNoZWV0cyB0byBpdC5cbiAqIE9uIHRoZSBzZXJ2ZXIgb25lIHNob3VsZCB1c2UgYW4gb3duIFNoZWV0c1JlZ2lzdHJ5IGluc3RhbmNlIGFuZCBhZGQgdGhlXG4gKiBzaGVldHMgdG8gaXQsIGJlY2F1c2UgeW91IG5lZWQgdG8gbWFrZSBzdXJlIHRvIGNyZWF0ZSBhIG5ldyByZWdpc3RyeSBmb3JcbiAqIGVhY2ggcmVxdWVzdCBpbiBvcmRlciB0byBub3QgbGVhayBzaGVldHMgYWNyb3NzIHJlcXVlc3RzLlxuICovXG5cbnZhciBzaGVldHMgPSBuZXcgU2hlZXRzUmVnaXN0cnkoKTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuLyoqXG4gKiBOb3cgdGhhdCBgZ2xvYmFsVGhpc2AgaXMgYXZhaWxhYmxlIG9uIG1vc3QgcGxhdGZvcm1zXG4gKiAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvZ2xvYmFsVGhpcyNicm93c2VyX2NvbXBhdGliaWxpdHkpXG4gKiB3ZSBjaGVjayBmb3IgYGdsb2JhbFRoaXNgIGZpcnN0LiBgZ2xvYmFsVGhpc2AgaXMgbmVjZXNzYXJ5IGZvciBqc3NcbiAqIHRvIHJ1biBpbiBBZ29yaWMncyBzZWN1cmUgdmVyc2lvbiBvZiBKYXZhU2NyaXB0IChTRVMpLiBVbmRlciBTRVMsXG4gKiBgZ2xvYmFsVGhpc2AgZXhpc3RzLCBidXQgYHdpbmRvd2AsIGBzZWxmYCwgYW5kIGBGdW5jdGlvbigncmV0dXJuXG4gKiB0aGlzJykoKWAgYXJlIGFsbCB1bmRlZmluZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbiAqL1xudmFyIGdsb2JhbFRoaXMkMSA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PT0gTWF0aCA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIG5zID0gJzJmMWFjYzZjM2E2MDZiMDgyZTVlZWY1ZTU0NDE0ZmZiJztcbmlmIChnbG9iYWxUaGlzJDFbbnNdID09IG51bGwpIGdsb2JhbFRoaXMkMVtuc10gPSAwOyAvLyBCdW5kbGUgbWF5IGNvbnRhaW4gbXVsdGlwbGUgSlNTIHZlcnNpb25zIGF0IHRoZSBzYW1lIHRpbWUuIEluIG9yZGVyIHRvIGlkZW50aWZ5XG4vLyB0aGUgY3VycmVudCB2ZXJzaW9uIHdpdGgganVzdCBvbmUgc2hvcnQgbnVtYmVyIGFuZCB1c2UgaXQgZm9yIGNsYXNzZXMgZ2VuZXJhdGlvblxuLy8gd2UgdXNlIGEgY291bnRlci4gQWxzbyBpdCBpcyBtb3JlIGFjY3VyYXRlLCBiZWNhdXNlIHVzZXIgY2FuIG1hbnVhbGx5IHJlZXZhbHVhdGVcbi8vIHRoZSBtb2R1bGUuXG5cbnZhciBtb2R1bGVJZCA9IGdsb2JhbFRoaXMkMVtuc10rKztcblxudmFyIG1heFJ1bGVzID0gMWUxMDtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlcyB1bmlxdWUgY2xhc3MgbmFtZXMgYmFzZWQgb24gY291bnRlcnMuXG4gKiBXaGVuIG5ldyBnZW5lcmF0b3IgZnVuY3Rpb24gaXMgY3JlYXRlZCwgcnVsZSBjb3VudGVyIGlzIHJlc2V0ZWQuXG4gKiBXZSBuZWVkIHRvIHJlc2V0IHRoZSBydWxlIGNvdW50ZXIgZm9yIFNTUiBmb3IgZWFjaCByZXF1ZXN0LlxuICovXG5cbnZhciBjcmVhdGVHZW5lcmF0ZUlkID0gZnVuY3Rpb24gY3JlYXRlR2VuZXJhdGVJZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgcnVsZUNvdW50ZXIgPSAwO1xuXG4gIHZhciBnZW5lcmF0ZUlkID0gZnVuY3Rpb24gZ2VuZXJhdGVJZChydWxlLCBzaGVldCkge1xuICAgIHJ1bGVDb3VudGVyICs9IDE7XG5cbiAgICBpZiAocnVsZUNvdW50ZXIgPiBtYXhSdWxlcykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBZb3UgbWlnaHQgaGF2ZSBhIG1lbW9yeSBsZWFrLiBSdWxlIGNvdW50ZXIgaXMgYXQgXCIgKyBydWxlQ291bnRlciArIFwiLlwiKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIganNzSWQgPSAnJztcbiAgICB2YXIgcHJlZml4ID0gJyc7XG5cbiAgICBpZiAoc2hlZXQpIHtcbiAgICAgIGlmIChzaGVldC5vcHRpb25zLmNsYXNzTmFtZVByZWZpeCkge1xuICAgICAgICBwcmVmaXggPSBzaGVldC5vcHRpb25zLmNsYXNzTmFtZVByZWZpeDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoZWV0Lm9wdGlvbnMuanNzLmlkICE9IG51bGwpIHtcbiAgICAgICAganNzSWQgPSBTdHJpbmcoc2hlZXQub3B0aW9ucy5qc3MuaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm1pbmlmeSkge1xuICAgICAgLy8gVXNpbmcgXCJjXCIgYmVjYXVzZSBhIG51bWJlciBjYW4ndCBiZSB0aGUgZmlyc3QgY2hhciBpbiBhIGNsYXNzIG5hbWUuXG4gICAgICByZXR1cm4gXCJcIiArIChwcmVmaXggfHwgJ2MnKSArIG1vZHVsZUlkICsganNzSWQgKyBydWxlQ291bnRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlZml4ICsgcnVsZS5rZXkgKyBcIi1cIiArIG1vZHVsZUlkICsgKGpzc0lkID8gXCItXCIgKyBqc3NJZCA6ICcnKSArIFwiLVwiICsgcnVsZUNvdW50ZXI7XG4gIH07XG5cbiAgcmV0dXJuIGdlbmVyYXRlSWQ7XG59O1xuXG4vKipcbiAqIENhY2hlIHRoZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdCB0aW1lIGEgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICovXG5cbnZhciBtZW1vaXplID0gZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICB2YXIgdmFsdWU7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF2YWx1ZSkgdmFsdWUgPSBmbigpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn07XG4vKipcbiAqIEdldCBhIHN0eWxlIHByb3BlcnR5IHZhbHVlLlxuICovXG5cblxudmFyIGdldFByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0eVZhbHVlKGNzc1J1bGUsIHByb3ApIHtcbiAgdHJ5IHtcbiAgICAvLyBTdXBwb3J0IENTU1RPTS5cbiAgICBpZiAoY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcCkge1xuICAgICAgcmV0dXJuIGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXAuZ2V0KHByb3ApO1xuICAgIH1cblxuICAgIHJldHVybiBjc3NSdWxlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElFIG1heSB0aHJvdyBpZiBwcm9wZXJ0eSBpcyB1bmtub3duLlxuICAgIHJldHVybiAnJztcbiAgfVxufTtcbi8qKlxuICogU2V0IGEgc3R5bGUgcHJvcGVydHkuXG4gKi9cblxuXG52YXIgc2V0UHJvcGVydHkgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0eShjc3NSdWxlLCBwcm9wLCB2YWx1ZSkge1xuICB0cnkge1xuICAgIHZhciBjc3NWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBjc3NWYWx1ZSA9IHRvQ3NzVmFsdWUodmFsdWUsIHRydWUpO1xuXG4gICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICchaW1wb3J0YW50Jykge1xuICAgICAgICBjc3NSdWxlLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIGNzc1ZhbHVlLCAnaW1wb3J0YW50Jyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gLy8gU3VwcG9ydCBDU1NUT00uXG5cblxuICAgIGlmIChjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwKSB7XG4gICAgICBjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwLnNldChwcm9wLCBjc3NWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNzc1J1bGUuc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgY3NzVmFsdWUpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSUUgbWF5IHRocm93IGlmIHByb3BlcnR5IGlzIHVua25vd24uXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBSZW1vdmUgYSBzdHlsZSBwcm9wZXJ0eS5cbiAqL1xuXG5cbnZhciByZW1vdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIHJlbW92ZVByb3BlcnR5KGNzc1J1bGUsIHByb3ApIHtcbiAgdHJ5IHtcbiAgICAvLyBTdXBwb3J0IENTU1RPTS5cbiAgICBpZiAoY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcCkge1xuICAgICAgY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcC5kZWxldGUocHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNzc1J1bGUuc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIERPTUV4Y2VwdGlvbiBcXFwiXCIgKyBlcnIubWVzc2FnZSArIFwiXFxcIiB3YXMgdGhyb3duLiBUcmllZCB0byByZW1vdmUgcHJvcGVydHkgXFxcIlwiICsgcHJvcCArIFwiXFxcIi5cIikgOiB2b2lkIDA7XG4gIH1cbn07XG4vKipcbiAqIFNldCB0aGUgc2VsZWN0b3IuXG4gKi9cblxuXG52YXIgc2V0U2VsZWN0b3IgPSBmdW5jdGlvbiBzZXRTZWxlY3Rvcihjc3NSdWxlLCBzZWxlY3RvclRleHQpIHtcbiAgY3NzUnVsZS5zZWxlY3RvclRleHQgPSBzZWxlY3RvclRleHQ7IC8vIFJldHVybiBmYWxzZSBpZiBzZXR0ZXIgd2FzIG5vdCBzdWNjZXNzZnVsLlxuICAvLyBDdXJyZW50bHkgd29ya3MgaW4gY2hyb21lIG9ubHkuXG5cbiAgcmV0dXJuIGNzc1J1bGUuc2VsZWN0b3JUZXh0ID09PSBzZWxlY3RvclRleHQ7XG59O1xuLyoqXG4gKiBHZXRzIHRoZSBgaGVhZGAgZWxlbWVudCB1cG9uIHRoZSBmaXJzdCBjYWxsIGFuZCBjYWNoZXMgaXQuXG4gKiBXZSBhc3N1bWUgaXQgY2FuJ3QgYmUgbnVsbC5cbiAqL1xuXG5cbnZhciBnZXRIZWFkID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkJyk7XG59KTtcbi8qKlxuICogRmluZCBhdHRhY2hlZCBzaGVldCB3aXRoIGFuIGluZGV4IGhpZ2hlciB0aGFuIHRoZSBwYXNzZWQgb25lLlxuICovXG5cbmZ1bmN0aW9uIGZpbmRIaWdoZXJTaGVldChyZWdpc3RyeSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNoZWV0ID0gcmVnaXN0cnlbaV07XG5cbiAgICBpZiAoc2hlZXQuYXR0YWNoZWQgJiYgc2hlZXQub3B0aW9ucy5pbmRleCA+IG9wdGlvbnMuaW5kZXggJiYgc2hlZXQub3B0aW9ucy5pbnNlcnRpb25Qb2ludCA9PT0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludCkge1xuICAgICAgcmV0dXJuIHNoZWV0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBGaW5kIGF0dGFjaGVkIHNoZWV0IHdpdGggdGhlIGhpZ2hlc3QgaW5kZXguXG4gKi9cblxuXG5mdW5jdGlvbiBmaW5kSGlnaGVzdFNoZWV0KHJlZ2lzdHJ5LCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSByZWdpc3RyeS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBzaGVldCA9IHJlZ2lzdHJ5W2ldO1xuXG4gICAgaWYgKHNoZWV0LmF0dGFjaGVkICYmIHNoZWV0Lm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgPT09IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQpIHtcbiAgICAgIHJldHVybiBzaGVldDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRmluZCBhIGNvbW1lbnQgd2l0aCBcImpzc1wiIGluc2lkZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmRDb21tZW50Tm9kZSh0ZXh0KSB7XG4gIHZhciBoZWFkID0gZ2V0SGVhZCgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBoZWFkLmNoaWxkTm9kZXNbaV07XG5cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZS50cmltKCkgPT09IHRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBGaW5kIGEgbm9kZSBiZWZvcmUgd2hpY2ggd2UgY2FuIGluc2VydCB0aGUgc2hlZXQuXG4gKi9cblxuXG5mdW5jdGlvbiBmaW5kUHJldk5vZGUob3B0aW9ucykge1xuICB2YXIgcmVnaXN0cnkgPSBzaGVldHMucmVnaXN0cnk7XG5cbiAgaWYgKHJlZ2lzdHJ5Lmxlbmd0aCA+IDApIHtcbiAgICAvLyBUcnkgdG8gaW5zZXJ0IGJlZm9yZSB0aGUgbmV4dCBoaWdoZXIgc2hlZXQuXG4gICAgdmFyIHNoZWV0ID0gZmluZEhpZ2hlclNoZWV0KHJlZ2lzdHJ5LCBvcHRpb25zKTtcblxuICAgIGlmIChzaGVldCAmJiBzaGVldC5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFyZW50OiBzaGVldC5yZW5kZXJlci5lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICAgIG5vZGU6IHNoZWV0LnJlbmRlcmVyLmVsZW1lbnRcbiAgICAgIH07XG4gICAgfSAvLyBPdGhlcndpc2UgaW5zZXJ0IGFmdGVyIHRoZSBsYXN0IGF0dGFjaGVkLlxuXG5cbiAgICBzaGVldCA9IGZpbmRIaWdoZXN0U2hlZXQocmVnaXN0cnksIG9wdGlvbnMpO1xuXG4gICAgaWYgKHNoZWV0ICYmIHNoZWV0LnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJlbnQ6IHNoZWV0LnJlbmRlcmVyLmVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgbm9kZTogc2hlZXQucmVuZGVyZXIuZWxlbWVudC5uZXh0U2libGluZ1xuICAgICAgfTtcbiAgICB9XG4gIH0gLy8gVHJ5IHRvIGZpbmQgYSBjb21tZW50IHBsYWNlaG9sZGVyIGlmIHJlZ2lzdHJ5IGlzIGVtcHR5LlxuXG5cbiAgdmFyIGluc2VydGlvblBvaW50ID0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludDtcblxuICBpZiAoaW5zZXJ0aW9uUG9pbnQgJiYgdHlwZW9mIGluc2VydGlvblBvaW50ID09PSAnc3RyaW5nJykge1xuICAgIHZhciBjb21tZW50ID0gZmluZENvbW1lbnROb2RlKGluc2VydGlvblBvaW50KTtcblxuICAgIGlmIChjb21tZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJlbnQ6IGNvbW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgbm9kZTogY29tbWVudC5uZXh0U2libGluZ1xuICAgICAgfTtcbiAgICB9IC8vIElmIHVzZXIgc3BlY2lmaWVzIGFuIGluc2VydGlvbiBwb2ludCBhbmQgaXQgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIGRvY3VtZW50IC1cbiAgICAvLyBiYWQgc3BlY2lmaWNpdHkgaXNzdWVzIG1heSBhcHBlYXIuXG5cblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gSW5zZXJ0aW9uIHBvaW50IFxcXCJcIiArIGluc2VydGlvblBvaW50ICsgXCJcXFwiIG5vdCBmb3VuZC5cIikgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEluc2VydCBzdHlsZSBlbGVtZW50IGludG8gdGhlIERPTS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlKHN0eWxlLCBvcHRpb25zKSB7XG4gIHZhciBpbnNlcnRpb25Qb2ludCA9IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQ7XG4gIHZhciBuZXh0Tm9kZSA9IGZpbmRQcmV2Tm9kZShvcHRpb25zKTtcblxuICBpZiAobmV4dE5vZGUgIT09IGZhbHNlICYmIG5leHROb2RlLnBhcmVudCkge1xuICAgIG5leHROb2RlLnBhcmVudC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHROb2RlLm5vZGUpO1xuICAgIHJldHVybjtcbiAgfSAvLyBXb3JrcyB3aXRoIGlmcmFtZXMgYW5kIGFueSBub2RlIHR5cGVzLlxuXG5cbiAgaWYgKGluc2VydGlvblBvaW50ICYmIHR5cGVvZiBpbnNlcnRpb25Qb2ludC5ub2RlVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgaW5zZXJ0aW9uUG9pbnRFbGVtZW50ID0gaW5zZXJ0aW9uUG9pbnQ7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBpbnNlcnRpb25Qb2ludEVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGUsIGluc2VydGlvblBvaW50RWxlbWVudC5uZXh0U2libGluZyk7ZWxzZSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAnW0pTU10gSW5zZXJ0aW9uIHBvaW50IGlzIG5vdCBpbiB0aGUgRE9NLicpIDogdm9pZCAwO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGdldEhlYWQoKS5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG4vKipcbiAqIFJlYWQganNzIG5vbmNlIHNldHRpbmcgZnJvbSB0aGUgcGFnZSBpZiB0aGUgdXNlciBoYXMgc2V0IGl0LlxuICovXG5cblxudmFyIGdldE5vbmNlID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtwcm9wZXJ0eT1cImNzcC1ub25jZVwiXScpO1xuICByZXR1cm4gbm9kZSA/IG5vZGUuZ2V0QXR0cmlidXRlKCdjb250ZW50JykgOiBudWxsO1xufSk7XG5cbnZhciBfaW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIGluc2VydFJ1bGUoY29udGFpbmVyLCBydWxlLCBpbmRleCkge1xuICB0cnkge1xuICAgIGlmICgnaW5zZXJ0UnVsZScgaW4gY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXIuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gICAgfSAvLyBLZXlmcmFtZXMgcnVsZS5cbiAgICBlbHNlIGlmICgnYXBwZW5kUnVsZScgaW4gY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRSdWxlKHJ1bGUpO1xuICAgICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFwiICsgZXJyLm1lc3NhZ2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjb250YWluZXIuY3NzUnVsZXNbaW5kZXhdO1xufTtcblxudmFyIGdldFZhbGlkUnVsZUluc2VydGlvbkluZGV4ID0gZnVuY3Rpb24gZ2V0VmFsaWRSdWxlSW5zZXJ0aW9uSW5kZXgoY29udGFpbmVyLCBpbmRleCkge1xuICB2YXIgbWF4SW5kZXggPSBjb250YWluZXIuY3NzUnVsZXMubGVuZ3RoOyAvLyBJbiBjYXNlIHByZXZpb3VzIGluc2VydGlvbiBmYWlscywgcGFzc2VkIGluZGV4IG1pZ2h0IGJlIHdyb25nXG5cbiAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPiBtYXhJbmRleCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHJldHVybiBtYXhJbmRleDtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG5cbnZhciBjcmVhdGVTdHlsZSA9IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlKCkge1xuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpOyAvLyBXaXRob3V0IGl0LCBJRSB3aWxsIGhhdmUgYSBicm9rZW4gc291cmNlIG9yZGVyIHNwZWNpZmljaXR5IGlmIHdlXG4gIC8vIGluc2VydCBydWxlcyBhZnRlciB3ZSBpbnNlcnQgdGhlIHN0eWxlIHRhZy5cbiAgLy8gSXQgc2VlbXMgdG8ga2ljay1vZmYgdGhlIHNvdXJjZSBvcmRlciBzcGVjaWZpY2l0eSBhbGdvcml0aG0uXG5cbiAgZWwudGV4dENvbnRlbnQgPSAnXFxuJztcbiAgcmV0dXJuIGVsO1xufTtcblxudmFyIERvbVJlbmRlcmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gV2lsbCBiZSBlbXB0eSBpZiBsaW5rOiB0cnVlIG9wdGlvbiBpcyBub3Qgc2V0LCBiZWNhdXNlXG4gIC8vIGl0IGlzIG9ubHkgZm9yIHVzZSB0b2dldGhlciB3aXRoIGluc2VydFJ1bGUgQVBJLlxuICBmdW5jdGlvbiBEb21SZW5kZXJlcihzaGVldCkge1xuICAgIHRoaXMuZ2V0UHJvcGVydHlWYWx1ZSA9IGdldFByb3BlcnR5VmFsdWU7XG4gICAgdGhpcy5zZXRQcm9wZXJ0eSA9IHNldFByb3BlcnR5O1xuICAgIHRoaXMucmVtb3ZlUHJvcGVydHkgPSByZW1vdmVQcm9wZXJ0eTtcbiAgICB0aGlzLnNldFNlbGVjdG9yID0gc2V0U2VsZWN0b3I7XG4gICAgdGhpcy5oYXNJbnNlcnRlZFJ1bGVzID0gZmFsc2U7XG4gICAgdGhpcy5jc3NSdWxlcyA9IFtdO1xuICAgIC8vIFRoZXJlIGlzIG5vIHNoZWV0IHdoZW4gdGhlIHJlbmRlcmVyIGlzIHVzZWQgZnJvbSBhIHN0YW5kYWxvbmUgU3R5bGVSdWxlLlxuICAgIGlmIChzaGVldCkgc2hlZXRzLmFkZChzaGVldCk7XG4gICAgdGhpcy5zaGVldCA9IHNoZWV0O1xuXG4gICAgdmFyIF9yZWYgPSB0aGlzLnNoZWV0ID8gdGhpcy5zaGVldC5vcHRpb25zIDoge30sXG4gICAgICAgIG1lZGlhID0gX3JlZi5tZWRpYSxcbiAgICAgICAgbWV0YSA9IF9yZWYubWV0YSxcbiAgICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudDtcblxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQgfHwgY3JlYXRlU3R5bGUoKTtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWpzcycsICcnKTtcbiAgICBpZiAobWVkaWEpIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICAgIGlmIChtZXRhKSB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLW1ldGEnLCBtZXRhKTtcbiAgICB2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuICAgIGlmIChub25jZSkgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBzdHlsZSBlbGVtZW50IGludG8gcmVuZGVyIHRyZWUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IERvbVJlbmRlcmVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYXR0YWNoID0gZnVuY3Rpb24gYXR0YWNoKCkge1xuICAgIC8vIEluIHRoZSBjYXNlIHRoZSBlbGVtZW50IG5vZGUgaXMgZXh0ZXJuYWwgYW5kIGl0IGlzIGFscmVhZHkgaW4gdGhlIERPTS5cbiAgICBpZiAodGhpcy5lbGVtZW50LnBhcmVudE5vZGUgfHwgIXRoaXMuc2hlZXQpIHJldHVybjtcbiAgICBpbnNlcnRTdHlsZSh0aGlzLmVsZW1lbnQsIHRoaXMuc2hlZXQub3B0aW9ucyk7IC8vIFdoZW4gcnVsZXMgYXJlIGluc2VydGVkIHVzaW5nIGBpbnNlcnRSdWxlYCBBUEksIGFmdGVyIGBzaGVldC5kZXRhY2goKS5hdHRhY2goKWBcbiAgICAvLyBtb3N0IGJyb3dzZXJzIGNyZWF0ZSBhIG5ldyBDU1NTdHlsZVNoZWV0LCBleGNlcHQgb2YgYWxsIElFcy5cblxuICAgIHZhciBkZXBsb3llZCA9IEJvb2xlYW4odGhpcy5zaGVldCAmJiB0aGlzLnNoZWV0LmRlcGxveWVkKTtcblxuICAgIGlmICh0aGlzLmhhc0luc2VydGVkUnVsZXMgJiYgZGVwbG95ZWQpIHtcbiAgICAgIHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyA9IGZhbHNlO1xuICAgICAgdGhpcy5kZXBsb3koKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBzdHlsZSBlbGVtZW50IGZyb20gcmVuZGVyIHRyZWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICBpZiAoIXRoaXMuc2hlZXQpIHJldHVybjtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMuZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7IC8vIEluIHRoZSBtb3N0IGJyb3dzZXJzLCBydWxlcyBpbnNlcnRlZCB1c2luZyBpbnNlcnRSdWxlKCkgQVBJIHdpbGwgYmUgbG9zdCB3aGVuIHN0eWxlIGVsZW1lbnQgaXMgcmVtb3ZlZC5cbiAgICAvLyBUaG91Z2ggSUUgd2lsbCBrZWVwIHRoZW0gYW5kIHdlIG5lZWQgYSBjb25zaXN0ZW50IGJlaGF2aW9yLlxuXG4gICAgaWYgKHRoaXMuc2hlZXQub3B0aW9ucy5saW5rKSB7XG4gICAgICB0aGlzLmNzc1J1bGVzID0gW107XG4gICAgICB0aGlzLmVsZW1lbnQudGV4dENvbnRlbnQgPSAnXFxuJztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluamVjdCBDU1Mgc3RyaW5nIGludG8gZWxlbWVudC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVwbG95ID0gZnVuY3Rpb24gZGVwbG95KCkge1xuICAgIHZhciBzaGVldCA9IHRoaXMuc2hlZXQ7XG4gICAgaWYgKCFzaGVldCkgcmV0dXJuO1xuXG4gICAgaWYgKHNoZWV0Lm9wdGlvbnMubGluaykge1xuICAgICAgdGhpcy5pbnNlcnRSdWxlcyhzaGVldC5ydWxlcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LnRleHRDb250ZW50ID0gXCJcXG5cIiArIHNoZWV0LnRvU3RyaW5nKCkgKyBcIlxcblwiO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgUnVsZUxpc3QgaW50byBhbiBlbGVtZW50LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbnNlcnRSdWxlcyA9IGZ1bmN0aW9uIGluc2VydFJ1bGVzKHJ1bGVzLCBuYXRpdmVQYXJlbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmluZGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmluc2VydFJ1bGUocnVsZXMuaW5kZXhbaV0sIGksIG5hdGl2ZVBhcmVudCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgYSBydWxlIGludG8gZWxlbWVudC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIGluc2VydFJ1bGUocnVsZSwgaW5kZXgsIG5hdGl2ZVBhcmVudCkge1xuICAgIGlmIChuYXRpdmVQYXJlbnQgPT09IHZvaWQgMCkge1xuICAgICAgbmF0aXZlUGFyZW50ID0gdGhpcy5lbGVtZW50LnNoZWV0O1xuICAgIH1cblxuICAgIGlmIChydWxlLnJ1bGVzKSB7XG4gICAgICB2YXIgcGFyZW50ID0gcnVsZTtcbiAgICAgIHZhciBsYXRlc3ROYXRpdmVQYXJlbnQgPSBuYXRpdmVQYXJlbnQ7XG5cbiAgICAgIGlmIChydWxlLnR5cGUgPT09ICdjb25kaXRpb25hbCcgfHwgcnVsZS50eXBlID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgICB2YXIgX2luc2VydGlvbkluZGV4ID0gZ2V0VmFsaWRSdWxlSW5zZXJ0aW9uSW5kZXgobmF0aXZlUGFyZW50LCBpbmRleCk7IC8vIFdlIG5lZWQgdG8gcmVuZGVyIHRoZSBjb250YWluZXIgd2l0aG91dCBjaGlsZHJlbiBmaXJzdC5cblxuXG4gICAgICAgIGxhdGVzdE5hdGl2ZVBhcmVudCA9IF9pbnNlcnRSdWxlKG5hdGl2ZVBhcmVudCwgcGFyZW50LnRvU3RyaW5nKHtcbiAgICAgICAgICBjaGlsZHJlbjogZmFsc2VcbiAgICAgICAgfSksIF9pbnNlcnRpb25JbmRleCk7XG5cbiAgICAgICAgaWYgKGxhdGVzdE5hdGl2ZVBhcmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZkNzc1J1bGUocnVsZSwgX2luc2VydGlvbkluZGV4LCBsYXRlc3ROYXRpdmVQYXJlbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluc2VydFJ1bGVzKHBhcmVudC5ydWxlcywgbGF0ZXN0TmF0aXZlUGFyZW50KTtcbiAgICAgIHJldHVybiBsYXRlc3ROYXRpdmVQYXJlbnQ7XG4gICAgfVxuXG4gICAgdmFyIHJ1bGVTdHIgPSBydWxlLnRvU3RyaW5nKCk7XG4gICAgaWYgKCFydWxlU3RyKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGluc2VydGlvbkluZGV4ID0gZ2V0VmFsaWRSdWxlSW5zZXJ0aW9uSW5kZXgobmF0aXZlUGFyZW50LCBpbmRleCk7XG5cbiAgICB2YXIgbmF0aXZlUnVsZSA9IF9pbnNlcnRSdWxlKG5hdGl2ZVBhcmVudCwgcnVsZVN0ciwgaW5zZXJ0aW9uSW5kZXgpO1xuXG4gICAgaWYgKG5hdGl2ZVJ1bGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5oYXNJbnNlcnRlZFJ1bGVzID0gdHJ1ZTtcbiAgICB0aGlzLnJlZkNzc1J1bGUocnVsZSwgaW5zZXJ0aW9uSW5kZXgsIG5hdGl2ZVJ1bGUpO1xuICAgIHJldHVybiBuYXRpdmVSdWxlO1xuICB9O1xuXG4gIF9wcm90by5yZWZDc3NSdWxlID0gZnVuY3Rpb24gcmVmQ3NzUnVsZShydWxlLCBpbmRleCwgY3NzUnVsZSkge1xuICAgIHJ1bGUucmVuZGVyYWJsZSA9IGNzc1J1bGU7IC8vIFdlIG9ubHkgd2FudCB0byByZWZlcmVuY2UgdGhlIHRvcCBsZXZlbCBydWxlcywgZGVsZXRlUnVsZSBBUEkgZG9lc24ndCBzdXBwb3J0IHJlbW92aW5nIG5lc3RlZCBydWxlc1xuICAgIC8vIGxpa2UgcnVsZXMgaW5zaWRlIG1lZGlhIHF1ZXJpZXMgb3Iga2V5ZnJhbWVzXG5cbiAgICBpZiAocnVsZS5vcHRpb25zLnBhcmVudCBpbnN0YW5jZW9mIFN0eWxlU2hlZXQpIHtcbiAgICAgIHRoaXMuY3NzUnVsZXNbaW5kZXhdID0gY3NzUnVsZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiBkZWxldGVSdWxlKGNzc1J1bGUpIHtcbiAgICB2YXIgc2hlZXQgPSB0aGlzLmVsZW1lbnQuc2hlZXQ7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKGNzc1J1bGUpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICBzaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICB0aGlzLmNzc1J1bGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIENTUyBSdWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihjc3NSdWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuY3NzUnVsZXMuaW5kZXhPZihjc3NSdWxlKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgYSBuZXcgQ1NTIHJ1bGUgYW5kIHJlcGxhY2UgdGhlIGV4aXN0aW5nIG9uZS5cbiAgICpcbiAgICogT25seSB1c2VkIGZvciBzb21lIG9sZCBicm93c2VycyBiZWNhdXNlIHRoZXkgY2FuJ3Qgc2V0IGEgc2VsZWN0b3IuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlcGxhY2VSdWxlID0gZnVuY3Rpb24gcmVwbGFjZVJ1bGUoY3NzUnVsZSwgcnVsZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZihjc3NSdWxlKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5lbGVtZW50LnNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgIHRoaXMuY3NzUnVsZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCBydWxlcyBlbGVtZW50cy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0UnVsZXMgPSBmdW5jdGlvbiBnZXRSdWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnNoZWV0LmNzc1J1bGVzO1xuICB9O1xuXG4gIHJldHVybiBEb21SZW5kZXJlcjtcbn0oKTtcblxudmFyIGluc3RhbmNlQ291bnRlciA9IDA7XG5cbnZhciBKc3MgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBKc3Mob3B0aW9ucykge1xuICAgIHRoaXMuaWQgPSBpbnN0YW5jZUNvdW50ZXIrKztcbiAgICB0aGlzLnZlcnNpb24gPSBcIjEwLjguMFwiO1xuICAgIHRoaXMucGx1Z2lucyA9IG5ldyBQbHVnaW5zUmVnaXN0cnkoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBpZDoge1xuICAgICAgICBtaW5pZnk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgY3JlYXRlR2VuZXJhdGVJZDogY3JlYXRlR2VuZXJhdGVJZCxcbiAgICAgIFJlbmRlcmVyOiBpc0luQnJvd3NlciA/IERvbVJlbmRlcmVyIDogbnVsbCxcbiAgICAgIHBsdWdpbnM6IFtdXG4gICAgfTtcbiAgICB0aGlzLmdlbmVyYXRlSWQgPSBjcmVhdGVHZW5lcmF0ZUlkKHtcbiAgICAgIG1pbmlmeTogZmFsc2VcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5wbHVnaW5zLnVzZShwbHVnaW5zW2ldLCB7XG4gICAgICAgIHF1ZXVlOiAnaW50ZXJuYWwnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldHVwKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBQcmVwYXJlcyB2YXJpb3VzIG9wdGlvbnMsIGFwcGxpZXMgcGx1Z2lucy5cbiAgICogU2hvdWxkIG5vdCBiZSB1c2VkIHR3aWNlIG9uIHRoZSBzYW1lIGluc3RhbmNlLCBiZWNhdXNlIHRoZXJlIGlzIG5vIHBsdWdpbnNcbiAgICogZGVkdXBsaWNhdGlvbiBsb2dpYy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gSnNzLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0dXAgPSBmdW5jdGlvbiBzZXR1cChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkID0gb3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmlkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuaWQgPSBfZXh0ZW5kcyh7fSwgdGhpcy5vcHRpb25zLmlkLCBvcHRpb25zLmlkKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkIHx8IG9wdGlvbnMuaWQpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVJZCA9IHRoaXMub3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkKHRoaXMub3B0aW9ucy5pZCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgIT0gbnVsbCkgdGhpcy5vcHRpb25zLmluc2VydGlvblBvaW50ID0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludDtcblxuICAgIGlmICgnUmVuZGVyZXInIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5SZW5kZXJlciA9IG9wdGlvbnMuUmVuZGVyZXI7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuXG5cbiAgICBpZiAob3B0aW9ucy5wbHVnaW5zKSB0aGlzLnVzZS5hcHBseSh0aGlzLCBvcHRpb25zLnBsdWdpbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBTdHlsZSBTaGVldC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY3JlYXRlU3R5bGVTaGVldCA9IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlU2hlZXQoc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICAgIGluZGV4ID0gX29wdGlvbnMuaW5kZXg7XG5cbiAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgaW5kZXggPSBzaGVldHMuaW5kZXggPT09IDAgPyAwIDogc2hlZXRzLmluZGV4ICsgMTtcbiAgICB9XG5cbiAgICB2YXIgc2hlZXQgPSBuZXcgU3R5bGVTaGVldChzdHlsZXMsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBqc3M6IHRoaXMsXG4gICAgICBnZW5lcmF0ZUlkOiBvcHRpb25zLmdlbmVyYXRlSWQgfHwgdGhpcy5nZW5lcmF0ZUlkLFxuICAgICAgaW5zZXJ0aW9uUG9pbnQ6IHRoaXMub3B0aW9ucy5pbnNlcnRpb25Qb2ludCxcbiAgICAgIFJlbmRlcmVyOiB0aGlzLm9wdGlvbnMuUmVuZGVyZXIsXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9KSk7XG4gICAgdGhpcy5wbHVnaW5zLm9uUHJvY2Vzc1NoZWV0KHNoZWV0KTtcbiAgICByZXR1cm4gc2hlZXQ7XG4gIH1cbiAgLyoqXG4gICAqIERldGFjaCB0aGUgU3R5bGUgU2hlZXQgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVtb3ZlU3R5bGVTaGVldCA9IGZ1bmN0aW9uIHJlbW92ZVN0eWxlU2hlZXQoc2hlZXQpIHtcbiAgICBzaGVldC5kZXRhY2goKTtcbiAgICBzaGVldHMucmVtb3ZlKHNoZWV0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgcnVsZSB3aXRob3V0IGEgU3R5bGUgU2hlZXQuXG4gICAqIFtEZXByZWNhdGVkXSB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY3JlYXRlUnVsZSA9IGZ1bmN0aW9uIGNyZWF0ZVJ1bGUkMShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChzdHlsZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdHlsZSA9IHt9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBFbmFibGUgcnVsZSB3aXRob3V0IG5hbWUgZm9yIGlubGluZSBzdHlsZXMuXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUnVsZSh1bmRlZmluZWQsIG5hbWUsIHN0eWxlKTtcbiAgICB9XG5cbiAgICB2YXIgcnVsZU9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGpzczogdGhpcyxcbiAgICAgIFJlbmRlcmVyOiB0aGlzLm9wdGlvbnMuUmVuZGVyZXJcbiAgICB9KTtcblxuICAgIGlmICghcnVsZU9wdGlvbnMuZ2VuZXJhdGVJZCkgcnVsZU9wdGlvbnMuZ2VuZXJhdGVJZCA9IHRoaXMuZ2VuZXJhdGVJZDtcbiAgICBpZiAoIXJ1bGVPcHRpb25zLmNsYXNzZXMpIHJ1bGVPcHRpb25zLmNsYXNzZXMgPSB7fTtcbiAgICBpZiAoIXJ1bGVPcHRpb25zLmtleWZyYW1lcykgcnVsZU9wdGlvbnMua2V5ZnJhbWVzID0ge307XG5cbiAgICB2YXIgcnVsZSA9IGNyZWF0ZVJ1bGUobmFtZSwgc3R5bGUsIHJ1bGVPcHRpb25zKTtcblxuICAgIGlmIChydWxlKSB0aGlzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShydWxlKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgcGx1Z2luLiBQYXNzZWQgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdpdGggYSBydWxlIGluc3RhbmNlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51c2UgPSBmdW5jdGlvbiB1c2UoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcGx1Z2luc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgX3RoaXMucGx1Z2lucy51c2UocGx1Z2luKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gSnNzO1xufSgpO1xuXG52YXIgY3JlYXRlSnNzID0gZnVuY3Rpb24gY3JlYXRlSnNzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBKc3Mob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFNoZWV0c01hbmFnZXIgaXMgbGlrZSBhIFdlYWtNYXAgd2hpY2ggaXMgZGVzaWduZWQgdG8gY291bnQgU3R5bGVTaGVldFxuICogaW5zdGFuY2VzIGFuZCBhdHRhY2gvZGV0YWNoIGF1dG9tYXRpY2FsbHkuXG4gKiBVc2VkIGluIHJlYWN0LWpzcy5cbiAqL1xuXG52YXIgU2hlZXRzTWFuYWdlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNoZWV0c01hbmFnZXIoKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuc2hlZXRzID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTaGVldHNNYW5hZ2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuc2hlZXRzLmdldChrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS5zaGVldDtcbiAgfTtcblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKGtleSwgc2hlZXQpIHtcbiAgICBpZiAodGhpcy5zaGVldHMuaGFzKGtleSkpIHJldHVybjtcbiAgICB0aGlzLmxlbmd0aCsrO1xuICAgIHRoaXMuc2hlZXRzLnNldChrZXksIHtcbiAgICAgIHNoZWV0OiBzaGVldCxcbiAgICAgIHJlZnM6IDBcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ubWFuYWdlID0gZnVuY3Rpb24gbWFuYWdlKGtleSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuc2hlZXRzLmdldChrZXkpO1xuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBpZiAoZW50cnkucmVmcyA9PT0gMCkge1xuICAgICAgICBlbnRyeS5zaGVldC5hdHRhY2goKTtcbiAgICAgIH1cblxuICAgICAgZW50cnkucmVmcysrO1xuICAgICAgcmV0dXJuIGVudHJ5LnNoZWV0O1xuICAgIH1cblxuICAgIHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gU2hlZXRzTWFuYWdlcjogY2FuJ3QgZmluZCBzaGVldCB0byBtYW5hZ2VcIik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICBfcHJvdG8udW5tYW5hZ2UgPSBmdW5jdGlvbiB1bm1hbmFnZShrZXkpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLnNoZWV0cy5nZXQoa2V5KTtcblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgaWYgKGVudHJ5LnJlZnMgPiAwKSB7XG4gICAgICAgIGVudHJ5LnJlZnMtLTtcbiAgICAgICAgaWYgKGVudHJ5LnJlZnMgPT09IDApIGVudHJ5LnNoZWV0LmRldGFjaCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCBcIlNoZWV0c01hbmFnZXI6IGNhbid0IGZpbmQgc2hlZXQgdG8gdW5tYW5hZ2VcIik7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTaGVldHNNYW5hZ2VyLCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNoZWV0c01hbmFnZXI7XG59KCk7XG5cbi8qKlxuKiBFeHBvcnQgYSBjb25zdGFudCBpbmRpY2F0aW5nIGlmIHRoaXMgYnJvd3NlciBoYXMgQ1NTVE9NIHN1cHBvcnQuXG4qIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTgvMDMvY3Nzb21cbiovXG52YXIgaGFzQ1NTVE9NU3VwcG9ydCA9IHR5cGVvZiBDU1MgPT09ICdvYmplY3QnICYmIENTUyAhPSBudWxsICYmICdudW1iZXInIGluIENTUztcblxuLyoqXG4gKiBFeHRyYWN0cyBhIHN0eWxlcyBvYmplY3Qgd2l0aCBvbmx5IHByb3BzIHRoYXQgY29udGFpbiBmdW5jdGlvbiB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldER5bmFtaWNTdHlsZXMoc3R5bGVzKSB7XG4gIHZhciB0byA9IG51bGw7XG5cbiAgZm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuICAgIHZhciB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICghdG8pIHRvID0ge307XG4gICAgICB0b1trZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhciBleHRyYWN0ZWQgPSBnZXREeW5hbWljU3R5bGVzKHZhbHVlKTtcblxuICAgICAgaWYgKGV4dHJhY3RlZCkge1xuICAgICAgICBpZiAoIXRvKSB0byA9IHt9O1xuICAgICAgICB0b1trZXldID0gZXh0cmFjdGVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBBIGJldHRlciBhYnN0cmFjdGlvbiBvdmVyIENTUy5cbiAqXG4gKiBAY29weXJpZ2h0IE9sZWcgSXNvbmVuIChTbG9ib2Rza29pKSAvIElzb25lbiAyMDE0LXByZXNlbnRcbiAqIEB3ZWJzaXRlIGh0dHBzOi8vZ2l0aHViLmNvbS9jc3NpbmpzL2pzc1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cbnZhciBpbmRleCA9IGNyZWF0ZUpzcygpO1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbmV4cG9ydCB7IFJ1bGVMaXN0LCBTaGVldHNNYW5hZ2VyLCBTaGVldHNSZWdpc3RyeSwgY3JlYXRlSnNzIGFzIGNyZWF0ZSwgY3JlYXRlR2VuZXJhdGVJZCwgY3JlYXRlUnVsZSwgZ2V0RHluYW1pY1N0eWxlcywgaGFzQ1NTVE9NU3VwcG9ydCwgc2hlZXRzLCB0b0Nzc1ZhbHVlIH07XG4iLCJpbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuaW1wb3J0IHsgY3JlYXRlUnVsZSB9IGZyb20gJ2pzcyc7XG5cbnZhciBub3cgPSBEYXRlLm5vdygpO1xudmFyIGZuVmFsdWVzTnMgPSBcImZuVmFsdWVzXCIgKyBub3c7XG52YXIgZm5SdWxlTnMgPSBcImZuU3R5bGVcIiArICsrbm93O1xuXG52YXIgZnVuY3Rpb25QbHVnaW4gPSBmdW5jdGlvbiBmdW5jdGlvblBsdWdpbigpIHtcbiAgcmV0dXJuIHtcbiAgICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIGRlY2wgIT09ICdmdW5jdGlvbicpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHJ1bGUgPSBjcmVhdGVSdWxlKG5hbWUsIHt9LCBvcHRpb25zKTtcbiAgICAgIHJ1bGVbZm5SdWxlTnNdID0gZGVjbDtcbiAgICAgIHJldHVybiBydWxlO1xuICAgIH0sXG4gICAgb25Qcm9jZXNzU3R5bGU6IGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGV4dHJhY3QgZnVuY3Rpb24gdmFsdWVzIGZyb20gdGhlIGRlY2xhcmF0aW9uLCBzbyB0aGF0IHdlIGNhbiBrZWVwIGNvcmUgdW5hd2FyZSBvZiB0aGVtLlxuICAgICAgLy8gV2UgbmVlZCB0byBkbyB0aGF0IG9ubHkgb25jZS5cbiAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gZXh0cmFjdCBmdW5jdGlvbnMgb24gZWFjaCBzdHlsZSB1cGRhdGUsIHNpbmNlIHRoaXMgY2FuIGhhcHBlbiBvbmx5IG9uY2UuXG4gICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IGZ1bmN0aW9uIHZhbHVlcyBpbnNpZGUgb2YgZnVuY3Rpb24gcnVsZXMuXG4gICAgICBpZiAoZm5WYWx1ZXNOcyBpbiBydWxlIHx8IGZuUnVsZU5zIGluIHJ1bGUpIHJldHVybiBzdHlsZTtcbiAgICAgIHZhciBmblZhbHVlcyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSBjb250aW51ZTtcbiAgICAgICAgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICAgICAgICBmblZhbHVlc1twcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBydWxlW2ZuVmFsdWVzTnNdID0gZm5WYWx1ZXM7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcbiAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoZGF0YSwgcnVsZSwgc2hlZXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdHlsZVJ1bGUgPSBydWxlO1xuICAgICAgdmFyIGZuUnVsZSA9IHN0eWxlUnVsZVtmblJ1bGVOc107IC8vIElmIHdlIGhhdmUgYSBzdHlsZSBmdW5jdGlvbiwgdGhlIGVudGlyZSBydWxlIGlzIGR5bmFtaWMgYW5kIHN0eWxlIG9iamVjdFxuICAgICAgLy8gd2lsbCBiZSByZXR1cm5lZCBmcm9tIHRoYXQgZnVuY3Rpb24uXG5cbiAgICAgIGlmIChmblJ1bGUpIHtcbiAgICAgICAgLy8gRW1wdHkgb2JqZWN0IHdpbGwgcmVtb3ZlIGFsbCBjdXJyZW50bHkgZGVmaW5lZCBwcm9wc1xuICAgICAgICAvLyBpbiBjYXNlIGZ1bmN0aW9uIHJ1bGUgcmV0dXJucyBhIGZhbHN5IHZhbHVlLlxuICAgICAgICBzdHlsZVJ1bGUuc3R5bGUgPSBmblJ1bGUoZGF0YSkgfHwge307XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZVJ1bGUuc3R5bGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGVSdWxlLnN0eWxlW3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdbSlNTXSBGdW5jdGlvbiB2YWx1ZXMgaW5zaWRlIGZ1bmN0aW9uIHJ1bGVzIGFyZSBub3Qgc3VwcG9ydGVkLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGZuVmFsdWVzID0gc3R5bGVSdWxlW2ZuVmFsdWVzTnNdOyAvLyBJZiB3ZSBoYXZlIGEgZm4gdmFsdWVzIG1hcCwgaXQgaXMgYSBydWxlIHdpdGggZnVuY3Rpb24gdmFsdWVzLlxuXG4gICAgICBpZiAoZm5WYWx1ZXMpIHtcbiAgICAgICAgZm9yICh2YXIgX3Byb3AgaW4gZm5WYWx1ZXMpIHtcbiAgICAgICAgICBzdHlsZVJ1bGUucHJvcChfcHJvcCwgZm5WYWx1ZXNbX3Byb3BdKGRhdGEpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uUGx1Z2luO1xuIiwiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IHsgUnVsZUxpc3QgfSBmcm9tICdqc3MnO1xuXG52YXIgYXQgPSAnQGdsb2JhbCc7XG52YXIgYXRQcmVmaXggPSAnQGdsb2JhbCAnO1xuXG52YXIgR2xvYmFsQ29udGFpbmVyUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdsb2JhbENvbnRhaW5lclJ1bGUoa2V5LCBzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnZ2xvYmFsJztcbiAgICB0aGlzLmF0ID0gYXQ7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5ydWxlcyA9IG5ldyBSdWxlTGlzdChfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgcGFyZW50OiB0aGlzXG4gICAgfSkpO1xuXG4gICAgZm9yICh2YXIgc2VsZWN0b3IgaW4gc3R5bGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChzZWxlY3Rvciwgc3R5bGVzW3NlbGVjdG9yXSk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5wcm9jZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHJ1bGUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IEdsb2JhbENvbnRhaW5lclJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRSdWxlID0gZnVuY3Rpb24gZ2V0UnVsZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuZ2V0KG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUsIHJ1biBwbHVnaW5zLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hZGRSdWxlID0gZnVuY3Rpb24gYWRkUnVsZShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHZhciBydWxlID0gdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGUsIG9wdGlvbnMpO1xuICAgIGlmIChydWxlKSB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShydWxlKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmluZGV4T2YocnVsZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMudG9TdHJpbmcoKTtcbiAgfTtcblxuICByZXR1cm4gR2xvYmFsQ29udGFpbmVyUnVsZTtcbn0oKTtcblxudmFyIEdsb2JhbFByZWZpeGVkUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdsb2JhbFByZWZpeGVkUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2dsb2JhbCc7XG4gICAgdGhpcy5hdCA9IGF0O1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBzZWxlY3RvciA9IGtleS5zdWJzdHIoYXRQcmVmaXgubGVuZ3RoKTtcbiAgICB0aGlzLnJ1bGUgPSBvcHRpb25zLmpzcy5jcmVhdGVSdWxlKHNlbGVjdG9yLCBzdHlsZSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gR2xvYmFsUHJlZml4ZWRSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJ1bGUgPyB0aGlzLnJ1bGUudG9TdHJpbmcob3B0aW9ucykgOiAnJztcbiAgfTtcblxuICByZXR1cm4gR2xvYmFsUHJlZml4ZWRSdWxlO1xufSgpO1xuXG52YXIgc2VwYXJhdG9yUmVnRXhwID0gL1xccyosXFxzKi9nO1xuXG5mdW5jdGlvbiBhZGRTY29wZShzZWxlY3Rvciwgc2NvcGUpIHtcbiAgdmFyIHBhcnRzID0gc2VsZWN0b3Iuc3BsaXQoc2VwYXJhdG9yUmVnRXhwKTtcbiAgdmFyIHNjb3BlZCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBzY29wZWQgKz0gc2NvcGUgKyBcIiBcIiArIHBhcnRzW2ldLnRyaW0oKTtcbiAgICBpZiAocGFydHNbaSArIDFdKSBzY29wZWQgKz0gJywgJztcbiAgfVxuXG4gIHJldHVybiBzY29wZWQ7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU5lc3RlZEdsb2JhbENvbnRhaW5lclJ1bGUocnVsZSwgc2hlZXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBydWxlLm9wdGlvbnMsXG4gICAgICBzdHlsZSA9IHJ1bGUuc3R5bGU7XG4gIHZhciBydWxlcyA9IHN0eWxlID8gc3R5bGVbYXRdIDogbnVsbDtcbiAgaWYgKCFydWxlcykgcmV0dXJuO1xuXG4gIGZvciAodmFyIG5hbWUgaW4gcnVsZXMpIHtcbiAgICBzaGVldC5hZGRSdWxlKG5hbWUsIHJ1bGVzW25hbWVdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgc2VsZWN0b3I6IGFkZFNjb3BlKG5hbWUsIHJ1bGUuc2VsZWN0b3IpXG4gICAgfSkpO1xuICB9XG5cbiAgZGVsZXRlIHN0eWxlW2F0XTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUHJlZml4ZWRHbG9iYWxSdWxlKHJ1bGUsIHNoZWV0KSB7XG4gIHZhciBvcHRpb25zID0gcnVsZS5vcHRpb25zLFxuICAgICAgc3R5bGUgPSBydWxlLnN0eWxlO1xuXG4gIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICBpZiAocHJvcFswXSAhPT0gJ0AnIHx8IHByb3Auc3Vic3RyKDAsIGF0Lmxlbmd0aCkgIT09IGF0KSBjb250aW51ZTtcbiAgICB2YXIgc2VsZWN0b3IgPSBhZGRTY29wZShwcm9wLnN1YnN0cihhdC5sZW5ndGgpLCBydWxlLnNlbGVjdG9yKTtcbiAgICBzaGVldC5hZGRSdWxlKHNlbGVjdG9yLCBzdHlsZVtwcm9wXSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHNlbGVjdG9yOiBzZWxlY3RvclxuICAgIH0pKTtcbiAgICBkZWxldGUgc3R5bGVbcHJvcF07XG4gIH1cbn1cbi8qKlxuICogQ29udmVydCBuZXN0ZWQgcnVsZXMgdG8gc2VwYXJhdGUsIHJlbW92ZSB0aGVtIGZyb20gb3JpZ2luYWwgc3R5bGVzLlxuICovXG5cblxuZnVuY3Rpb24ganNzR2xvYmFsKCkge1xuICBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFuYW1lKSByZXR1cm4gbnVsbDtcblxuICAgIGlmIChuYW1lID09PSBhdCkge1xuICAgICAgcmV0dXJuIG5ldyBHbG9iYWxDb250YWluZXJSdWxlKG5hbWUsIHN0eWxlcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVbMF0gPT09ICdAJyAmJiBuYW1lLnN1YnN0cigwLCBhdFByZWZpeC5sZW5ndGgpID09PSBhdFByZWZpeCkge1xuICAgICAgcmV0dXJuIG5ldyBHbG9iYWxQcmVmaXhlZFJ1bGUobmFtZSwgc3R5bGVzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LnR5cGUgPT09ICdnbG9iYWwnIHx8IHBhcmVudC5vcHRpb25zLnBhcmVudCAmJiBwYXJlbnQub3B0aW9ucy5wYXJlbnQudHlwZSA9PT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgb3B0aW9ucy5zY29wZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zY29wZWQgPT09IGZhbHNlKSB7XG4gICAgICBvcHRpb25zLnNlbGVjdG9yID0gbmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1J1bGUocnVsZSwgc2hlZXQpIHtcbiAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnIHx8ICFzaGVldCkgcmV0dXJuO1xuICAgIGhhbmRsZU5lc3RlZEdsb2JhbENvbnRhaW5lclJ1bGUocnVsZSwgc2hlZXQpO1xuICAgIGhhbmRsZVByZWZpeGVkR2xvYmFsUnVsZShydWxlLCBzaGVldCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9uQ3JlYXRlUnVsZTogb25DcmVhdGVSdWxlLFxuICAgIG9uUHJvY2Vzc1J1bGU6IG9uUHJvY2Vzc1J1bGVcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQganNzR2xvYmFsO1xuIiwiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAndGlueS13YXJuaW5nJztcblxudmFyIHNlcGFyYXRvclJlZ0V4cCA9IC9cXHMqLFxccyovZztcbnZhciBwYXJlbnRSZWdFeHAgPSAvJi9nO1xudmFyIHJlZlJlZ0V4cCA9IC9cXCQoW1xcdy1dKykvZztcbi8qKlxuICogQ29udmVydCBuZXN0ZWQgcnVsZXMgdG8gc2VwYXJhdGUsIHJlbW92ZSB0aGVtIGZyb20gb3JpZ2luYWwgc3R5bGVzLlxuICovXG5cbmZ1bmN0aW9uIGpzc05lc3RlZCgpIHtcbiAgLy8gR2V0IGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgJHJlZiByZXBsYWNlbWVudC5cbiAgZnVuY3Rpb24gZ2V0UmVwbGFjZVJlZihjb250YWluZXIsIHNoZWV0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCwga2V5KSB7XG4gICAgICB2YXIgcnVsZSA9IGNvbnRhaW5lci5nZXRSdWxlKGtleSkgfHwgc2hlZXQgJiYgc2hlZXQuZ2V0UnVsZShrZXkpO1xuXG4gICAgICBpZiAocnVsZSkge1xuICAgICAgICByZXR1cm4gcnVsZS5zZWxlY3RvcjtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBDb3VsZCBub3QgZmluZCB0aGUgcmVmZXJlbmNlZCBydWxlIFxcXCJcIiArIGtleSArIFwiXFxcIiBpbiBcXFwiXCIgKyAoY29udGFpbmVyLm9wdGlvbnMubWV0YSB8fCBjb250YWluZXIudG9TdHJpbmcoKSkgKyBcIlxcXCIuXCIpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZVBhcmVudFJlZnMobmVzdGVkUHJvcCwgcGFyZW50UHJvcCkge1xuICAgIHZhciBwYXJlbnRTZWxlY3RvcnMgPSBwYXJlbnRQcm9wLnNwbGl0KHNlcGFyYXRvclJlZ0V4cCk7XG4gICAgdmFyIG5lc3RlZFNlbGVjdG9ycyA9IG5lc3RlZFByb3Auc3BsaXQoc2VwYXJhdG9yUmVnRXhwKTtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudFNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcmVudCA9IHBhcmVudFNlbGVjdG9yc1tpXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuZXN0ZWRTZWxlY3RvcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG5lc3RlZCA9IG5lc3RlZFNlbGVjdG9yc1tqXTtcbiAgICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9ICcsICc7IC8vIFJlcGxhY2UgYWxsICYgYnkgdGhlIHBhcmVudCBvciBwcmVmaXggJiB3aXRoIHRoZSBwYXJlbnQuXG5cbiAgICAgICAgcmVzdWx0ICs9IG5lc3RlZC5pbmRleE9mKCcmJykgIT09IC0xID8gbmVzdGVkLnJlcGxhY2UocGFyZW50UmVnRXhwLCBwYXJlbnQpIDogcGFyZW50ICsgXCIgXCIgKyBuZXN0ZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9wdGlvbnMocnVsZSwgY29udGFpbmVyLCBwcmV2T3B0aW9ucykge1xuICAgIC8vIE9wdGlvbnMgaGFzIGJlZW4gYWxyZWFkeSBjcmVhdGVkLCBub3cgd2Ugb25seSBpbmNyZWFzZSBpbmRleC5cbiAgICBpZiAocHJldk9wdGlvbnMpIHJldHVybiBfZXh0ZW5kcyh7fSwgcHJldk9wdGlvbnMsIHtcbiAgICAgIGluZGV4OiBwcmV2T3B0aW9ucy5pbmRleCArIDFcbiAgICB9KTtcbiAgICB2YXIgbmVzdGluZ0xldmVsID0gcnVsZS5vcHRpb25zLm5lc3RpbmdMZXZlbDtcbiAgICBuZXN0aW5nTGV2ZWwgPSBuZXN0aW5nTGV2ZWwgPT09IHVuZGVmaW5lZCA/IDEgOiBuZXN0aW5nTGV2ZWwgKyAxO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgcnVsZS5vcHRpb25zLCB7XG4gICAgICBuZXN0aW5nTGV2ZWw6IG5lc3RpbmdMZXZlbCxcbiAgICAgIGluZGV4OiBjb250YWluZXIuaW5kZXhPZihydWxlKSArIDEgLy8gV2UgZG9uJ3QgbmVlZCB0aGUgcGFyZW50IG5hbWUgdG8gYmUgc2V0IG9wdGlvbnMgZm9yIGNobGlkLlxuXG4gICAgfSk7XG5cbiAgICBkZWxldGUgb3B0aW9ucy5uYW1lO1xuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuICAgIHZhciBzdHlsZVJ1bGUgPSBydWxlO1xuICAgIHZhciBjb250YWluZXIgPSBzdHlsZVJ1bGUub3B0aW9ucy5wYXJlbnQ7XG4gICAgdmFyIG9wdGlvbnM7XG4gICAgdmFyIHJlcGxhY2VSZWY7XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICB2YXIgaXNOZXN0ZWQgPSBwcm9wLmluZGV4T2YoJyYnKSAhPT0gLTE7XG4gICAgICB2YXIgaXNOZXN0ZWRDb25kaXRpb25hbCA9IHByb3BbMF0gPT09ICdAJztcbiAgICAgIGlmICghaXNOZXN0ZWQgJiYgIWlzTmVzdGVkQ29uZGl0aW9uYWwpIGNvbnRpbnVlO1xuICAgICAgb3B0aW9ucyA9IGdldE9wdGlvbnMoc3R5bGVSdWxlLCBjb250YWluZXIsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoaXNOZXN0ZWQpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gcmVwbGFjZVBhcmVudFJlZnMocHJvcCwgc3R5bGVSdWxlLnNlbGVjdG9yKTsgLy8gTGF6aWx5IGNyZWF0ZSB0aGUgcmVmIHJlcGxhY2VyIGZ1bmN0aW9uIGp1c3Qgb25jZSBmb3JcbiAgICAgICAgLy8gYWxsIG5lc3RlZCBydWxlcyB3aXRoaW4gdGhlIHNoZWV0LlxuXG4gICAgICAgIGlmICghcmVwbGFjZVJlZikgcmVwbGFjZVJlZiA9IGdldFJlcGxhY2VSZWYoY29udGFpbmVyLCBzaGVldCk7IC8vIFJlcGxhY2UgYWxsICRyZWZzLlxuXG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShyZWZSZWdFeHAsIHJlcGxhY2VSZWYpO1xuICAgICAgICBjb250YWluZXIuYWRkUnVsZShzZWxlY3Rvciwgc3R5bGVbcHJvcF0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXN0ZWRDb25kaXRpb25hbCkge1xuICAgICAgICAvLyBQbGFjZSBjb25kaXRpb25hbCByaWdodCBhZnRlciB0aGUgcGFyZW50IHJ1bGUgdG8gZW5zdXJlIHJpZ2h0IG9yZGVyaW5nLlxuICAgICAgICBjb250YWluZXIuYWRkUnVsZShwcm9wLCB7fSwgb3B0aW9ucykuYWRkUnVsZShzdHlsZVJ1bGUua2V5LCBzdHlsZVtwcm9wXSwge1xuICAgICAgICAgIHNlbGVjdG9yOiBzdHlsZVJ1bGUuc2VsZWN0b3JcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBqc3NOZXN0ZWQ7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby12YXIsIHByZWZlci10ZW1wbGF0ZSAqL1xudmFyIHVwcGVyY2FzZVBhdHRlcm4gPSAvW0EtWl0vZ1xudmFyIG1zUGF0dGVybiA9IC9ebXMtL1xudmFyIGNhY2hlID0ge31cblxuZnVuY3Rpb24gdG9IeXBoZW5Mb3dlcihtYXRjaCkge1xuICByZXR1cm4gJy0nICsgbWF0Y2gudG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUobmFtZSkge1xuICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gY2FjaGVbbmFtZV1cbiAgfVxuXG4gIHZhciBoTmFtZSA9IG5hbWUucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCB0b0h5cGhlbkxvd2VyKVxuICByZXR1cm4gKGNhY2hlW25hbWVdID0gbXNQYXR0ZXJuLnRlc3QoaE5hbWUpID8gJy0nICsgaE5hbWUgOiBoTmFtZSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgaHlwaGVuYXRlU3R5bGVOYW1lXG4iLCJpbXBvcnQgaHlwaGVuYXRlIGZyb20gJ2h5cGhlbmF0ZS1zdHlsZS1uYW1lJztcblxuLyoqXG4gKiBDb252ZXJ0IGNhbWVsIGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGRhc2ggc2VwYXJhdGVkLlxuICovXG5cbmZ1bmN0aW9uIGNvbnZlcnRDYXNlKHN0eWxlKSB7XG4gIHZhciBjb252ZXJ0ZWQgPSB7fTtcblxuICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgdmFyIGtleSA9IHByb3AuaW5kZXhPZignLS0nKSA9PT0gMCA/IHByb3AgOiBoeXBoZW5hdGUocHJvcCk7XG4gICAgY29udmVydGVkW2tleV0gPSBzdHlsZVtwcm9wXTtcbiAgfVxuXG4gIGlmIChzdHlsZS5mYWxsYmFja3MpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZS5mYWxsYmFja3MpKSBjb252ZXJ0ZWQuZmFsbGJhY2tzID0gc3R5bGUuZmFsbGJhY2tzLm1hcChjb252ZXJ0Q2FzZSk7ZWxzZSBjb252ZXJ0ZWQuZmFsbGJhY2tzID0gY29udmVydENhc2Uoc3R5bGUuZmFsbGJhY2tzKTtcbiAgfVxuXG4gIHJldHVybiBjb252ZXJ0ZWQ7XG59XG4vKipcbiAqIEFsbG93IGNhbWVsIGNhc2VkIHByb3BlcnR5IG5hbWVzIGJ5IGNvbnZlcnRpbmcgdGhlbSBiYWNrIHRvIGRhc2hlcml6ZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBjYW1lbENhc2UoKSB7XG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICAvLyBIYW5kbGUgcnVsZXMgbGlrZSBAZm9udC1mYWNlLCB3aGljaCBjYW4gaGF2ZSBtdWx0aXBsZSBzdHlsZXMgaW4gYW4gYXJyYXlcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdHlsZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc3R5bGVbaW5kZXhdID0gY29udmVydENhc2Uoc3R5bGVbaW5kZXhdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cblxuICAgIHJldHVybiBjb252ZXJ0Q2FzZShzdHlsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKHZhbHVlLCBwcm9wLCBydWxlKSB7XG4gICAgaWYgKHByb3AuaW5kZXhPZignLS0nKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBoeXBoZW5hdGVkUHJvcCA9IGh5cGhlbmF0ZShwcm9wKTsgLy8gVGhlcmUgd2FzIG5vIGNhbWVsIGNhc2UgaW4gcGxhY2VcblxuICAgIGlmIChwcm9wID09PSBoeXBoZW5hdGVkUHJvcCkgcmV0dXJuIHZhbHVlO1xuICAgIHJ1bGUucHJvcChoeXBoZW5hdGVkUHJvcCwgdmFsdWUpOyAvLyBDb3JlIHdpbGwgaWdub3JlIHRoYXQgcHJvcGVydHkgdmFsdWUgd2Ugc2V0IHRoZSBwcm9wZXIgb25lIGFib3ZlLlxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZSxcbiAgICBvbkNoYW5nZVZhbHVlOiBvbkNoYW5nZVZhbHVlXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhbWVsQ2FzZTtcbiIsImltcG9ydCB7IGhhc0NTU1RPTVN1cHBvcnQgfSBmcm9tICdqc3MnO1xuXG52YXIgcHggPSBoYXNDU1NUT01TdXBwb3J0ICYmIENTUyA/IENTUy5weCA6ICdweCc7XG52YXIgbXMgPSBoYXNDU1NUT01TdXBwb3J0ICYmIENTUyA/IENTUy5tcyA6ICdtcyc7XG52YXIgcGVyY2VudCA9IGhhc0NTU1RPTVN1cHBvcnQgJiYgQ1NTID8gQ1NTLnBlcmNlbnQgOiAnJSc7XG4vKipcbiAqIEdlbmVyYXRlZCBqc3MtcGx1Z2luLWRlZmF1bHQtdW5pdCBDU1MgcHJvcGVydHkgdW5pdHNcbiAqL1xuXG52YXIgZGVmYXVsdFVuaXRzID0ge1xuICAvLyBBbmltYXRpb24gcHJvcGVydGllc1xuICAnYW5pbWF0aW9uLWRlbGF5JzogbXMsXG4gICdhbmltYXRpb24tZHVyYXRpb24nOiBtcyxcbiAgLy8gQmFja2dyb3VuZCBwcm9wZXJ0aWVzXG4gICdiYWNrZ3JvdW5kLXBvc2l0aW9uJzogcHgsXG4gICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnOiBweCxcbiAgJ2JhY2tncm91bmQtcG9zaXRpb24teSc6IHB4LFxuICAnYmFja2dyb3VuZC1zaXplJzogcHgsXG4gIC8vIEJvcmRlciBQcm9wZXJ0aWVzXG4gIGJvcmRlcjogcHgsXG4gICdib3JkZXItYm90dG9tJzogcHgsXG4gICdib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzJzogcHgsXG4gICdib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLWJvdHRvbS13aWR0aCc6IHB4LFxuICAnYm9yZGVyLWxlZnQnOiBweCxcbiAgJ2JvcmRlci1sZWZ0LXdpZHRoJzogcHgsXG4gICdib3JkZXItcmFkaXVzJzogcHgsXG4gICdib3JkZXItcmlnaHQnOiBweCxcbiAgJ2JvcmRlci1yaWdodC13aWR0aCc6IHB4LFxuICAnYm9yZGVyLXRvcCc6IHB4LFxuICAnYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLXRvcC1yaWdodC1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci10b3Atd2lkdGgnOiBweCxcbiAgJ2JvcmRlci13aWR0aCc6IHB4LFxuICAnYm9yZGVyLWJsb2NrJzogcHgsXG4gICdib3JkZXItYmxvY2stZW5kJzogcHgsXG4gICdib3JkZXItYmxvY2stZW5kLXdpZHRoJzogcHgsXG4gICdib3JkZXItYmxvY2stc3RhcnQnOiBweCxcbiAgJ2JvcmRlci1ibG9jay1zdGFydC13aWR0aCc6IHB4LFxuICAnYm9yZGVyLWJsb2NrLXdpZHRoJzogcHgsXG4gICdib3JkZXItaW5saW5lJzogcHgsXG4gICdib3JkZXItaW5saW5lLWVuZCc6IHB4LFxuICAnYm9yZGVyLWlubGluZS1lbmQtd2lkdGgnOiBweCxcbiAgJ2JvcmRlci1pbmxpbmUtc3RhcnQnOiBweCxcbiAgJ2JvcmRlci1pbmxpbmUtc3RhcnQtd2lkdGgnOiBweCxcbiAgJ2JvcmRlci1pbmxpbmUtd2lkdGgnOiBweCxcbiAgJ2JvcmRlci1zdGFydC1zdGFydC1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci1zdGFydC1lbmQtcmFkaXVzJzogcHgsXG4gICdib3JkZXItZW5kLXN0YXJ0LXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLWVuZC1lbmQtcmFkaXVzJzogcHgsXG4gIC8vIE1hcmdpbiBwcm9wZXJ0aWVzXG4gIG1hcmdpbjogcHgsXG4gICdtYXJnaW4tYm90dG9tJzogcHgsXG4gICdtYXJnaW4tbGVmdCc6IHB4LFxuICAnbWFyZ2luLXJpZ2h0JzogcHgsXG4gICdtYXJnaW4tdG9wJzogcHgsXG4gICdtYXJnaW4tYmxvY2snOiBweCxcbiAgJ21hcmdpbi1ibG9jay1lbmQnOiBweCxcbiAgJ21hcmdpbi1ibG9jay1zdGFydCc6IHB4LFxuICAnbWFyZ2luLWlubGluZSc6IHB4LFxuICAnbWFyZ2luLWlubGluZS1lbmQnOiBweCxcbiAgJ21hcmdpbi1pbmxpbmUtc3RhcnQnOiBweCxcbiAgLy8gUGFkZGluZyBwcm9wZXJ0aWVzXG4gIHBhZGRpbmc6IHB4LFxuICAncGFkZGluZy1ib3R0b20nOiBweCxcbiAgJ3BhZGRpbmctbGVmdCc6IHB4LFxuICAncGFkZGluZy1yaWdodCc6IHB4LFxuICAncGFkZGluZy10b3AnOiBweCxcbiAgJ3BhZGRpbmctYmxvY2snOiBweCxcbiAgJ3BhZGRpbmctYmxvY2stZW5kJzogcHgsXG4gICdwYWRkaW5nLWJsb2NrLXN0YXJ0JzogcHgsXG4gICdwYWRkaW5nLWlubGluZSc6IHB4LFxuICAncGFkZGluZy1pbmxpbmUtZW5kJzogcHgsXG4gICdwYWRkaW5nLWlubGluZS1zdGFydCc6IHB4LFxuICAvLyBNYXNrIHByb3BlcnRpZXNcbiAgJ21hc2stcG9zaXRpb24teCc6IHB4LFxuICAnbWFzay1wb3NpdGlvbi15JzogcHgsXG4gICdtYXNrLXNpemUnOiBweCxcbiAgLy8gV2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzXG4gIGhlaWdodDogcHgsXG4gIHdpZHRoOiBweCxcbiAgJ21pbi1oZWlnaHQnOiBweCxcbiAgJ21heC1oZWlnaHQnOiBweCxcbiAgJ21pbi13aWR0aCc6IHB4LFxuICAnbWF4LXdpZHRoJzogcHgsXG4gIC8vIFBvc2l0aW9uIHByb3BlcnRpZXNcbiAgYm90dG9tOiBweCxcbiAgbGVmdDogcHgsXG4gIHRvcDogcHgsXG4gIHJpZ2h0OiBweCxcbiAgaW5zZXQ6IHB4LFxuICAnaW5zZXQtYmxvY2snOiBweCxcbiAgJ2luc2V0LWJsb2NrLWVuZCc6IHB4LFxuICAnaW5zZXQtYmxvY2stc3RhcnQnOiBweCxcbiAgJ2luc2V0LWlubGluZSc6IHB4LFxuICAnaW5zZXQtaW5saW5lLWVuZCc6IHB4LFxuICAnaW5zZXQtaW5saW5lLXN0YXJ0JzogcHgsXG4gIC8vIFNoYWRvdyBwcm9wZXJ0aWVzXG4gICdib3gtc2hhZG93JzogcHgsXG4gICd0ZXh0LXNoYWRvdyc6IHB4LFxuICAvLyBDb2x1bW4gcHJvcGVydGllc1xuICAnY29sdW1uLWdhcCc6IHB4LFxuICAnY29sdW1uLXJ1bGUnOiBweCxcbiAgJ2NvbHVtbi1ydWxlLXdpZHRoJzogcHgsXG4gICdjb2x1bW4td2lkdGgnOiBweCxcbiAgLy8gRm9udCBhbmQgdGV4dCBwcm9wZXJ0aWVzXG4gICdmb250LXNpemUnOiBweCxcbiAgJ2ZvbnQtc2l6ZS1kZWx0YSc6IHB4LFxuICAnbGV0dGVyLXNwYWNpbmcnOiBweCxcbiAgJ3RleHQtZGVjb3JhdGlvbi10aGlja25lc3MnOiBweCxcbiAgJ3RleHQtaW5kZW50JzogcHgsXG4gICd0ZXh0LXN0cm9rZSc6IHB4LFxuICAndGV4dC1zdHJva2Utd2lkdGgnOiBweCxcbiAgJ3dvcmQtc3BhY2luZyc6IHB4LFxuICAvLyBNb3Rpb24gcHJvcGVydGllc1xuICBtb3Rpb246IHB4LFxuICAnbW90aW9uLW9mZnNldCc6IHB4LFxuICAvLyBPdXRsaW5lIHByb3BlcnRpZXNcbiAgb3V0bGluZTogcHgsXG4gICdvdXRsaW5lLW9mZnNldCc6IHB4LFxuICAnb3V0bGluZS13aWR0aCc6IHB4LFxuICAvLyBQZXJzcGVjdGl2ZSBwcm9wZXJ0aWVzXG4gIHBlcnNwZWN0aXZlOiBweCxcbiAgJ3BlcnNwZWN0aXZlLW9yaWdpbi14JzogcGVyY2VudCxcbiAgJ3BlcnNwZWN0aXZlLW9yaWdpbi15JzogcGVyY2VudCxcbiAgLy8gVHJhbnNmb3JtIHByb3BlcnRpZXNcbiAgJ3RyYW5zZm9ybS1vcmlnaW4nOiBwZXJjZW50LFxuICAndHJhbnNmb3JtLW9yaWdpbi14JzogcGVyY2VudCxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4teSc6IHBlcmNlbnQsXG4gICd0cmFuc2Zvcm0tb3JpZ2luLXonOiBwZXJjZW50LFxuICAvLyBUcmFuc2l0aW9uIHByb3BlcnRpZXNcbiAgJ3RyYW5zaXRpb24tZGVsYXknOiBtcyxcbiAgJ3RyYW5zaXRpb24tZHVyYXRpb24nOiBtcyxcbiAgLy8gQWxpZ25tZW50IHByb3BlcnRpZXNcbiAgJ3ZlcnRpY2FsLWFsaWduJzogcHgsXG4gICdmbGV4LWJhc2lzJzogcHgsXG4gIC8vIFNvbWUgcmFuZG9tIHByb3BlcnRpZXNcbiAgJ3NoYXBlLW1hcmdpbic6IHB4LFxuICBzaXplOiBweCxcbiAgZ2FwOiBweCxcbiAgLy8gR3JpZCBwcm9wZXJ0aWVzXG4gIGdyaWQ6IHB4LFxuICAnZ3JpZC1nYXAnOiBweCxcbiAgJ3Jvdy1nYXAnOiBweCxcbiAgJ2dyaWQtcm93LWdhcCc6IHB4LFxuICAnZ3JpZC1jb2x1bW4tZ2FwJzogcHgsXG4gICdncmlkLXRlbXBsYXRlLXJvd3MnOiBweCxcbiAgJ2dyaWQtdGVtcGxhdGUtY29sdW1ucyc6IHB4LFxuICAnZ3JpZC1hdXRvLXJvd3MnOiBweCxcbiAgJ2dyaWQtYXV0by1jb2x1bW5zJzogcHgsXG4gIC8vIE5vdCBleGlzdGluZyBwcm9wZXJ0aWVzLlxuICAvLyBVc2VkIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGpzcy1wbHVnaW4tZXhwYW5kIGludGVncmF0aW9uLlxuICAnYm94LXNoYWRvdy14JzogcHgsXG4gICdib3gtc2hhZG93LXknOiBweCxcbiAgJ2JveC1zaGFkb3ctYmx1cic6IHB4LFxuICAnYm94LXNoYWRvdy1zcHJlYWQnOiBweCxcbiAgJ2ZvbnQtbGluZS1oZWlnaHQnOiBweCxcbiAgJ3RleHQtc2hhZG93LXgnOiBweCxcbiAgJ3RleHQtc2hhZG93LXknOiBweCxcbiAgJ3RleHQtc2hhZG93LWJsdXInOiBweFxufTtcblxuLyoqXG4gKiBDbG9uZXMgdGhlIG9iamVjdCBhbmQgYWRkcyBhIGNhbWVsIGNhc2VkIHByb3BlcnR5IHZlcnNpb24uXG4gKi9cblxuZnVuY3Rpb24gYWRkQ2FtZWxDYXNlZFZlcnNpb24ob2JqKSB7XG4gIHZhciByZWdFeHAgPSAvKC1bYS16XSkvZztcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0clsxXS50b1VwcGVyQ2FzZSgpO1xuICB9O1xuXG4gIHZhciBuZXdPYmogPSB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICBuZXdPYmpba2V5LnJlcGxhY2UocmVnRXhwLCByZXBsYWNlKV0gPSBvYmpba2V5XTtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG5cbnZhciB1bml0cyA9IGFkZENhbWVsQ2FzZWRWZXJzaW9uKGRlZmF1bHRVbml0cyk7XG4vKipcbiAqIFJlY3Vyc2l2ZSBkZWVwIHN0eWxlIHBhc3NpbmcgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBpdGVyYXRlKHByb3AsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdmFsdWU7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVbaV0gPSBpdGVyYXRlKHByb3AsIHZhbHVlW2ldLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChwcm9wID09PSAnZmFsbGJhY2tzJykge1xuICAgICAgZm9yICh2YXIgaW5uZXJQcm9wIGluIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlW2lubmVyUHJvcF0gPSBpdGVyYXRlKGlubmVyUHJvcCwgdmFsdWVbaW5uZXJQcm9wXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIF9pbm5lclByb3AgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFsdWVbX2lubmVyUHJvcF0gPSBpdGVyYXRlKHByb3AgKyBcIi1cIiArIF9pbm5lclByb3AsIHZhbHVlW19pbm5lclByb3BdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcblxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpID09PSBmYWxzZSkge1xuICAgIHZhciB1bml0ID0gb3B0aW9uc1twcm9wXSB8fCB1bml0c1twcm9wXTsgLy8gQWRkIHRoZSB1bml0IGlmIGF2YWlsYWJsZSwgZXhjZXB0IGZvciB0aGUgc3BlY2lhbCBjYXNlIG9mIDBweC5cblxuICAgIGlmICh1bml0ICYmICEodmFsdWUgPT09IDAgJiYgdW5pdCA9PT0gcHgpKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHVuaXQgPT09ICdmdW5jdGlvbicgPyB1bml0KHZhbHVlKS50b1N0cmluZygpIDogXCJcIiArIHZhbHVlICsgdW5pdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogQWRkIHVuaXQgdG8gbnVtZXJpYyB2YWx1ZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBkZWZhdWx0VW5pdChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgY2FtZWxDYXNlZE9wdGlvbnMgPSBhZGRDYW1lbENhc2VkVmVyc2lvbihvcHRpb25zKTtcblxuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybiBzdHlsZTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHN0eWxlW3Byb3BdID0gaXRlcmF0ZShwcm9wLCBzdHlsZVtwcm9wXSwgY2FtZWxDYXNlZE9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3ApIHtcbiAgICByZXR1cm4gaXRlcmF0ZShwcm9wLCB2YWx1ZSwgY2FtZWxDYXNlZE9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUsXG4gICAgb25DaGFuZ2VWYWx1ZTogb25DaGFuZ2VWYWx1ZVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0VW5pdDtcbiIsImltcG9ydCBpc0luQnJvd3NlciBmcm9tICdpcy1pbi1icm93c2VyJztcbmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXknO1xuXG4vLyBFeHBvcnQgamF2YXNjcmlwdCBzdHlsZSBhbmQgY3NzIHN0eWxlIHZlbmRvciBwcmVmaXhlcy5cbnZhciBqcyA9ICcnO1xudmFyIGNzcyA9ICcnO1xudmFyIHZlbmRvciA9ICcnO1xudmFyIGJyb3dzZXIgPSAnJztcbnZhciBpc1RvdWNoID0gaXNJbkJyb3dzZXIgJiYgJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyAvLyBXZSBzaG91bGQgbm90IGRvIGFueXRoaW5nIGlmIHJlcXVpcmVkIHNlcnZlcnNpZGUuXG5cbmlmIChpc0luQnJvd3Nlcikge1xuICAvLyBPcmRlciBtYXR0ZXJzLiBXZSBuZWVkIHRvIGNoZWNrIFdlYmtpdCB0aGUgbGFzdCBvbmUgYmVjYXVzZVxuICAvLyBvdGhlciB2ZW5kb3JzIHVzZSB0byBhZGQgV2Via2l0IHByZWZpeGVzIHRvIHNvbWUgcHJvcGVydGllc1xuICB2YXIganNDc3NNYXAgPSB7XG4gICAgTW96OiAnLW1vei0nLFxuICAgIG1zOiAnLW1zLScsXG4gICAgTzogJy1vLScsXG4gICAgV2Via2l0OiAnLXdlYmtpdC0nXG4gIH07XG5cbiAgdmFyIF9kb2N1bWVudCRjcmVhdGVFbGVtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKSxcbiAgICAgIHN0eWxlID0gX2RvY3VtZW50JGNyZWF0ZUVsZW1lLnN0eWxlO1xuXG4gIHZhciB0ZXN0UHJvcCA9ICdUcmFuc2Zvcm0nO1xuXG4gIGZvciAodmFyIGtleSBpbiBqc0Nzc01hcCkge1xuICAgIGlmIChrZXkgKyB0ZXN0UHJvcCBpbiBzdHlsZSkge1xuICAgICAganMgPSBrZXk7XG4gICAgICBjc3MgPSBqc0Nzc01hcFtrZXldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9IC8vIENvcnJlY3RseSBkZXRlY3QgdGhlIEVkZ2UgYnJvd3Nlci5cblxuXG4gIGlmIChqcyA9PT0gJ1dlYmtpdCcgJiYgJ21zSHlwaGVucycgaW4gc3R5bGUpIHtcbiAgICBqcyA9ICdtcyc7XG4gICAgY3NzID0ganNDc3NNYXAubXM7XG4gICAgYnJvd3NlciA9ICdlZGdlJztcbiAgfSAvLyBDb3JyZWN0bHkgZGV0ZWN0IHRoZSBTYWZhcmkgYnJvd3Nlci5cblxuXG4gIGlmIChqcyA9PT0gJ1dlYmtpdCcgJiYgJy1hcHBsZS10cmFpbGluZy13b3JkJyBpbiBzdHlsZSkge1xuICAgIHZlbmRvciA9ICdhcHBsZSc7XG4gIH1cbn1cbi8qKlxuICogVmVuZG9yIHByZWZpeCBzdHJpbmcgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKlxuICogQHR5cGUge3tqczogU3RyaW5nLCBjc3M6IFN0cmluZywgdmVuZG9yOiBTdHJpbmcsIGJyb3dzZXI6IFN0cmluZ319XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxudmFyIHByZWZpeCA9IHtcbiAganM6IGpzLFxuICBjc3M6IGNzcyxcbiAgdmVuZG9yOiB2ZW5kb3IsXG4gIGJyb3dzZXI6IGJyb3dzZXIsXG4gIGlzVG91Y2g6IGlzVG91Y2hcbn07XG5cbi8qKlxuICogVGVzdCBpZiBhIGtleWZyYW1lIGF0LXJ1bGUgc2hvdWxkIGJlIHByZWZpeGVkIG9yIG5vdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2ZW5kb3IgcHJlZml4IHN0cmluZyBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydGVkS2V5ZnJhbWVzKGtleSkge1xuICAvLyBLZXlmcmFtZXMgaXMgYWxyZWFkeSBwcmVmaXhlZC4gZS5nLiBrZXkgPSAnQC13ZWJraXQta2V5ZnJhbWVzIGEnXG4gIGlmIChrZXlbMV0gPT09ICctJykgcmV0dXJuIGtleTsgLy8gTm8gbmVlZCB0byBwcmVmaXggSUUvRWRnZS4gT2xkZXIgYnJvd3NlcnMgd2lsbCBpZ25vcmUgdW5zdXBwb3J0ZWQgcnVsZXMuXG4gIC8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1rZXlmcmFtZXNcblxuICBpZiAocHJlZml4LmpzID09PSAnbXMnKSByZXR1cm4ga2V5O1xuICByZXR1cm4gXCJAXCIgKyBwcmVmaXguY3NzICsgXCJrZXlmcmFtZXNcIiArIGtleS5zdWJzdHIoMTApO1xufVxuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9YXBwZWFyYW5jZVxuXG52YXIgYXBwZWFyZW5jZSA9IHtcbiAgbm9QcmVmaWxsOiBbJ2FwcGVhcmFuY2UnXSxcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3ApIHtcbiAgICBpZiAocHJvcCAhPT0gJ2FwcGVhcmFuY2UnKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ21zJykgcmV0dXJuIFwiLXdlYmtpdC1cIiArIHByb3A7XG4gICAgcmV0dXJuIHByZWZpeC5jc3MgKyBwcm9wO1xuICB9XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9Y29sb3ItYWRqdXN0XG5cbnZhciBjb2xvckFkanVzdCA9IHtcbiAgbm9QcmVmaWxsOiBbJ2NvbG9yLWFkanVzdCddLFxuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCkge1xuICAgIGlmIChwcm9wICE9PSAnY29sb3ItYWRqdXN0JykgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwcmVmaXguanMgPT09ICdXZWJraXQnKSByZXR1cm4gcHJlZml4LmNzcyArIFwicHJpbnQtXCIgKyBwcm9wO1xuICAgIHJldHVybiBwcm9wO1xuICB9XG59O1xuXG52YXIgcmVnRXhwID0gL1stXFxzXSsoLik/L2c7XG4vKipcbiAqIFJlcGxhY2VzIHRoZSBsZXR0ZXIgd2l0aCB0aGUgY2FwaXRhbCBsZXR0ZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWF0Y2hcbiAqIEBwYXJhbSB7U3RyaW5nfSBjXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB0b1VwcGVyKG1hdGNoLCBjKSB7XG4gIHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7XG59XG4vKipcbiAqIENvbnZlcnQgZGFzaCBzZXBhcmF0ZWQgc3RyaW5ncyB0byBjYW1lbC1jYXNlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UocmVnRXhwLCB0b1VwcGVyKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGRhc2ggc2VwYXJhdGVkIHN0cmluZ3MgdG8gcGFzY2FsIGNhc2VkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhc2NhbGl6ZShzdHIpIHtcbiAgcmV0dXJuIGNhbWVsaXplKFwiLVwiICsgc3RyKTtcbn1cblxuLy8gYnV0IHdlIGNhbiB1c2UgYSBsb25naGFuZCBwcm9wZXJ0eSBpbnN0ZWFkLlxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPW1hc2tcblxudmFyIG1hc2sgPSB7XG4gIG5vUHJlZmlsbDogWydtYXNrJ10sXG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBzdHlsZSkge1xuICAgIGlmICghL15tYXNrLy50ZXN0KHByb3ApKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAocHJlZml4LmpzID09PSAnV2Via2l0Jykge1xuICAgICAgdmFyIGxvbmdoYW5kID0gJ21hc2staW1hZ2UnO1xuXG4gICAgICBpZiAoY2FtZWxpemUobG9uZ2hhbmQpIGluIHN0eWxlKSB7XG4gICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJlZml4LmpzICsgcGFzY2FsaXplKGxvbmdoYW5kKSBpbiBzdHlsZSkge1xuICAgICAgICByZXR1cm4gcHJlZml4LmNzcyArIHByb3A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD10ZXh0LW9yaWVudGF0aW9uXG5cbnZhciB0ZXh0T3JpZW50YXRpb24gPSB7XG4gIG5vUHJlZmlsbDogWyd0ZXh0LW9yaWVudGF0aW9uJ10sXG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKSB7XG4gICAgaWYgKHByb3AgIT09ICd0ZXh0LW9yaWVudGF0aW9uJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHByZWZpeC52ZW5kb3IgPT09ICdhcHBsZScgJiYgIXByZWZpeC5pc1RvdWNoKSB7XG4gICAgICByZXR1cm4gcHJlZml4LmNzcyArIHByb3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI3NlYXJjaD10cmFuc2Zvcm1cblxudmFyIHRyYW5zZm9ybSA9IHtcbiAgbm9QcmVmaWxsOiBbJ3RyYW5zZm9ybSddLFxuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAocHJvcCAhPT0gJ3RyYW5zZm9ybScpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLnRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZpeC5jc3MgKyBwcm9wO1xuICB9XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9dHJhbnNpdGlvblxuXG52YXIgdHJhbnNpdGlvbiA9IHtcbiAgbm9QcmVmaWxsOiBbJ3RyYW5zaXRpb24nXSxcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKHByb3AgIT09ICd0cmFuc2l0aW9uJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZpeC5jc3MgKyBwcm9wO1xuICB9XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9d3JpdGluZy1tb2RlXG5cbnZhciB3cml0aW5nTW9kZSA9IHtcbiAgbm9QcmVmaWxsOiBbJ3dyaXRpbmctbW9kZSddLFxuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCkge1xuICAgIGlmIChwcm9wICE9PSAnd3JpdGluZy1tb2RlJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ1dlYmtpdCcgfHwgcHJlZml4LmpzID09PSAnbXMnICYmIHByZWZpeC5icm93c2VyICE9PSAnZWRnZScpIHtcbiAgICAgIHJldHVybiBwcmVmaXguY3NzICsgcHJvcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXVzZXItc2VsZWN0XG5cbnZhciB1c2VyU2VsZWN0ID0ge1xuICBub1ByZWZpbGw6IFsndXNlci1zZWxlY3QnXSxcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3ApIHtcbiAgICBpZiAocHJvcCAhPT0gJ3VzZXItc2VsZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ01veicgfHwgcHJlZml4LmpzID09PSAnbXMnIHx8IHByZWZpeC52ZW5kb3IgPT09ICdhcHBsZScpIHtcbiAgICAgIHJldHVybiBwcmVmaXguY3NzICsgcHJvcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPW11bHRpY29sdW1uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcG9zdGNzcy9hdXRvcHJlZml4ZXIvaXNzdWVzLzQ5MVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bvc3Rjc3MvYXV0b3ByZWZpeGVyL2lzc3Vlcy8xNzdcblxudmFyIGJyZWFrUHJvcHNPbGQgPSB7XG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBzdHlsZSkge1xuICAgIGlmICghL15icmVhay0vLnRlc3QocHJvcCkpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwcmVmaXguanMgPT09ICdXZWJraXQnKSB7XG4gICAgICB2YXIganNQcm9wID0gXCJXZWJraXRDb2x1bW5cIiArIHBhc2NhbGl6ZShwcm9wKTtcbiAgICAgIHJldHVybiBqc1Byb3AgaW4gc3R5bGUgPyBwcmVmaXguY3NzICsgXCJjb2x1bW4tXCIgKyBwcm9wIDogZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ01veicpIHtcbiAgICAgIHZhciBfanNQcm9wID0gXCJwYWdlXCIgKyBwYXNjYWxpemUocHJvcCk7XG5cbiAgICAgIHJldHVybiBfanNQcm9wIGluIHN0eWxlID8gXCJwYWdlLVwiICsgcHJvcCA6IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3N0Y3NzL2F1dG9wcmVmaXhlci9pc3N1ZXMvMzI0LlxuXG52YXIgaW5saW5lTG9naWNhbE9sZCA9IHtcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIHN0eWxlKSB7XG4gICAgaWYgKCEvXihib3JkZXJ8bWFyZ2lufHBhZGRpbmcpLWlubGluZS8udGVzdChwcm9wKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwcmVmaXguanMgPT09ICdNb3onKSByZXR1cm4gcHJvcDtcbiAgICB2YXIgbmV3UHJvcCA9IHByb3AucmVwbGFjZSgnLWlubGluZScsICcnKTtcbiAgICByZXR1cm4gcHJlZml4LmpzICsgcGFzY2FsaXplKG5ld1Byb3ApIGluIHN0eWxlID8gcHJlZml4LmNzcyArIG5ld1Byb3AgOiBmYWxzZTtcbiAgfVxufTtcblxuLy8gQ2FtZWxpemF0aW9uIGlzIHJlcXVpcmVkIGJlY2F1c2Ugd2UgY2FuJ3QgdGVzdCB1c2luZy5cbi8vIENTUyBzeW50YXggZm9yIGUuZy4gaW4gRkYuXG5cbnZhciB1bnByZWZpeGVkID0ge1xuICBzdXBwb3J0ZWRQcm9wZXJ0eTogZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCwgc3R5bGUpIHtcbiAgICByZXR1cm4gY2FtZWxpemUocHJvcCkgaW4gc3R5bGUgPyBwcm9wIDogZmFsc2U7XG4gIH1cbn07XG5cbnZhciBwcmVmaXhlZCA9IHtcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIHN0eWxlKSB7XG4gICAgdmFyIHBhc2NhbGl6ZWQgPSBwYXNjYWxpemUocHJvcCk7IC8vIFJldHVybiBjdXN0b20gQ1NTIHZhcmlhYmxlIHdpdGhvdXQgcHJlZml4aW5nLlxuXG4gICAgaWYgKHByb3BbMF0gPT09ICctJykgcmV0dXJuIHByb3A7IC8vIFJldHVybiBhbHJlYWR5IHByZWZpeGVkIHZhbHVlIHdpdGhvdXQgcHJlZml4aW5nLlxuXG4gICAgaWYgKHByb3BbMF0gPT09ICctJyAmJiBwcm9wWzFdID09PSAnLScpIHJldHVybiBwcm9wO1xuICAgIGlmIChwcmVmaXguanMgKyBwYXNjYWxpemVkIGluIHN0eWxlKSByZXR1cm4gcHJlZml4LmNzcyArIHByb3A7IC8vIFRyeSB3ZWJraXQgZmFsbGJhY2suXG5cbiAgICBpZiAocHJlZml4LmpzICE9PSAnV2Via2l0JyAmJiBcIldlYmtpdFwiICsgcGFzY2FsaXplZCBpbiBzdHlsZSkgcmV0dXJuIFwiLXdlYmtpdC1cIiArIHByb3A7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9c2Nyb2xsLXNuYXBcblxudmFyIHNjcm9sbFNuYXAgPSB7XG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKSB7XG4gICAgaWYgKHByb3Auc3Vic3RyaW5nKDAsIDExKSAhPT0gJ3Njcm9sbC1zbmFwJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHByZWZpeC5qcyA9PT0gJ21zJykge1xuICAgICAgcmV0dXJuIFwiXCIgKyBwcmVmaXguY3NzICsgcHJvcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPW92ZXJzY3JvbGwtYmVoYXZpb3JcblxudmFyIG92ZXJzY3JvbGxCZWhhdmlvciA9IHtcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3ApIHtcbiAgICBpZiAocHJvcCAhPT0gJ292ZXJzY3JvbGwtYmVoYXZpb3InKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAocHJlZml4LmpzID09PSAnbXMnKSB7XG4gICAgICByZXR1cm4gcHJlZml4LmNzcyArIFwic2Nyb2xsLWNoYWluaW5nXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn07XG5cbnZhciBwcm9wTWFwID0ge1xuICAnZmxleC1ncm93JzogJ2ZsZXgtcG9zaXRpdmUnLFxuICAnZmxleC1zaHJpbmsnOiAnZmxleC1uZWdhdGl2ZScsXG4gICdmbGV4LWJhc2lzJzogJ2ZsZXgtcHJlZmVycmVkLXNpemUnLFxuICAnanVzdGlmeS1jb250ZW50JzogJ2ZsZXgtcGFjaycsXG4gIG9yZGVyOiAnZmxleC1vcmRlcicsXG4gICdhbGlnbi1pdGVtcyc6ICdmbGV4LWFsaWduJyxcbiAgJ2FsaWduLWNvbnRlbnQnOiAnZmxleC1saW5lLXBhY2snIC8vICdhbGlnbi1zZWxmJyBpcyBoYW5kbGVkIGJ5ICdhbGlnbi1zZWxmJyBwbHVnaW4uXG5cbn07IC8vIFN1cHBvcnQgb2xkIGZsZXggc3BlYyBmcm9tIDIwMTIuXG5cbnZhciBmbGV4MjAxMiA9IHtcbiAgc3VwcG9ydGVkUHJvcGVydHk6IGZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3AsIHN0eWxlKSB7XG4gICAgdmFyIG5ld1Byb3AgPSBwcm9wTWFwW3Byb3BdO1xuICAgIGlmICghbmV3UHJvcCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBwcmVmaXguanMgKyBwYXNjYWxpemUobmV3UHJvcCkgaW4gc3R5bGUgPyBwcmVmaXguY3NzICsgbmV3UHJvcCA6IGZhbHNlO1xuICB9XG59O1xuXG52YXIgcHJvcE1hcCQxID0ge1xuICBmbGV4OiAnYm94LWZsZXgnLFxuICAnZmxleC1ncm93JzogJ2JveC1mbGV4JyxcbiAgJ2ZsZXgtZGlyZWN0aW9uJzogWydib3gtb3JpZW50JywgJ2JveC1kaXJlY3Rpb24nXSxcbiAgb3JkZXI6ICdib3gtb3JkaW5hbC1ncm91cCcsXG4gICdhbGlnbi1pdGVtcyc6ICdib3gtYWxpZ24nLFxuICAnZmxleC1mbG93JzogWydib3gtb3JpZW50JywgJ2JveC1kaXJlY3Rpb24nXSxcbiAgJ2p1c3RpZnktY29udGVudCc6ICdib3gtcGFjaydcbn07XG52YXIgcHJvcEtleXMgPSBPYmplY3Qua2V5cyhwcm9wTWFwJDEpO1xuXG52YXIgcHJlZml4Q3NzID0gZnVuY3Rpb24gcHJlZml4Q3NzKHApIHtcbiAgcmV0dXJuIHByZWZpeC5jc3MgKyBwO1xufTsgLy8gU3VwcG9ydCBvbGQgZmxleCBzcGVjIGZyb20gMjAwOS5cblxuXG52YXIgZmxleDIwMDkgPSB7XG4gIHN1cHBvcnRlZFByb3BlcnR5OiBmdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wLCBzdHlsZSwgX3JlZikge1xuICAgIHZhciBtdWx0aXBsZSA9IF9yZWYubXVsdGlwbGU7XG5cbiAgICBpZiAocHJvcEtleXMuaW5kZXhPZihwcm9wKSA+IC0xKSB7XG4gICAgICB2YXIgbmV3UHJvcCA9IHByb3BNYXAkMVtwcm9wXTtcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG5ld1Byb3ApKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXguanMgKyBwYXNjYWxpemUobmV3UHJvcCkgaW4gc3R5bGUgPyBwcmVmaXguY3NzICsgbmV3UHJvcCA6IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW11bHRpcGxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3UHJvcC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIShwcmVmaXguanMgKyBwYXNjYWxpemUobmV3UHJvcFswXSkgaW4gc3R5bGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdQcm9wLm1hcChwcmVmaXhDc3MpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gcGx1Z2lucyA9IFtcbi8vICAgLi4ucGx1Z2lucyxcbi8vICAgIGJyZWFrUHJvcHNPbGQsXG4vLyAgICBpbmxpbmVMb2dpY2FsT2xkLFxuLy8gICAgdW5wcmVmaXhlZCxcbi8vICAgIHByZWZpeGVkLFxuLy8gICAgc2Nyb2xsU25hcCxcbi8vICAgIGZsZXgyMDEyLFxuLy8gICAgZmxleDIwMDlcbi8vIF1cbi8vIFBsdWdpbnMgd2l0aG91dCAnbm9QcmVmaWxsJyB2YWx1ZSwgZ29pbmcgbGFzdC5cbi8vICdmbGV4LSonIHBsdWdpbnMgc2hvdWxkIGJlIGF0IHRoZSBib3R0b20uXG4vLyAnZmxleDIwMDknIGdvaW5nIGFmdGVyICdmbGV4MjAxMicuXG4vLyAncHJlZml4ZWQnIGdvaW5nIGFmdGVyICd1bnByZWZpeGVkJ1xuXG52YXIgcGx1Z2lucyA9IFthcHBlYXJlbmNlLCBjb2xvckFkanVzdCwgbWFzaywgdGV4dE9yaWVudGF0aW9uLCB0cmFuc2Zvcm0sIHRyYW5zaXRpb24sIHdyaXRpbmdNb2RlLCB1c2VyU2VsZWN0LCBicmVha1Byb3BzT2xkLCBpbmxpbmVMb2dpY2FsT2xkLCB1bnByZWZpeGVkLCBwcmVmaXhlZCwgc2Nyb2xsU25hcCwgb3ZlcnNjcm9sbEJlaGF2aW9yLCBmbGV4MjAxMiwgZmxleDIwMDldO1xudmFyIHByb3BlcnR5RGV0ZWN0b3JzID0gcGx1Z2lucy5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIHAuc3VwcG9ydGVkUHJvcGVydHk7XG59KS5tYXAoZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIHAuc3VwcG9ydGVkUHJvcGVydHk7XG59KTtcbnZhciBub1ByZWZpbGwgPSBwbHVnaW5zLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICByZXR1cm4gcC5ub1ByZWZpbGw7XG59KS5yZWR1Y2UoZnVuY3Rpb24gKGEsIHApIHtcbiAgYS5wdXNoLmFwcGx5KGEsIF90b0NvbnN1bWFibGVBcnJheShwLm5vUHJlZmlsbCkpO1xuICByZXR1cm4gYTtcbn0sIFtdKTtcblxudmFyIGVsO1xudmFyIGNhY2hlID0ge307XG5cbmlmIChpc0luQnJvd3Nlcikge1xuICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTsgLy8gV2UgdGVzdCBldmVyeSBwcm9wZXJ0eSBvbiB2ZW5kb3IgcHJlZml4IHJlcXVpcmVtZW50LlxuICAvLyBPbmNlIHRlc3RlZCwgcmVzdWx0IGlzIGNhY2hlZC4gSXQgZ2l2ZXMgdXMgdXAgdG8gNzAlIHBlcmYgYm9vc3QuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2VsZW1lbnQtc3R5bGUtb2JqZWN0LWFjY2Vzcy12cy1wbGFpbi1vYmplY3RcbiAgLy9cbiAgLy8gUHJlZmlsbCBjYWNoZSB3aXRoIGtub3duIGNzcyBwcm9wZXJ0aWVzIHRvIHJlZHVjZSBhbW91bnQgb2ZcbiAgLy8gcHJvcGVydGllcyB3ZSBuZWVkIHRvIGZlYXR1cmUgdGVzdCBhdCBydW50aW1lLlxuICAvLyBodHRwOi8vZGF2aWR3YWxzaC5uYW1lL3ZlbmRvci1wcmVmaXhcblxuICB2YXIgY29tcHV0ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICcnKTtcblxuICBmb3IgKHZhciBrZXkkMSBpbiBjb21wdXRlZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICBpZiAoIWlzTmFOKGtleSQxKSkgY2FjaGVbY29tcHV0ZWRba2V5JDFdXSA9IGNvbXB1dGVkW2tleSQxXTtcbiAgfSAvLyBQcm9wZXJ0aWVzIHRoYXQgY2Fubm90IGJlIGNvcnJlY3RseSBkZXRlY3RlZCB1c2luZyB0aGVcbiAgLy8gY2FjaGUgcHJlZmlsbCBtZXRob2QuXG5cblxuICBub1ByZWZpbGwuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBkZWxldGUgY2FjaGVbeF07XG4gIH0pO1xufVxuLyoqXG4gKiBUZXN0IGlmIGEgcHJvcGVydHkgaXMgc3VwcG9ydGVkLCByZXR1cm5zIHN1cHBvcnRlZCBwcm9wZXJ0eSB3aXRoIHZlbmRvclxuICogcHJlZml4IGlmIHJlcXVpcmVkLiBSZXR1cm5zIGBmYWxzZWAgaWYgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBkYXNoIHNlcGFyYXRlZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7U3RyaW5nfEJvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgLy8gRm9yIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgaWYgKCFlbCkgcmV0dXJuIHByb3A7IC8vIFJlbW92ZSBjYWNoZSBmb3IgYmVuY2htYXJrIHRlc3RzIG9yIHJldHVybiBwcm9wZXJ0eSBmcm9tIHRoZSBjYWNoZS5cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdiZW5jaG1hcmsnICYmIGNhY2hlW3Byb3BdICE9IG51bGwpIHtcbiAgICByZXR1cm4gY2FjaGVbcHJvcF07XG4gIH0gLy8gQ2hlY2sgaWYgJ3RyYW5zaXRpb24nIG9yICd0cmFuc2Zvcm0nIG5hdGl2ZWx5IHN1cHBvcnRlZCBpbiBicm93c2VyLlxuXG5cbiAgaWYgKHByb3AgPT09ICd0cmFuc2l0aW9uJyB8fCBwcm9wID09PSAndHJhbnNmb3JtJykge1xuICAgIG9wdGlvbnNbcHJvcF0gPSBwcm9wIGluIGVsLnN0eWxlO1xuICB9IC8vIEZpbmQgYSBwbHVnaW4gZm9yIGN1cnJlbnQgcHJlZml4IHByb3BlcnR5LlxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0eURldGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIGNhY2hlW3Byb3BdID0gcHJvcGVydHlEZXRlY3RvcnNbaV0ocHJvcCwgZWwuc3R5bGUsIG9wdGlvbnMpOyAvLyBCcmVhayBsb29wLCBpZiB2YWx1ZSBmb3VuZC5cblxuICAgIGlmIChjYWNoZVtwcm9wXSkgYnJlYWs7XG4gIH0gLy8gUmVzZXQgc3R5bGVzIGZvciBjdXJyZW50IHByb3BlcnR5LlxuICAvLyBGaXJlZm94IGNhbiBldmVuIHRocm93IGFuIGVycm9yIGZvciBpbnZhbGlkIHByb3BlcnRpZXMsIGUuZy4sIFwiMFwiLlxuXG5cbiAgdHJ5IHtcbiAgICBlbC5zdHlsZVtwcm9wXSA9ICcnO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gY2FjaGVbcHJvcF07XG59XG5cbnZhciBjYWNoZSQxID0ge307XG52YXIgdHJhbnNpdGlvblByb3BlcnRpZXMgPSB7XG4gIHRyYW5zaXRpb246IDEsXG4gICd0cmFuc2l0aW9uLXByb3BlcnR5JzogMSxcbiAgJy13ZWJraXQtdHJhbnNpdGlvbic6IDEsXG4gICctd2Via2l0LXRyYW5zaXRpb24tcHJvcGVydHknOiAxXG59O1xudmFyIHRyYW5zUHJvcHNSZWdFeHAgPSAvKF5cXHMqW1xcdy1dKyl8LCAoXFxzKltcXHctXSspKD8hW14oKV0qXFwpKS9nO1xudmFyIGVsJDE7XG4vKipcbiAqIFJldHVybnMgcHJlZml4ZWQgdmFsdWUgdHJhbnNpdGlvbi90cmFuc2Zvcm0gaWYgbmVlZGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtYXRjaFxuICogQHBhcmFtIHtTdHJpbmd9IHAxXG4gKiBAcGFyYW0ge1N0cmluZ30gcDJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHByZWZpeFRyYW5zaXRpb25DYWxsYmFjayhtYXRjaCwgcDEsIHAyKSB7XG4gIGlmIChwMSA9PT0gJ3ZhcicpIHJldHVybiAndmFyJztcbiAgaWYgKHAxID09PSAnYWxsJykgcmV0dXJuICdhbGwnO1xuICBpZiAocDIgPT09ICdhbGwnKSByZXR1cm4gJywgYWxsJztcbiAgdmFyIHByZWZpeGVkVmFsdWUgPSBwMSA/IHN1cHBvcnRlZFByb3BlcnR5KHAxKSA6IFwiLCBcIiArIHN1cHBvcnRlZFByb3BlcnR5KHAyKTtcbiAgaWYgKCFwcmVmaXhlZFZhbHVlKSByZXR1cm4gcDEgfHwgcDI7XG4gIHJldHVybiBwcmVmaXhlZFZhbHVlO1xufVxuXG5pZiAoaXNJbkJyb3dzZXIpIGVsJDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4vKipcbiAqIFJldHVybnMgcHJlZml4ZWQgdmFsdWUgaWYgbmVlZGVkLiBSZXR1cm5zIGBmYWxzZWAgaWYgdmFsdWUgaXMgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfEJvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRlZFZhbHVlKHByb3BlcnR5LCB2YWx1ZSkge1xuICAvLyBGb3Igc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICB2YXIgcHJlZml4ZWRWYWx1ZSA9IHZhbHVlO1xuICBpZiAoIWVsJDEgfHwgcHJvcGVydHkgPT09ICdjb250ZW50JykgcmV0dXJuIHZhbHVlOyAvLyBJdCBpcyBhIHN0cmluZyBvciBhIG51bWJlciBhcyBhIHN0cmluZyBsaWtlICcxJy5cbiAgLy8gV2Ugd2FudCBvbmx5IHByZWZpeGFibGUgdmFsdWVzIGhlcmUuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcblxuICBpZiAodHlwZW9mIHByZWZpeGVkVmFsdWUgIT09ICdzdHJpbmcnIHx8ICFpc05hTihwYXJzZUludChwcmVmaXhlZFZhbHVlLCAxMCkpKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkVmFsdWU7XG4gIH0gLy8gQ3JlYXRlIGNhY2hlIGtleSBmb3IgY3VycmVudCB2YWx1ZS5cblxuXG4gIHZhciBjYWNoZUtleSA9IHByb3BlcnR5ICsgcHJlZml4ZWRWYWx1ZTsgLy8gUmVtb3ZlIGNhY2hlIGZvciBiZW5jaG1hcmsgdGVzdHMgb3IgcmV0dXJuIHZhbHVlIGZyb20gY2FjaGUuXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnYmVuY2htYXJrJyAmJiBjYWNoZSQxW2NhY2hlS2V5XSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGNhY2hlJDFbY2FjaGVLZXldO1xuICB9IC8vIElFIGNhbiBldmVuIHRocm93IGFuIGVycm9yIGluIHNvbWUgY2FzZXMsIGZvciBlLmcuIHN0eWxlLmNvbnRlbnQgPSAnYmFyJy5cblxuXG4gIHRyeSB7XG4gICAgLy8gVGVzdCB2YWx1ZSBhcyBpdCBpcy5cbiAgICBlbCQxLnN0eWxlW3Byb3BlcnR5XSA9IHByZWZpeGVkVmFsdWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFJldHVybiBmYWxzZSBpZiB2YWx1ZSBub3Qgc3VwcG9ydGVkLlxuICAgIGNhY2hlJDFbY2FjaGVLZXldID0gZmFsc2U7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElmICd0cmFuc2l0aW9uJyBvciAndHJhbnNpdGlvbi1wcm9wZXJ0eScgcHJvcGVydHkuXG5cblxuICBpZiAodHJhbnNpdGlvblByb3BlcnRpZXNbcHJvcGVydHldKSB7XG4gICAgcHJlZml4ZWRWYWx1ZSA9IHByZWZpeGVkVmFsdWUucmVwbGFjZSh0cmFuc1Byb3BzUmVnRXhwLCBwcmVmaXhUcmFuc2l0aW9uQ2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKGVsJDEuc3R5bGVbcHJvcGVydHldID09PSAnJykge1xuICAgIC8vIFZhbHVlIHdpdGggYSB2ZW5kb3IgcHJlZml4LlxuICAgIHByZWZpeGVkVmFsdWUgPSBwcmVmaXguY3NzICsgcHJlZml4ZWRWYWx1ZTsgLy8gSGFyZGNvZGUgdGVzdCB0byBjb252ZXJ0IFwiZmxleFwiIHRvIFwiLW1zLWZsZXhib3hcIiBmb3IgSUUxMC5cblxuICAgIGlmIChwcmVmaXhlZFZhbHVlID09PSAnLW1zLWZsZXgnKSBlbCQxLnN0eWxlW3Byb3BlcnR5XSA9ICctbXMtZmxleGJveCc7IC8vIFRlc3QgcHJlZml4ZWQgdmFsdWUuXG5cbiAgICBlbCQxLnN0eWxlW3Byb3BlcnR5XSA9IHByZWZpeGVkVmFsdWU7IC8vIFJldHVybiBmYWxzZSBpZiB2YWx1ZSBub3Qgc3VwcG9ydGVkLlxuXG4gICAgaWYgKGVsJDEuc3R5bGVbcHJvcGVydHldID09PSAnJykge1xuICAgICAgY2FjaGUkMVtjYWNoZUtleV0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gUmVzZXQgc3R5bGVzIGZvciBjdXJyZW50IHByb3BlcnR5LlxuXG5cbiAgZWwkMS5zdHlsZVtwcm9wZXJ0eV0gPSAnJzsgLy8gV3JpdGUgY3VycmVudCB2YWx1ZSB0byBjYWNoZS5cblxuICBjYWNoZSQxW2NhY2hlS2V5XSA9IHByZWZpeGVkVmFsdWU7XG4gIHJldHVybiBjYWNoZSQxW2NhY2hlS2V5XTtcbn1cblxuZXhwb3J0IHsgcHJlZml4LCBzdXBwb3J0ZWRLZXlmcmFtZXMsIHN1cHBvcnRlZFByb3BlcnR5LCBzdXBwb3J0ZWRWYWx1ZSB9O1xuIiwiaW1wb3J0IHsgc3VwcG9ydGVkS2V5ZnJhbWVzLCBzdXBwb3J0ZWRWYWx1ZSwgc3VwcG9ydGVkUHJvcGVydHkgfSBmcm9tICdjc3MtdmVuZG9yJztcbmltcG9ydCB7IHRvQ3NzVmFsdWUgfSBmcm9tICdqc3MnO1xuXG4vKipcbiAqIEFkZCB2ZW5kb3IgcHJlZml4IHRvIGEgcHJvcGVydHkgbmFtZSB3aGVuIG5lZWRlZC5cbiAqL1xuXG5mdW5jdGlvbiBqc3NWZW5kb3JQcmVmaXhlcigpIHtcbiAgZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgIHZhciBhdFJ1bGUgPSBydWxlO1xuICAgICAgYXRSdWxlLmF0ID0gc3VwcG9ydGVkS2V5ZnJhbWVzKGF0UnVsZS5hdCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJlZml4U3R5bGUoc3R5bGUpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wXTtcblxuICAgICAgaWYgKHByb3AgPT09ICdmYWxsYmFja3MnICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHN0eWxlW3Byb3BdID0gdmFsdWUubWFwKHByZWZpeFN0eWxlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFuZ2VQcm9wID0gZmFsc2U7XG4gICAgICB2YXIgc3VwcG9ydGVkUHJvcCA9IHN1cHBvcnRlZFByb3BlcnR5KHByb3ApO1xuICAgICAgaWYgKHN1cHBvcnRlZFByb3AgJiYgc3VwcG9ydGVkUHJvcCAhPT0gcHJvcCkgY2hhbmdlUHJvcCA9IHRydWU7XG4gICAgICB2YXIgY2hhbmdlVmFsdWUgPSBmYWxzZTtcbiAgICAgIHZhciBzdXBwb3J0ZWRWYWx1ZSQxID0gc3VwcG9ydGVkVmFsdWUoc3VwcG9ydGVkUHJvcCwgdG9Dc3NWYWx1ZSh2YWx1ZSkpO1xuICAgICAgaWYgKHN1cHBvcnRlZFZhbHVlJDEgJiYgc3VwcG9ydGVkVmFsdWUkMSAhPT0gdmFsdWUpIGNoYW5nZVZhbHVlID0gdHJ1ZTtcblxuICAgICAgaWYgKGNoYW5nZVByb3AgfHwgY2hhbmdlVmFsdWUpIHtcbiAgICAgICAgaWYgKGNoYW5nZVByb3ApIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgICAgICAgc3R5bGVbc3VwcG9ydGVkUHJvcCB8fCBwcm9wXSA9IHN1cHBvcnRlZFZhbHVlJDEgfHwgdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm4gc3R5bGU7XG4gICAgcmV0dXJuIHByZWZpeFN0eWxlKHN0eWxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3ApIHtcbiAgICByZXR1cm4gc3VwcG9ydGVkVmFsdWUocHJvcCwgdG9Dc3NWYWx1ZSh2YWx1ZSkpIHx8IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NSdWxlOiBvblByb2Nlc3NSdWxlLFxuICAgIG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZSxcbiAgICBvbkNoYW5nZVZhbHVlOiBvbkNoYW5nZVZhbHVlXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGpzc1ZlbmRvclByZWZpeGVyO1xuIiwiLyoqXG4gKiBTb3J0IHByb3BzIGJ5IGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24ganNzUHJvcHNTb3J0KCkge1xuICB2YXIgc29ydCA9IGZ1bmN0aW9uIHNvcnQocHJvcDAsIHByb3AxKSB7XG4gICAgaWYgKHByb3AwLmxlbmd0aCA9PT0gcHJvcDEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcHJvcDAgPiBwcm9wMSA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcDAubGVuZ3RoIC0gcHJvcDEubGVuZ3RoO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgb25Qcm9jZXNzU3R5bGU6IGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm4gc3R5bGU7XG4gICAgICB2YXIgbmV3U3R5bGUgPSB7fTtcbiAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5rZXlzKHN0eWxlKS5zb3J0KHNvcnQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld1N0eWxlW3Byb3BzW2ldXSA9IHN0eWxlW3Byb3BzW2ldXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1N0eWxlO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQganNzUHJvcHNTb3J0O1xuIiwiaW1wb3J0IGZ1bmN0aW9ucyBmcm9tICdqc3MtcGx1Z2luLXJ1bGUtdmFsdWUtZnVuY3Rpb24nO1xuaW1wb3J0IGdsb2JhbCBmcm9tICdqc3MtcGx1Z2luLWdsb2JhbCc7XG5pbXBvcnQgbmVzdGVkIGZyb20gJ2pzcy1wbHVnaW4tbmVzdGVkJztcbmltcG9ydCBjYW1lbENhc2UgZnJvbSAnanNzLXBsdWdpbi1jYW1lbC1jYXNlJztcbmltcG9ydCBkZWZhdWx0VW5pdCBmcm9tICdqc3MtcGx1Z2luLWRlZmF1bHQtdW5pdCc7XG5pbXBvcnQgdmVuZG9yUHJlZml4ZXIgZnJvbSAnanNzLXBsdWdpbi12ZW5kb3ItcHJlZml4ZXInO1xuaW1wb3J0IHByb3BzU29ydCBmcm9tICdqc3MtcGx1Z2luLXByb3BzLXNvcnQnOyAvLyBTdWJzZXQgb2YganNzLXByZXNldC1kZWZhdWx0IHdpdGggb25seSB0aGUgcGx1Z2lucyB0aGUgTWF0ZXJpYWwtVUkgY29tcG9uZW50cyBhcmUgdXNpbmcuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGpzc1ByZXNldCgpIHtcbiAgcmV0dXJuIHtcbiAgICBwbHVnaW5zOiBbZnVuY3Rpb25zKCksIGdsb2JhbCgpLCBuZXN0ZWQoKSwgY2FtZWxDYXNlKCksIGRlZmF1bHRVbml0KCksIC8vIERpc2FibGUgdGhlIHZlbmRvciBwcmVmaXhlciBzZXJ2ZXItc2lkZSwgaXQgZG9lcyBub3RoaW5nLlxuICAgIC8vIFRoaXMgd2F5LCB3ZSBjYW4gZ2V0IGEgcGVyZm9ybWFuY2UgYm9vc3QuXG4gICAgLy8gSW4gdGhlIGRvY3VtZW50YXRpb24sIHdlIGFyZSB1c2luZyBgYXV0b3ByZWZpeGVyYCB0byBzb2x2ZSB0aGlzIHByb2JsZW0uXG4gICAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdmVuZG9yUHJlZml4ZXIoKSwgcHJvcHNTb3J0KCldXG4gIH07XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgeyBnZXREaXNwbGF5TmFtZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUNsYXNzZXMoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGJhc2VDbGFzc2VzID0gb3B0aW9ucy5iYXNlQ2xhc3NlcyxcbiAgICAgIG5ld0NsYXNzZXMgPSBvcHRpb25zLm5ld0NsYXNzZXMsXG4gICAgICBDb21wb25lbnQgPSBvcHRpb25zLkNvbXBvbmVudDtcblxuICBpZiAoIW5ld0NsYXNzZXMpIHtcbiAgICByZXR1cm4gYmFzZUNsYXNzZXM7XG4gIH1cblxuICB2YXIgbmV4dENsYXNzZXMgPSBfZXh0ZW5kcyh7fSwgYmFzZUNsYXNzZXMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDbGFzc2VzID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc29sZS5lcnJvcihbXCJNYXRlcmlhbC1VSTogVGhlIHZhbHVlIGBcIi5jb25jYXQobmV3Q2xhc3NlcywgXCJgIFwiKSArIFwicHJvdmlkZWQgdG8gdGhlIGNsYXNzZXMgcHJvcCBvZiBcIi5jb25jYXQoZ2V0RGlzcGxheU5hbWUoQ29tcG9uZW50KSwgXCIgaXMgaW5jb3JyZWN0LlwiKSwgJ1lvdSBtaWdodCB3YW50IHRvIHVzZSB0aGUgY2xhc3NOYW1lIHByb3AgaW5zdGVhZC4nXS5qb2luKCdcXG4nKSk7XG4gICAgICByZXR1cm4gYmFzZUNsYXNzZXM7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMobmV3Q2xhc3NlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYmFzZUNsYXNzZXNba2V5XSAmJiBuZXdDbGFzc2VzW2tleV0pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihbXCJNYXRlcmlhbC1VSTogVGhlIGtleSBgXCIuY29uY2F0KGtleSwgXCJgIFwiKSArIFwicHJvdmlkZWQgdG8gdGhlIGNsYXNzZXMgcHJvcCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gXCIuY29uY2F0KGdldERpc3BsYXlOYW1lKENvbXBvbmVudCksIFwiLlwiKSwgXCJZb3UgY2FuIG9ubHkgb3ZlcnJpZGUgb25lIG9mIHRoZSBmb2xsb3dpbmc6IFwiLmNvbmNhdChPYmplY3Qua2V5cyhiYXNlQ2xhc3Nlcykuam9pbignLCcpLCBcIi5cIildLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0NsYXNzZXNba2V5XSAmJiB0eXBlb2YgbmV3Q2xhc3Nlc1trZXldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFtcIk1hdGVyaWFsLVVJOiBUaGUga2V5IGBcIi5jb25jYXQoa2V5LCBcImAgXCIpICsgXCJwcm92aWRlZCB0byB0aGUgY2xhc3NlcyBwcm9wIGlzIG5vdCB2YWxpZCBmb3IgXCIuY29uY2F0KGdldERpc3BsYXlOYW1lKENvbXBvbmVudCksIFwiLlwiKSwgXCJZb3UgbmVlZCB0byBwcm92aWRlIGEgbm9uIGVtcHR5IHN0cmluZyBpbnN0ZWFkIG9mOiBcIi5jb25jYXQobmV3Q2xhc3Nlc1trZXldLCBcIi5cIildLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmV3Q2xhc3Nlc1trZXldKSB7XG4gICAgICBuZXh0Q2xhc3Nlc1trZXldID0gXCJcIi5jb25jYXQoYmFzZUNsYXNzZXNba2V5XSwgXCIgXCIpLmNvbmNhdChuZXdDbGFzc2VzW2tleV0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXh0Q2xhc3Nlcztcbn0iLCIvLyBVc2VkIGh0dHBzOi8vZ2l0aHViLmNvbS90aGlua2xvb3AvbXVsdGkta2V5LWNhY2hlIGFzIGluc3BpcmF0aW9uXG52YXIgbXVsdGlLZXlTdG9yZSA9IHtcbiAgc2V0OiBmdW5jdGlvbiBzZXQoY2FjaGUsIGtleTEsIGtleTIsIHZhbHVlKSB7XG4gICAgdmFyIHN1YkNhY2hlID0gY2FjaGUuZ2V0KGtleTEpO1xuXG4gICAgaWYgKCFzdWJDYWNoZSkge1xuICAgICAgc3ViQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICBjYWNoZS5zZXQoa2V5MSwgc3ViQ2FjaGUpO1xuICAgIH1cblxuICAgIHN1YkNhY2hlLnNldChrZXkyLCB2YWx1ZSk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gZ2V0KGNhY2hlLCBrZXkxLCBrZXkyKSB7XG4gICAgdmFyIHN1YkNhY2hlID0gY2FjaGUuZ2V0KGtleTEpO1xuICAgIHJldHVybiBzdWJDYWNoZSA/IHN1YkNhY2hlLmdldChrZXkyKSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgZGVsZXRlOiBmdW5jdGlvbiBfZGVsZXRlKGNhY2hlLCBrZXkxLCBrZXkyKSB7XG4gICAgdmFyIHN1YkNhY2hlID0gY2FjaGUuZ2V0KGtleTEpO1xuICAgIHN1YkNhY2hlLmRlbGV0ZShrZXkyKTtcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IG11bHRpS2V5U3RvcmU7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbnZhciBUaGVtZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBUaGVtZUNvbnRleHQuZGlzcGxheU5hbWUgPSAnVGhlbWVDb250ZXh0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGhlbWVDb250ZXh0OyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgVGhlbWVDb250ZXh0IGZyb20gJy4vVGhlbWVDb250ZXh0JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZVRoZW1lKCkge1xuICB2YXIgdGhlbWUgPSBSZWFjdC51c2VDb250ZXh0KFRoZW1lQ29udGV4dCk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VEZWJ1Z1ZhbHVlKHRoZW1lKTtcbiAgfVxuXG4gIHJldHVybiB0aGVtZTtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGV4YWN0UHJvcCB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUgZnJvbSAnLi4vY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUnO1xuaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnanNzJztcbmltcG9ydCBqc3NQcmVzZXQgZnJvbSAnLi4vanNzUHJlc2V0JzsgLy8gRGVmYXVsdCBKU1MgaW5zdGFuY2UuXG5cbnZhciBqc3MgPSBjcmVhdGUoanNzUHJlc2V0KCkpOyAvLyBVc2UgYSBzaW5nbGV0b24gb3IgdGhlIHByb3ZpZGVkIG9uZSBieSB0aGUgY29udGV4dC5cbi8vXG4vLyBUaGUgY291bnRlci1iYXNlZCBhcHByb2FjaCBkb2Vzbid0IHRvbGVyYXRlIGFueSBtaXN0YWtlLlxuLy8gSXQncyBtdWNoIHNhZmVyIHRvIHVzZSB0aGUgc2FtZSBjb3VudGVyIGV2ZXJ5d2hlcmUuXG5cbnZhciBnZW5lcmF0ZUNsYXNzTmFtZSA9IGNyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lKCk7IC8vIEV4cG9ydGVkIGZvciB0ZXN0IHB1cnBvc2VzXG5cbmV4cG9ydCB2YXIgc2hlZXRzTWFuYWdlciA9IG5ldyBNYXAoKTtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZGlzYWJsZUdlbmVyYXRpb246IGZhbHNlLFxuICBnZW5lcmF0ZUNsYXNzTmFtZTogZ2VuZXJhdGVDbGFzc05hbWUsXG4gIGpzczoganNzLFxuICBzaGVldHNDYWNoZTogbnVsbCxcbiAgc2hlZXRzTWFuYWdlcjogc2hlZXRzTWFuYWdlcixcbiAgc2hlZXRzUmVnaXN0cnk6IG51bGxcbn07XG5leHBvcnQgdmFyIFN0eWxlc0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KGRlZmF1bHRPcHRpb25zKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgU3R5bGVzQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdTdHlsZXNDb250ZXh0Jztcbn1cblxudmFyIGluamVjdEZpcnN0Tm9kZTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFN0eWxlc1Byb3ZpZGVyKHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgX3Byb3BzJGluamVjdEZpcnN0ID0gcHJvcHMuaW5qZWN0Rmlyc3QsXG4gICAgICBpbmplY3RGaXJzdCA9IF9wcm9wcyRpbmplY3RGaXJzdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkaW5qZWN0Rmlyc3QsXG4gICAgICBfcHJvcHMkZGlzYWJsZUdlbmVyYXQgPSBwcm9wcy5kaXNhYmxlR2VuZXJhdGlvbixcbiAgICAgIGRpc2FibGVHZW5lcmF0aW9uID0gX3Byb3BzJGRpc2FibGVHZW5lcmF0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlR2VuZXJhdCxcbiAgICAgIGxvY2FsT3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJpbmplY3RGaXJzdFwiLCBcImRpc2FibGVHZW5lcmF0aW9uXCJdKTtcblxuICB2YXIgb3V0ZXJPcHRpb25zID0gUmVhY3QudXNlQ29udGV4dChTdHlsZXNDb250ZXh0KTtcblxuICB2YXIgY29udGV4dCA9IF9leHRlbmRzKHt9LCBvdXRlck9wdGlvbnMsIHtcbiAgICBkaXNhYmxlR2VuZXJhdGlvbjogZGlzYWJsZUdlbmVyYXRpb25cbiAgfSwgbG9jYWxPcHRpb25zKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyAmJiAhY29udGV4dC5zaGVldHNNYW5hZ2VyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNYXRlcmlhbC1VSTogWW91IG5lZWQgdG8gdXNlIHRoZSBTZXJ2ZXJTdHlsZVNoZWV0cyBBUEkgd2hlbiByZW5kZXJpbmcgb24gdGhlIHNlcnZlci4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChjb250ZXh0Lmpzcy5vcHRpb25zLmluc2VydGlvblBvaW50ICYmIGluamVjdEZpcnN0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNYXRlcmlhbC1VSTogWW91IGNhbm5vdCB1c2UgYSBjdXN0b20gaW5zZXJ0aW9uUG9pbnQgYW5kIDxTdHlsZXNDb250ZXh0IGluamVjdEZpcnN0PiBhdCB0aGUgc2FtZSB0aW1lLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGluamVjdEZpcnN0ICYmIGxvY2FsT3B0aW9ucy5qc3MpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01hdGVyaWFsLVVJOiBZb3UgY2Fubm90IHVzZSB0aGUganNzIGFuZCBpbmplY3RGaXJzdCBwcm9wcyBhdCB0aGUgc2FtZSB0aW1lLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGV4dC5qc3Mub3B0aW9ucy5pbnNlcnRpb25Qb2ludCAmJiBpbmplY3RGaXJzdCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICghaW5qZWN0Rmlyc3ROb2RlKSB7XG4gICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQ7XG4gICAgICBpbmplY3RGaXJzdE5vZGUgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCdtdWktaW5qZWN0LWZpcnN0Jyk7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShpbmplY3RGaXJzdE5vZGUsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgY29udGV4dC5qc3MgPSBjcmVhdGUoe1xuICAgICAgcGx1Z2luczoganNzUHJlc2V0KCkucGx1Z2lucyxcbiAgICAgIGluc2VydGlvblBvaW50OiBpbmplY3RGaXJzdE5vZGVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTdHlsZXNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRcbiAgfSwgY2hpbGRyZW4pO1xufVxucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gU3R5bGVzUHJvdmlkZXIucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogWW91ciBjb21wb25lbnQgdHJlZS5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBZb3UgY2FuIGRpc2FibGUgdGhlIGdlbmVyYXRpb24gb2YgdGhlIHN0eWxlcyB3aXRoIHRoaXMgb3B0aW9uLlxuICAgKiBJdCBjYW4gYmUgdXNlZnVsIHdoZW4gdHJhdmVyc2luZyB0aGUgUmVhY3QgdHJlZSBvdXRzaWRlIG9mIHRoZSBIVE1MXG4gICAqIHJlbmRlcmluZyBzdGVwIG9uIHRoZSBzZXJ2ZXIuXG4gICAqIExldCdzIHNheSB5b3UgYXJlIHVzaW5nIHJlYWN0LWFwb2xsbyB0byBleHRyYWN0IGFsbFxuICAgKiB0aGUgcXVlcmllcyBtYWRlIGJ5IHRoZSBpbnRlcmZhY2Ugc2VydmVyLXNpZGUgLSB5b3UgY2FuIHNpZ25pZmljYW50bHkgc3BlZWQgdXAgdGhlIHRyYXZlcnNhbCB3aXRoIHRoaXMgcHJvcC5cbiAgICovXG4gIGRpc2FibGVHZW5lcmF0aW9uOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSlNTJ3MgY2xhc3MgbmFtZSBnZW5lcmF0b3IuXG4gICAqL1xuICBnZW5lcmF0ZUNsYXNzTmFtZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBzdHlsZXMgYXJlIGluamVjdGVkIGxhc3QgaW4gdGhlIDxoZWFkPiBlbGVtZW50IG9mIHRoZSBwYWdlLlxuICAgKiBBcyBhIHJlc3VsdCwgdGhleSBnYWluIG1vcmUgc3BlY2lmaWNpdHkgdGhhbiBhbnkgb3RoZXIgc3R5bGUgc2hlZXQuXG4gICAqIElmIHlvdSB3YW50IHRvIG92ZXJyaWRlIE1hdGVyaWFsLVVJJ3Mgc3R5bGVzLCBzZXQgdGhpcyBwcm9wLlxuICAgKi9cbiAgaW5qZWN0Rmlyc3Q6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBKU1MncyBpbnN0YW5jZS5cbiAgICovXG4gIGpzczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc2VydmVyR2VuZXJhdGVDbGFzc05hbWU6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqXG4gICAqIEJldGEgZmVhdHVyZS5cbiAgICpcbiAgICogQ2FjaGUgZm9yIHRoZSBzaGVldHMuXG4gICAqL1xuICBzaGVldHNDYWNoZTogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKlxuICAgKiBUaGUgc2hlZXRzTWFuYWdlciBpcyB1c2VkIHRvIGRlZHVwbGljYXRlIHN0eWxlIHNoZWV0IGluamVjdGlvbiBpbiB0aGUgcGFnZS5cbiAgICogSXQncyBkZWR1cGxpY2F0aW5nIHVzaW5nIHRoZSAodGhlbWUsIHN0eWxlcykgY291cGxlLlxuICAgKiBPbiB0aGUgc2VydmVyLCB5b3Ugc2hvdWxkIHByb3ZpZGUgYSBuZXcgaW5zdGFuY2UgZm9yIGVhY2ggcmVxdWVzdC5cbiAgICovXG4gIHNoZWV0c01hbmFnZXI6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICpcbiAgICogQ29sbGVjdCB0aGUgc2hlZXRzLlxuICAgKi9cbiAgc2hlZXRzUmVnaXN0cnk6IFByb3BUeXBlcy5vYmplY3Rcbn0gOiB2b2lkIDA7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFN0eWxlc1Byb3ZpZGVyLnByb3BUeXBlcyA9IGV4YWN0UHJvcChTdHlsZXNQcm92aWRlci5wcm9wVHlwZXMpIDogdm9pZCAwO1xufSIsIi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9wcmVmZXItZGVmYXVsdC1leHBvcnQgKi9cbi8vIEdsb2JhbCBpbmRleCBjb3VudGVyIHRvIHByZXNlcnZlIHNvdXJjZSBvcmRlci5cbi8vIFdlIGNyZWF0ZSB0aGUgc3R5bGUgc2hlZXQgZHVyaW5nIHRoZSBjcmVhdGlvbiBvZiB0aGUgY29tcG9uZW50LFxuLy8gY2hpbGRyZW4gYXJlIGhhbmRsZWQgYWZ0ZXIgdGhlIHBhcmVudHMsIHNvIHRoZSBvcmRlciBvZiBzdHlsZSBlbGVtZW50cyB3b3VsZCBiZSBwYXJlbnQtPmNoaWxkLlxuLy8gSXQgaXMgYSBwcm9ibGVtIHRob3VnaCB3aGVuIGEgcGFyZW50IHBhc3NlcyBhIGNsYXNzTmFtZVxuLy8gd2hpY2ggbmVlZHMgdG8gb3ZlcnJpZGUgYW55IGNoaWxkJ3Mgc3R5bGVzLlxuLy8gU3R5bGVTaGVldCBvZiB0aGUgY2hpbGQgaGFzIGEgaGlnaGVyIHNwZWNpZmljaXR5LCBiZWNhdXNlIG9mIHRoZSBzb3VyY2Ugb3JkZXIuXG4vLyBTbyBvdXIgc29sdXRpb24gaXMgdG8gcmVuZGVyIHNoZWV0cyB0aGVtIGluIHRoZSByZXZlcnNlIG9yZGVyIGNoaWxkLT5zaGVldCwgc29cbi8vIHRoYXQgcGFyZW50IGhhcyBhIGhpZ2hlciBzcGVjaWZpY2l0eS5cbnZhciBpbmRleENvdW50ZXIgPSAtMWU5O1xuZXhwb3J0IGZ1bmN0aW9uIGluY3JlbWVudCgpIHtcbiAgaW5kZXhDb3VudGVyICs9IDE7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaW5kZXhDb3VudGVyID49IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihbJ01hdGVyaWFsLVVJOiBZb3UgbWlnaHQgaGF2ZSBhIG1lbW9yeSBsZWFrLicsICdUaGUgaW5kZXhDb3VudGVyIGlzIG5vdCBzdXBwb3NlZCB0byBncm93IHRoYXQgbXVjaC4nXS5qb2luKCdcXG4nKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZGV4Q291bnRlcjtcbn0iLCIvLyBXZSB1c2UgdGhlIHNhbWUgZW1wdHkgb2JqZWN0IHRvIHJlZiBjb3VudCB0aGUgc3R5bGVzIHRoYXQgZG9uJ3QgbmVlZCBhIHRoZW1lIG9iamVjdC5cbnZhciBub29wVGhlbWUgPSB7fTtcbmV4cG9ydCBkZWZhdWx0IG5vb3BUaGVtZTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfdHlwZW9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2ZcIjtcbmltcG9ydCB7IGRlZXBtZXJnZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgbm9vcFRoZW1lIGZyb20gJy4vbm9vcFRoZW1lJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFN0eWxlc0NyZWF0b3Ioc3R5bGVzT3JDcmVhdG9yKSB7XG4gIHZhciB0aGVtaW5nRW5hYmxlZCA9IHR5cGVvZiBzdHlsZXNPckNyZWF0b3IgPT09ICdmdW5jdGlvbic7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoX3R5cGVvZihzdHlsZXNPckNyZWF0b3IpICE9PSAnb2JqZWN0JyAmJiAhdGhlbWluZ0VuYWJsZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydNYXRlcmlhbC1VSTogVGhlIGBzdHlsZXNgIGFyZ3VtZW50IHByb3ZpZGVkIGlzIGludmFsaWQuJywgJ1lvdSBuZWVkIHRvIHByb3ZpZGUgYSBmdW5jdGlvbiBnZW5lcmF0aW5nIHRoZSBzdHlsZXMgb3IgYSBzdHlsZXMgb2JqZWN0LiddLmpvaW4oJ1xcbicpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKHRoZW1lLCBuYW1lKSB7XG4gICAgICB2YXIgc3R5bGVzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBzdHlsZXMgPSB0aGVtaW5nRW5hYmxlZCA/IHN0eWxlc09yQ3JlYXRvcih0aGVtZSkgOiBzdHlsZXNPckNyZWF0b3I7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGhlbWluZ0VuYWJsZWQgPT09IHRydWUgJiYgdGhlbWUgPT09IG5vb3BUaGVtZSkge1xuICAgICAgICAgICAgLy8gVE9ETzogcHJlcGVuZCBlcnJvciBtZXNzYWdlL25hbWUgaW5zdGVhZFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihbJ01hdGVyaWFsLVVJOiBUaGUgYHN0eWxlc2AgYXJndW1lbnQgcHJvdmlkZWQgaXMgaW52YWxpZC4nLCAnWW91IGFyZSBwcm92aWRpbmcgYSBmdW5jdGlvbiB3aXRob3V0IGEgdGhlbWUgaW4gdGhlIGNvbnRleHQuJywgJ09uZSBvZiB0aGUgcGFyZW50IGVsZW1lbnRzIG5lZWRzIHRvIHVzZSBhIFRoZW1lUHJvdmlkZXIuJ10uam9pbignXFxuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFuYW1lIHx8ICF0aGVtZS5vdmVycmlkZXMgfHwgIXRoZW1lLm92ZXJyaWRlc1tuYW1lXSkge1xuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3ZlcnJpZGVzID0gdGhlbWUub3ZlcnJpZGVzW25hbWVdO1xuXG4gICAgICB2YXIgc3R5bGVzV2l0aE92ZXJyaWRlcyA9IF9leHRlbmRzKHt9LCBzdHlsZXMpO1xuXG4gICAgICBPYmplY3Qua2V5cyhvdmVycmlkZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICghc3R5bGVzV2l0aE92ZXJyaWRlc1trZXldKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oWydNYXRlcmlhbC1VSTogWW91IGFyZSB0cnlpbmcgdG8gb3ZlcnJpZGUgYSBzdHlsZSB0aGF0IGRvZXMgbm90IGV4aXN0LicsIFwiRml4IHRoZSBgXCIuY29uY2F0KGtleSwgXCJgIGtleSBvZiBgdGhlbWUub3ZlcnJpZGVzLlwiKS5jb25jYXQobmFtZSwgXCJgLlwiKV0uam9pbignXFxuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlc1dpdGhPdmVycmlkZXNba2V5XSA9IGRlZXBtZXJnZShzdHlsZXNXaXRoT3ZlcnJpZGVzW2tleV0sIG92ZXJyaWRlc1trZXldKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0eWxlc1dpdGhPdmVycmlkZXM7XG4gICAgfSxcbiAgICBvcHRpb25zOiB7fVxuICB9O1xufSIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBnZXREeW5hbWljU3R5bGVzIH0gZnJvbSAnanNzJztcbmltcG9ydCBtZXJnZUNsYXNzZXMgZnJvbSAnLi4vbWVyZ2VDbGFzc2VzJztcbmltcG9ydCBtdWx0aUtleVN0b3JlIGZyb20gJy4vbXVsdGlLZXlTdG9yZSc7XG5pbXBvcnQgdXNlVGhlbWUgZnJvbSAnLi4vdXNlVGhlbWUnO1xuaW1wb3J0IHsgU3R5bGVzQ29udGV4dCB9IGZyb20gJy4uL1N0eWxlc1Byb3ZpZGVyJztcbmltcG9ydCB7IGluY3JlbWVudCB9IGZyb20gJy4vaW5kZXhDb3VudGVyJztcbmltcG9ydCBnZXRTdHlsZXNDcmVhdG9yIGZyb20gJy4uL2dldFN0eWxlc0NyZWF0b3InO1xuaW1wb3J0IG5vb3BUaGVtZSBmcm9tICcuLi9nZXRTdHlsZXNDcmVhdG9yL25vb3BUaGVtZSc7XG5cbmZ1bmN0aW9uIGdldENsYXNzZXMoX3JlZiwgY2xhc3NlcywgQ29tcG9uZW50KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBzdHlsZXNPcHRpb25zID0gX3JlZi5zdHlsZXNPcHRpb25zO1xuXG4gIGlmIChzdHlsZXNPcHRpb25zLmRpc2FibGVHZW5lcmF0aW9uKSB7XG4gICAgcmV0dXJuIGNsYXNzZXMgfHwge307XG4gIH1cblxuICBpZiAoIXN0YXRlLmNhY2hlQ2xhc3Nlcykge1xuICAgIHN0YXRlLmNhY2hlQ2xhc3NlcyA9IHtcbiAgICAgIC8vIENhY2hlIGZvciB0aGUgZmluYWxpemVkIGNsYXNzZXMgdmFsdWUuXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIC8vIENhY2hlIGZvciB0aGUgbGFzdCB1c2VkIGNsYXNzZXMgcHJvcCBwb2ludGVyLlxuICAgICAgbGFzdFByb3A6IG51bGwsXG4gICAgICAvLyBDYWNoZSBmb3IgdGhlIGxhc3QgdXNlZCByZW5kZXJlZCBjbGFzc2VzIHBvaW50ZXIuXG4gICAgICBsYXN0SlNTOiB7fVxuICAgIH07XG4gIH0gLy8gVHJhY2tzIGlmIGVpdGhlciB0aGUgcmVuZGVyZWQgY2xhc3NlcyBvciBjbGFzc2VzIHByb3AgaGFzIGNoYW5nZWQsXG4gIC8vIHJlcXVpcmluZyB0aGUgZ2VuZXJhdGlvbiBvZiBhIG5ldyBmaW5hbGl6ZWQgY2xhc3NlcyBvYmplY3QuXG5cblxuICB2YXIgZ2VuZXJhdGUgPSBmYWxzZTtcblxuICBpZiAoc3RhdGUuY2xhc3NlcyAhPT0gc3RhdGUuY2FjaGVDbGFzc2VzLmxhc3RKU1MpIHtcbiAgICBzdGF0ZS5jYWNoZUNsYXNzZXMubGFzdEpTUyA9IHN0YXRlLmNsYXNzZXM7XG4gICAgZ2VuZXJhdGUgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGNsYXNzZXMgIT09IHN0YXRlLmNhY2hlQ2xhc3Nlcy5sYXN0UHJvcCkge1xuICAgIHN0YXRlLmNhY2hlQ2xhc3Nlcy5sYXN0UHJvcCA9IGNsYXNzZXM7XG4gICAgZ2VuZXJhdGUgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGdlbmVyYXRlKSB7XG4gICAgc3RhdGUuY2FjaGVDbGFzc2VzLnZhbHVlID0gbWVyZ2VDbGFzc2VzKHtcbiAgICAgIGJhc2VDbGFzc2VzOiBzdGF0ZS5jYWNoZUNsYXNzZXMubGFzdEpTUyxcbiAgICAgIG5ld0NsYXNzZXM6IGNsYXNzZXMsXG4gICAgICBDb21wb25lbnQ6IENvbXBvbmVudFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmNhY2hlQ2xhc3Nlcy52YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoKF9yZWYyLCBwcm9wcykge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIHRoZW1lID0gX3JlZjIudGhlbWUsXG4gICAgICBzdHlsZXNPcHRpb25zID0gX3JlZjIuc3R5bGVzT3B0aW9ucyxcbiAgICAgIHN0eWxlc0NyZWF0b3IgPSBfcmVmMi5zdHlsZXNDcmVhdG9yLFxuICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XG5cbiAgaWYgKHN0eWxlc09wdGlvbnMuZGlzYWJsZUdlbmVyYXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2hlZXRNYW5hZ2VyID0gbXVsdGlLZXlTdG9yZS5nZXQoc3R5bGVzT3B0aW9ucy5zaGVldHNNYW5hZ2VyLCBzdHlsZXNDcmVhdG9yLCB0aGVtZSk7XG5cbiAgaWYgKCFzaGVldE1hbmFnZXIpIHtcbiAgICBzaGVldE1hbmFnZXIgPSB7XG4gICAgICByZWZzOiAwLFxuICAgICAgc3RhdGljU2hlZXQ6IG51bGwsXG4gICAgICBkeW5hbWljU3R5bGVzOiBudWxsXG4gICAgfTtcbiAgICBtdWx0aUtleVN0b3JlLnNldChzdHlsZXNPcHRpb25zLnNoZWV0c01hbmFnZXIsIHN0eWxlc0NyZWF0b3IsIHRoZW1lLCBzaGVldE1hbmFnZXIpO1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgc3R5bGVzQ3JlYXRvci5vcHRpb25zLCBzdHlsZXNPcHRpb25zLCB7XG4gICAgdGhlbWU6IHRoZW1lLFxuICAgIGZsaXA6IHR5cGVvZiBzdHlsZXNPcHRpb25zLmZsaXAgPT09ICdib29sZWFuJyA/IHN0eWxlc09wdGlvbnMuZmxpcCA6IHRoZW1lLmRpcmVjdGlvbiA9PT0gJ3J0bCdcbiAgfSk7XG5cbiAgb3B0aW9ucy5nZW5lcmF0ZUlkID0gb3B0aW9ucy5zZXJ2ZXJHZW5lcmF0ZUNsYXNzTmFtZSB8fCBvcHRpb25zLmdlbmVyYXRlQ2xhc3NOYW1lO1xuICB2YXIgc2hlZXRzUmVnaXN0cnkgPSBzdHlsZXNPcHRpb25zLnNoZWV0c1JlZ2lzdHJ5O1xuXG4gIGlmIChzaGVldE1hbmFnZXIucmVmcyA9PT0gMCkge1xuICAgIHZhciBzdGF0aWNTaGVldDtcblxuICAgIGlmIChzdHlsZXNPcHRpb25zLnNoZWV0c0NhY2hlKSB7XG4gICAgICBzdGF0aWNTaGVldCA9IG11bHRpS2V5U3RvcmUuZ2V0KHN0eWxlc09wdGlvbnMuc2hlZXRzQ2FjaGUsIHN0eWxlc0NyZWF0b3IsIHRoZW1lKTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVzID0gc3R5bGVzQ3JlYXRvci5jcmVhdGUodGhlbWUsIG5hbWUpO1xuXG4gICAgaWYgKCFzdGF0aWNTaGVldCkge1xuICAgICAgc3RhdGljU2hlZXQgPSBzdHlsZXNPcHRpb25zLmpzcy5jcmVhdGVTdHlsZVNoZWV0KHN0eWxlcywgX2V4dGVuZHMoe1xuICAgICAgICBsaW5rOiBmYWxzZVxuICAgICAgfSwgb3B0aW9ucykpO1xuICAgICAgc3RhdGljU2hlZXQuYXR0YWNoKCk7XG5cbiAgICAgIGlmIChzdHlsZXNPcHRpb25zLnNoZWV0c0NhY2hlKSB7XG4gICAgICAgIG11bHRpS2V5U3RvcmUuc2V0KHN0eWxlc09wdGlvbnMuc2hlZXRzQ2FjaGUsIHN0eWxlc0NyZWF0b3IsIHRoZW1lLCBzdGF0aWNTaGVldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNoZWV0c1JlZ2lzdHJ5KSB7XG4gICAgICBzaGVldHNSZWdpc3RyeS5hZGQoc3RhdGljU2hlZXQpO1xuICAgIH1cblxuICAgIHNoZWV0TWFuYWdlci5zdGF0aWNTaGVldCA9IHN0YXRpY1NoZWV0O1xuICAgIHNoZWV0TWFuYWdlci5keW5hbWljU3R5bGVzID0gZ2V0RHluYW1pY1N0eWxlcyhzdHlsZXMpO1xuICB9XG5cbiAgaWYgKHNoZWV0TWFuYWdlci5keW5hbWljU3R5bGVzKSB7XG4gICAgdmFyIGR5bmFtaWNTaGVldCA9IHN0eWxlc09wdGlvbnMuanNzLmNyZWF0ZVN0eWxlU2hlZXQoc2hlZXRNYW5hZ2VyLmR5bmFtaWNTdHlsZXMsIF9leHRlbmRzKHtcbiAgICAgIGxpbms6IHRydWVcbiAgICB9LCBvcHRpb25zKSk7XG4gICAgZHluYW1pY1NoZWV0LnVwZGF0ZShwcm9wcyk7XG4gICAgZHluYW1pY1NoZWV0LmF0dGFjaCgpO1xuICAgIHN0YXRlLmR5bmFtaWNTaGVldCA9IGR5bmFtaWNTaGVldDtcbiAgICBzdGF0ZS5jbGFzc2VzID0gbWVyZ2VDbGFzc2VzKHtcbiAgICAgIGJhc2VDbGFzc2VzOiBzaGVldE1hbmFnZXIuc3RhdGljU2hlZXQuY2xhc3NlcyxcbiAgICAgIG5ld0NsYXNzZXM6IGR5bmFtaWNTaGVldC5jbGFzc2VzXG4gICAgfSk7XG5cbiAgICBpZiAoc2hlZXRzUmVnaXN0cnkpIHtcbiAgICAgIHNoZWV0c1JlZ2lzdHJ5LmFkZChkeW5hbWljU2hlZXQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jbGFzc2VzID0gc2hlZXRNYW5hZ2VyLnN0YXRpY1NoZWV0LmNsYXNzZXM7XG4gIH1cblxuICBzaGVldE1hbmFnZXIucmVmcyArPSAxO1xufVxuXG5mdW5jdGlvbiB1cGRhdGUoX3JlZjMsIHByb3BzKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYzLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS5keW5hbWljU2hlZXQpIHtcbiAgICBzdGF0ZS5keW5hbWljU2hlZXQudXBkYXRlKHByb3BzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2goX3JlZjQpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjQuc3RhdGUsXG4gICAgICB0aGVtZSA9IF9yZWY0LnRoZW1lLFxuICAgICAgc3R5bGVzT3B0aW9ucyA9IF9yZWY0LnN0eWxlc09wdGlvbnMsXG4gICAgICBzdHlsZXNDcmVhdG9yID0gX3JlZjQuc3R5bGVzQ3JlYXRvcjtcblxuICBpZiAoc3R5bGVzT3B0aW9ucy5kaXNhYmxlR2VuZXJhdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzaGVldE1hbmFnZXIgPSBtdWx0aUtleVN0b3JlLmdldChzdHlsZXNPcHRpb25zLnNoZWV0c01hbmFnZXIsIHN0eWxlc0NyZWF0b3IsIHRoZW1lKTtcbiAgc2hlZXRNYW5hZ2VyLnJlZnMgLT0gMTtcbiAgdmFyIHNoZWV0c1JlZ2lzdHJ5ID0gc3R5bGVzT3B0aW9ucy5zaGVldHNSZWdpc3RyeTtcblxuICBpZiAoc2hlZXRNYW5hZ2VyLnJlZnMgPT09IDApIHtcbiAgICBtdWx0aUtleVN0b3JlLmRlbGV0ZShzdHlsZXNPcHRpb25zLnNoZWV0c01hbmFnZXIsIHN0eWxlc0NyZWF0b3IsIHRoZW1lKTtcbiAgICBzdHlsZXNPcHRpb25zLmpzcy5yZW1vdmVTdHlsZVNoZWV0KHNoZWV0TWFuYWdlci5zdGF0aWNTaGVldCk7XG5cbiAgICBpZiAoc2hlZXRzUmVnaXN0cnkpIHtcbiAgICAgIHNoZWV0c1JlZ2lzdHJ5LnJlbW92ZShzaGVldE1hbmFnZXIuc3RhdGljU2hlZXQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5keW5hbWljU2hlZXQpIHtcbiAgICBzdHlsZXNPcHRpb25zLmpzcy5yZW1vdmVTdHlsZVNoZWV0KHN0YXRlLmR5bmFtaWNTaGVldCk7XG5cbiAgICBpZiAoc2hlZXRzUmVnaXN0cnkpIHtcbiAgICAgIHNoZWV0c1JlZ2lzdHJ5LnJlbW92ZShzdGF0ZS5keW5hbWljU2hlZXQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VTeW5jaHJvbm91c0VmZmVjdChmdW5jLCB2YWx1ZXMpIHtcbiAgdmFyIGtleSA9IFJlYWN0LnVzZVJlZihbXSk7XG4gIHZhciBvdXRwdXQ7IC8vIFN0b3JlIFwiZ2VuZXJhdGlvblwiIGtleS4gSnVzdCByZXR1cm5zIGEgbmV3IG9iamVjdCBldmVyeSB0aW1lXG5cbiAgdmFyIGN1cnJlbnRLZXkgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge307XG4gIH0sIHZhbHVlcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIC8vIFwidGhlIGZpcnN0IHJlbmRlclwiLCBvciBcIm1lbW8gZHJvcHBlZCB0aGUgdmFsdWVcIlxuXG4gIGlmIChrZXkuY3VycmVudCAhPT0gY3VycmVudEtleSkge1xuICAgIGtleS5jdXJyZW50ID0gY3VycmVudEtleTtcbiAgICBvdXRwdXQgPSBmdW5jKCk7XG4gIH1cblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgIG91dHB1dCgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtjdXJyZW50S2V5XSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYWtlU3R5bGVzKHN0eWxlc09yQ3JlYXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUsXG4gICAgICBjbGFzc05hbWVQcmVmaXhPcHRpb24gPSBvcHRpb25zLmNsYXNzTmFtZVByZWZpeCxcbiAgICAgIENvbXBvbmVudCA9IG9wdGlvbnMuQ29tcG9uZW50LFxuICAgICAgX29wdGlvbnMkZGVmYXVsdFRoZW1lID0gb3B0aW9ucy5kZWZhdWx0VGhlbWUsXG4gICAgICBkZWZhdWx0VGhlbWUgPSBfb3B0aW9ucyRkZWZhdWx0VGhlbWUgPT09IHZvaWQgMCA/IG5vb3BUaGVtZSA6IF9vcHRpb25zJGRlZmF1bHRUaGVtZSxcbiAgICAgIHN0eWxlc09wdGlvbnMyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9wdGlvbnMsIFtcIm5hbWVcIiwgXCJjbGFzc05hbWVQcmVmaXhcIiwgXCJDb21wb25lbnRcIiwgXCJkZWZhdWx0VGhlbWVcIl0pO1xuXG4gIHZhciBzdHlsZXNDcmVhdG9yID0gZ2V0U3R5bGVzQ3JlYXRvcihzdHlsZXNPckNyZWF0b3IpO1xuICB2YXIgY2xhc3NOYW1lUHJlZml4ID0gbmFtZSB8fCBjbGFzc05hbWVQcmVmaXhPcHRpb24gfHwgJ21ha2VTdHlsZXMnO1xuICBzdHlsZXNDcmVhdG9yLm9wdGlvbnMgPSB7XG4gICAgaW5kZXg6IGluY3JlbWVudCgpLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgbWV0YTogY2xhc3NOYW1lUHJlZml4LFxuICAgIGNsYXNzTmFtZVByZWZpeDogY2xhc3NOYW1lUHJlZml4XG4gIH07XG5cbiAgdmFyIHVzZVN0eWxlcyA9IGZ1bmN0aW9uIHVzZVN0eWxlcygpIHtcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciB0aGVtZSA9IHVzZVRoZW1lKCkgfHwgZGVmYXVsdFRoZW1lO1xuXG4gICAgdmFyIHN0eWxlc09wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgUmVhY3QudXNlQ29udGV4dChTdHlsZXNDb250ZXh0KSwgc3R5bGVzT3B0aW9uczIpO1xuXG4gICAgdmFyIGluc3RhbmNlID0gUmVhY3QudXNlUmVmKCk7XG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IFJlYWN0LnVzZVJlZigpO1xuICAgIHVzZVN5bmNocm9ub3VzRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBzdGF0ZToge30sXG4gICAgICAgIHN0eWxlc0NyZWF0b3I6IHN0eWxlc0NyZWF0b3IsXG4gICAgICAgIHN0eWxlc09wdGlvbnM6IHN0eWxlc09wdGlvbnMsXG4gICAgICAgIHRoZW1lOiB0aGVtZVxuICAgICAgfTtcbiAgICAgIGF0dGFjaChjdXJyZW50LCBwcm9wcyk7XG4gICAgICBzaG91bGRVcGRhdGUuY3VycmVudCA9IGZhbHNlO1xuICAgICAgaW5zdGFuY2UuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBkZXRhY2goY3VycmVudCk7XG4gICAgICB9O1xuICAgIH0sIFt0aGVtZSwgc3R5bGVzQ3JlYXRvcl0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlLmN1cnJlbnQpIHtcbiAgICAgICAgdXBkYXRlKGluc3RhbmNlLmN1cnJlbnQsIHByb3BzKTtcbiAgICAgIH1cblxuICAgICAgc2hvdWxkVXBkYXRlLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHZhciBjbGFzc2VzID0gZ2V0Q2xhc3NlcyhpbnN0YW5jZS5jdXJyZW50LCBwcm9wcy5jbGFzc2VzLCBDb21wb25lbnQpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgUmVhY3QudXNlRGVidWdWYWx1ZShjbGFzc2VzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xhc3NlcztcbiAgfTtcblxuICByZXR1cm4gdXNlU3R5bGVzO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgY29udGV4dFR5cGU6IHRydWUsXG4gIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogdHJ1ZSxcbiAgbWl4aW5zOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgbmFtZTogdHJ1ZSxcbiAgbGVuZ3RoOiB0cnVlLFxuICBwcm90b3R5cGU6IHRydWUsXG4gIGNhbGxlcjogdHJ1ZSxcbiAgY2FsbGVlOiB0cnVlLFxuICBhcmd1bWVudHM6IHRydWUsXG4gIGFyaXR5OiB0cnVlXG59O1xudmFyIEZPUldBUkRfUkVGX1NUQVRJQ1MgPSB7XG4gICckJHR5cGVvZic6IHRydWUsXG4gIHJlbmRlcjogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlXG59O1xudmFyIE1FTU9fU1RBVElDUyA9IHtcbiAgJyQkdHlwZW9mJzogdHJ1ZSxcbiAgY29tcGFyZTogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIFRZUEVfU1RBVElDUyA9IHt9O1xuVFlQRV9TVEFUSUNTW3JlYWN0SXMuRm9yd2FyZFJlZl0gPSBGT1JXQVJEX1JFRl9TVEFUSUNTO1xuVFlQRV9TVEFUSUNTW3JlYWN0SXMuTWVtb10gPSBNRU1PX1NUQVRJQ1M7XG5cbmZ1bmN0aW9uIGdldFN0YXRpY3MoY29tcG9uZW50KSB7XG4gIC8vIFJlYWN0IHYxNi4xMSBhbmQgYmVsb3dcbiAgaWYgKHJlYWN0SXMuaXNNZW1vKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gTUVNT19TVEFUSUNTO1xuICB9IC8vIFJlYWN0IHYxNi4xMiBhbmQgYWJvdmVcblxuXG4gIHJldHVybiBUWVBFX1NUQVRJQ1NbY29tcG9uZW50WyckJHR5cGVvZiddXSB8fCBSRUFDVF9TVEFUSUNTO1xufVxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBibGFja2xpc3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0U3RhdGljcyA9IGdldFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50KTtcbiAgICB2YXIgc291cmNlU3RhdGljcyA9IGdldFN0YXRpY3Moc291cmNlQ29tcG9uZW50KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghS05PV05fU1RBVElDU1trZXldICYmICEoYmxhY2tsaXN0ICYmIGJsYWNrbGlzdFtrZXldKSAmJiAhKHNvdXJjZVN0YXRpY3MgJiYgc291cmNlU3RhdGljc1trZXldKSAmJiAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaG9pc3ROb25SZWFjdFN0YXRpY3M7XG4iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBob2lzdE5vblJlYWN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5pbXBvcnQgeyBjaGFpblByb3BUeXBlcywgZ2V0RGlzcGxheU5hbWUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IG1ha2VTdHlsZXMgZnJvbSAnLi4vbWFrZVN0eWxlcyc7XG5pbXBvcnQgZ2V0VGhlbWVQcm9wcyBmcm9tICcuLi9nZXRUaGVtZVByb3BzJztcbmltcG9ydCB1c2VUaGVtZSBmcm9tICcuLi91c2VUaGVtZSc7IC8vIExpbmsgYSBzdHlsZSBzaGVldCB3aXRoIGEgY29tcG9uZW50LlxuLy8gSXQgZG9lcyBub3QgbW9kaWZ5IHRoZSBjb21wb25lbnQgcGFzc2VkIHRvIGl0O1xuLy8gaW5zdGVhZCwgaXQgcmV0dXJucyBhIG5ldyBjb21wb25lbnQsIHdpdGggYSBgY2xhc3Nlc2AgcHJvcGVydHkuXG5cbnZhciB3aXRoU3R5bGVzID0gZnVuY3Rpb24gd2l0aFN0eWxlcyhzdHlsZXNPckNyZWF0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgIHZhciBkZWZhdWx0VGhlbWUgPSBvcHRpb25zLmRlZmF1bHRUaGVtZSxcbiAgICAgICAgX29wdGlvbnMkd2l0aFRoZW1lID0gb3B0aW9ucy53aXRoVGhlbWUsXG4gICAgICAgIHdpdGhUaGVtZSA9IF9vcHRpb25zJHdpdGhUaGVtZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyR3aXRoVGhlbWUsXG4gICAgICAgIG5hbWUgPSBvcHRpb25zLm5hbWUsXG4gICAgICAgIHN0eWxlc09wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3B0aW9ucywgW1wiZGVmYXVsdFRoZW1lXCIsIFwid2l0aFRoZW1lXCIsIFwibmFtZVwiXSk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKENvbXBvbmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihbJ1lvdSBhcmUgY2FsbGluZyB3aXRoU3R5bGVzKHN0eWxlcykoQ29tcG9uZW50KSB3aXRoIGFuIHVuZGVmaW5lZCBjb21wb25lbnQuJywgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gaW1wb3J0IGl0LiddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2xhc3NOYW1lUHJlZml4ID0gbmFtZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgLy8gUHJvdmlkZSBhIGJldHRlciBEWCBvdXRzaWRlIHByb2R1Y3Rpb24uXG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lKENvbXBvbmVudCk7XG5cbiAgICAgICAgaWYgKGRpc3BsYXlOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbGFzc05hbWVQcmVmaXggPSBkaXNwbGF5TmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1c2VTdHlsZXMgPSBtYWtlU3R5bGVzKHN0eWxlc09yQ3JlYXRvciwgX2V4dGVuZHMoe1xuICAgICAgZGVmYXVsdFRoZW1lOiBkZWZhdWx0VGhlbWUsXG4gICAgICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgICAgIG5hbWU6IG5hbWUgfHwgQ29tcG9uZW50LmRpc3BsYXlOYW1lLFxuICAgICAgY2xhc3NOYW1lUHJlZml4OiBjbGFzc05hbWVQcmVmaXhcbiAgICB9LCBzdHlsZXNPcHRpb25zKSk7XG4gICAgdmFyIFdpdGhTdHlsZXMgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBXaXRoU3R5bGVzKHByb3BzLCByZWYpIHtcbiAgICAgIHZhciBjbGFzc2VzUHJvcCA9IHByb3BzLmNsYXNzZXMsXG4gICAgICAgICAgaW5uZXJSZWYgPSBwcm9wcy5pbm5lclJlZixcbiAgICAgICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2xhc3Nlc1wiLCBcImlubmVyUmVmXCJdKTsgLy8gVGhlIHdyYXBwZXIgcmVjZWl2ZXMgb25seSB1c2VyIHN1cHBsaWVkIHByb3BzLCB3aGljaCBjb3VsZCBiZSBhIHN1YnNldCBvZlxuICAgICAgLy8gdGhlIGFjdHVhbCBwcm9wcyBDb21wb25lbnQgbWlnaHQgcmVjZWl2ZSBkdWUgdG8gbWVyZ2luZyB3aXRoIGRlZmF1bHRQcm9wcy5cbiAgICAgIC8vIFNvIGNvcHlpbmcgaXQgaGVyZSB3b3VsZCBnaXZlIHVzIHRoZSBzYW1lIHJlc3VsdCBpbiB0aGUgd3JhcHBlciBhcyB3ZWxsLlxuXG5cbiAgICAgIHZhciBjbGFzc2VzID0gdXNlU3R5bGVzKF9leHRlbmRzKHt9LCBDb21wb25lbnQuZGVmYXVsdFByb3BzLCBwcm9wcykpO1xuICAgICAgdmFyIHRoZW1lO1xuICAgICAgdmFyIG1vcmUgPSBvdGhlcjtcblxuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyB8fCB3aXRoVGhlbWUpIHtcbiAgICAgICAgLy8gbmFtZSBhbmQgd2l0aFRoZW1lIGFyZSBpbnZhcmlhbnQgaW4gdGhlIG91dGVyIHNjb3BlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICB0aGVtZSA9IHVzZVRoZW1lKCkgfHwgZGVmYXVsdFRoZW1lO1xuXG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgbW9yZSA9IGdldFRoZW1lUHJvcHMoe1xuICAgICAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHByb3BzOiBvdGhlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIFByb3ZpZGUgdGhlIHRoZW1lIHRvIHRoZSB3cmFwcGVkIGNvbXBvbmVudC5cbiAgICAgICAgLy8gU28gd2UgZG9uJ3QgaGF2ZSB0byB1c2UgdGhlIGB3aXRoVGhlbWUoKWAgSGlnaGVyLW9yZGVyIENvbXBvbmVudC5cblxuXG4gICAgICAgIGlmICh3aXRoVGhlbWUgJiYgIW1vcmUudGhlbWUpIHtcbiAgICAgICAgICBtb3JlLnRoZW1lID0gdGhlbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgICAgICByZWY6IGlubmVyUmVmIHx8IHJlZixcbiAgICAgICAgY2xhc3NlczogY2xhc3Nlc1xuICAgICAgfSwgbW9yZSkpO1xuICAgIH0pO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFdpdGhTdHlsZXMucHJvcFR5cGVzID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAgICAgKi9cbiAgICAgIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlIHRoYXQgcHJvcCB0byBwYXNzIGEgcmVmIHRvIHRoZSBkZWNvcmF0ZWQgY29tcG9uZW50LlxuICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAqL1xuICAgICAgaW5uZXJSZWY6IGNoYWluUHJvcFR5cGVzKFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMub2JqZWN0XSksIGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMuaW5uZXJSZWYgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIC8vICAgJ01hdGVyaWFsLVVJOiBUaGUgYGlubmVyUmVmYCBwcm9wIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2NS4gJyArXG4gICAgICAgIC8vICAgICAnUmVmcyBhcmUgbm93IGF1dG9tYXRpY2FsbHkgZm9yd2FyZGVkIHRvIHRoZSBpbm5lciBjb21wb25lbnQuJyxcbiAgICAgICAgLy8gKTtcbiAgICAgIH0pXG4gICAgfSA6IHZvaWQgMDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBXaXRoU3R5bGVzLmRpc3BsYXlOYW1lID0gXCJXaXRoU3R5bGVzKFwiLmNvbmNhdChnZXREaXNwbGF5TmFtZShDb21wb25lbnQpLCBcIilcIik7XG4gICAgfVxuXG4gICAgaG9pc3ROb25SZWFjdFN0YXRpY3MoV2l0aFN0eWxlcywgQ29tcG9uZW50KTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBFeHBvc2VkIGZvciB0ZXN0IHB1cnBvc2VzLlxuICAgICAgV2l0aFN0eWxlcy5OYWtlZCA9IENvbXBvbmVudDtcbiAgICAgIFdpdGhTdHlsZXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICBXaXRoU3R5bGVzLnVzZVN0eWxlcyA9IHVzZVN0eWxlcztcbiAgICB9XG5cbiAgICByZXR1cm4gV2l0aFN0eWxlcztcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXM7IiwiaW1wb3J0IGNyZWF0ZVRoZW1lIGZyb20gJy4vY3JlYXRlVGhlbWUnO1xudmFyIGRlZmF1bHRUaGVtZSA9IGNyZWF0ZVRoZW1lKCk7XG5leHBvcnQgZGVmYXVsdCBkZWZhdWx0VGhlbWU7IiwiaW1wb3J0IHsgdXNlVGhlbWUgYXMgdXNlVGhlbWVXaXRob3V0RGVmYXVsdCB9IGZyb20gJ0BtYXRlcmlhbC11aS9zdHlsZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBkZWZhdWx0VGhlbWUgZnJvbSAnLi9kZWZhdWx0VGhlbWUnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlVGhlbWUoKSB7XG4gIHZhciB0aGVtZSA9IHVzZVRoZW1lV2l0aG91dERlZmF1bHQoKSB8fCBkZWZhdWx0VGhlbWU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VEZWJ1Z1ZhbHVlKHRoZW1lKTtcbiAgfVxuXG4gIHJldHVybiB0aGVtZTtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCB7IHdpdGhTdHlsZXMgYXMgd2l0aFN0eWxlc1dpdGhvdXREZWZhdWx0IH0gZnJvbSAnQG1hdGVyaWFsLXVpL3N0eWxlcyc7XG5pbXBvcnQgZGVmYXVsdFRoZW1lIGZyb20gJy4vZGVmYXVsdFRoZW1lJztcblxuZnVuY3Rpb24gd2l0aFN0eWxlcyhzdHlsZXNPckNyZWF0b3IsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHdpdGhTdHlsZXNXaXRob3V0RGVmYXVsdChzdHlsZXNPckNyZWF0b3IsIF9leHRlbmRzKHtcbiAgICBkZWZhdWx0VGhlbWU6IGRlZmF1bHRUaGVtZVxuICB9LCBvcHRpb25zKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXM7IiwiLyoqIVxuICogQGZpbGVPdmVydmlldyBLaWNrYXNzIGxpYnJhcnkgdG8gY3JlYXRlIGFuZCBwbGFjZSBwb3BwZXJzIG5lYXIgdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnRzLlxuICogQHZlcnNpb24gMS4xNi4xLWx0c1xuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBGZWRlcmljbyBaaXZvbG8gYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgdGltZW91dER1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG9uZ2VyVGltZW91dEJyb3dzZXJzID0gWydFZGdlJywgJ1RyaWRlbnQnLCAnRmlyZWZveCddO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxvbmdlclRpbWVvdXRCcm93c2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChpc0Jyb3dzZXIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKGxvbmdlclRpbWVvdXRCcm93c2Vyc1tpXSkgPj0gMCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufSgpO1xuXG5mdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHdpbmRvdy5Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgZm4oKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG52YXIgc3VwcG9ydHNNaWNyb1Rhc2tzID0gaXNCcm93c2VyICYmIHdpbmRvdy5Qcm9taXNlO1xuXG4vKipcbiogQ3JlYXRlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBtZXRob2QsIHRoYXQncyBhc3luY2hyb25vdXNseSBkZWZlcnJlZFxuKiBidXQgY2FsbGVkIGluIHRoZSBtaW5pbXVtIHRpbWUgcG9zc2libGUuXG4qXG4qIEBtZXRob2RcbiogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuKiBAcmV0dXJucyB7RnVuY3Rpb259XG4qL1xudmFyIGRlYm91bmNlID0gc3VwcG9ydHNNaWNyb1Rhc2tzID8gbWljcm90YXNrRGVib3VuY2UgOiB0YXNrRGVib3VuY2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QW55fSBmdW5jdGlvblRvQ2hlY2sgLSB2YXJpYWJsZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgY3NzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIHJldHVybiBwcm9wZXJ0eSA/IGNzc1twcm9wZXJ0eV0gOiBjc3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyZW50Tm9kZSBvciB0aGUgaG9zdCBvZiB0aGUgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2Nyb2xsaW5nIHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gc2Nyb2xsIHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBSZXR1cm4gYm9keSwgYGdldFNjcm9sbGAgd2lsbCB0YWtlIGNhcmUgdG8gZ2V0IHRoZSBjb3JyZWN0IGBzY3JvbGxUb3BgIGZyb20gaXRcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBzd2l0Y2ggKGVsZW1lbnQubm9kZU5hbWUpIHtcbiAgICBjYXNlICdIVE1MJzpcbiAgICBjYXNlICdCT0RZJzpcbiAgICAgIHJldHVybiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuYm9keTtcbiAgfVxuXG4gIC8vIEZpcmVmb3ggd2FudCB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuXG4gIHZhciBfZ2V0U3R5bGVDb21wdXRlZFByb3AgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dZO1xuXG4gIGlmICgvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZWZlcmVuY2Ugbm9kZSBvZiB0aGUgcmVmZXJlbmNlIG9iamVjdCwgb3IgdGhlIHJlZmVyZW5jZSBvYmplY3QgaXRzZWxmLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHJlZmVyZW5jZSAmJiByZWZlcmVuY2UucmVmZXJlbmNlTm9kZSA/IHJlZmVyZW5jZS5yZWZlcmVuY2VOb2RlIDogcmVmZXJlbmNlO1xufVxuXG52YXIgaXNJRTExID0gaXNCcm93c2VyICYmICEhKHdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUpO1xudmFyIGlzSUUxMCA9IGlzQnJvd3NlciAmJiAvTVNJRSAxMC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge051bWJlcn0gdmVyc2lvbiB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGlzSUVcbiAqL1xuZnVuY3Rpb24gaXNJRSh2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uID09PSAxMSkge1xuICAgIHJldHVybiBpc0lFMTE7XG4gIH1cbiAgaWYgKHZlcnNpb24gPT09IDEwKSB7XG4gICAgcmV0dXJuIGlzSUUxMDtcbiAgfVxuICByZXR1cm4gaXNJRTExIHx8IGlzSUUxMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvZmZzZXQgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICB2YXIgbm9PZmZzZXRQYXJlbnQgPSBpc0lFKDEwKSA/IGRvY3VtZW50LmJvZHkgOiBudWxsO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudCB8fCBudWxsO1xuICAvLyBTa2lwIGhpZGRlbiBlbGVtZW50cyB3aGljaCBkb24ndCBoYXZlIGFuIG9mZnNldFBhcmVudFxuICB3aGlsZSAob2Zmc2V0UGFyZW50ID09PSBub09mZnNldFBhcmVudCAmJiBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykge1xuICAgIG9mZnNldFBhcmVudCA9IChlbGVtZW50ID0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpLm9mZnNldFBhcmVudDtcbiAgfVxuXG4gIHZhciBub2RlTmFtZSA9IG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQubm9kZU5hbWU7XG5cbiAgaWYgKCFub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyAub2Zmc2V0UGFyZW50IHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IFRILCBURCBvciBUQUJMRSBpbiBjYXNlXG4gIC8vIG5vIG9mZnNldFBhcmVudCBpcyBwcmVzZW50LCBJIGhhdGUgdGhpcyBqb2IuLi5cbiAgaWYgKFsnVEgnLCAnVEQnLCAnVEFCTEUnXS5pbmRleE9mKG9mZnNldFBhcmVudC5ub2RlTmFtZSkgIT09IC0xICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbm9kZU5hbWUgPT09ICdIVE1MJyB8fCBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIHJvb3Qgbm9kZSAoZG9jdW1lbnQsIHNoYWRvd0RPTSByb290KSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcm9vdCBub2RlXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldFJvb3Qobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBvZmZzZXQgcGFyZW50IGNvbW1vbiB0byB0aGUgdHdvIHByb3ZpZGVkIG5vZGVzXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQxXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQyXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gY29tbW9uIG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZWxlbWVudDIpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudDEgfHwgIWVsZW1lbnQxLm5vZGVUeXBlIHx8ICFlbGVtZW50MiB8fCAhZWxlbWVudDIubm9kZVR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gSGVyZSB3ZSBtYWtlIHN1cmUgdG8gZ2l2ZSBhcyBcInN0YXJ0XCIgdGhlIGVsZW1lbnQgdGhhdCBjb21lcyBmaXJzdCBpbiB0aGUgRE9NXG4gIHZhciBvcmRlciA9IGVsZW1lbnQxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICB2YXIgc3RhcnQgPSBvcmRlciA/IGVsZW1lbnQxIDogZWxlbWVudDI7XG4gIHZhciBlbmQgPSBvcmRlciA/IGVsZW1lbnQyIDogZWxlbWVudDE7XG5cbiAgLy8gR2V0IGNvbW1vbiBhbmNlc3RvciBjb250YWluZXJcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQsIDApO1xuICByYW5nZS5zZXRFbmQoZW5kLCAwKTtcbiAgdmFyIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgLy8gQm90aCBub2RlcyBhcmUgaW5zaWRlICNkb2N1bWVudFxuXG4gIGlmIChlbGVtZW50MSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgJiYgZWxlbWVudDIgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIHx8IHN0YXJ0LmNvbnRhaW5zKGVuZCkpIHtcbiAgICBpZiAoaXNPZmZzZXRDb250YWluZXIoY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChjb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBvbmUgb2YgdGhlIG5vZGVzIGlzIGluc2lkZSBzaGFkb3dET00sIGZpbmQgd2hpY2ggb25lXG4gIHZhciBlbGVtZW50MXJvb3QgPSBnZXRSb290KGVsZW1lbnQxKTtcbiAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDFyb290Lmhvc3QsIGVsZW1lbnQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGxlZnRgXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbChlbGVtZW50KSB7XG4gIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndG9wJztcblxuICB2YXIgdXBwZXJTaWRlID0gc2lkZSA9PT0gJ3RvcCcgPyAnc2Nyb2xsVG9wJyA6ICdzY3JvbGxMZWZ0JztcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgaHRtbDtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRbdXBwZXJTaWRlXTtcbn1cblxuLypcbiAqIFN1bSBvciBzdWJ0cmFjdCB0aGUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIChsZWZ0IGFuZCB0b3ApIGZyb20gYSBnaXZlbiByZWN0IG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgLSBSZWN0IG9iamVjdCB5b3Ugd2FudCB0byBjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHBhcmFtIHtCb29sZWFufSBzdWJ0cmFjdCAtIHNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHN1YnRyYWN0IHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY3QgLSBUaGUgbW9kaWZpZXIgcmVjdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVNjcm9sbChyZWN0LCBlbGVtZW50KSB7XG4gIHZhciBzdWJ0cmFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gIHZhciBtb2RpZmllciA9IHN1YnRyYWN0ID8gLTEgOiAxO1xuICByZWN0LnRvcCArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZXR1cm4gcmVjdDtcbn1cblxuLypcbiAqIEhlbHBlciB0byBkZXRlY3QgYm9yZGVycyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXG4gKiBSZXN1bHQgb2YgYGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eWAgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIC0gYHhgIG9yIGB5YFxuICogQHJldHVybiB7bnVtYmVyfSBib3JkZXJzIC0gVGhlIGJvcmRlcnMgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpc1xuICovXG5cbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcywgYXhpcykge1xuICB2YXIgc2lkZUEgPSBheGlzID09PSAneCcgPyAnTGVmdCcgOiAnVG9wJztcbiAgdmFyIHNpZGVCID0gc2lkZUEgPT09ICdMZWZ0JyA/ICdSaWdodCcgOiAnQm90dG9tJztcblxuICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQSArICdXaWR0aCddKSArIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUIgKyAnV2lkdGgnXSk7XG59XG5cbmZ1bmN0aW9uIGdldFNpemUoYXhpcywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSkge1xuICByZXR1cm4gTWF0aC5tYXgoYm9keVsnb2Zmc2V0JyArIGF4aXNdLCBib2R5WydzY3JvbGwnICsgYXhpc10sIGh0bWxbJ2NsaWVudCcgKyBheGlzXSwgaHRtbFsnb2Zmc2V0JyArIGF4aXNdLCBodG1sWydzY3JvbGwnICsgYXhpc10sIGlzSUUoMTApID8gcGFyc2VJbnQoaHRtbFsnb2Zmc2V0JyArIGF4aXNdKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnVG9wJyA6ICdMZWZ0JyldKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCcpXSkgOiAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2l6ZXMoZG9jdW1lbnQpIHtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBpc0lFKDEwKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICB9O1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG9mZnNldHMsIHtcbiAgICByaWdodDogb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aCxcbiAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gY2xpZW50IHJlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSB7fTtcblxuICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAvLyBUaGlzIGlzbid0IHJlcHJvZHVjaWJsZSBpbiBJRTEwIGNvbXBhdGliaWxpdHkgbW9kZSBvZiBJRTExXG4gIHRyeSB7XG4gICAgaWYgKGlzSUUoMTApKSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICB3aWR0aDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgfTtcblxuICAvLyBzdWJ0cmFjdCBzY3JvbGxiYXIgc2l6ZSBmcm9tIHNpemVzXG4gIHZhciBzaXplcyA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJyA/IGdldFdpbmRvd1NpemVzKGVsZW1lbnQub3duZXJEb2N1bWVudCkgOiB7fTtcbiAgdmFyIHdpZHRoID0gc2l6ZXMud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCB8fCByZXN1bHQud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBzaXplcy5oZWlnaHQgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQgfHwgcmVzdWx0LmhlaWdodDtcblxuICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIHZhciB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgdmVydFNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd5Jyk7XG5cbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3QocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBpc0lFMTAgPSBpc0lFKDEwKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG5cbiAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICB2YXIgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCk7XG4gIHZhciBib3JkZXJMZWZ0V2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgpO1xuXG4gIC8vIEluIGNhc2VzIHdoZXJlIHRoZSBwYXJlbnQgaXMgZml4ZWQsIHdlIG11c3QgaWdub3JlIG5lZ2F0aXZlIHNjcm9sbCBpbiBvZmZzZXQgY2FsY1xuICBpZiAoZml4ZWRQb3NpdGlvbiAmJiBpc0hUTUwpIHtcbiAgICBwYXJlbnRSZWN0LnRvcCA9IE1hdGgubWF4KHBhcmVudFJlY3QudG9wLCAwKTtcbiAgICBwYXJlbnRSZWN0LmxlZnQgPSBNYXRoLm1heChwYXJlbnRSZWN0LmxlZnQsIDApO1xuICB9XG4gIHZhciBvZmZzZXRzID0gZ2V0Q2xpZW50UmVjdCh7XG4gICAgdG9wOiBjaGlsZHJlblJlY3QudG9wIC0gcGFyZW50UmVjdC50b3AgLSBib3JkZXJUb3BXaWR0aCxcbiAgICBsZWZ0OiBjaGlsZHJlblJlY3QubGVmdCAtIHBhcmVudFJlY3QubGVmdCAtIGJvcmRlckxlZnRXaWR0aCxcbiAgICB3aWR0aDogY2hpbGRyZW5SZWN0LndpZHRoLFxuICAgIGhlaWdodDogY2hpbGRyZW5SZWN0LmhlaWdodFxuICB9KTtcbiAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSAwO1xuICBvZmZzZXRzLm1hcmdpbkxlZnQgPSAwO1xuXG4gIC8vIFN1YnRyYWN0IG1hcmdpbnMgb2YgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgaXQncyBiZWluZyB1c2VkIGFzIHBhcmVudFxuICAvLyB3ZSBkbyB0aGlzIG9ubHkgb24gSFRNTCBiZWNhdXNlIGl0J3MgdGhlIG9ubHkgZWxlbWVudCB0aGF0IGJlaGF2ZXNcbiAgLy8gZGlmZmVyZW50bHkgd2hlbiBtYXJnaW5zIGFyZSBhcHBsaWVkIHRvIGl0LiBUaGUgbWFyZ2lucyBhcmUgaW5jbHVkZWQgaW5cbiAgLy8gdGhlIGJveCBvZiB0aGUgZG9jdW1lbnRFbGVtZW50LCBpbiB0aGUgb3RoZXIgY2FzZXMgbm90LlxuICBpZiAoIWlzSUUxMCAmJiBpc0hUTUwpIHtcbiAgICB2YXIgbWFyZ2luVG9wID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wKTtcbiAgICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQpO1xuXG4gICAgb2Zmc2V0cy50b3AgLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5ib3R0b20gLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5sZWZ0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG4gICAgb2Zmc2V0cy5yaWdodCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuXG4gICAgLy8gQXR0YWNoIG1hcmdpblRvcCBhbmQgbWFyZ2luTGVmdCBiZWNhdXNlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3ZSBtYXkgbmVlZCB0aGVtXG4gICAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gbWFyZ2luTGVmdDtcbiAgfVxuXG4gIGlmIChpc0lFMTAgJiYgIWZpeGVkUG9zaXRpb24gPyBwYXJlbnQuY29udGFpbnMoc2Nyb2xsUGFyZW50KSA6IHBhcmVudCA9PT0gc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgb2Zmc2V0cyA9IGluY2x1ZGVTY3JvbGwob2Zmc2V0cywgcGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUoZWxlbWVudCkge1xuICB2YXIgZXhjbHVkZVNjcm9sbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KGh0bWwuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcblxuICB2YXIgc2Nyb2xsVG9wID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCkgOiAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwsICdsZWZ0JykgOiAwO1xuXG4gIHZhciBvZmZzZXQgPSB7XG4gICAgdG9wOiBzY3JvbGxUb3AgLSByZWxhdGl2ZU9mZnNldC50b3AgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5Ub3AsXG4gICAgbGVmdDogc2Nyb2xsTGVmdCAtIHJlbGF0aXZlT2Zmc2V0LmxlZnQgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5MZWZ0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KG9mZnNldCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvIFwiaXNGaXhlZD9cIlxuICovXG5mdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQocGFyZW50Tm9kZSk7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IHBhcmVudCBvZiBhbiBlbGVtZW50IHRoYXQgaGFzIGEgdHJhbnNmb3JtZWQgcHJvcGVydHkgZGVmaW5lZFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gZmlyc3QgdHJhbnNmb3JtZWQgcGFyZW50IG9yIGRvY3VtZW50RWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudEVsZW1lbnQgfHwgaXNJRSgpKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICB2YXIgZWwgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIHdoaWxlIChlbCAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWwsICd0cmFuc2Zvcm0nKSA9PT0gJ25vbmUnKSB7XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBlbCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZml4ZWRQb3NpdGlvbiAtIElzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuXG4gIHZhciBib3VuZGFyaWVzID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpKTtcblxuICAvLyBIYW5kbGUgdmlld3BvcnQgY2FzZVxuICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICBib3VuZGFyaWVzID0gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gSGFuZGxlIG90aGVyIGNhc2VzIGJhc2VkIG9uIERPTSBlbGVtZW50IHVzZWQgYXMgYm91bmRhcmllc1xuICAgIHZhciBib3VuZGFyaWVzTm9kZSA9IHZvaWQgMDtcbiAgICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKHJlZmVyZW5jZSkpO1xuICAgICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRzID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGJvdW5kYXJpZXNOb2RlLCBvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgdmFyIF9nZXRXaW5kb3dTaXplcyA9IGdldFdpbmRvd1NpemVzKHBvcHBlci5vd25lckRvY3VtZW50KSxcbiAgICAgICAgICBoZWlnaHQgPSBfZ2V0V2luZG93U2l6ZXMuaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoID0gX2dldFdpbmRvd1NpemVzLndpZHRoO1xuXG4gICAgICBib3VuZGFyaWVzLnRvcCArPSBvZmZzZXRzLnRvcCAtIG9mZnNldHMubWFyZ2luVG9wO1xuICAgICAgYm91bmRhcmllcy5ib3R0b20gPSBoZWlnaHQgKyBvZmZzZXRzLnRvcDtcbiAgICAgIGJvdW5kYXJpZXMubGVmdCArPSBvZmZzZXRzLmxlZnQgLSBvZmZzZXRzLm1hcmdpbkxlZnQ7XG4gICAgICBib3VuZGFyaWVzLnJpZ2h0ID0gd2lkdGggKyBvZmZzZXRzLmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBhbGwgdGhlIG90aGVyIERPTSBlbGVtZW50cywgdGhpcyBvbmUgaXMgZ29vZFxuICAgICAgYm91bmRhcmllcyA9IG9mZnNldHM7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmdzXG4gIHBhZGRpbmcgPSBwYWRkaW5nIHx8IDA7XG4gIHZhciBpc1BhZGRpbmdOdW1iZXIgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcic7XG4gIGJvdW5kYXJpZXMubGVmdCArPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5sZWZ0IHx8IDA7XG4gIGJvdW5kYXJpZXMudG9wICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnRvcCB8fCAwO1xuICBib3VuZGFyaWVzLnJpZ2h0IC09IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnJpZ2h0IHx8IDA7XG4gIGJvdW5kYXJpZXMuYm90dG9tIC09IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLmJvdHRvbSB8fCAwO1xuXG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuXG5mdW5jdGlvbiBnZXRBcmVhKF9yZWYpIHtcbiAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuXG4gIHJldHVybiB3aWR0aCAqIGhlaWdodDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBgYXV0b2AgcGxhY2VtZW50IHRvIHRoZSBwbGFjZW1lbnQgd2l0aCBtb3JlXG4gKiBhdmFpbGFibGUgc3BhY2UuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIHJlZlJlY3QsIHBvcHBlciwgcmVmZXJlbmNlLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcblxuICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgdmFyIHJlY3RzID0ge1xuICAgIHRvcDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZlJlY3QudG9wIC0gYm91bmRhcmllcy50b3BcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB3aWR0aDogcmVmUmVjdC5sZWZ0IC0gYm91bmRhcmllcy5sZWZ0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH1cbiAgfTtcblxuICB2YXIgc29ydGVkQXJlYXMgPSBPYmplY3Qua2V5cyhyZWN0cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBrZXlcbiAgICB9LCByZWN0c1trZXldLCB7XG4gICAgICBhcmVhOiBnZXRBcmVhKHJlY3RzW2tleV0pXG4gICAgfSk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hcmVhIC0gYS5hcmVhO1xuICB9KTtcblxuICB2YXIgZmlsdGVyZWRBcmVhcyA9IHNvcnRlZEFyZWFzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHJldHVybiB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHQ7XG4gIH0pO1xuXG4gIHZhciBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMCA/IGZpbHRlcmVkQXJlYXNbMF0ua2V5IDogc29ydGVkQXJlYXNbMF0ua2V5O1xuXG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtFbGVtZW50fSBmaXhlZFBvc2l0aW9uIC0gaXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgdmFyIGNvbW1vbk9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpKTtcbiAgcmV0dXJuIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShyZWZlcmVuY2UsIGNvbW1vbk9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvdXRlciBzaXplcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCAob2Zmc2V0IHNpemUgKyBtYXJnaW5zKVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJTaXplcyhlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgdmFyIHggPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3AgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Cb3R0b20gfHwgMCk7XG4gIHZhciB5ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCB8fCAwKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblJpZ2h0IHx8IDApO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoICsgeSxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgeFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICB2YXIgaGFzaCA9IHsgbGVmdDogJ3JpZ2h0JywgcmlnaHQ6ICdsZWZ0JywgYm90dG9tOiAndG9wJywgdG9wOiAnYm90dG9tJyB9O1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSBDU1MgcG9zaXRpb24gdGhlIFBvcHBlciB3aWxsIGdldCBhcHBsaWVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzIC0gdGhlIHJlZmVyZW5jZSBvZmZzZXRzICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGFjZW1lbnQgLSBvbmUgb2YgdGhlIHZhbGlkIHBsYWNlbWVudCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wcGVyT2Zmc2V0cyhwb3BwZXIsIHJlZmVyZW5jZU9mZnNldHMsIHBsYWNlbWVudCkge1xuICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICAvLyBHZXQgcG9wcGVyIG5vZGUgc2l6ZXNcbiAgdmFyIHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHtcbiAgICB3aWR0aDogcG9wcGVyUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHBvcHBlclJlY3QuaGVpZ2h0XG4gIH07XG5cbiAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICB2YXIgaXNIb3JpeiA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBtYWluU2lkZSA9IGlzSG9yaXogPyAndG9wJyA6ICdsZWZ0JztcbiAgdmFyIHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzZWNvbmRhcnlNZWFzdXJlbWVudCA9ICFpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIHBvcHBlck9mZnNldHNbbWFpblNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1ttYWluU2lkZV0gKyByZWZlcmVuY2VPZmZzZXRzW21lYXN1cmVtZW50XSAvIDIgLSBwb3BwZXJSZWN0W21lYXN1cmVtZW50XSAvIDI7XG4gIGlmIChwbGFjZW1lbnQgPT09IHNlY29uZGFyeVNpZGUpIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSAtIHBvcHBlclJlY3Rbc2Vjb25kYXJ5TWVhc3VyZW1lbnRdO1xuICB9IGVsc2Uge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW2dldE9wcG9zaXRlUGxhY2VtZW50KHNlY29uZGFyeVNpZGUpXTtcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPZmZzZXRzO1xufVxuXG4vKipcbiAqIE1pbWljcyB0aGUgYGZpbmRgIG1ldGhvZCBvZiBBcnJheVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kKGFyciwgY2hlY2spIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kIGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICByZXR1cm4gYXJyLmZpbmQoY2hlY2spO1xuICB9XG5cbiAgLy8gdXNlIGBmaWx0ZXJgIHRvIG9idGFpbiB0aGUgc2FtZSBiZWhhdmlvciBvZiBgZmluZGBcbiAgcmV0dXJuIGFyci5maWx0ZXIoY2hlY2spWzBdO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBwcm9wLCB2YWx1ZSkge1xuICAvLyB1c2UgbmF0aXZlIGZpbmRJbmRleCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChmdW5jdGlvbiAoY3VyKSB7XG4gICAgICByZXR1cm4gY3VyW3Byb3BdID09PSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHVzZSBgZmluZGAgKyBgaW5kZXhPZmAgaWYgYGZpbmRJbmRleGAgaXNuJ3Qgc3VwcG9ydGVkXG4gIHZhciBtYXRjaCA9IGZpbmQoYXJyLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9ialtwcm9wXSA9PT0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gYXJyLmluZGV4T2YobWF0Y2gpO1xufVxuXG4vKipcbiAqIExvb3AgdHJvdWdoIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBhbmQgcnVuIHRoZW0gaW4gb3JkZXIsXG4gKiBlYWNoIG9mIHRoZW0gd2lsbCB0aGVuIGVkaXQgdGhlIGRhdGEgb2JqZWN0LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRzIC0gT3B0aW9uYWwgbW9kaWZpZXIgbmFtZSB1c2VkIGFzIHN0b3BwZXJcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fVxuICovXG5mdW5jdGlvbiBydW5Nb2RpZmllcnMobW9kaWZpZXJzLCBkYXRhLCBlbmRzKSB7XG4gIHZhciBtb2RpZmllcnNUb1J1biA9IGVuZHMgPT09IHVuZGVmaW5lZCA/IG1vZGlmaWVycyA6IG1vZGlmaWVycy5zbGljZSgwLCBmaW5kSW5kZXgobW9kaWZpZXJzLCAnbmFtZScsIGVuZHMpKTtcblxuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmIChtb2RpZmllclsnZnVuY3Rpb24nXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgdmFyIGZuID0gbW9kaWZpZXJbJ2Z1bmN0aW9uJ10gfHwgbW9kaWZpZXIuZm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgaWYgKG1vZGlmaWVyLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIG9mZnNldHMgdG8gbWFrZSB0aGVtIGEgY29tcGxldGUgY2xpZW50UmVjdCBvYmplY3RcbiAgICAgIC8vIHdlIGRvIHRoaXMgYmVmb3JlIGVhY2ggbW9kaWZpZXIgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBvbmUgZG9lc24ndFxuICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG4gICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucmVmZXJlbmNlKTtcblxuICAgICAgZGF0YSA9IGZuKGRhdGEsIG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nXG4gKiB0aGUgbmV3IHN0eWxlLjxiciAvPlxuICogUHJlZmVyIGBzY2hlZHVsZVVwZGF0ZWAgb3ZlciBgdXBkYXRlYCBiZWNhdXNlIG9mIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgLy8gaWYgcG9wcGVyIGlzIGRlc3Ryb3llZCwgZG9uJ3QgcGVyZm9ybSBhbnkgZnVydGhlciB1cGRhdGVcbiAgaWYgKHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IHtcbiAgICBpbnN0YW5jZTogdGhpcyxcbiAgICBzdHlsZXM6IHt9LFxuICAgIGFycm93U3R5bGVzOiB7fSxcbiAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICBmbGlwcGVkOiBmYWxzZSxcbiAgICBvZmZzZXRzOiB7fVxuICB9O1xuXG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyh0aGlzLnN0YXRlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudCh0aGlzLm9wdGlvbnMucGxhY2VtZW50LCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIC8vIHN0b3JlIHRoZSBjb21wdXRlZCBwbGFjZW1lbnQgaW5zaWRlIGBvcmlnaW5hbFBsYWNlbWVudGBcbiAgZGF0YS5vcmlnaW5hbFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuXG4gIGRhdGEucG9zaXRpb25GaXhlZCA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkO1xuXG4gIC8vIGNvbXB1dGUgdGhlIHBvcHBlciBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRQb3BwZXJPZmZzZXRzKHRoaXMucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlci5wb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZSc7XG5cbiAgLy8gcnVuIHRoZSBtb2RpZmllcnNcbiAgZGF0YSA9IHJ1bk1vZGlmaWVycyh0aGlzLm1vZGlmaWVycywgZGF0YSk7XG5cbiAgLy8gdGhlIGZpcnN0IGB1cGRhdGVgIHdpbGwgY2FsbCBgb25DcmVhdGVgIGNhbGxiYWNrXG4gIC8vIHRoZSBvdGhlciBvbmVzIHdpbGwgY2FsbCBgb25VcGRhdGVgIGNhbGxiYWNrXG4gIGlmICghdGhpcy5zdGF0ZS5pc0NyZWF0ZWQpIHtcbiAgICB0aGlzLnN0YXRlLmlzQ3JlYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzLCBtb2RpZmllck5hbWUpIHtcbiAgcmV0dXJuIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIGVuYWJsZWQgPSBfcmVmLmVuYWJsZWQ7XG4gICAgcmV0dXJuIGVuYWJsZWQgJiYgbmFtZSA9PT0gbW9kaWZpZXJOYW1lO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByZWZpeGVkIHN1cHBvcnRlZCBwcm9wZXJ0eSBuYW1lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHkgKGNhbWVsQ2FzZSlcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWZpeGVkIHByb3BlcnR5IChjYW1lbENhc2Ugb3IgUGFzY2FsQ2FzZSwgZGVwZW5kaW5nIG9uIHRoZSB2ZW5kb3IgcHJlZml4KVxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUocHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gIHZhciB1cHBlclByb3AgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgdmFyIHRvQ2hlY2sgPSBwcmVmaXggPyAnJyArIHByZWZpeCArIHVwcGVyUHJvcCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgcG9wcGVyLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkZXN0cm95KCkge1xuICB0aGlzLnN0YXRlLmlzRGVzdHJveWVkID0gdHJ1ZTtcblxuICAvLyB0b3VjaCBET00gb25seSBpZiBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgaXMgZW5hYmxlZFxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQodGhpcy5tb2RpZmllcnMsICdhcHBseVN0eWxlJykpIHtcbiAgICB0aGlzLnBvcHBlci5yZW1vdmVBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50Jyk7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS50b3AgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucmlnaHQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5ib3R0b20gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGVbZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKV0gPSAnJztcbiAgfVxuXG4gIHRoaXMuZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgLy8gcmVtb3ZlIHRoZSBwb3BwZXIgaWYgdXNlciBleHBsaWNpdGx5IGFza2VkIGZvciB0aGUgZGVsZXRpb24gb24gZGVzdHJveVxuICAvLyBkbyBub3QgdXNlIGByZW1vdmVgIGJlY2F1c2UgSUUxMSBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICB0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge1dpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KGVsZW1lbnQpIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IHNjcm9sbFBhcmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogc2Nyb2xsUGFyZW50O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICBpZiAoIWlzQm9keSkge1xuICAgIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhnZXRTY3JvbGxQYXJlbnQodGFyZ2V0LnBhcmVudE5vZGUpLCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpO1xuICB9XG4gIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIG9wdGlvbnMsIHN0YXRlLCB1cGRhdGVCb3VuZCkge1xuICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gdXBkYXRlQm91bmQ7XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHZhciBzY3JvbGxFbGVtZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHJlZmVyZW5jZSk7XG4gIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxFbGVtZW50LCAnc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQsIHN0YXRlLnNjcm9sbFBhcmVudHMpO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIGBvblVwZGF0ZWAgY2FsbGJhY2sgYW55bW9yZSxcbiAqIHVubGVzcyB5b3UgY2FsbCBgdXBkYXRlYCBtZXRob2QgbWFudWFsbHkuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICAgIHRoaXMuc3RhdGUgPSByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5zdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUZWxscyBpZiBhIGdpdmVuIGlucHV0IGlzIGEgbnVtYmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0geyp9IGlucHV0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gbiAhPT0gJycgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgc3R5bGUgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgc3R5bGUgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldFN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHVuaXQgPSAnJztcbiAgICAvLyBhZGQgdW5pdCBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpYyBhbmQgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAgICBpZiAoWyd3aWR0aCcsICdoZWlnaHQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5kZXhPZihwcm9wKSAhPT0gLTEgJiYgaXNOdW1lcmljKHN0eWxlc1twcm9wXSkpIHtcbiAgICAgIHVuaXQgPSAncHgnO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdICsgdW5pdDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBhdHRyaWJ1dGVzIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZXMgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLnN0eWxlcyAtIExpc3Qgb2Ygc3R5bGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuYXR0cmlidXRlcyAtIExpc3Qgb2YgYXR0cmlidXRlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzYW1lIGRhdGEgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoZGF0YSkge1xuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5zdHlsZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyBpbiB0aGlzIHdheSB3ZSBjYW4gbWFrZSB0aGUgM3JkIHBhcnR5IG1vZGlmaWVycyBhZGQgY3VzdG9tIHN0eWxlcyB0byBpdFxuICAvLyBCZSBhd2FyZSwgbW9kaWZpZXJzIGNvdWxkIG92ZXJyaWRlIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhlIHByZXZpb3VzXG4gIC8vIGxpbmVzIG9mIHRoaXMgbW9kaWZpZXIhXG4gIHNldFN0eWxlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5zdHlsZXMpO1xuXG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLmF0dHJpYnV0ZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyB0aGV5IHdpbGwgYmUgc2V0IGFzIEhUTUwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICBzZXRBdHRyaWJ1dGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBkZWZpbmVkIGFuZCBhcnJvd1N0eWxlcyBoYXMgc29tZSBwcm9wZXJ0aWVzXG4gIGlmIChkYXRhLmFycm93RWxlbWVudCAmJiBPYmplY3Qua2V5cyhkYXRhLmFycm93U3R5bGVzKS5sZW5ndGgpIHtcbiAgICBzZXRTdHlsZXMoZGF0YS5hcnJvd0VsZW1lbnQsIGRhdGEuYXJyb3dTdHlsZXMpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogU2V0IHRoZSB4LXBsYWNlbWVudCBhdHRyaWJ1dGUgYmVmb3JlIGV2ZXJ5dGhpbmcgZWxzZSBiZWNhdXNlIGl0IGNvdWxkIGJlIHVzZWRcbiAqIHRvIGFkZCBtYXJnaW5zIHRvIHRoZSBwb3BwZXIgbWFyZ2lucyBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIHRvIGdldCB0aGVcbiAqIGNvcnJlY3QgcG9wcGVyIG9mZnNldHMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGFzIHBvcHBlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBQb3BwZXIuanMgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlT25Mb2FkKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIHN0YXRlKSB7XG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICB2YXIgcmVmZXJlbmNlT2Zmc2V0cyA9IGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICB2YXIgcGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQob3B0aW9ucy5wbGFjZW1lbnQsIHJlZmVyZW5jZU9mZnNldHMsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JywgcGxhY2VtZW50KTtcblxuICAvLyBBcHBseSBgcG9zaXRpb25gIHRvIHBvcHBlciBiZWZvcmUgYW55dGhpbmcgZWxzZSBiZWNhdXNlXG4gIC8vIHdpdGhvdXQgdGhlIHBvc2l0aW9uIGFwcGxpZWQgd2UgY2FuJ3QgZ3VhcmFudGVlIGNvcnJlY3QgY29tcHV0YXRpb25zXG4gIHNldFN0eWxlcyhwb3BwZXIsIHsgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnIH0pO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtCb29sZWFufSBzaG91bGRSb3VuZCAtIElmIHRoZSBvZmZzZXRzIHNob3VsZCBiZSByb3VuZGVkIGF0IGFsbFxuICogQHJldHVybnMge09iamVjdH0gVGhlIHBvcHBlcidzIHBvc2l0aW9uIG9mZnNldHMgcm91bmRlZFxuICpcbiAqIFRoZSB0YWxlIG9mIHBpeGVsLXBlcmZlY3QgcG9zaXRpb25pbmcuIEl0J3Mgc3RpbGwgbm90IDEwMCUgcGVyZmVjdCwgYnV0IGFzXG4gKiBnb29kIGFzIGl0IGNhbiBiZSB3aXRoaW4gcmVhc29uLlxuICogRGlzY3Vzc2lvbiBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9wdWxsLzcxNVxuICpcbiAqIExvdyBEUEkgc2NyZWVucyBjYXVzZSBhIHBvcHBlciB0byBiZSBibHVycnkgaWYgbm90IHVzaW5nIGZ1bGwgcGl4ZWxzIChTYWZhcmlcbiAqIGFzIHdlbGwgb24gSGlnaCBEUEkgc2NyZWVucykuXG4gKlxuICogRmlyZWZveCBwcmVmZXJzIG5vIHJvdW5kaW5nIGZvciBwb3NpdGlvbmluZyBhbmQgZG9lcyBub3QgaGF2ZSBibHVycmluZXNzIG9uXG4gKiBoaWdoIERQSSBzY3JlZW5zLlxuICpcbiAqIE9ubHkgaG9yaXpvbnRhbCBwbGFjZW1lbnQgYW5kIGxlZnQvcmlnaHQgdmFsdWVzIG5lZWQgdG8gYmUgY29uc2lkZXJlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgc2hvdWxkUm91bmQpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4gIHZhciBub1JvdW5kID0gZnVuY3Rpb24gbm9Sb3VuZCh2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgdmFyIHJlZmVyZW5jZVdpZHRoID0gcm91bmQocmVmZXJlbmNlLndpZHRoKTtcbiAgdmFyIHBvcHBlcldpZHRoID0gcm91bmQocG9wcGVyLndpZHRoKTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZGF0YS5wbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIGlzVmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuaW5kZXhPZignLScpICE9PSAtMTtcbiAgdmFyIHNhbWVXaWR0aFBhcml0eSA9IHJlZmVyZW5jZVdpZHRoICUgMiA9PT0gcG9wcGVyV2lkdGggJSAyO1xuICB2YXIgYm90aE9kZFdpZHRoID0gcmVmZXJlbmNlV2lkdGggJSAyID09PSAxICYmIHBvcHBlcldpZHRoICUgMiA9PT0gMTtcblxuICB2YXIgaG9yaXpvbnRhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiBpc1ZlcnRpY2FsIHx8IGlzVmFyaWF0aW9uIHx8IHNhbWVXaWR0aFBhcml0eSA/IHJvdW5kIDogZmxvb3I7XG4gIHZhciB2ZXJ0aWNhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiByb3VuZDtcblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGhvcml6b250YWxUb0ludGVnZXIoYm90aE9kZFdpZHRoICYmICFpc1ZhcmlhdGlvbiAmJiBzaG91bGRSb3VuZCA/IHBvcHBlci5sZWZ0IC0gMSA6IHBvcHBlci5sZWZ0KSxcbiAgICB0b3A6IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci50b3ApLFxuICAgIGJvdHRvbTogdmVydGljYWxUb0ludGVnZXIocG9wcGVyLmJvdHRvbSksXG4gICAgcmlnaHQ6IGhvcml6b250YWxUb0ludGVnZXIocG9wcGVyLnJpZ2h0KVxuICB9O1xufVxuXG52YXIgaXNGaXJlZm94ID0gaXNCcm93c2VyICYmIC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVN0eWxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIHggPSBvcHRpb25zLngsXG4gICAgICB5ID0gb3B0aW9ucy55O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICAvLyBSZW1vdmUgdGhpcyBsZWdhY3kgc3VwcG9ydCBpbiBQb3BwZXIuanMgdjJcblxuICB2YXIgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlJztcbiAgfSkuZ3B1QWNjZWxlcmF0aW9uO1xuICBpZiAobGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBncHVBY2NlbGVyYXRpb25gIG9wdGlvbiBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllciBhbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBQb3BwZXIuanMhJyk7XG4gIH1cbiAgdmFyIGdwdUFjY2VsZXJhdGlvbiA9IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkID8gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIDogb3B0aW9ucy5ncHVBY2NlbGVyYXRpb247XG5cbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBvZmZzZXRQYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG5cbiAgLy8gU3R5bGVzXG4gIHZhciBzdHlsZXMgPSB7XG4gICAgcG9zaXRpb246IHBvcHBlci5wb3NpdGlvblxuICB9O1xuXG4gIHZhciBvZmZzZXRzID0gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPCAyIHx8ICFpc0ZpcmVmb3gpO1xuXG4gIHZhciBzaWRlQSA9IHggPT09ICdib3R0b20nID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgdmFyIHNpZGVCID0geSA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cbiAgLy8gaWYgZ3B1QWNjZWxlcmF0aW9uIGlzIHNldCB0byBgdHJ1ZWAgYW5kIHRyYW5zZm9ybSBpcyBzdXBwb3J0ZWQsXG4gIC8vICB3ZSB1c2UgYHRyYW5zbGF0ZTNkYCB0byBhcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIHBvcHBlciB3ZVxuICAvLyBhdXRvbWF0aWNhbGx5IHVzZSB0aGUgc3VwcG9ydGVkIHByZWZpeGVkIHZlcnNpb24gaWYgbmVlZGVkXG4gIHZhciBwcmVmaXhlZFByb3BlcnR5ID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcblxuICAvLyBub3csIGxldCdzIG1ha2UgYSBzdGVwIGJhY2sgYW5kIGxvb2sgYXQgdGhpcyBjb2RlIGNsb3NlbHkgKHd0Zj8pXG4gIC8vIElmIHRoZSBjb250ZW50IG9mIHRoZSBwb3BwZXIgZ3Jvd3Mgb25jZSBpdCdzIGJlZW4gcG9zaXRpb25lZCwgaXRcbiAgLy8gbWF5IGhhcHBlbiB0aGF0IHRoZSBwb3BwZXIgZ2V0cyBtaXNwbGFjZWQgYmVjYXVzZSBvZiB0aGUgbmV3IGNvbnRlbnRcbiAgLy8gb3ZlcmZsb3dpbmcgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRvIGF2b2lkIHRoaXMgcHJvYmxlbSwgd2UgcHJvdmlkZSB0d28gb3B0aW9ucyAoeCBhbmQgeSksIHdoaWNoIGFsbG93XG4gIC8vIHRoZSBjb25zdW1lciB0byBkZWZpbmUgdGhlIG9mZnNldCBvcmlnaW4uXG4gIC8vIElmIHdlIHBvc2l0aW9uIGEgcG9wcGVyIG9uIHRvcCBvZiBhIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSBjYW4gc2V0XG4gIC8vIGB4YCB0byBgdG9wYCB0byBtYWtlIHRoZSBwb3BwZXIgZ3JvdyB0b3dhcmRzIGl0cyB0b3AgaW5zdGVhZCBvZlxuICAvLyBpdHMgYm90dG9tLlxuICB2YXIgbGVmdCA9IHZvaWQgMCxcbiAgICAgIHRvcCA9IHZvaWQgMDtcbiAgaWYgKHNpZGVBID09PSAnYm90dG9tJykge1xuICAgIC8vIHdoZW4gb2Zmc2V0UGFyZW50IGlzIDxodG1sPiB0aGUgcG9zaXRpb25pbmcgaXMgcmVsYXRpdmUgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuIChleGNsdWRpbmcgdGhlIHNjcm9sbGJhcilcbiAgICAvLyBhbmQgbm90IHRoZSBib3R0b20gb2YgdGhlIGh0bWwgZWxlbWVudFxuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudFJlY3QuaGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRvcCA9IG9mZnNldHMudG9wO1xuICB9XG4gIGlmIChzaWRlQiA9PT0gJ3JpZ2h0Jykge1xuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gLW9mZnNldFBhcmVudFJlY3Qud2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gb2Zmc2V0cy5sZWZ0O1xuICB9XG4gIGlmIChncHVBY2NlbGVyYXRpb24gJiYgcHJlZml4ZWRQcm9wZXJ0eSkge1xuICAgIHN0eWxlc1twcmVmaXhlZFByb3BlcnR5XSA9ICd0cmFuc2xhdGUzZCgnICsgbGVmdCArICdweCwgJyArIHRvcCArICdweCwgMCknO1xuICAgIHN0eWxlc1tzaWRlQV0gPSAwO1xuICAgIHN0eWxlc1tzaWRlQl0gPSAwO1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3Rod2VyaXNlLCB3ZSB1c2UgdGhlIHN0YW5kYXJkIGB0b3BgLCBgbGVmdGAsIGBib3R0b21gIGFuZCBgcmlnaHRgIHByb3BlcnRpZXNcbiAgICB2YXIgaW52ZXJ0VG9wID0gc2lkZUEgPT09ICdib3R0b20nID8gLTEgOiAxO1xuICAgIHZhciBpbnZlcnRMZWZ0ID0gc2lkZUIgPT09ICdyaWdodCcgPyAtMSA6IDE7XG4gICAgc3R5bGVzW3NpZGVBXSA9IHRvcCAqIGludmVydFRvcDtcbiAgICBzdHlsZXNbc2lkZUJdID0gbGVmdCAqIGludmVydExlZnQ7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSBzaWRlQSArICcsICcgKyBzaWRlQjtcbiAgfVxuXG4gIC8vIEF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ3gtcGxhY2VtZW50JzogZGF0YS5wbGFjZW1lbnRcbiAgfTtcblxuICAvLyBVcGRhdGUgYGRhdGFgIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgYXJyb3dTdHlsZXNcbiAgZGF0YS5hdHRyaWJ1dGVzID0gX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIGRhdGEuYXR0cmlidXRlcyk7XG4gIGRhdGEuc3R5bGVzID0gX2V4dGVuZHMoe30sIHN0eWxlcywgZGF0YS5zdHlsZXMpO1xuICBkYXRhLmFycm93U3R5bGVzID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5hcnJvdywgZGF0YS5hcnJvd1N0eWxlcyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgZGVwZW5kcyBmcm9tIGFub3RoZXIgb25lLjxiciAvPlxuICogSXQgY2hlY2tzIGlmIHRoZSBuZWVkZWQgbW9kaWZpZXIgaXMgbGlzdGVkIGFuZCBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzIC0gbGlzdCBvZiBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0aW5nTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RlZE5hbWUgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJSZXF1aXJlZChtb2RpZmllcnMsIHJlcXVlc3RpbmdOYW1lLCByZXF1ZXN0ZWROYW1lKSB7XG4gIHZhciByZXF1ZXN0aW5nID0gZmluZChtb2RpZmllcnMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgPT09IHJlcXVlc3RpbmdOYW1lO1xuICB9KTtcblxuICB2YXIgaXNSZXF1aXJlZCA9ICEhcmVxdWVzdGluZyAmJiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJiBtb2RpZmllci5lbmFibGVkICYmIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlcjtcbiAgfSk7XG5cbiAgaWYgKCFpc1JlcXVpcmVkKSB7XG4gICAgdmFyIF9yZXF1ZXN0aW5nID0gJ2AnICsgcmVxdWVzdGluZ05hbWUgKyAnYCc7XG4gICAgdmFyIHJlcXVlc3RlZCA9ICdgJyArIHJlcXVlc3RlZE5hbWUgKyAnYCc7XG4gICAgY29uc29sZS53YXJuKHJlcXVlc3RlZCArICcgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgJyArIF9yZXF1ZXN0aW5nICsgJyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICcgKyBfcmVxdWVzdGluZyArICchJyk7XG4gIH1cbiAgcmV0dXJuIGlzUmVxdWlyZWQ7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBhcnJvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzJGFycm93O1xuXG4gIC8vIGFycm93IGRlcGVuZHMgb24ga2VlcFRvZ2V0aGVyIGluIG9yZGVyIHRvIHdvcmtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdhcnJvdycsICdrZWVwVG9nZXRoZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGFycm93RWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgYSBzdHJpbmcsIHN1cHBvc2UgaXQncyBhIENTUyBzZWxlY3RvclxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgbm90IGZvdW5kLCBkb24ndCBydW4gdGhlIG1vZGlmaWVyXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgYXJyb3dFbGVtZW50IGlzbid0IGEgcXVlcnkgc2VsZWN0b3Igd2UgbXVzdCBjaGVjayB0aGF0IHRoZVxuICAgIC8vIHByb3ZpZGVkIERPTSBub2RlIGlzIGNoaWxkIG9mIGl0cyBwb3BwZXIgbm9kZVxuICAgIGlmICghZGF0YS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNpZGVDYXBpdGFsaXplZCA9IGlzVmVydGljYWwgPyAnVG9wJyA6ICdMZWZ0JztcbiAgdmFyIHNpZGUgPSBzaWRlQ2FwaXRhbGl6ZWQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGFsdFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICB2YXIgYXJyb3dFbGVtZW50U2l6ZSA9IGdldE91dGVyU2l6ZXMoYXJyb3dFbGVtZW50KVtsZW5dO1xuXG4gIC8vXG4gIC8vIGV4dGVuZHMga2VlcFRvZ2V0aGVyIGJlaGF2aW9yIG1ha2luZyBzdXJlIHRoZSBwb3BwZXIgYW5kIGl0c1xuICAvLyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1bmN0aW9uXG4gIC8vXG5cbiAgLy8gdG9wL2xlZnQgc2lkZVxuICBpZiAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplIDwgcG9wcGVyW3NpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtPSBwb3BwZXJbc2lkZV0gLSAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplKTtcbiAgfVxuICAvLyBib3R0b20vcmlnaHQgc2lkZVxuICBpZiAocmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSA+IHBvcHBlcltvcFNpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSArPSByZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplIC0gcG9wcGVyW29wU2lkZV07XG4gIH1cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG5cbiAgLy8gY29tcHV0ZSBjZW50ZXIgb2YgdGhlIHBvcHBlclxuICB2YXIgY2VudGVyID0gcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW2xlbl0gLyAyIC0gYXJyb3dFbGVtZW50U2l6ZSAvIDI7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgc2lkZVZhbHVlIHVzaW5nIHRoZSB1cGRhdGVkIHBvcHBlciBvZmZzZXRzXG4gIC8vIHRha2UgcG9wcGVyIG1hcmdpbiBpbiBhY2NvdW50IGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGlzIGluZm8gYXZhaWxhYmxlXG4gIHZhciBjc3MgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgcG9wcGVyTWFyZ2luU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydtYXJnaW4nICsgc2lkZUNhcGl0YWxpemVkXSk7XG4gIHZhciBwb3BwZXJCb3JkZXJTaWRlID0gcGFyc2VGbG9hdChjc3NbJ2JvcmRlcicgKyBzaWRlQ2FwaXRhbGl6ZWQgKyAnV2lkdGgnXSk7XG4gIHZhciBzaWRlVmFsdWUgPSBjZW50ZXIgLSBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC0gcG9wcGVyTWFyZ2luU2lkZSAtIHBvcHBlckJvcmRlclNpZGU7XG5cbiAgLy8gcHJldmVudCBhcnJvd0VsZW1lbnQgZnJvbSBiZWluZyBwbGFjZWQgbm90IGNvbnRpZ3VvdXNseSB0byBpdHMgcG9wcGVyXG4gIHNpZGVWYWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHBvcHBlcltsZW5dIC0gYXJyb3dFbGVtZW50U2l6ZSwgc2lkZVZhbHVlKSwgMCk7XG5cbiAgZGF0YS5hcnJvd0VsZW1lbnQgPSBhcnJvd0VsZW1lbnQ7XG4gIGRhdGEub2Zmc2V0cy5hcnJvdyA9IChfZGF0YSRvZmZzZXRzJGFycm93ID0ge30sIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIHNpZGUsIE1hdGgucm91bmQoc2lkZVZhbHVlKSksIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIGFsdFNpZGUsICcnKSwgX2RhdGEkb2Zmc2V0cyRhcnJvdyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgdmFyaWF0aW9uIG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudCB2YXJpYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKSB7XG4gIGlmICh2YXJpYXRpb24gPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdzdGFydCc7XG4gIH0gZWxzZSBpZiAodmFyaWF0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9XG4gIHJldHVybiB2YXJpYXRpb247XG59XG5cbi8qKlxuICogTGlzdCBvZiBhY2NlcHRlZCBwbGFjZW1lbnRzIHRvIHVzZSBhcyB2YWx1ZXMgb2YgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbi48YnIgLz5cbiAqIFZhbGlkIHBsYWNlbWVudHMgYXJlOlxuICogLSBgYXV0b2BcbiAqIC0gYHRvcGBcbiAqIC0gYHJpZ2h0YFxuICogLSBgYm90dG9tYFxuICogLSBgbGVmdGBcbiAqXG4gKiBFYWNoIHBsYWNlbWVudCBjYW4gaGF2ZSBhIHZhcmlhdGlvbiBmcm9tIHRoaXMgbGlzdDpcbiAqIC0gYC1zdGFydGBcbiAqIC0gYC1lbmRgXG4gKlxuICogVmFyaWF0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgZWFzaWx5IGlmIHlvdSB0aGluayBvZiB0aGVtIGFzIHRoZSBsZWZ0IHRvIHJpZ2h0XG4gKiB3cml0dGVuIGxhbmd1YWdlcy4gSG9yaXpvbnRhbGx5IChgdG9wYCBhbmQgYGJvdHRvbWApLCBgc3RhcnRgIGlzIGxlZnQgYW5kIGBlbmRgXG4gKiBpcyByaWdodC48YnIgLz5cbiAqIFZlcnRpY2FsbHkgKGBsZWZ0YCBhbmQgYHJpZ2h0YCksIGBzdGFydGAgaXMgdG9wIGFuZCBgZW5kYCBpcyBib3R0b20uXG4gKlxuICogU29tZSB2YWxpZCBleGFtcGxlcyBhcmU6XG4gKiAtIGB0b3AtZW5kYCAob24gdG9wIG9mIHJlZmVyZW5jZSwgcmlnaHQgYWxpZ25lZClcbiAqIC0gYHJpZ2h0LXN0YXJ0YCAob24gcmlnaHQgb2YgcmVmZXJlbmNlLCB0b3AgYWxpZ25lZClcbiAqIC0gYGJvdHRvbWAgKG9uIGJvdHRvbSwgY2VudGVyZWQpXG4gKiAtIGBhdXRvLWVuZGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIHBsYWNlbWVudHMgPSBbJ2F1dG8tc3RhcnQnLCAnYXV0bycsICdhdXRvLWVuZCcsICd0b3Atc3RhcnQnLCAndG9wJywgJ3RvcC1lbmQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQnLCAncmlnaHQtZW5kJywgJ2JvdHRvbS1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdsZWZ0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnXTtcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG52YXIgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHBsYWNlbWVudCwgcmV0dXJucyBhbGwgdGhlIHN1YnNlcXVlbnQgcGxhY2VtZW50c1xuICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCAtIEEgdmFsaWQgcGxhY2VtZW50IChpdCBhY2NlcHRzIHZhcmlhdGlvbnMpXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IGNvdW50ZXIgLSBTZXQgdG8gdHJ1ZSB0byB3YWxrIHRoZSBwbGFjZW1lbnRzIGNvdW50ZXJjbG9ja3dpc2VcbiAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICovXG5mdW5jdGlvbiBjbG9ja3dpc2UocGxhY2VtZW50KSB7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaW5kZXggPSB2YWxpZFBsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpO1xuICB2YXIgYXJyID0gdmFsaWRQbGFjZW1lbnRzLnNsaWNlKGluZGV4ICsgMSkuY29uY2F0KHZhbGlkUGxhY2VtZW50cy5zbGljZSgwLCBpbmRleCkpO1xuICByZXR1cm4gY291bnRlciA/IGFyci5yZXZlcnNlKCkgOiBhcnI7XG59XG5cbnZhciBCRUhBVklPUlMgPSB7XG4gIEZMSVA6ICdmbGlwJyxcbiAgQ0xPQ0tXSVNFOiAnY2xvY2t3aXNlJyxcbiAgQ09VTlRFUkNMT0NLV0lTRTogJ2NvdW50ZXJjbG9ja3dpc2UnXG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gZmxpcChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGlmIGBpbm5lcmAgbW9kaWZpZXIgaXMgZW5hYmxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBgZmxpcGAgbW9kaWZpZXJcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaW5uZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGEuZmxpcHBlZCAmJiBkYXRhLnBsYWNlbWVudCA9PT0gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgIC8vIHNlZW1zIGxpa2UgZmxpcCBpcyB0cnlpbmcgdG8gbG9vcCwgcHJvYmFibHkgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIG9uIGFueSBvZiB0aGUgZmxpcHBhYmxlIHNpZGVzXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzFdIHx8ICcnO1xuXG4gIHZhciBmbGlwT3JkZXIgPSBbXTtcblxuICBzd2l0Y2ggKG9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBjYXNlIEJFSEFWSU9SUy5GTElQOlxuICAgICAgZmxpcE9yZGVyID0gW3BsYWNlbWVudCwgcGxhY2VtZW50T3Bwb3NpdGVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DT1VOVEVSQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZmxpcE9yZGVyID0gb3B0aW9ucy5iZWhhdmlvcjtcbiAgfVxuXG4gIGZsaXBPcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwLCBpbmRleCkge1xuICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgICB2YXIgcmVmT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICAvLyB1c2luZyBmbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBvdmVybGFwc1JlZiA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IocmVmT2Zmc2V0cy5sZWZ0KSB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKHJlZk9mZnNldHMucmlnaHQpIHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IocmVmT2Zmc2V0cy50b3ApIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IocmVmT2Zmc2V0cy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0xlZnQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IoYm91bmRhcmllcy5sZWZ0KTtcbiAgICB2YXIgb3ZlcmZsb3dzUmlnaHQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKGJvdW5kYXJpZXMucmlnaHQpO1xuICAgIHZhciBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgdmFyIG92ZXJmbG93c0JvdHRvbSA9IGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKGJvdW5kYXJpZXMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NCb3VuZGFyaWVzID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBvdmVyZmxvd3NUb3AgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBvdmVyZmxvd3NCb3R0b207XG5cbiAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICAvLyBmbGlwcyB2YXJpYXRpb24gaWYgcmVmZXJlbmNlIGVsZW1lbnQgb3ZlcmZsb3dzIGJvdW5kYXJpZXNcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbkJ5UmVmID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NSaWdodCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzVG9wIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzQm90dG9tKTtcblxuICAgIC8vIGZsaXBzIHZhcmlhdGlvbiBpZiBwb3BwZXIgY29udGVudCBvdmVyZmxvd3MgYm91bmRhcmllc1xuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50ID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zQnlDb250ZW50ICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzQm90dG9tIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzVG9wKTtcblxuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uID0gZmxpcHBlZFZhcmlhdGlvbkJ5UmVmIHx8IGZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQ7XG5cbiAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcyB8fCBmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAvLyB0aGlzIGJvb2xlYW4gdG8gZGV0ZWN0IGFueSBmbGlwIGxvb3BcbiAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG5cbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgICB2YXJpYXRpb24gPSBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBsYWNlbWVudCA9IHBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG5cbiAgICAgIC8vIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGBwb3NpdGlvbmAsIHdlIHdhbnQgdG8gcHJlc2VydmUgaXQgYWxvbmcgd2l0aFxuICAgICAgLy8gYW55IGFkZGl0aW9uYWwgcHJvcGVydHkgd2UgbWF5IGFkZCBpbiB0aGUgZnV0dXJlXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5wb3BwZXIsIGdldFBvcHBlck9mZnNldHMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KSk7XG5cbiAgICAgIGRhdGEgPSBydW5Nb2RpZmllcnMoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGRhdGEsICdmbGlwJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBrZWVwVG9nZXRoZXIoZGF0YSkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIGlmIChwb3BwZXJbc2lkZV0gPCBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkgLSBwb3BwZXJbbWVhc3VyZW1lbnRdO1xuICB9XG4gIGlmIChwb3BwZXJbb3BTaWRlXSA+IGZsb29yKHJlZmVyZW5jZVtzaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgY29udGFpbmluZyB2YWx1ZSArIHVuaXQgaW50byBhIHB4IHZhbHVlIG51bWJlclxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHN0ciAtIFZhbHVlICsgdW5pdCBzdHJpbmdcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBtZWFzdXJlbWVudCAtIGBoZWlnaHRgIG9yIGB3aWR0aGBcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQHJldHVybnMge051bWJlcnxTdHJpbmd9XG4gKiBWYWx1ZSBpbiBwaXhlbHMsIG9yIG9yaWdpbmFsIHN0cmluZyBpZiBubyB2YWx1ZXMgd2VyZSBleHRyYWN0ZWRcbiAqL1xuZnVuY3Rpb24gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKSB7XG4gIC8vIHNlcGFyYXRlIHZhbHVlIGZyb20gdW5pdFxuICB2YXIgc3BsaXQgPSBzdHIubWF0Y2goLygoPzpcXC18XFwrKT9cXGQqXFwuP1xcZCopKC4qKS8pO1xuICB2YXIgdmFsdWUgPSArc3BsaXRbMV07XG4gIHZhciB1bml0ID0gc3BsaXRbMl07XG5cbiAgLy8gSWYgaXQncyBub3QgYSBudW1iZXIgaXQncyBhbiBvcGVyYXRvciwgSSBndWVzc1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmICh1bml0LmluZGV4T2YoJyUnKSA9PT0gMCkge1xuICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgY2FzZSAnJXAnOlxuICAgICAgICBlbGVtZW50ID0gcG9wcGVyT2Zmc2V0cztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICclJzpcbiAgICAgIGNhc2UgJyVyJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnQgPSByZWZlcmVuY2VPZmZzZXRzO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdChlbGVtZW50KTtcbiAgICByZXR1cm4gcmVjdFttZWFzdXJlbWVudF0gLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh1bml0ID09PSAndmgnIHx8IHVuaXQgPT09ICd2dycpIHtcbiAgICAvLyBpZiBpcyBhIHZoIG9yIHZ3LCB3ZSBjYWxjdWxhdGUgdGhlIHNpemUgYmFzZWQgb24gdGhlIHZpZXdwb3J0XG4gICAgdmFyIHNpemUgPSB2b2lkIDA7XG4gICAgaWYgKHVuaXQgPT09ICd2aCcpIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIGlzIGFuIGV4cGxpY2l0IHBpeGVsIHVuaXQsIHdlIGdldCByaWQgb2YgdGhlIHVuaXQgYW5kIGtlZXAgdGhlIHZhbHVlXG4gICAgLy8gaWYgaXMgYW4gaW1wbGljaXQgdW5pdCwgaXQncyBweCwgYW5kIHdlIHJldHVybiBqdXN0IHRoZSB2YWx1ZVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGBvZmZzZXRgIHN0cmluZyB0byBleHRyYXBvbGF0ZSBgeGAgYW5kIGB5YCBudW1lcmljIG9mZnNldHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gb2Zmc2V0XG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBiYXNlUGxhY2VtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl9IGEgdHdvIGNlbGxzIGFycmF5IHdpdGggeCBhbmQgeSBvZmZzZXRzIGluIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzLCBiYXNlUGxhY2VtZW50KSB7XG4gIHZhciBvZmZzZXRzID0gWzAsIDBdO1xuXG4gIC8vIFVzZSBoZWlnaHQgaWYgcGxhY2VtZW50IGlzIGxlZnQgb3IgcmlnaHQgYW5kIGluZGV4IGlzIDAgb3RoZXJ3aXNlIHVzZSB3aWR0aFxuICAvLyBpbiB0aGlzIHdheSB0aGUgZmlyc3Qgb2Zmc2V0IHdpbGwgdXNlIGFuIGF4aXMgYW5kIHRoZSBzZWNvbmQgb25lXG4gIC8vIHdpbGwgdXNlIHRoZSBvdGhlciBvbmVcbiAgdmFyIHVzZUhlaWdodCA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIC8vIFNwbGl0IHRoZSBvZmZzZXQgc3RyaW5nIHRvIG9idGFpbiBhIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kc1xuICAvLyBUaGUgcmVnZXggYWRkcmVzc2VzIHZhbHVlcyB3aXRoIHRoZSBwbHVzIG9yIG1pbnVzIHNpZ24gaW4gZnJvbnQgKCsxMCwgLTIwLCBldGMpXG4gIHZhciBmcmFnbWVudHMgPSBvZmZzZXQuc3BsaXQoLyhcXCt8XFwtKS8pLm1hcChmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnRyaW0oKTtcbiAgfSk7XG5cbiAgLy8gRGV0ZWN0IGlmIHRoZSBvZmZzZXQgc3RyaW5nIGNvbnRhaW5zIGEgcGFpciBvZiB2YWx1ZXMgb3IgYSBzaW5nbGUgb25lXG4gIC8vIHRoZXkgY291bGQgYmUgc2VwYXJhdGVkIGJ5IGNvbW1hIG9yIHNwYWNlXG4gIHZhciBkaXZpZGVyID0gZnJhZ21lbnRzLmluZGV4T2YoZmluZChmcmFnbWVudHMsIGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcuc2VhcmNoKC8sfFxccy8pICE9PSAtMTtcbiAgfSkpO1xuXG4gIGlmIChmcmFnbWVudHNbZGl2aWRlcl0gJiYgZnJhZ21lbnRzW2RpdmlkZXJdLmluZGV4T2YoJywnKSA9PT0gLTEpIHtcbiAgICBjb25zb2xlLndhcm4oJ09mZnNldHMgc2VwYXJhdGVkIGJ5IHdoaXRlIHNwYWNlKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgYSBjb21tYSAoLCkgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIC8vIElmIGRpdmlkZXIgaXMgZm91bmQsIHdlIGRpdmlkZSB0aGUgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzIHRvIGRpdmlkZVxuICAvLyB0aGVtIGJ5IG9mc2V0IFggYW5kIFkuXG4gIHZhciBzcGxpdFJlZ2V4ID0gL1xccyosXFxzKnxcXHMrLztcbiAgdmFyIG9wcyA9IGRpdmlkZXIgIT09IC0xID8gW2ZyYWdtZW50cy5zbGljZSgwLCBkaXZpZGVyKS5jb25jYXQoW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVswXV0pLCBbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzFdXS5jb25jYXQoZnJhZ21lbnRzLnNsaWNlKGRpdmlkZXIgKyAxKSldIDogW2ZyYWdtZW50c107XG5cbiAgLy8gQ29udmVydCB0aGUgdmFsdWVzIHdpdGggdW5pdHMgdG8gYWJzb2x1dGUgcGl4ZWxzIHRvIGFsbG93IG91ciBjb21wdXRhdGlvbnNcbiAgb3BzID0gb3BzLm1hcChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgLy8gTW9zdCBvZiB0aGUgdW5pdHMgcmVseSBvbiB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHBvcHBlclxuICAgIHZhciBtZWFzdXJlbWVudCA9IChpbmRleCA9PT0gMSA/ICF1c2VIZWlnaHQgOiB1c2VIZWlnaHQpID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgIHJldHVybiBvcFxuICAgIC8vIFRoaXMgYWdncmVnYXRlcyBhbnkgYCtgIG9yIGAtYCBzaWduIHRoYXQgYXJlbid0IGNvbnNpZGVyZWQgb3BlcmF0b3JzXG4gICAgLy8gZS5nLjogMTAgKyArNSA9PiBbMTAsICssICs1XVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhW2EubGVuZ3RoIC0gMV0gPT09ICcnICYmIFsnKycsICctJ10uaW5kZXhPZihiKSAhPT0gLTEpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdID0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSBpZiAobWVyZ2VXaXRoUHJldmlvdXMpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdICs9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfVxuICAgIH0sIFtdKVxuICAgIC8vIEhlcmUgd2UgY29udmVydCB0aGUgc3RyaW5nIHZhbHVlcyBpbnRvIG51bWJlciB2YWx1ZXMgKGluIHB4KVxuICAgIC5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIExvb3AgdHJvdWdoIHRoZSBvZmZzZXRzIGFycmF5cyBhbmQgZXhlY3V0ZSB0aGUgb3BlcmF0aW9uc1xuICBvcHMuZm9yRWFjaChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgb3AuZm9yRWFjaChmdW5jdGlvbiAoZnJhZywgaW5kZXgyKSB7XG4gICAgICBpZiAoaXNOdW1lcmljKGZyYWcpKSB7XG4gICAgICAgIG9mZnNldHNbaW5kZXhdICs9IGZyYWcgKiAob3BbaW5kZXgyIC0gMV0gPT09ICctJyA/IC0xIDogMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAYXJndW1lbnQge051bWJlcnxTdHJpbmd9IG9wdGlvbnMub2Zmc2V0PTBcbiAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBvZmZzZXQoZGF0YSwgX3JlZikge1xuICB2YXIgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudCxcbiAgICAgIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgdmFyIG9mZnNldHMgPSB2b2lkIDA7XG4gIGlmIChpc051bWVyaWMoK29mZnNldCkpIHtcbiAgICBvZmZzZXRzID0gWytvZmZzZXQsIDBdO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldHMgPSBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlciwgcmVmZXJlbmNlLCBiYXNlUGxhY2VtZW50KTtcbiAgfVxuXG4gIGlmIChiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzFdO1xuICB9XG5cbiAgZGF0YS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgYm91bmRhcmllc0VsZW1lbnQgPSBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50IHx8IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG5cbiAgLy8gSWYgb2Zmc2V0UGFyZW50IGlzIHRoZSByZWZlcmVuY2UgZWxlbWVudCwgd2UgcmVhbGx5IHdhbnQgdG9cbiAgLy8gZ28gb25lIHN0ZXAgdXAgYW5kIHVzZSB0aGUgbmV4dCBvZmZzZXRQYXJlbnQgYXMgcmVmZXJlbmNlIHRvXG4gIC8vIGF2b2lkIHRvIG1ha2UgdGhpcyBtb2RpZmllciBjb21wbGV0ZWx5IHVzZWxlc3MgYW5kIGxvb2sgbGlrZSBicm9rZW5cbiAgaWYgKGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlID09PSBib3VuZGFyaWVzRWxlbWVudCkge1xuICAgIGJvdW5kYXJpZXNFbGVtZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGJvdW5kYXJpZXNFbGVtZW50KTtcbiAgfVxuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXNldHMgdGhlIHBvcHBlcidzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIGRvY3VtZW50IHNpemUgY2FuIGJlIGNhbGN1bGF0ZWQgZXhjbHVkaW5nXG4gIC8vIHRoZSBzaXplIG9mIHRoZSBwb3BwZXIgZWxlbWVudCBpdHNlbGZcbiAgdmFyIHRyYW5zZm9ybVByb3AgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuICB2YXIgcG9wcGVyU3R5bGVzID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIuc3R5bGU7IC8vIGFzc2lnbm1lbnQgdG8gaGVscCBtaW5pZmljYXRpb25cbiAgdmFyIHRvcCA9IHBvcHBlclN0eWxlcy50b3AsXG4gICAgICBsZWZ0ID0gcG9wcGVyU3R5bGVzLmxlZnQsXG4gICAgICB0cmFuc2Zvcm0gPSBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF07XG5cbiAgcG9wcGVyU3R5bGVzLnRvcCA9ICcnO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9ICcnO1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSAnJztcblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXN0b3JlcyB0aGUgb3JpZ2luYWwgc3R5bGUgcHJvcGVydGllcyBhZnRlciB0aGUgb2Zmc2V0cyBoYXZlIGJlZW4gY29tcHV0ZWRcbiAgcG9wcGVyU3R5bGVzLnRvcCA9IHRvcDtcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSBsZWZ0O1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm07XG5cbiAgb3B0aW9ucy5ib3VuZGFyaWVzID0gYm91bmRhcmllcztcblxuICB2YXIgb3JkZXIgPSBvcHRpb25zLnByaW9yaXR5O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICB2YXIgY2hlY2sgPSB7XG4gICAgcHJpbWFyeTogZnVuY3Rpb24gcHJpbWFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlcltwbGFjZW1lbnRdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdIDwgYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1heChwb3BwZXJbcGxhY2VtZW50XSwgYm91bmRhcmllc1twbGFjZW1lbnRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgcGxhY2VtZW50LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZWNvbmRhcnk6IGZ1bmN0aW9uIHNlY29uZGFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciBtYWluU2lkZSA9IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW21haW5TaWRlXTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA+IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4ocG9wcGVyW21haW5TaWRlXSwgYm91bmRhcmllc1twbGFjZW1lbnRdIC0gKHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/IHBvcHBlci53aWR0aCA6IHBvcHBlci5oZWlnaHQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgbWFpblNpZGUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgdmFyIHNpZGUgPSBbJ2xlZnQnLCAndG9wJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMSA/ICdwcmltYXJ5JyA6ICdzZWNvbmRhcnknO1xuICAgIHBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIGNoZWNrW3NpZGVdKHBsYWNlbWVudCkpO1xuICB9KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gcG9wcGVyO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBzaGlmdChkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHNoaWZ0dmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgLy8gaWYgc2hpZnQgc2hpZnR2YXJpYXRpb24gaXMgc3BlY2lmaWVkLCBydW4gdGhlIG1vZGlmaWVyXG4gIGlmIChzaGlmdHZhcmlhdGlvbikge1xuICAgIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXI7XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsnYm90dG9tJywgJ3RvcCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuICAgIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgICB2YXIgc2hpZnRPZmZzZXRzID0ge1xuICAgICAgc3RhcnQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0pLFxuICAgICAgZW5kOiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW21lYXN1cmVtZW50XSAtIHBvcHBlclttZWFzdXJlbWVudF0pXG4gICAgfTtcblxuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBzaGlmdE9mZnNldHNbc2hpZnR2YXJpYXRpb25dKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaGlkZShkYXRhKSB7XG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaGlkZScsICdwcmV2ZW50T3ZlcmZsb3cnKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHJlZlJlY3QgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgYm91bmQgPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ3ByZXZlbnRPdmVyZmxvdyc7XG4gIH0pLmJvdW5kYXJpZXM7XG5cbiAgaWYgKHJlZlJlY3QuYm90dG9tIDwgYm91bmQudG9wIHx8IHJlZlJlY3QubGVmdCA+IGJvdW5kLnJpZ2h0IHx8IHJlZlJlY3QudG9wID4gYm91bmQuYm90dG9tIHx8IHJlZlJlY3QucmlnaHQgPCBib3VuZC5sZWZ0KSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gdHJ1ZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSBmYWxzZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGlubmVyKGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzSG9yaXogPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgc3VidHJhY3RMZW5ndGggPSBbJ3RvcCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA9PT0gLTE7XG5cbiAgcG9wcGVyW2lzSG9yaXogPyAnbGVmdCcgOiAndG9wJ10gPSByZWZlcmVuY2VbYmFzZVBsYWNlbWVudF0gLSAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAqIHRvIGl0cyBgZm5gIHByb3BlcnR5LjxiciAvPlxuICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLCB0aGlzIG1lYW5zIHRoYXQgeW91IG11c3RcbiAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAqXG4gKiBAZnVuY3Rpb24gTW9kaWZpZXJGblxuICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcnMgYXJlIHBsdWdpbnMgdXNlZCB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgeW91ciBwb3BwZXJzLjxiciAvPlxuICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICogbmVlZGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICpcbiAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICogQWxsIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGFyZSBjb25maWd1cmF0aW9ucyB0aGF0IGNvdWxkIGJlIHR3ZWFrZWQuXG4gKiBAbmFtZXNwYWNlIG1vZGlmaWVyc1xuICovXG52YXIgbW9kaWZpZXJzID0ge1xuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZVxuICAgKiBlbGVtZW50LjxiciAvPlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIHZhcmlhdGlvbiBvZiB0aGUgYHBsYWNlbWVudGAgcHJvcGVydHkuPGJyIC8+XG4gICAqIEl0IGNhbiBiZSBvbmUgZWl0aGVyIGAtZW5kYCBvciBgLXN0YXJ0YC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHNoaWZ0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTEwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogc2hpZnRcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGBvZmZzZXRgIG1vZGlmaWVyIGNhbiBzaGlmdCB5b3VyIHBvcHBlciBvbiBib3RoIGl0cyBheGlzLlxuICAgKlxuICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAqIC0gYHB4YCBvciB1bml0LWxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGBoZWlnaHRgLlxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBzaW5nbGUgdmFsdWUgKGFzIGBOdW1iZXJgIG9yIGBTdHJpbmdgKSwgb3IgYSBwYWlyIG9mIHZhbHVlc1xuICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAqIFRoZSBsYXR0ZXIgaXMgYSBkZXByZWNhdGVkIG1ldGhvZCBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZ1c2lvbiBhbmQgd2lsbCBiZVxuICAgKiByZW1vdmVkIGluIHYyLjxiciAvPlxuICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAqIE5vdGUgdGhhdCBtdWx0aXBsaWNhdGlvbnMgYW5kIGRpdmlzaW9ucyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIGBgYFxuICAgKiAxMFxuICAgKiAnMTAlJ1xuICAgKiAnMTAsIDEwJ1xuICAgKiAnMTAlLCAxMCdcbiAgICogJzEwICsgMTAlJ1xuICAgKiAnMTAgLSA1dmggKyAzJSdcbiAgICogJy0xMHB4ICsgNXZoLCA1cHggLSA2JSdcbiAgICogYGBgXG4gICAqID4gKipOQioqOiBJZiB5b3UgZGVzaXJlIHRvIGFwcGx5IG9mZnNldHMgdG8geW91ciBwb3BwZXJzIGluIGEgd2F5IHRoYXQgbWF5IG1ha2UgdGhlbSBvdmVybGFwXG4gICAqID4gd2l0aCB0aGVpciByZWZlcmVuY2UgZWxlbWVudCwgdW5mb3J0dW5hdGVseSwgeW91IHdpbGwgaGF2ZSB0byBkaXNhYmxlIHRoZSBgZmxpcGAgbW9kaWZpZXIuXG4gICAqID4gWW91IGNhbiByZWFkIG1vcmUgb24gdGhpcyBhdCB0aGlzIFtpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzM3MykuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBvZmZzZXQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBvZmZzZXQsXG4gICAgLyoqIEBwcm9wIHtOdW1iZXJ8U3RyaW5nfSBvZmZzZXQ9MFxuICAgICAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIG9mZnNldDogMFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHByZXZlbnQgdGhlIHBvcHBlciBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgb3V0c2lkZSB0aGUgYm91bmRhcnkuXG4gICAqXG4gICAqIEEgc2NlbmFyaW8gZXhpc3RzIHdoZXJlIHRoZSByZWZlcmVuY2UgaXRzZWxmIGlzIG5vdCB3aXRoaW4gdGhlIGJvdW5kYXJpZXMuPGJyIC8+XG4gICAqIFdlIGNhbiBzYXkgaXQgaGFzIFwiZXNjYXBlZCB0aGUgYm91bmRhcmllc1wiIOKAlCBvciBqdXN0IFwiZXNjYXBlZFwiLjxiciAvPlxuICAgKiBJbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBkZWNpZGUgd2hldGhlciB0aGUgcG9wcGVyIHNob3VsZCBlaXRoZXI6XG4gICAqXG4gICAqIC0gZGV0YWNoIGZyb20gdGhlIHJlZmVyZW5jZSBhbmQgcmVtYWluIFwidHJhcHBlZFwiIGluIHRoZSBib3VuZGFyaWVzLCBvclxuICAgKiAtIGlmIGl0IHNob3VsZCBpZ25vcmUgdGhlIGJvdW5kYXJ5IGFuZCBcImVzY2FwZSB3aXRoIGl0cyByZWZlcmVuY2VcIlxuICAgKlxuICAgKiBXaGVuIGBlc2NhcGVXaXRoUmVmZXJlbmNlYCBpcyBzZXQgdG9gdHJ1ZWAgYW5kIHJlZmVyZW5jZSBpcyBjb21wbGV0ZWx5XG4gICAqIG91dHNpZGUgaXRzIGJvdW5kYXJpZXMsIHRoZSBwb3BwZXIgd2lsbCBvdmVyZmxvdyAob3IgY29tcGxldGVseSBsZWF2ZSlcbiAgICogdGhlIGJvdW5kYXJpZXMgaW4gb3JkZXIgdG8gcmVtYWluIGF0dGFjaGVkIHRvIHRoZSBlZGdlIG9mIHRoZSByZWZlcmVuY2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAzMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gICAgLyoqXG4gICAgICogQHByb3Age0FycmF5fSBbcHJpb3JpdHk9WydsZWZ0JywncmlnaHQnLCd0b3AnLCdib3R0b20nXV1cbiAgICAgKiBQb3BwZXIgd2lsbCB0cnkgdG8gcHJldmVudCBvdmVyZmxvdyBmb2xsb3dpbmcgdGhlc2UgcHJpb3JpdGllcyBieSBkZWZhdWx0LFxuICAgICAqIHRoZW4sIGl0IGNvdWxkIG92ZXJmbG93IG9uIHRoZSBsZWZ0IGFuZCBvbiB0b3Agb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwcmlvcml0eTogWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBBbW91bnQgb2YgcGl4ZWwgdXNlZCB0byBkZWZpbmUgYSBtaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvdW5kYXJpZXNcbiAgICAgKiBhbmQgdGhlIHBvcHBlci4gVGhpcyBtYWtlcyBzdXJlIHRoZSBwb3BwZXIgYWx3YXlzIGhhcyBhIGxpdHRsZSBwYWRkaW5nXG4gICAgICogYmV0d2VlbiB0aGUgZWRnZXMgb2YgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3Njcm9sbFBhcmVudCdcbiAgICAgKiBCb3VuZGFyaWVzIHVzZWQgYnkgdGhlIG1vZGlmaWVyLiBDYW4gYmUgYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgLFxuICAgICAqIGB2aWV3cG9ydGAgb3IgYW55IERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlIGFuZCBpdHMgcG9wcGVyIHN0YXkgbmVhciBlYWNoIG90aGVyXG4gICAqIHdpdGhvdXQgbGVhdmluZyBhbnkgZ2FwIGJldHdlZW4gdGhlIHR3by4gRXNwZWNpYWxseSB1c2VmdWwgd2hlbiB0aGUgYXJyb3cgaXNcbiAgICogZW5hYmxlZCBhbmQgeW91IHdhbnQgdG8gZW5zdXJlIHRoYXQgaXQgcG9pbnRzIHRvIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogSXQgY2FyZXMgb25seSBhYm91dCB0aGUgZmlyc3QgYXhpcy4gWW91IGNhbiBzdGlsbCBoYXZlIHBvcHBlcnMgd2l0aCBtYXJnaW5cbiAgICogYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBrZWVwVG9nZXRoZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NDAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBrZWVwVG9nZXRoZXJcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtb2RpZmllciBpcyB1c2VkIHRvIG1vdmUgdGhlIGBhcnJvd0VsZW1lbnRgIG9mIHRoZSBwb3BwZXIgdG8gbWFrZVxuICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICogSXQgd2lsbCByZWFkIHRoZSBvdXRlciBzaXplIG9mIHRoZSBgYXJyb3dFbGVtZW50YCBub2RlIHRvIGRldGVjdCBob3cgbWFueVxuICAgKiBwaXhlbHMgb2YgY29uanVuY3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBvcHBlcidzIHBsYWNlbWVudCB3aGVuIGl0IHN0YXJ0cyB0byBvdmVybGFwIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudC5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKlxuICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICogcmVzdGFydCBpdCBpZiBpdCBkZXRlY3RzIHRoZSBuZWVkIHRvIGZsaXAgdGhlIHBsYWNlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGZsaXA6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA2MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBmbGlwLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8QXJyYXl9IGJlaGF2aW9yPSdmbGlwJ1xuICAgICAqIFRoZSBiZWhhdmlvciB1c2VkIHRvIGNoYW5nZSB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LiBJdCBjYW4gYmUgb25lIG9mXG4gICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICogcGxhY2VtZW50cyAod2l0aCBvcHRpb25hbCB2YXJpYXRpb25zKVxuICAgICAqL1xuICAgIGJlaGF2aW9yOiAnZmxpcCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogVGhlIHBvcHBlciB3aWxsIGZsaXAgaWYgaXQgaGl0cyB0aGUgZWRnZXMgb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSd2aWV3cG9ydCdcbiAgICAgKiBUaGUgZWxlbWVudCB3aGljaCB3aWxsIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcG9wcGVyIHBvc2l0aW9uLlxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgZGVmaW5lZCBib3VuZGFyaWVzXG4gICAgICogKGV4Y2VwdCBpZiBga2VlcFRvZ2V0aGVyYCBpcyBlbmFibGVkKVxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAndmlld3BvcnQnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBmbGlwVmFyaWF0aW9ucz1mYWxzZVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBzd2l0Y2ggcGxhY2VtZW50IHZhcmlhdGlvbiBiZXR3ZWVuIGAtc3RhcnRgIGFuZCBgLWVuZGAgd2hlblxuICAgICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudCBvdmVybGFwcyBpdHMgYm91bmRhcmllcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAqL1xuICAgIGZsaXBWYXJpYXRpb25zOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQ9ZmFsc2VcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgc3dpdGNoIHBsYWNlbWVudCB2YXJpYXRpb24gYmV0d2VlbiBgLXN0YXJ0YCBhbmQgYC1lbmRgIHdoZW5cbiAgICAgKiB0aGUgcG9wcGVyIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIHJlZmVyZW5jZSBib3VuZGFyaWVzLlxuICAgICAqXG4gICAgICogVGhlIG9yaWdpbmFsIHBsYWNlbWVudCBzaG91bGQgaGF2ZSBhIHNldCB2YXJpYXRpb24uXG4gICAgICovXG4gICAgZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQ6IGZhbHNlXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSB0aGUgcG9wcGVyIGZsb3cgdG93YXJkIHRoZSBpbm5lciBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEJ5IGRlZmF1bHQsIHdoZW4gdGhpcyBtb2RpZmllciBpcyBkaXNhYmxlZCwgdGhlIHBvcHBlciB3aWxsIGJlIHBsYWNlZCBvdXRzaWRlXG4gICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGlubmVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTcwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD1mYWxzZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBpbm5lclxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGhpZGUgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXRzaWRlIG9mIHRoZVxuICAgKiBwb3BwZXIgYm91bmRhcmllcy4gSXQgd2lsbCBzZXQgYSBgeC1vdXQtb2YtYm91bmRhcmllc2AgYXR0cmlidXRlIHdoaWNoIGNhblxuICAgKiBiZSB1c2VkIHRvIGhpZGUgd2l0aCBhIENTUyBzZWxlY3RvciB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBpc1xuICAgKiBvdXQgb2YgYm91bmRhcmllcy5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaGlkZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDgwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGhpZGVcbiAgfSxcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHN0eWxlIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgZWxlbWVudCB0byBnZXRzXG4gICAqIHByb3Blcmx5IHBvc2l0aW9uZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1vZGlmaWVyIHdpbGwgbm90IHRvdWNoIHRoZSBET00sIGl0IGp1c3QgcHJlcGFyZXMgdGhlIHN0eWxlc1xuICAgKiBzbyB0aGF0IGBhcHBseVN0eWxlYCBtb2RpZmllciBjYW4gYXBwbHkgaXQuIFRoaXMgc2VwYXJhdGlvbiBpcyB1c2VmdWxcbiAgICogaW4gY2FzZSB5b3UgbmVlZCB0byByZXBsYWNlIGBhcHBseVN0eWxlYCB3aXRoIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBUaGlzIG1vZGlmaWVyIGhhcyBgODUwYCBhcyBgb3JkZXJgIHZhbHVlIHRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICogd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBQb3BwZXIuanMuIEV4cGVjdCB0aGUgbW9kaWZpZXJzIG9yZGVyaW5nIG1ldGhvZFxuICAgKiB0byBjaGFuZ2UgaW4gZnV0dXJlIG1ham9yIHZlcnNpb25zIG9mIHRoZSBsaWJyYXJ5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgY29tcHV0ZVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTg1MCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODUwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogY29tcHV0ZVN0eWxlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nYm90dG9tJ11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGBib3R0b21gXG4gICAgICovXG4gICAgeDogJ2JvdHRvbScsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2xlZnQnXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYHJpZ2h0YFxuICAgICAqL1xuICAgIHk6ICdyaWdodCdcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICpcbiAgICogQWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyBhcmUgbGltaXRlZCB0byB0aGlzIG1vZGlmaWVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAqIHdhbnQgdG8gZGVsZWdhdGUgYWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyB0byBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogaGFzIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGFic29sdXRlYCBiZWZvcmUgUG9wcGVyLmpzIGNhbiBkbyBpdHMgd29yayFcbiAgICpcbiAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3VyIG93biB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIGVmZmVjdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFwcGx5U3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9OTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA5MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcHBseVN0eWxlLFxuICAgIC8qKiBAcHJvcCB7RnVuY3Rpb259ICovXG4gICAgb25Mb2FkOiBhcHBseVN0eWxlT25Mb2FkLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xMC4wLCB0aGUgcHJvcGVydHkgbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXJcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHVuZGVmaW5lZFxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBgZGF0YU9iamVjdGAgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvcm1hdGlvbiB1c2VkIGJ5IFBvcHBlci5qcy5cbiAqIFRoaXMgb2JqZWN0IGlzIHBhc3NlZCB0byBtb2RpZmllcnMgYW5kIHRvIHRoZSBgb25DcmVhdGVgIGFuZCBgb25VcGRhdGVgIGNhbGxiYWNrcy5cbiAqIEBuYW1lIGRhdGFPYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmluc3RhbmNlIFRoZSBQb3BwZXIuanMgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLnBsYWNlbWVudCBQbGFjZW1lbnQgYXBwbGllZCB0byBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50IFBsYWNlbWVudCBvcmlnaW5hbGx5IGRlZmluZWQgb24gaW5pdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmZsaXBwZWQgVHJ1ZSBpZiBwb3BwZXIgaGFzIGJlZW4gZmxpcHBlZCBieSBmbGlwIG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuaGlkZSBUcnVlIGlmIHRoZSByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXQgb2YgYm91bmRhcmllcywgdXNlZnVsIHRvIGtub3cgd2hlbiB0byBoaWRlIHRoZSBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGRhdGEuYXJyb3dFbGVtZW50IE5vZGUgdXNlZCBhcyBhcnJvdyBieSBhcnJvdyBtb2RpZmllclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuc3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYXJyb3dTdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgYXJyb3cuIEl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5ib3VuZGFyaWVzIE9mZnNldHMgb2YgdGhlIHBvcHBlciBib3VuZGFyaWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzIFRoZSBtZWFzdXJlbWVudHMgb2YgcG9wcGVyLCByZWZlcmVuY2UgYW5kIGFycm93IGVsZW1lbnRzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnBvcHBlciBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucmVmZXJlbmNlIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5hcnJvd10gYHRvcGAgYW5kIGBsZWZ0YCBvZmZzZXRzLCBvbmx5IG9uZSBvZiB0aGVtIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gMFxuICovXG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkIHRvIFBvcHBlci5qcyBjb25zdHJ1Y3Rvci48YnIgLz5cbiAqIFRoZXNlIGNhbiBiZSBvdmVycmlkZGVuIHVzaW5nIHRoZSBgb3B0aW9uc2AgYXJndW1lbnQgb2YgUG9wcGVyLmpzLjxiciAvPlxuICogVG8gb3ZlcnJpZGUgYW4gb3B0aW9uLCBzaW1wbHkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZVxuICogc3RydWN0dXJlIG9mIHRoZSBgb3B0aW9uc2Agb2JqZWN0LCBhcyB0aGUgM3JkIGFyZ3VtZW50LiBGb3IgZXhhbXBsZTpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWYsIHBvcCwge1xuICogICBtb2RpZmllcnM6IHtcbiAqICAgICBwcmV2ZW50T3ZlcmZsb3c6IHsgZW5hYmxlZDogZmFsc2UgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgRGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBQb3BwZXIncyBwbGFjZW1lbnQuXG4gICAqIEBwcm9wIHtQb3BwZXIucGxhY2VtZW50c30gcGxhY2VtZW50PSdib3R0b20nXG4gICAqL1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyB0byB0cnVlIGlmIHlvdSB3YW50IHBvcHBlciB0byBwb3NpdGlvbiBpdCBzZWxmIGluICdmaXhlZCcgbW9kZVxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcG9zaXRpb25GaXhlZD1mYWxzZVxuICAgKi9cbiAgcG9zaXRpb25GaXhlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZXZlbnRzIChyZXNpemUsIHNjcm9sbCkgYXJlIGluaXRpYWxseSBlbmFibGVkLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gZXZlbnRzRW5hYmxlZD10cnVlXG4gICAqL1xuICBldmVudHNFbmFibGVkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgcG9wcGVyIHdoZW5cbiAgICogeW91IGNhbGwgdGhlIGBkZXN0cm95YCBtZXRob2QuXG4gICAqIEBwcm9wIHtCb29sZWFufSByZW1vdmVPbkRlc3Ryb3k9ZmFsc2VcbiAgICovXG4gIHJlbW92ZU9uRGVzdHJveTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgY3JlYXRlZC48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25DcmVhdGV9XG4gICAqL1xuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoKSB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanMuXG4gICAqIEBwcm9wIHttb2RpZmllcnN9XG4gICAqL1xuICBtb2RpZmllcnM6IG1vZGlmaWVyc1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgb25DcmVhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9uVXBkYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vLyBVdGlsc1xuLy8gTWV0aG9kc1xudmFyIFBvcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUG9wcGVyLmpzIGluc3RhbmNlLlxuICAgKiBAY2xhc3MgUG9wcGVyXG4gICAqIEBwYXJhbSB7RWxlbWVudHxyZWZlcmVuY2VPYmplY3R9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCAvIFhNTCBlbGVtZW50IHVzZWQgYXMgdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFlvdXIgY3VzdG9tIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIG9uZXMgZGVmaW5lZCBpbiBbRGVmYXVsdHNdKCNkZWZhdWx0cylcbiAgICogQHJldHVybiB7T2JqZWN0fSBpbnN0YW5jZSAtIFRoZSBnZW5lcmF0ZWQgUG9wcGVyLmpzIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcHBlcik7XG5cbiAgICB0aGlzLnNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy51cGRhdGUpO1xuICAgIH07XG5cbiAgICAvLyBtYWtlIHVwZGF0ZSgpIGRlYm91bmNlZCwgc28gdGhhdCBpdCBvbmx5IHJ1bnMgYXQgbW9zdCBvbmNlLXBlci10aWNrXG4gICAgdGhpcy51cGRhdGUgPSBkZWJvdW5jZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHdpdGgge30gd2UgY3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIGluc2lkZSBpdFxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgLy8gaW5pdCBzdGF0ZVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgICBpc0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgc2Nyb2xsUGFyZW50czogW11cbiAgICB9O1xuXG4gICAgLy8gZ2V0IHJlZmVyZW5jZSBhbmQgcG9wcGVyIGVsZW1lbnRzIChhbGxvdyBqUXVlcnkgd3JhcHBlcnMpXG4gICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLmpxdWVyeSA/IHJlZmVyZW5jZVswXSA6IHJlZmVyZW5jZTtcbiAgICB0aGlzLnBvcHBlciA9IHBvcHBlciAmJiBwb3BwZXIuanF1ZXJ5ID8gcG9wcGVyWzBdIDogcG9wcGVyO1xuXG4gICAgLy8gRGVlcCBtZXJnZSBtb2RpZmllcnMgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVycywgb3B0aW9ucy5tb2RpZmllcnMpKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzW25hbWVdIHx8IHt9LCBvcHRpb25zLm1vZGlmaWVycyA/IG9wdGlvbnMubW9kaWZpZXJzW25hbWVdIDoge30pO1xuICAgIH0pO1xuXG4gICAgLy8gUmVmYWN0b3JpbmcgbW9kaWZpZXJzJyBsaXN0IChPYmplY3QgPT4gQXJyYXkpXG4gICAgdGhpcy5tb2RpZmllcnMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMubW9kaWZpZXJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0sIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdKTtcbiAgICB9KVxuICAgIC8vIHNvcnQgdGhlIG1vZGlmaWVycyBieSBvcmRlclxuICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgfSk7XG5cbiAgICAvLyBtb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIHdoZW4gUG9wcGVyLmpzIGdldCBpbml0ZWRcbiAgICAvLyBzdWNoIGNvZGUgaXMgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgb2YgaXRzIG1vZGlmaWVyXG4gICAgLy8gdGhleSBjb3VsZCBhZGQgbmV3IHByb3BlcnRpZXMgdG8gdGhlaXIgb3B0aW9ucyBjb25maWd1cmF0aW9uXG4gICAgLy8gQkUgQVdBUkU6IGRvbid0IGFkZCBvcHRpb25zIHRvIGBvcHRpb25zLm1vZGlmaWVycy5uYW1lYCBidXQgdG8gYG1vZGlmaWVyT3B0aW9uc2AhXG4gICAgdGhpcy5tb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJPcHRpb25zKSB7XG4gICAgICBpZiAobW9kaWZpZXJPcHRpb25zLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihtb2RpZmllck9wdGlvbnMub25Mb2FkKSkge1xuICAgICAgICBtb2RpZmllck9wdGlvbnMub25Mb2FkKF90aGlzLnJlZmVyZW5jZSwgX3RoaXMucG9wcGVyLCBfdGhpcy5vcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIF90aGlzLnN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGZpcmUgdGhlIGZpcnN0IHVwZGF0ZSB0byBwb3NpdGlvbiB0aGUgcG9wcGVyIGluIHRoZSByaWdodCBwbGFjZVxuICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICB2YXIgZXZlbnRzRW5hYmxlZCA9IHRoaXMub3B0aW9ucy5ldmVudHNFbmFibGVkO1xuICAgIGlmIChldmVudHNFbmFibGVkKSB7XG4gICAgICAvLyBzZXR1cCBldmVudCBsaXN0ZW5lcnMsIHRoZXkgd2lsbCB0YWtlIGNhcmUgb2YgdXBkYXRlIHRoZSBwb3NpdGlvbiBpbiBzcGVjaWZpYyBzaXR1YXRpb25zXG4gICAgICB0aGlzLmVuYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkID0gZXZlbnRzRW5hYmxlZDtcbiAgfVxuXG4gIC8vIFdlIGNhbid0IHVzZSBjbGFzcyBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBkb24ndCBnZXQgbGlzdGVkIGluIHRoZVxuICAvLyBjbGFzcyBwcm90b3R5cGUgYW5kIGJyZWFrIHN0dWZmIGxpa2UgU2lub24gc3R1YnNcblxuXG4gIGNyZWF0ZUNsYXNzKFBvcHBlciwgW3tcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUkJDEoKSB7XG4gICAgICByZXR1cm4gdXBkYXRlLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3kkJDEoKSB7XG4gICAgICByZXR1cm4gZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZW5hYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIHVwZGF0ZS4gSXQgd2lsbCBydW4gb24gdGhlIG5leHQgVUkgdXBkYXRlIGF2YWlsYWJsZS5cbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAgICpcbiAgICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gUG9wcGVyO1xufSgpO1xuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuICogQG5hbWUgcmVmZXJlbmNlT2JqZWN0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkYXRhLmdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZXQgb2YgY29vcmRpbmF0ZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBuYXRpdmUgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgbWV0aG9kLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50V2lkdGhcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgd2lkdGggb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRIZWlnaHRcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgaGVpZ2h0IG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG5cblxuUG9wcGVyLlV0aWxzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKS5Qb3BwZXJVdGlscztcblBvcHBlci5wbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblBvcHBlci5EZWZhdWx0cyA9IERlZmF1bHRzO1xuXG5leHBvcnQgZGVmYXVsdCBQb3BwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3BwZXIuanMubWFwXG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZXByZWNhdGVkUHJvcFR5cGUodmFsaWRhdG9yLCByZWFzb24pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWVTYWZlID0gY29tcG9uZW50TmFtZSB8fCAnPDxhbm9ueW1vdXM+Pic7XG4gICAgdmFyIHByb3BGdWxsTmFtZVNhZmUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICBpZiAodHlwZW9mIHByb3BzW3Byb3BOYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJUaGUgXCIuY29uY2F0KGxvY2F0aW9uLCBcIiBgXCIpLmNvbmNhdChwcm9wRnVsbE5hbWVTYWZlLCBcImAgb2YgXCIpICsgXCJgXCIuY29uY2F0KGNvbXBvbmVudE5hbWVTYWZlLCBcImAgaXMgZGVwcmVjYXRlZC4gXCIpLmNvbmNhdChyZWFzb24pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn0iLCIvLyBUT0RPIHY1OiBjb25zaWRlciB0byBtYWtlIGl0IHByaXZhdGVcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldFJlZihyZWYsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKHZhbHVlKTtcbiAgfSBlbHNlIGlmIChyZWYpIHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9XG59IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHNldFJlZiBmcm9tICcuL3NldFJlZic7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VGb3JrUmVmKHJlZkEsIHJlZkIpIHtcbiAgLyoqXG4gICAqIFRoaXMgd2lsbCBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gaWYgdGhlIHJlZiBwcm9wcyBjaGFuZ2UgYW5kIGFyZSBkZWZpbmVkLlxuICAgKiBUaGlzIG1lYW5zIHJlYWN0IHdpbGwgY2FsbCB0aGUgb2xkIGZvcmtSZWYgd2l0aCBgbnVsbGAgYW5kIHRoZSBuZXcgZm9ya1JlZlxuICAgKiB3aXRoIHRoZSByZWYuIENsZWFudXAgbmF0dXJhbGx5IGVtZXJnZXMgZnJvbSB0aGlzIGJlaGF2aW9yXG4gICAqL1xuICByZXR1cm4gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJlZkEgPT0gbnVsbCAmJiByZWZCID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAocmVmVmFsdWUpIHtcbiAgICAgIHNldFJlZihyZWZBLCByZWZWYWx1ZSk7XG4gICAgICBzZXRSZWYocmVmQiwgcmVmVmFsdWUpO1xuICAgIH07XG4gIH0sIFtyZWZBLCByZWZCXSk7XG59IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBleGFjdFByb3AsIEhUTUxFbGVtZW50VHlwZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgZGVwcmVjYXRlZFByb3BUeXBlIGZyb20gJy4uL3V0aWxzL2RlcHJlY2F0ZWRQcm9wVHlwZSc7XG5pbXBvcnQgc2V0UmVmIGZyb20gJy4uL3V0aWxzL3NldFJlZic7XG5pbXBvcnQgdXNlRm9ya1JlZiBmcm9tICcuLi91dGlscy91c2VGb3JrUmVmJztcblxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyKGNvbnRhaW5lcikge1xuICBjb250YWluZXIgPSB0eXBlb2YgY29udGFpbmVyID09PSAnZnVuY3Rpb24nID8gY29udGFpbmVyKCkgOiBjb250YWluZXI7IC8vICNTdHJpY3RNb2RlIHJlYWR5XG5cbiAgcmV0dXJuIFJlYWN0RE9NLmZpbmRET01Ob2RlKGNvbnRhaW5lcik7XG59XG5cbnZhciB1c2VFbmhhbmNlZEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuLyoqXG4gKiBQb3J0YWxzIHByb3ZpZGUgYSBmaXJzdC1jbGFzcyB3YXkgdG8gcmVuZGVyIGNoaWxkcmVuIGludG8gYSBET00gbm9kZVxuICogdGhhdCBleGlzdHMgb3V0c2lkZSB0aGUgRE9NIGhpZXJhcmNoeSBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqL1xuXG52YXIgUG9ydGFsID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gUG9ydGFsKHByb3BzLCByZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjb250YWluZXIgPSBwcm9wcy5jb250YWluZXIsXG4gICAgICBfcHJvcHMkZGlzYWJsZVBvcnRhbCA9IHByb3BzLmRpc2FibGVQb3J0YWwsXG4gICAgICBkaXNhYmxlUG9ydGFsID0gX3Byb3BzJGRpc2FibGVQb3J0YWwgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVQb3J0YWwsXG4gICAgICBvblJlbmRlcmVkID0gcHJvcHMub25SZW5kZXJlZDtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUobnVsbCksXG4gICAgICBtb3VudE5vZGUgPSBfUmVhY3QkdXNlU3RhdGVbMF0sXG4gICAgICBzZXRNb3VudE5vZGUgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIGhhbmRsZVJlZiA9IHVzZUZvcmtSZWYoIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBjaGlsZHJlbi5yZWYgOiBudWxsLCByZWYpO1xuICB1c2VFbmhhbmNlZEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFkaXNhYmxlUG9ydGFsKSB7XG4gICAgICBzZXRNb3VudE5vZGUoZ2V0Q29udGFpbmVyKGNvbnRhaW5lcikgfHwgZG9jdW1lbnQuYm9keSk7XG4gICAgfVxuICB9LCBbY29udGFpbmVyLCBkaXNhYmxlUG9ydGFsXSk7XG4gIHVzZUVuaGFuY2VkRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobW91bnROb2RlICYmICFkaXNhYmxlUG9ydGFsKSB7XG4gICAgICBzZXRSZWYocmVmLCBtb3VudE5vZGUpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0UmVmKHJlZiwgbnVsbCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sIFtyZWYsIG1vdW50Tm9kZSwgZGlzYWJsZVBvcnRhbF0pO1xuICB1c2VFbmhhbmNlZEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG9uUmVuZGVyZWQgJiYgKG1vdW50Tm9kZSB8fCBkaXNhYmxlUG9ydGFsKSkge1xuICAgICAgb25SZW5kZXJlZCgpO1xuICAgIH1cbiAgfSwgW29uUmVuZGVyZWQsIG1vdW50Tm9kZSwgZGlzYWJsZVBvcnRhbF0pO1xuXG4gIGlmIChkaXNhYmxlUG9ydGFsKSB7XG4gICAgaWYgKCAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChjaGlsZHJlbiwge1xuICAgICAgICByZWY6IGhhbmRsZVJlZlxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgcmV0dXJuIG1vdW50Tm9kZSA/IC8qI19fUFVSRV9fKi9SZWFjdERPTS5jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIG1vdW50Tm9kZSkgOiBtb3VudE5vZGU7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFBvcnRhbC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBUaGUgY2hpbGRyZW4gdG8gcmVuZGVyIGludG8gdGhlIGBjb250YWluZXJgLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBBIEhUTUwgZWxlbWVudCwgY29tcG9uZW50IGluc3RhbmNlLCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgZWl0aGVyLlxuICAgKiBUaGUgYGNvbnRhaW5lcmAgd2lsbCBoYXZlIHRoZSBwb3J0YWwgY2hpbGRyZW4gYXBwZW5kZWQgdG8gaXQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGl0IHVzZXMgdGhlIGJvZHkgb2YgdGhlIHRvcC1sZXZlbCBkb2N1bWVudCBvYmplY3QsXG4gICAqIHNvIGl0J3Mgc2ltcGx5IGBkb2N1bWVudC5ib2R5YCBtb3N0IG9mIHRoZSB0aW1lLlxuICAgKi9cbiAgY29udGFpbmVyOiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAub25lT2ZUeXBlKFtIVE1MRWxlbWVudFR5cGUsIFByb3BUeXBlcy5pbnN0YW5jZU9mKFJlYWN0LkNvbXBvbmVudCksIFByb3BUeXBlcy5mdW5jXSksXG5cbiAgLyoqXG4gICAqIERpc2FibGUgdGhlIHBvcnRhbCBiZWhhdmlvci5cbiAgICogVGhlIGNoaWxkcmVuIHN0YXkgd2l0aGluIGl0J3MgcGFyZW50IERPTSBoaWVyYXJjaHkuXG4gICAqL1xuICBkaXNhYmxlUG9ydGFsOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgb25jZSB0aGUgY2hpbGRyZW4gaGFzIGJlZW4gbW91bnRlZCBpbnRvIHRoZSBgY29udGFpbmVyYC5cbiAgICpcbiAgICogVGhpcyBwcm9wIHdpbGwgYmUgcmVtb3ZlZCBpbiB2NSwgdGhlIHJlZiBjYW4gYmUgdXNlZCBpbnN0ZWFkLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHJlZiBpbnN0ZWFkLlxuICAgKi9cbiAgb25SZW5kZXJlZDogZGVwcmVjYXRlZFByb3BUeXBlKFByb3BUeXBlcy5mdW5jLCAnVXNlIHRoZSByZWYgaW5zdGVhZC4nKVxufSA6IHZvaWQgMDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIFBvcnRhbFsncHJvcFR5cGVzJyArICcnXSA9IGV4YWN0UHJvcChQb3J0YWwucHJvcFR5cGVzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9ydGFsOyIsIi8qKlxuICogU2FmZSBjaGFpbmVkIGZ1bmN0aW9uXG4gKlxuICogV2lsbCBvbmx5IGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBpZiBuZWVkZWQsXG4gKiBvdGhlcndpc2Ugd2lsbCBwYXNzIGJhY2sgZXhpc3RpbmcgZnVuY3Rpb25zIG9yIG51bGwuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY3Rpb25zIHRvIGNoYWluXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb258bnVsbH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3MucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGZ1bmMpIHtcbiAgICBpZiAoZnVuYyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTWF0ZXJpYWwtVUk6IEludmFsaWQgQXJndW1lbnQgVHlwZSwgbXVzdCBvbmx5IHByb3ZpZGUgZnVuY3Rpb25zLCB1bmRlZmluZWQsIG9yIG51bGwuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIGFjYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfSwgZnVuY3Rpb24gKCkge30pO1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUG9wcGVySnMgZnJvbSAncG9wcGVyLmpzJztcbmltcG9ydCB7IGNoYWluUHJvcFR5cGVzLCByZWZUeXBlLCBIVE1MRWxlbWVudFR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IHsgdXNlVGhlbWUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvc3R5bGVzJztcbmltcG9ydCBQb3J0YWwgZnJvbSAnLi4vUG9ydGFsJztcbmltcG9ydCBjcmVhdGVDaGFpbmVkRnVuY3Rpb24gZnJvbSAnLi4vdXRpbHMvY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uJztcbmltcG9ydCBzZXRSZWYgZnJvbSAnLi4vdXRpbHMvc2V0UmVmJztcbmltcG9ydCB1c2VGb3JrUmVmIGZyb20gJy4uL3V0aWxzL3VzZUZvcmtSZWYnO1xuXG5mdW5jdGlvbiBmbGlwUGxhY2VtZW50KHBsYWNlbWVudCwgdGhlbWUpIHtcbiAgdmFyIGRpcmVjdGlvbiA9IHRoZW1lICYmIHRoZW1lLmRpcmVjdGlvbiB8fCAnbHRyJztcblxuICBpZiAoZGlyZWN0aW9uID09PSAnbHRyJykge1xuICAgIHJldHVybiBwbGFjZW1lbnQ7XG4gIH1cblxuICBzd2l0Y2ggKHBsYWNlbWVudCkge1xuICAgIGNhc2UgJ2JvdHRvbS1lbmQnOlxuICAgICAgcmV0dXJuICdib3R0b20tc3RhcnQnO1xuXG4gICAgY2FzZSAnYm90dG9tLXN0YXJ0JzpcbiAgICAgIHJldHVybiAnYm90dG9tLWVuZCc7XG5cbiAgICBjYXNlICd0b3AtZW5kJzpcbiAgICAgIHJldHVybiAndG9wLXN0YXJ0JztcblxuICAgIGNhc2UgJ3RvcC1zdGFydCc6XG4gICAgICByZXR1cm4gJ3RvcC1lbmQnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwbGFjZW1lbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5jaG9yRWwoYW5jaG9yRWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBhbmNob3JFbCA9PT0gJ2Z1bmN0aW9uJyA/IGFuY2hvckVsKCkgOiBhbmNob3JFbDtcbn1cblxudmFyIHVzZUVuaGFuY2VkRWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG52YXIgZGVmYXVsdFBvcHBlck9wdGlvbnMgPSB7fTtcbi8qKlxuICogUG9wcGVycyByZWx5IG9uIHRoZSAzcmQgcGFydHkgbGlicmFyeSBbUG9wcGVyLmpzXShodHRwczovL3BvcHBlci5qcy5vcmcvZG9jcy92MS8pIGZvciBwb3NpdGlvbmluZy5cbiAqL1xuXG52YXIgUG9wcGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gUG9wcGVyKHByb3BzLCByZWYpIHtcbiAgdmFyIGFuY2hvckVsID0gcHJvcHMuYW5jaG9yRWwsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY29udGFpbmVyID0gcHJvcHMuY29udGFpbmVyLFxuICAgICAgX3Byb3BzJGRpc2FibGVQb3J0YWwgPSBwcm9wcy5kaXNhYmxlUG9ydGFsLFxuICAgICAgZGlzYWJsZVBvcnRhbCA9IF9wcm9wcyRkaXNhYmxlUG9ydGFsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlUG9ydGFsLFxuICAgICAgX3Byb3BzJGtlZXBNb3VudGVkID0gcHJvcHMua2VlcE1vdW50ZWQsXG4gICAgICBrZWVwTW91bnRlZCA9IF9wcm9wcyRrZWVwTW91bnRlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMka2VlcE1vdW50ZWQsXG4gICAgICBtb2RpZmllcnMgPSBwcm9wcy5tb2RpZmllcnMsXG4gICAgICBvcGVuID0gcHJvcHMub3BlbixcbiAgICAgIF9wcm9wcyRwbGFjZW1lbnQgPSBwcm9wcy5wbGFjZW1lbnQsXG4gICAgICBpbml0aWFsUGxhY2VtZW50ID0gX3Byb3BzJHBsYWNlbWVudCA9PT0gdm9pZCAwID8gJ2JvdHRvbScgOiBfcHJvcHMkcGxhY2VtZW50LFxuICAgICAgX3Byb3BzJHBvcHBlck9wdGlvbnMgPSBwcm9wcy5wb3BwZXJPcHRpb25zLFxuICAgICAgcG9wcGVyT3B0aW9ucyA9IF9wcm9wcyRwb3BwZXJPcHRpb25zID09PSB2b2lkIDAgPyBkZWZhdWx0UG9wcGVyT3B0aW9ucyA6IF9wcm9wcyRwb3BwZXJPcHRpb25zLFxuICAgICAgcG9wcGVyUmVmUHJvcCA9IHByb3BzLnBvcHBlclJlZixcbiAgICAgIHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICBfcHJvcHMkdHJhbnNpdGlvbiA9IHByb3BzLnRyYW5zaXRpb24sXG4gICAgICB0cmFuc2l0aW9uID0gX3Byb3BzJHRyYW5zaXRpb24gPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJHRyYW5zaXRpb24sXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYW5jaG9yRWxcIiwgXCJjaGlsZHJlblwiLCBcImNvbnRhaW5lclwiLCBcImRpc2FibGVQb3J0YWxcIiwgXCJrZWVwTW91bnRlZFwiLCBcIm1vZGlmaWVyc1wiLCBcIm9wZW5cIiwgXCJwbGFjZW1lbnRcIiwgXCJwb3BwZXJPcHRpb25zXCIsIFwicG9wcGVyUmVmXCIsIFwic3R5bGVcIiwgXCJ0cmFuc2l0aW9uXCJdKTtcblxuICB2YXIgdG9vbHRpcFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIG93blJlZiA9IHVzZUZvcmtSZWYodG9vbHRpcFJlZiwgcmVmKTtcbiAgdmFyIHBvcHBlclJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIGhhbmRsZVBvcHBlclJlZiA9IHVzZUZvcmtSZWYocG9wcGVyUmVmLCBwb3BwZXJSZWZQcm9wKTtcbiAgdmFyIGhhbmRsZVBvcHBlclJlZlJlZiA9IFJlYWN0LnVzZVJlZihoYW5kbGVQb3BwZXJSZWYpO1xuICB1c2VFbmhhbmNlZEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaGFuZGxlUG9wcGVyUmVmUmVmLmN1cnJlbnQgPSBoYW5kbGVQb3BwZXJSZWY7XG4gIH0sIFtoYW5kbGVQb3BwZXJSZWZdKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShwb3BwZXJSZWZQcm9wLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBvcHBlclJlZi5jdXJyZW50O1xuICB9LCBbXSk7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKHRydWUpLFxuICAgICAgZXhpdGVkID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgc2V0RXhpdGVkID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIHZhciBydGxQbGFjZW1lbnQgPSBmbGlwUGxhY2VtZW50KGluaXRpYWxQbGFjZW1lbnQsIHRoZW1lKTtcbiAgLyoqXG4gICAqIHBsYWNlbWVudCBpbml0aWFsaXplZCBmcm9tIHByb3AgYnV0IGNhbiBjaGFuZ2UgZHVyaW5nIGxpZmV0aW1lIGlmIG1vZGlmaWVycy5mbGlwLlxuICAgKiBtb2RpZmllcnMuZmxpcCBpcyBlc3NlbnRpYWxseSBhIGZsaXAgZm9yIGNvbnRyb2xsZWQvdW5jb250cm9sbGVkIGJlaGF2aW9yXG4gICAqL1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUyID0gUmVhY3QudXNlU3RhdGUocnRsUGxhY2VtZW50KSxcbiAgICAgIHBsYWNlbWVudCA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRQbGFjZW1lbnQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHBvcHBlclJlZi5jdXJyZW50KSB7XG4gICAgICBwb3BwZXJSZWYuY3VycmVudC51cGRhdGUoKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgaGFuZGxlT3BlbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRvb2x0aXBSZWYuY3VycmVudCB8fCAhYW5jaG9yRWwgfHwgIW9wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocG9wcGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIHBvcHBlclJlZi5jdXJyZW50LmRlc3Ryb3koKTtcbiAgICAgIGhhbmRsZVBvcHBlclJlZlJlZi5jdXJyZW50KG51bGwpO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVQb3BwZXJVcGRhdGUgPSBmdW5jdGlvbiBoYW5kbGVQb3BwZXJVcGRhdGUoZGF0YSkge1xuICAgICAgc2V0UGxhY2VtZW50KGRhdGEucGxhY2VtZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmVkQW5jaG9yRWwgPSBnZXRBbmNob3JFbChhbmNob3JFbCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHJlc29sdmVkQW5jaG9yRWwgJiYgcmVzb2x2ZWRBbmNob3JFbC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICB2YXIgYm94ID0gcmVzb2x2ZWRBbmNob3JFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJiBib3gudG9wID09PSAwICYmIGJveC5sZWZ0ID09PSAwICYmIGJveC5yaWdodCA9PT0gMCAmJiBib3guYm90dG9tID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFsnTWF0ZXJpYWwtVUk6IFRoZSBgYW5jaG9yRWxgIHByb3AgcHJvdmlkZWQgdG8gdGhlIGNvbXBvbmVudCBpcyBpbnZhbGlkLicsICdUaGUgYW5jaG9yIGVsZW1lbnQgc2hvdWxkIGJlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGxheW91dC4nLCBcIk1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyBwcmVzZW50IGluIHRoZSBkb2N1bWVudCBvciB0aGF0IGl0J3Mgbm90IGRpc3BsYXkgbm9uZS5cIl0uam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBvcHBlciA9IG5ldyBQb3BwZXJKcyhnZXRBbmNob3JFbChhbmNob3JFbCksIHRvb2x0aXBSZWYuY3VycmVudCwgX2V4dGVuZHMoe1xuICAgICAgcGxhY2VtZW50OiBydGxQbGFjZW1lbnRcbiAgICB9LCBwb3BwZXJPcHRpb25zLCB7XG4gICAgICBtb2RpZmllcnM6IF9leHRlbmRzKHt9LCBkaXNhYmxlUG9ydGFsID8ge30gOiB7XG4gICAgICAgIC8vIEl0J3MgdXNpbmcgc2Nyb2xsUGFyZW50IGJ5IGRlZmF1bHQsIHdlIGNhbiB1c2UgdGhlIHZpZXdwb3J0IHdoZW4gdXNpbmcgYSBwb3J0YWwuXG4gICAgICAgIHByZXZlbnRPdmVyZmxvdzoge1xuICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnd2luZG93J1xuICAgICAgICB9XG4gICAgICB9LCBtb2RpZmllcnMsIHBvcHBlck9wdGlvbnMubW9kaWZpZXJzKSxcbiAgICAgIC8vIFdlIGNvdWxkIGhhdmUgYmVlbiB1c2luZyBhIGN1c3RvbSBtb2RpZmllciBsaWtlIHJlYWN0LXBvcHBlciBpcyBkb2luZy5cbiAgICAgIC8vIEJ1dCBpdCBzZWVtcyB0aGlzIGlzIHRoZSBiZXN0IHB1YmxpYyBBUEkgZm9yIHRoaXMgdXNlIGNhc2UuXG4gICAgICBvbkNyZWF0ZTogY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKGhhbmRsZVBvcHBlclVwZGF0ZSwgcG9wcGVyT3B0aW9ucy5vbkNyZWF0ZSksXG4gICAgICBvblVwZGF0ZTogY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKGhhbmRsZVBvcHBlclVwZGF0ZSwgcG9wcGVyT3B0aW9ucy5vblVwZGF0ZSlcbiAgICB9KSk7XG4gICAgaGFuZGxlUG9wcGVyUmVmUmVmLmN1cnJlbnQocG9wcGVyKTtcbiAgfSwgW2FuY2hvckVsLCBkaXNhYmxlUG9ydGFsLCBtb2RpZmllcnMsIG9wZW4sIHJ0bFBsYWNlbWVudCwgcG9wcGVyT3B0aW9uc10pO1xuICB2YXIgaGFuZGxlUmVmID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBzZXRSZWYob3duUmVmLCBub2RlKTtcbiAgICBoYW5kbGVPcGVuKCk7XG4gIH0sIFtvd25SZWYsIGhhbmRsZU9wZW5dKTtcblxuICB2YXIgaGFuZGxlRW50ZXIgPSBmdW5jdGlvbiBoYW5kbGVFbnRlcigpIHtcbiAgICBzZXRFeGl0ZWQoZmFsc2UpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVDbG9zZSA9IGZ1bmN0aW9uIGhhbmRsZUNsb3NlKCkge1xuICAgIGlmICghcG9wcGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwb3BwZXJSZWYuY3VycmVudC5kZXN0cm95KCk7XG4gICAgaGFuZGxlUG9wcGVyUmVmUmVmLmN1cnJlbnQobnVsbCk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUV4aXRlZCA9IGZ1bmN0aW9uIGhhbmRsZUV4aXRlZCgpIHtcbiAgICBzZXRFeGl0ZWQodHJ1ZSk7XG4gICAgaGFuZGxlQ2xvc2UoKTtcbiAgfTtcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBoYW5kbGVDbG9zZSgpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIW9wZW4gJiYgIXRyYW5zaXRpb24pIHtcbiAgICAgIC8vIE90aGVyd2lzZSBoYW5kbGVFeGl0ZWQgd2lsbCBjYWxsIHRoaXMuXG4gICAgICBoYW5kbGVDbG9zZSgpO1xuICAgIH1cbiAgfSwgW29wZW4sIHRyYW5zaXRpb25dKTtcblxuICBpZiAoIWtlZXBNb3VudGVkICYmICFvcGVuICYmICghdHJhbnNpdGlvbiB8fCBleGl0ZWQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY2hpbGRQcm9wcyA9IHtcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9O1xuXG4gIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgY2hpbGRQcm9wcy5UcmFuc2l0aW9uUHJvcHMgPSB7XG4gICAgICBpbjogb3BlbixcbiAgICAgIG9uRW50ZXI6IGhhbmRsZUVudGVyLFxuICAgICAgb25FeGl0ZWQ6IGhhbmRsZUV4aXRlZFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUG9ydGFsLCB7XG4gICAgZGlzYWJsZVBvcnRhbDogZGlzYWJsZVBvcnRhbCxcbiAgICBjb250YWluZXI6IGNvbnRhaW5lclxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBoYW5kbGVSZWYsXG4gICAgcm9sZTogXCJ0b29sdGlwXCJcbiAgfSwgb3RoZXIsIHtcbiAgICBzdHlsZTogX2V4dGVuZHMoe1xuICAgICAgLy8gUHJldmVudHMgc2Nyb2xsIGlzc3VlLCB3YWl0aW5nIGZvciBQb3BwZXIuanMgdG8gYWRkIHRoaXMgc3R5bGUgb25jZSBpbml0aWF0ZWQuXG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIC8vIEZpeCBQb3BwZXIuanMgZGlzcGxheSBpc3N1ZVxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIGRpc3BsYXk6ICFvcGVuICYmIGtlZXBNb3VudGVkICYmICF0cmFuc2l0aW9uID8gJ25vbmUnIDogbnVsbFxuICAgIH0sIHN0eWxlKVxuICB9KSwgdHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nID8gY2hpbGRyZW4oY2hpbGRQcm9wcykgOiBjaGlsZHJlbikpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBQb3BwZXIucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQSBIVE1MIGVsZW1lbnQsIFtyZWZlcmVuY2VPYmplY3RdKGh0dHBzOi8vcG9wcGVyLmpzLm9yZy9kb2NzL3YxLyNyZWZlcmVuY2VPYmplY3QpLFxuICAgKiBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBlaXRoZXIuXG4gICAqIEl0J3MgdXNlZCB0byBzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIuXG4gICAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBwYXNzZWQgYXMgdGhlIHJlZmVyZW5jZSBvYmplY3Qgb2YgdGhlIFBvcHBlciBpbnN0YW5jZS5cbiAgICovXG4gIGFuY2hvckVsOiBjaGFpblByb3BUeXBlcyhQcm9wVHlwZXMub25lT2ZUeXBlKFtIVE1MRWxlbWVudFR5cGUsIFByb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksIGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGlmIChwcm9wcy5vcGVuKSB7XG4gICAgICB2YXIgcmVzb2x2ZWRBbmNob3JFbCA9IGdldEFuY2hvckVsKHByb3BzLmFuY2hvckVsKTtcblxuICAgICAgaWYgKHJlc29sdmVkQW5jaG9yRWwgJiYgcmVzb2x2ZWRBbmNob3JFbC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICB2YXIgYm94ID0gcmVzb2x2ZWRBbmNob3JFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJiBib3gudG9wID09PSAwICYmIGJveC5sZWZ0ID09PSAwICYmIGJveC5yaWdodCA9PT0gMCAmJiBib3guYm90dG9tID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihbJ01hdGVyaWFsLVVJOiBUaGUgYGFuY2hvckVsYCBwcm9wIHByb3ZpZGVkIHRvIHRoZSBjb21wb25lbnQgaXMgaW52YWxpZC4nLCAnVGhlIGFuY2hvciBlbGVtZW50IHNob3VsZCBiZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBsYXlvdXQuJywgXCJNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgcHJlc2VudCBpbiB0aGUgZG9jdW1lbnQgb3IgdGhhdCBpdCdzIG5vdCBkaXNwbGF5IG5vbmUuXCJdLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghcmVzb2x2ZWRBbmNob3JFbCB8fCB0eXBlb2YgcmVzb2x2ZWRBbmNob3JFbC5jbGllbnRXaWR0aCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHJlc29sdmVkQW5jaG9yRWwuY2xpZW50SGVpZ2h0ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcmVzb2x2ZWRBbmNob3JFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihbJ01hdGVyaWFsLVVJOiBUaGUgYGFuY2hvckVsYCBwcm9wIHByb3ZpZGVkIHRvIHRoZSBjb21wb25lbnQgaXMgaW52YWxpZC4nLCAnSXQgc2hvdWxkIGJlIGFuIEhUTUwgZWxlbWVudCBpbnN0YW5jZSBvciBhIHJlZmVyZW5jZU9iamVjdCAnLCAnKGh0dHBzOi8vcG9wcGVyLmpzLm9yZy9kb2NzL3YxLyNyZWZlcmVuY2VPYmplY3QpLiddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSksXG5cbiAgLyoqXG4gICAqIFBvcHBlciByZW5kZXIgZnVuY3Rpb24gb3Igbm9kZS5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAub25lT2ZUeXBlKFtQcm9wVHlwZXMubm9kZSwgUHJvcFR5cGVzLmZ1bmNdKS5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBBIEhUTUwgZWxlbWVudCwgY29tcG9uZW50IGluc3RhbmNlLCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgZWl0aGVyLlxuICAgKiBUaGUgYGNvbnRhaW5lcmAgd2lsbCBoYXZlIHRoZSBwb3J0YWwgY2hpbGRyZW4gYXBwZW5kZWQgdG8gaXQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGl0IHVzZXMgdGhlIGJvZHkgb2YgdGhlIHRvcC1sZXZlbCBkb2N1bWVudCBvYmplY3QsXG4gICAqIHNvIGl0J3Mgc2ltcGx5IGBkb2N1bWVudC5ib2R5YCBtb3N0IG9mIHRoZSB0aW1lLlxuICAgKi9cbiAgY29udGFpbmVyOiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAub25lT2ZUeXBlKFtIVE1MRWxlbWVudFR5cGUsIFByb3BUeXBlcy5pbnN0YW5jZU9mKFJlYWN0LkNvbXBvbmVudCksIFByb3BUeXBlcy5mdW5jXSksXG5cbiAgLyoqXG4gICAqIERpc2FibGUgdGhlIHBvcnRhbCBiZWhhdmlvci5cbiAgICogVGhlIGNoaWxkcmVuIHN0YXkgd2l0aGluIGl0J3MgcGFyZW50IERPTSBoaWVyYXJjaHkuXG4gICAqL1xuICBkaXNhYmxlUG9ydGFsOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQWx3YXlzIGtlZXAgdGhlIGNoaWxkcmVuIGluIHRoZSBET00uXG4gICAqIFRoaXMgcHJvcCBjYW4gYmUgdXNlZnVsIGluIFNFTyBzaXR1YXRpb24gb3JcbiAgICogd2hlbiB5b3Ugd2FudCB0byBtYXhpbWl6ZSB0aGUgcmVzcG9uc2l2ZW5lc3Mgb2YgdGhlIFBvcHBlci5cbiAgICovXG4gIGtlZXBNb3VudGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogUG9wcGVyLmpzIGlzIGJhc2VkIG9uIGEgXCJwbHVnaW4tbGlrZVwiIGFyY2hpdGVjdHVyZSxcbiAgICogbW9zdCBvZiBpdHMgZmVhdHVyZXMgYXJlIGZ1bGx5IGVuY2Fwc3VsYXRlZCBcIm1vZGlmaWVyc1wiLlxuICAgKlxuICAgKiBBIG1vZGlmaWVyIGlzIGEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgZWFjaCB0aW1lIFBvcHBlci5qcyBuZWVkcyB0b1xuICAgKiBjb21wdXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLlxuICAgKiBGb3IgdGhpcyByZWFzb24sIG1vZGlmaWVycyBzaG91bGQgYmUgdmVyeSBwZXJmb3JtYW50IHRvIGF2b2lkIGJvdHRsZW5lY2tzLlxuICAgKiBUbyBsZWFybiBob3cgdG8gY3JlYXRlIGEgbW9kaWZpZXIsIFtyZWFkIHRoZSBtb2RpZmllcnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9wb3BwZXIuanMub3JnL2RvY3MvdjEvI21vZGlmaWVycykuXG4gICAqL1xuICBtb2RpZmllcnM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHBvcHBlciBpcyB2aXNpYmxlLlxuICAgKi9cbiAgb3BlbjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogUG9wcGVyIHBsYWNlbWVudC5cbiAgICovXG4gIHBsYWNlbWVudDogUHJvcFR5cGVzLm9uZU9mKFsnYm90dG9tLWVuZCcsICdib3R0b20tc3RhcnQnLCAnYm90dG9tJywgJ2xlZnQtZW5kJywgJ2xlZnQtc3RhcnQnLCAnbGVmdCcsICdyaWdodC1lbmQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQnLCAndG9wLWVuZCcsICd0b3Atc3RhcnQnLCAndG9wJ10pLFxuXG4gIC8qKlxuICAgKiBPcHRpb25zIHByb3ZpZGVkIHRvIHRoZSBbYHBvcHBlci5qc2BdKGh0dHBzOi8vcG9wcGVyLmpzLm9yZy9kb2NzL3YxLykgaW5zdGFuY2UuXG4gICAqL1xuICBwb3BwZXJPcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBBIHJlZiB0aGF0IHBvaW50cyB0byB0aGUgdXNlZCBwb3BwZXIgaW5zdGFuY2UuXG4gICAqL1xuICBwb3BwZXJSZWY6IHJlZlR5cGUsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBIZWxwIHN1cHBvcnRpbmcgYSByZWFjdC10cmFuc2l0aW9uLWdyb3VwL1RyYW5zaXRpb24gY29tcG9uZW50LlxuICAgKi9cbiAgdHJhbnNpdGlvbjogUHJvcFR5cGVzLmJvb2xcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCBQb3BwZXI7IiwiaW1wb3J0IHsgZm9ybWF0TXVpRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRNdWlFcnJvck1lc3NhZ2UgfSBmcm9tIFwiQG1hdGVyaWFsLXVpL3V0aWxzXCI7XG4vLyBJdCBzaG91bGQgdG8gYmUgbm90ZWQgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzbid0IGVxdWl2YWxlbnQgdG8gYHRleHQtdHJhbnNmb3JtOiBjYXBpdGFsaXplYC5cbi8vXG4vLyBBIHN0cmljdCBjYXBpdGFsaXphdGlvbiBzaG91bGQgdXBwZXJjYXNlIHRoZSBmaXJzdCBsZXR0ZXIgb2YgZWFjaCB3b3JkIGEgdGhlIHNlbnRlbmNlLlxuLy8gV2Ugb25seSBoYW5kbGUgdGhlIGZpcnN0IHdvcmQuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJNYXRlcmlhbC1VSTogY2FwaXRhbGl6ZShzdHJpbmcpIGV4cGVjdHMgYSBzdHJpbmcgYXJndW1lbnQuXCIgOiBfZm9ybWF0TXVpRXJyb3JNZXNzYWdlKDcpKTtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IGNhcGl0YWxpemUgZnJvbSAnLi4vdXRpbHMvY2FwaXRhbGl6ZSc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gICAgcm9vdDoge1xuICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICBsaW5lSGVpZ2h0OiAnNDhweCcsXG4gICAgICBsaXN0U3R5bGU6ICdub25lJyxcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnRleHQuc2Vjb25kYXJ5LFxuICAgICAgZm9udEZhbWlseTogdGhlbWUudHlwb2dyYXBoeS5mb250RmFtaWx5LFxuICAgICAgZm9udFdlaWdodDogdGhlbWUudHlwb2dyYXBoeS5mb250V2VpZ2h0TWVkaXVtLFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkucHhUb1JlbSgxNClcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgY29sb3I9XCJwcmltYXJ5XCJgLiAqL1xuICAgIGNvbG9yUHJpbWFyeToge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbG9yPVwiaW5oZXJpdFwiYC4gKi9cbiAgICBjb2xvckluaGVyaXQ6IHtcbiAgICAgIGNvbG9yOiAnaW5oZXJpdCdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGlubmVyIGBjb21wb25lbnRgIGVsZW1lbnQgaWYgYGRpc2FibGVHdXR0ZXJzPXtmYWxzZX1gLiAqL1xuICAgIGd1dHRlcnM6IHtcbiAgICAgIHBhZGRpbmdMZWZ0OiAxNixcbiAgICAgIHBhZGRpbmdSaWdodDogMTZcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgaW5zZXQ9e3RydWV9YC4gKi9cbiAgICBpbnNldDoge1xuICAgICAgcGFkZGluZ0xlZnQ6IDcyXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVTdGlja3k9e2ZhbHNlfWAuICovXG4gICAgc3RpY2t5OiB7XG4gICAgICBwb3NpdGlvbjogJ3N0aWNreScsXG4gICAgICB0b3A6IDAsXG4gICAgICB6SW5kZXg6IDEsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdpbmhlcml0J1xuICAgIH1cbiAgfTtcbn07XG52YXIgTGlzdFN1YmhlYWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIExpc3RTdWJoZWFkZXIocHJvcHMsIHJlZikge1xuICB2YXIgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkY29sb3IgPSBwcm9wcy5jb2xvcixcbiAgICAgIGNvbG9yID0gX3Byb3BzJGNvbG9yID09PSB2b2lkIDAgPyAnZGVmYXVsdCcgOiBfcHJvcHMkY29sb3IsXG4gICAgICBfcHJvcHMkY29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50LFxuICAgICAgQ29tcG9uZW50ID0gX3Byb3BzJGNvbXBvbmVudCA9PT0gdm9pZCAwID8gJ2xpJyA6IF9wcm9wcyRjb21wb25lbnQsXG4gICAgICBfcHJvcHMkZGlzYWJsZUd1dHRlcnMgPSBwcm9wcy5kaXNhYmxlR3V0dGVycyxcbiAgICAgIGRpc2FibGVHdXR0ZXJzID0gX3Byb3BzJGRpc2FibGVHdXR0ZXJzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlR3V0dGVycyxcbiAgICAgIF9wcm9wcyRkaXNhYmxlU3RpY2t5ID0gcHJvcHMuZGlzYWJsZVN0aWNreSxcbiAgICAgIGRpc2FibGVTdGlja3kgPSBfcHJvcHMkZGlzYWJsZVN0aWNreSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZVN0aWNreSxcbiAgICAgIF9wcm9wcyRpbnNldCA9IHByb3BzLmluc2V0LFxuICAgICAgaW5zZXQgPSBfcHJvcHMkaW5zZXQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGluc2V0LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjb2xvclwiLCBcImNvbXBvbmVudFwiLCBcImRpc2FibGVHdXR0ZXJzXCIsIFwiZGlzYWJsZVN0aWNreVwiLCBcImluc2V0XCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lLCBjb2xvciAhPT0gJ2RlZmF1bHQnICYmIGNsYXNzZXNbXCJjb2xvclwiLmNvbmNhdChjYXBpdGFsaXplKGNvbG9yKSldLCBpbnNldCAmJiBjbGFzc2VzLmluc2V0LCAhZGlzYWJsZVN0aWNreSAmJiBjbGFzc2VzLnN0aWNreSwgIWRpc2FibGVHdXR0ZXJzICYmIGNsYXNzZXMuZ3V0dGVycyksXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gTGlzdFN1YmhlYWRlci5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2YgdGhlIGNvbXBvbmVudC4gSXQgc3VwcG9ydHMgdGhvc2UgdGhlbWUgY29sb3JzIHRoYXQgbWFrZSBzZW5zZSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnZGVmYXVsdCcsICdwcmltYXJ5JywgJ2luaGVyaXQnXSksXG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBMaXN0IFN1YmhlYWRlciB3aWxsIG5vdCBoYXZlIGd1dHRlcnMuXG4gICAqL1xuICBkaXNhYmxlR3V0dGVyczogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIExpc3QgU3ViaGVhZGVyIHdpbGwgbm90IHN0aWNrIHRvIHRoZSB0b3AgZHVyaW5nIHNjcm9sbC5cbiAgICovXG4gIGRpc2FibGVTdGlja3k6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBMaXN0IFN1YmhlYWRlciB3aWxsIGJlIGluZGVudGVkLlxuICAgKi9cbiAgaW5zZXQ6IFByb3BUeXBlcy5ib29sXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUxpc3RTdWJoZWFkZXInXG59KShMaXN0U3ViaGVhZGVyKTsiLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyBjaGFpblByb3BUeXBlcyB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICB2YXIgZWxldmF0aW9ucyA9IHt9O1xuICB0aGVtZS5zaGFkb3dzLmZvckVhY2goZnVuY3Rpb24gKHNoYWRvdywgaW5kZXgpIHtcbiAgICBlbGV2YXRpb25zW1wiZWxldmF0aW9uXCIuY29uY2F0KGluZGV4KV0gPSB7XG4gICAgICBib3hTaGFkb3c6IHNoYWRvd1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gICAgcm9vdDoge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLmJhY2tncm91bmQucGFwZXIsXG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS50ZXh0LnByaW1hcnksXG4gICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ2JveC1zaGFkb3cnKVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBzcXVhcmU9e2ZhbHNlfWAuICovXG4gICAgcm91bmRlZDoge1xuICAgICAgYm9yZGVyUmFkaXVzOiB0aGVtZS5zaGFwZS5ib3JkZXJSYWRpdXNcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cIm91dGxpbmVkXCJgLiAqL1xuICAgIG91dGxpbmVkOiB7XG4gICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIFwiLmNvbmNhdCh0aGVtZS5wYWxldHRlLmRpdmlkZXIpXG4gICAgfVxuICB9LCBlbGV2YXRpb25zKTtcbn07XG52YXIgUGFwZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBQYXBlcihwcm9wcywgcmVmKSB7XG4gIHZhciBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRjb21wb25lbnQgPSBwcm9wcy5jb21wb25lbnQsXG4gICAgICBDb21wb25lbnQgPSBfcHJvcHMkY29tcG9uZW50ID09PSB2b2lkIDAgPyAnZGl2JyA6IF9wcm9wcyRjb21wb25lbnQsXG4gICAgICBfcHJvcHMkc3F1YXJlID0gcHJvcHMuc3F1YXJlLFxuICAgICAgc3F1YXJlID0gX3Byb3BzJHNxdWFyZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkc3F1YXJlLFxuICAgICAgX3Byb3BzJGVsZXZhdGlvbiA9IHByb3BzLmVsZXZhdGlvbixcbiAgICAgIGVsZXZhdGlvbiA9IF9wcm9wcyRlbGV2YXRpb24gPT09IHZvaWQgMCA/IDEgOiBfcHJvcHMkZWxldmF0aW9uLFxuICAgICAgX3Byb3BzJHZhcmlhbnQgPSBwcm9wcy52YXJpYW50LFxuICAgICAgdmFyaWFudCA9IF9wcm9wcyR2YXJpYW50ID09PSB2b2lkIDAgPyAnZWxldmF0aW9uJyA6IF9wcm9wcyR2YXJpYW50LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjb21wb25lbnRcIiwgXCJzcXVhcmVcIiwgXCJlbGV2YXRpb25cIiwgXCJ2YXJpYW50XCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lLCB2YXJpYW50ID09PSAnb3V0bGluZWQnID8gY2xhc3Nlcy5vdXRsaW5lZCA6IGNsYXNzZXNbXCJlbGV2YXRpb25cIi5jb25jYXQoZWxldmF0aW9uKV0sICFzcXVhcmUgJiYgY2xhc3Nlcy5yb3VuZGVkKSxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlcikpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBQYXBlci5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgcm9vdCBub2RlLlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgY29tcG9uZW50OiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAuZWxlbWVudFR5cGUsXG5cbiAgLyoqXG4gICAqIFNoYWRvdyBkZXB0aCwgY29ycmVzcG9uZHMgdG8gYGRwYCBpbiB0aGUgc3BlYy5cbiAgICogSXQgYWNjZXB0cyB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAyNCBpbmNsdXNpdmUuXG4gICAqL1xuICBlbGV2YXRpb246IGNoYWluUHJvcFR5cGVzKFByb3BUeXBlcy5udW1iZXIsIGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgICAgZWxldmF0aW9uID0gcHJvcHMuZWxldmF0aW9uOyAvLyBpbiBjYXNlIGB3aXRoU3R5bGVzYCBmYWlscyB0byBpbmplY3Qgd2UgZG9uJ3QgbmVlZCB0aGlzIHdhcm5pbmdcblxuICAgIGlmIChjbGFzc2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChlbGV2YXRpb24gIT0gbnVsbCAmJiBjbGFzc2VzW1wiZWxldmF0aW9uXCIuY29uY2F0KGVsZXZhdGlvbildID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJNYXRlcmlhbC1VSTogVGhpcyBlbGV2YXRpb24gYFwiLmNvbmNhdChlbGV2YXRpb24sIFwiYCBpcyBub3QgaW1wbGVtZW50ZWQuXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgcm91bmRlZCBjb3JuZXJzIGFyZSBkaXNhYmxlZC5cbiAgICovXG4gIHNxdWFyZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSB2YXJpYW50IHRvIHVzZS5cbiAgICovXG4gIHZhcmlhbnQ6IFByb3BUeXBlcy5vbmVPZihbJ2VsZXZhdGlvbicsICdvdXRsaW5lZCddKVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlQYXBlcidcbn0pKFBhcGVyKTsiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG52YXIgdXNlRW5oYW5jZWRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDA5OSNpc3N1ZWNvbW1lbnQtNDQwMDEzODkyXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VFdmVudENhbGxiYWNrKGZuKSB7XG4gIHZhciByZWYgPSBSZWFjdC51c2VSZWYoZm4pO1xuICB1c2VFbmhhbmNlZEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVmLmN1cnJlbnQgPSBmbjtcbiAgfSk7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICgwLCByZWYuY3VycmVudCkuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LCBbXSk7XG59IiwiLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvZm9jdXMtdmlzaWJsZS9ibG9iL3Y0LjEuNS9zcmMvZm9jdXMtdmlzaWJsZS5qc1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbnZhciBoYWRLZXlib2FyZEV2ZW50ID0gdHJ1ZTtcbnZhciBoYWRGb2N1c1Zpc2libGVSZWNlbnRseSA9IGZhbHNlO1xudmFyIGhhZEZvY3VzVmlzaWJsZVJlY2VudGx5VGltZW91dCA9IG51bGw7XG52YXIgaW5wdXRUeXBlc1doaXRlbGlzdCA9IHtcbiAgdGV4dDogdHJ1ZSxcbiAgc2VhcmNoOiB0cnVlLFxuICB1cmw6IHRydWUsXG4gIHRlbDogdHJ1ZSxcbiAgZW1haWw6IHRydWUsXG4gIHBhc3N3b3JkOiB0cnVlLFxuICBudW1iZXI6IHRydWUsXG4gIGRhdGU6IHRydWUsXG4gIG1vbnRoOiB0cnVlLFxuICB3ZWVrOiB0cnVlLFxuICB0aW1lOiB0cnVlLFxuICBkYXRldGltZTogdHJ1ZSxcbiAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZVxufTtcbi8qKlxuICogQ29tcHV0ZXMgd2hldGhlciB0aGUgZ2l2ZW4gZWxlbWVudCBzaG91bGQgYXV0b21hdGljYWxseSB0cmlnZ2VyIHRoZVxuICogYGZvY3VzLXZpc2libGVgIGNsYXNzIGJlaW5nIGFkZGVkLCBpLmUuIHdoZXRoZXIgaXQgc2hvdWxkIGFsd2F5cyBtYXRjaFxuICogYDpmb2N1cy12aXNpYmxlYCB3aGVuIGZvY3VzZWQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gZm9jdXNUcmlnZ2Vyc0tleWJvYXJkTW9kYWxpdHkobm9kZSkge1xuICB2YXIgdHlwZSA9IG5vZGUudHlwZSxcbiAgICAgIHRhZ05hbWUgPSBub2RlLnRhZ05hbWU7XG5cbiAgaWYgKHRhZ05hbWUgPT09ICdJTlBVVCcgJiYgaW5wdXRUeXBlc1doaXRlbGlzdFt0eXBlXSAmJiAhbm9kZS5yZWFkT25seSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHRhZ05hbWUgPT09ICdURVhUQVJFQScgJiYgIW5vZGUucmVhZE9ubHkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChub2RlLmlzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEtlZXAgdHJhY2sgb2Ygb3VyIGtleWJvYXJkIG1vZGFsaXR5IHN0YXRlIHdpdGggYGhhZEtleWJvYXJkRXZlbnRgLlxuICogSWYgdGhlIG1vc3QgcmVjZW50IHVzZXIgaW50ZXJhY3Rpb24gd2FzIHZpYSB0aGUga2V5Ym9hcmQ7XG4gKiBhbmQgdGhlIGtleSBwcmVzcyBkaWQgbm90IGluY2x1ZGUgYSBtZXRhLCBhbHQvb3B0aW9uLCBvciBjb250cm9sIGtleTtcbiAqIHRoZW4gdGhlIG1vZGFsaXR5IGlzIGtleWJvYXJkLiBPdGhlcndpc2UsIHRoZSBtb2RhbGl0eSBpcyBub3Qga2V5Ym9hcmQuXG4gKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XG4gKi9cblxuXG5mdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gIGlmIChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaGFkS2V5Ym9hcmRFdmVudCA9IHRydWU7XG59XG4vKipcbiAqIElmIGF0IGFueSBwb2ludCBhIHVzZXIgY2xpY2tzIHdpdGggYSBwb2ludGluZyBkZXZpY2UsIGVuc3VyZSB0aGF0IHdlIGNoYW5nZVxuICogdGhlIG1vZGFsaXR5IGF3YXkgZnJvbSBrZXlib2FyZC5cbiAqIFRoaXMgYXZvaWRzIHRoZSBzaXR1YXRpb24gd2hlcmUgYSB1c2VyIHByZXNzZXMgYSBrZXkgb24gYW4gYWxyZWFkeSBmb2N1c2VkXG4gKiBlbGVtZW50LCBhbmQgdGhlbiBjbGlja3Mgb24gYSBkaWZmZXJlbnQgZWxlbWVudCwgZm9jdXNpbmcgaXQgd2l0aCBhXG4gKiBwb2ludGluZyBkZXZpY2UsIHdoaWxlIHdlIHN0aWxsIHRoaW5rIHdlJ3JlIGluIGtleWJvYXJkIG1vZGFsaXR5LlxuICovXG5cblxuZnVuY3Rpb24gaGFuZGxlUG9pbnRlckRvd24oKSB7XG4gIGhhZEtleWJvYXJkRXZlbnQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgaWYgKHRoaXMudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJykge1xuICAgIC8vIElmIHRoZSB0YWIgYmVjb21lcyBhY3RpdmUgYWdhaW4sIHRoZSBicm93c2VyIHdpbGwgaGFuZGxlIGNhbGxpbmcgZm9jdXNcbiAgICAvLyBvbiB0aGUgZWxlbWVudCAoU2FmYXJpIGFjdHVhbGx5IGNhbGxzIGl0IHR3aWNlKS5cbiAgICAvLyBJZiB0aGlzIHRhYiBjaGFuZ2UgY2F1c2VkIGEgYmx1ciBvbiBhbiBlbGVtZW50IHdpdGggZm9jdXMtdmlzaWJsZSxcbiAgICAvLyByZS1hcHBseSB0aGUgY2xhc3Mgd2hlbiB0aGUgdXNlciBzd2l0Y2hlcyBiYWNrIHRvIHRoZSB0YWIuXG4gICAgaWYgKGhhZEZvY3VzVmlzaWJsZVJlY2VudGx5KSB7XG4gICAgICBoYWRLZXlib2FyZEV2ZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZShkb2MpIHtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duLCB0cnVlKTtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZVBvaW50ZXJEb3duLCB0cnVlKTtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24sIHRydWUpO1xuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZVBvaW50ZXJEb3duLCB0cnVlKTtcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlLCB0cnVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlYXJkb3duKGRvYykge1xuICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24sIHRydWUpO1xuICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlUG9pbnRlckRvd24sIHRydWUpO1xuICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVQb2ludGVyRG93biwgdHJ1ZSk7XG4gIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgaGFuZGxlUG9pbnRlckRvd24sIHRydWUpO1xuICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBpc0ZvY3VzVmlzaWJsZShldmVudCkge1xuICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHRhcmdldC5tYXRjaGVzKCc6Zm9jdXMtdmlzaWJsZScpO1xuICB9IGNhdGNoIChlcnJvcikge30gLy8gYnJvd3NlcnMgbm90IGltcGxlbWVudGluZyA6Zm9jdXMtdmlzaWJsZSB3aWxsIHRocm93IGEgU3ludGF4RXJyb3JcbiAgLy8gd2UgdXNlIG91ciBvd24gaGV1cmlzdGljIGZvciB0aG9zZSBicm93c2Vyc1xuICAvLyByZXRocm93IG1pZ2h0IGJlIGJldHRlciBpZiBpdCdzIG5vdCB0aGUgZXhwZWN0ZWQgZXJyb3IgYnV0IGRvIHdlIHJlYWxseVxuICAvLyB3YW50IHRvIGNyYXNoIGlmIGZvY3VzLXZpc2libGUgbWFsZnVuY3Rpb25lZD9cbiAgLy8gbm8gbmVlZCBmb3IgdmFsaWRGb2N1c1RhcmdldCBjaGVjay4gdGhlIHVzZXIgZG9lcyB0aGF0IGJ5IGF0dGFjaGluZyBpdCB0b1xuICAvLyBmb2N1c2FibGUgZXZlbnRzIG9ubHlcblxuXG4gIHJldHVybiBoYWRLZXlib2FyZEV2ZW50IHx8IGZvY3VzVHJpZ2dlcnNLZXlib2FyZE1vZGFsaXR5KHRhcmdldCk7XG59XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgaWYgYSBibHVyIGV2ZW50IGlzIGZpcmVkIG9uIGEgZm9jdXMtdmlzaWJsZSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiBoYW5kbGVCbHVyVmlzaWJsZSgpIHtcbiAgLy8gVG8gZGV0ZWN0IGEgdGFiL3dpbmRvdyBzd2l0Y2gsIHdlIGxvb2sgZm9yIGEgYmx1ciBldmVudCBmb2xsb3dlZFxuICAvLyByYXBpZGx5IGJ5IGEgdmlzaWJpbGl0eSBjaGFuZ2UuXG4gIC8vIElmIHdlIGRvbid0IHNlZSBhIHZpc2liaWxpdHkgY2hhbmdlIHdpdGhpbiAxMDBtcywgaXQncyBwcm9iYWJseSBhXG4gIC8vIHJlZ3VsYXIgZm9jdXMgY2hhbmdlLlxuICBoYWRGb2N1c1Zpc2libGVSZWNlbnRseSA9IHRydWU7XG4gIHdpbmRvdy5jbGVhclRpbWVvdXQoaGFkRm9jdXNWaXNpYmxlUmVjZW50bHlUaW1lb3V0KTtcbiAgaGFkRm9jdXNWaXNpYmxlUmVjZW50bHlUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGhhZEZvY3VzVmlzaWJsZVJlY2VudGx5ID0gZmFsc2U7XG4gIH0sIDEwMCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZUlzRm9jdXNWaXNpYmxlKCkge1xuICB2YXIgcmVmID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZShpbnN0YW5jZSk7XG5cbiAgICBpZiAobm9kZSAhPSBudWxsKSB7XG4gICAgICBwcmVwYXJlKG5vZGUub3duZXJEb2N1bWVudCk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VEZWJ1Z1ZhbHVlKGlzRm9jdXNWaXNpYmxlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNGb2N1c1Zpc2libGU6IGlzRm9jdXNWaXNpYmxlLFxuICAgIG9uQmx1clZpc2libGU6IGhhbmRsZUJsdXJWaXNpYmxlLFxuICAgIHJlZjogcmVmXG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQge1xuICBkaXNhYmxlZDogZmFsc2Vcbn07IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmV4cG9ydCB2YXIgdGltZW91dHNTaGFwZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc2hhcGUoe1xuICBlbnRlcjogUHJvcFR5cGVzLm51bWJlcixcbiAgZXhpdDogUHJvcFR5cGVzLm51bWJlcixcbiAgYXBwZWFyOiBQcm9wVHlwZXMubnVtYmVyXG59KS5pc1JlcXVpcmVkXSkgOiBudWxsO1xuZXhwb3J0IHZhciBjbGFzc05hbWVzU2hhcGUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLnNoYXBlKHtcbiAgZW50ZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGV4aXQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGFjdGl2ZTogUHJvcFR5cGVzLnN0cmluZ1xufSksIFByb3BUeXBlcy5zaGFwZSh7XG4gIGVudGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBlbnRlckRvbmU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGVudGVyQWN0aXZlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBleGl0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICBleGl0RG9uZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZXhpdEFjdGl2ZTogUHJvcFR5cGVzLnN0cmluZ1xufSldKSA6IG51bGw7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBkZWZhdWx0IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2VcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgY29uZmlnIGZyb20gJy4vY29uZmlnJztcbmltcG9ydCB7IHRpbWVvdXRzU2hhcGUgfSBmcm9tICcuL3V0aWxzL1Byb3BUeXBlcyc7XG5pbXBvcnQgVHJhbnNpdGlvbkdyb3VwQ29udGV4dCBmcm9tICcuL1RyYW5zaXRpb25Hcm91cENvbnRleHQnO1xuZXhwb3J0IHZhciBVTk1PVU5URUQgPSAndW5tb3VudGVkJztcbmV4cG9ydCB2YXIgRVhJVEVEID0gJ2V4aXRlZCc7XG5leHBvcnQgdmFyIEVOVEVSSU5HID0gJ2VudGVyaW5nJztcbmV4cG9ydCB2YXIgRU5URVJFRCA9ICdlbnRlcmVkJztcbmV4cG9ydCB2YXIgRVhJVElORyA9ICdleGl0aW5nJztcbi8qKlxuICogVGhlIFRyYW5zaXRpb24gY29tcG9uZW50IGxldHMgeW91IGRlc2NyaWJlIGEgdHJhbnNpdGlvbiBmcm9tIG9uZSBjb21wb25lbnRcbiAqIHN0YXRlIHRvIGFub3RoZXIgX292ZXIgdGltZV8gd2l0aCBhIHNpbXBsZSBkZWNsYXJhdGl2ZSBBUEkuIE1vc3QgY29tbW9ubHlcbiAqIGl0J3MgdXNlZCB0byBhbmltYXRlIHRoZSBtb3VudGluZyBhbmQgdW5tb3VudGluZyBvZiBhIGNvbXBvbmVudCwgYnV0IGNhbiBhbHNvXG4gKiBiZSB1c2VkIHRvIGRlc2NyaWJlIGluLXBsYWNlIHRyYW5zaXRpb24gc3RhdGVzIGFzIHdlbGwuXG4gKlxuICogLS0tXG4gKlxuICogKipOb3RlKio6IGBUcmFuc2l0aW9uYCBpcyBhIHBsYXRmb3JtLWFnbm9zdGljIGJhc2UgY29tcG9uZW50LiBJZiB5b3UncmUgdXNpbmdcbiAqIHRyYW5zaXRpb25zIGluIENTUywgeW91J2xsIHByb2JhYmx5IHdhbnQgdG8gdXNlXG4gKiBbYENTU1RyYW5zaXRpb25gXShodHRwczovL3JlYWN0Y29tbXVuaXR5Lm9yZy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2Nzcy10cmFuc2l0aW9uKVxuICogaW5zdGVhZC4gSXQgaW5oZXJpdHMgYWxsIHRoZSBmZWF0dXJlcyBvZiBgVHJhbnNpdGlvbmAsIGJ1dCBjb250YWluc1xuICogYWRkaXRpb25hbCBmZWF0dXJlcyBuZWNlc3NhcnkgdG8gcGxheSBuaWNlIHdpdGggQ1NTIHRyYW5zaXRpb25zIChoZW5jZSB0aGVcbiAqIG5hbWUgb2YgdGhlIGNvbXBvbmVudCkuXG4gKlxuICogLS0tXG4gKlxuICogQnkgZGVmYXVsdCB0aGUgYFRyYW5zaXRpb25gIGNvbXBvbmVudCBkb2VzIG5vdCBhbHRlciB0aGUgYmVoYXZpb3Igb2YgdGhlXG4gKiBjb21wb25lbnQgaXQgcmVuZGVycywgaXQgb25seSB0cmFja3MgXCJlbnRlclwiIGFuZCBcImV4aXRcIiBzdGF0ZXMgZm9yIHRoZVxuICogY29tcG9uZW50cy4gSXQncyB1cCB0byB5b3UgdG8gZ2l2ZSBtZWFuaW5nIGFuZCBlZmZlY3QgdG8gdGhvc2Ugc3RhdGVzLiBGb3JcbiAqIGV4YW1wbGUgd2UgY2FuIGFkZCBzdHlsZXMgdG8gYSBjb21wb25lbnQgd2hlbiBpdCBlbnRlcnMgb3IgZXhpdHM6XG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAncmVhY3QtdHJhbnNpdGlvbi1ncm91cCc7XG4gKlxuICogY29uc3QgZHVyYXRpb24gPSAzMDA7XG4gKlxuICogY29uc3QgZGVmYXVsdFN0eWxlID0ge1xuICogICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke2R1cmF0aW9ufW1zIGVhc2UtaW4tb3V0YCxcbiAqICAgb3BhY2l0eTogMCxcbiAqIH1cbiAqXG4gKiBjb25zdCB0cmFuc2l0aW9uU3R5bGVzID0ge1xuICogICBlbnRlcmluZzogeyBvcGFjaXR5OiAxIH0sXG4gKiAgIGVudGVyZWQ6ICB7IG9wYWNpdHk6IDEgfSxcbiAqICAgZXhpdGluZzogIHsgb3BhY2l0eTogMCB9LFxuICogICBleGl0ZWQ6ICB7IG9wYWNpdHk6IDAgfSxcbiAqIH07XG4gKlxuICogY29uc3QgRmFkZSA9ICh7IGluOiBpblByb3AgfSkgPT4gKFxuICogICA8VHJhbnNpdGlvbiBpbj17aW5Qcm9wfSB0aW1lb3V0PXtkdXJhdGlvbn0+XG4gKiAgICAge3N0YXRlID0+IChcbiAqICAgICAgIDxkaXYgc3R5bGU9e3tcbiAqICAgICAgICAgLi4uZGVmYXVsdFN0eWxlLFxuICogICAgICAgICAuLi50cmFuc2l0aW9uU3R5bGVzW3N0YXRlXVxuICogICAgICAgfX0+XG4gKiAgICAgICAgIEknbSBhIGZhZGUgVHJhbnNpdGlvbiFcbiAqICAgICAgIDwvZGl2PlxuICogICAgICl9XG4gKiAgIDwvVHJhbnNpdGlvbj5cbiAqICk7XG4gKiBgYGBcbiAqXG4gKiBUaGVyZSBhcmUgNCBtYWluIHN0YXRlcyBhIFRyYW5zaXRpb24gY2FuIGJlIGluOlxuICogIC0gYCdlbnRlcmluZydgXG4gKiAgLSBgJ2VudGVyZWQnYFxuICogIC0gYCdleGl0aW5nJ2BcbiAqICAtIGAnZXhpdGVkJ2BcbiAqXG4gKiBUcmFuc2l0aW9uIHN0YXRlIGlzIHRvZ2dsZWQgdmlhIHRoZSBgaW5gIHByb3AuIFdoZW4gYHRydWVgIHRoZSBjb21wb25lbnRcbiAqIGJlZ2lucyB0aGUgXCJFbnRlclwiIHN0YWdlLiBEdXJpbmcgdGhpcyBzdGFnZSwgdGhlIGNvbXBvbmVudCB3aWxsIHNoaWZ0IGZyb21cbiAqIGl0cyBjdXJyZW50IHRyYW5zaXRpb24gc3RhdGUsIHRvIGAnZW50ZXJpbmcnYCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZVxuICogdHJhbnNpdGlvbiBhbmQgdGhlbiB0byB0aGUgYCdlbnRlcmVkJ2Agc3RhZ2Ugb25jZSBpdCdzIGNvbXBsZXRlLiBMZXQncyB0YWtlXG4gKiB0aGUgZm9sbG93aW5nIGV4YW1wbGUgKHdlJ2xsIHVzZSB0aGVcbiAqIFt1c2VTdGF0ZV0oaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2hvb2tzLXJlZmVyZW5jZS5odG1sI3VzZXN0YXRlKSBob29rKTpcbiAqXG4gKiBgYGBqc3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgW2luUHJvcCwgc2V0SW5Qcm9wXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8ZGl2PlxuICogICAgICAgPFRyYW5zaXRpb24gaW49e2luUHJvcH0gdGltZW91dD17NTAwfT5cbiAqICAgICAgICAge3N0YXRlID0+IChcbiAqICAgICAgICAgICAvLyAuLi5cbiAqICAgICAgICAgKX1cbiAqICAgICAgIDwvVHJhbnNpdGlvbj5cbiAqICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gc2V0SW5Qcm9wKHRydWUpfT5cbiAqICAgICAgICAgQ2xpY2sgdG8gRW50ZXJcbiAqICAgICAgIDwvYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogV2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWQgdGhlIGNvbXBvbmVudCB3aWxsIHNoaWZ0IHRvIHRoZSBgJ2VudGVyaW5nJ2Agc3RhdGVcbiAqIGFuZCBzdGF5IHRoZXJlIGZvciA1MDBtcyAodGhlIHZhbHVlIG9mIGB0aW1lb3V0YCkgYmVmb3JlIGl0IGZpbmFsbHkgc3dpdGNoZXNcbiAqIHRvIGAnZW50ZXJlZCdgLlxuICpcbiAqIFdoZW4gYGluYCBpcyBgZmFsc2VgIHRoZSBzYW1lIHRoaW5nIGhhcHBlbnMgZXhjZXB0IHRoZSBzdGF0ZSBtb3ZlcyBmcm9tXG4gKiBgJ2V4aXRpbmcnYCB0byBgJ2V4aXRlZCdgLlxuICovXG5cbnZhciBUcmFuc2l0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRyYW5zaXRpb24sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRyYW5zaXRpb24ocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkgfHwgdGhpcztcbiAgICB2YXIgcGFyZW50R3JvdXAgPSBjb250ZXh0OyAvLyBJbiB0aGUgY29udGV4dCBvZiBhIFRyYW5zaXRpb25Hcm91cCBhbGwgZW50ZXJzIGFyZSByZWFsbHkgYXBwZWFyc1xuXG4gICAgdmFyIGFwcGVhciA9IHBhcmVudEdyb3VwICYmICFwYXJlbnRHcm91cC5pc01vdW50aW5nID8gcHJvcHMuZW50ZXIgOiBwcm9wcy5hcHBlYXI7XG4gICAgdmFyIGluaXRpYWxTdGF0dXM7XG4gICAgX3RoaXMuYXBwZWFyU3RhdHVzID0gbnVsbDtcblxuICAgIGlmIChwcm9wcy5pbikge1xuICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICBpbml0aWFsU3RhdHVzID0gRVhJVEVEO1xuICAgICAgICBfdGhpcy5hcHBlYXJTdGF0dXMgPSBFTlRFUklORztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRpYWxTdGF0dXMgPSBFTlRFUkVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcHMudW5tb3VudE9uRXhpdCB8fCBwcm9wcy5tb3VudE9uRW50ZXIpIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IFVOTU9VTlRFRDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRpYWxTdGF0dXMgPSBFWElURUQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBzdGF0dXM6IGluaXRpYWxTdGF0dXNcbiAgICB9O1xuICAgIF90aGlzLm5leHRDYWxsYmFjayA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgVHJhbnNpdGlvbi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoX3JlZiwgcHJldlN0YXRlKSB7XG4gICAgdmFyIG5leHRJbiA9IF9yZWYuaW47XG5cbiAgICBpZiAobmV4dEluICYmIHByZXZTdGF0ZS5zdGF0dXMgPT09IFVOTU9VTlRFRCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBFWElURURcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocHJldlByb3BzKSB7XG4gIC8vICAgbGV0IG5leHRTdGF0dXMgPSBudWxsXG4gIC8vICAgaWYgKHByZXZQcm9wcyAhPT0gdGhpcy5wcm9wcykge1xuICAvLyAgICAgY29uc3QgeyBzdGF0dXMgfSA9IHRoaXMuc3RhdGVcbiAgLy8gICAgIGlmICh0aGlzLnByb3BzLmluKSB7XG4gIC8vICAgICAgIGlmIChzdGF0dXMgIT09IEVOVEVSSU5HICYmIHN0YXR1cyAhPT0gRU5URVJFRCkge1xuICAvLyAgICAgICAgIG5leHRTdGF0dXMgPSBFTlRFUklOR1xuICAvLyAgICAgICB9XG4gIC8vICAgICB9IGVsc2Uge1xuICAvLyAgICAgICBpZiAoc3RhdHVzID09PSBFTlRFUklORyB8fCBzdGF0dXMgPT09IEVOVEVSRUQpIHtcbiAgLy8gICAgICAgICBuZXh0U3RhdHVzID0gRVhJVElOR1xuICAvLyAgICAgICB9XG4gIC8vICAgICB9XG4gIC8vICAgfVxuICAvLyAgIHJldHVybiB7IG5leHRTdGF0dXMgfVxuICAvLyB9XG4gIDtcblxuICB2YXIgX3Byb3RvID0gVHJhbnNpdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51cGRhdGVTdGF0dXModHJ1ZSwgdGhpcy5hcHBlYXJTdGF0dXMpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgdmFyIG5leHRTdGF0dXMgPSBudWxsO1xuXG4gICAgaWYgKHByZXZQcm9wcyAhPT0gdGhpcy5wcm9wcykge1xuICAgICAgdmFyIHN0YXR1cyA9IHRoaXMuc3RhdGUuc3RhdHVzO1xuXG4gICAgICBpZiAodGhpcy5wcm9wcy5pbikge1xuICAgICAgICBpZiAoc3RhdHVzICE9PSBFTlRFUklORyAmJiBzdGF0dXMgIT09IEVOVEVSRUQpIHtcbiAgICAgICAgICBuZXh0U3RhdHVzID0gRU5URVJJTkc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IEVOVEVSSU5HIHx8IHN0YXR1cyA9PT0gRU5URVJFRCkge1xuICAgICAgICAgIG5leHRTdGF0dXMgPSBFWElUSU5HO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTdGF0dXMoZmFsc2UsIG5leHRTdGF0dXMpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuY2FuY2VsTmV4dENhbGxiYWNrKCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldFRpbWVvdXRzID0gZnVuY3Rpb24gZ2V0VGltZW91dHMoKSB7XG4gICAgdmFyIHRpbWVvdXQgPSB0aGlzLnByb3BzLnRpbWVvdXQ7XG4gICAgdmFyIGV4aXQsIGVudGVyLCBhcHBlYXI7XG4gICAgZXhpdCA9IGVudGVyID0gYXBwZWFyID0gdGltZW91dDtcblxuICAgIGlmICh0aW1lb3V0ICE9IG51bGwgJiYgdHlwZW9mIHRpbWVvdXQgIT09ICdudW1iZXInKSB7XG4gICAgICBleGl0ID0gdGltZW91dC5leGl0O1xuICAgICAgZW50ZXIgPSB0aW1lb3V0LmVudGVyOyAvLyBUT0RPOiByZW1vdmUgZmFsbGJhY2sgZm9yIG5leHQgbWFqb3JcblxuICAgICAgYXBwZWFyID0gdGltZW91dC5hcHBlYXIgIT09IHVuZGVmaW5lZCA/IHRpbWVvdXQuYXBwZWFyIDogZW50ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGV4aXQ6IGV4aXQsXG4gICAgICBlbnRlcjogZW50ZXIsXG4gICAgICBhcHBlYXI6IGFwcGVhclxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZVN0YXR1cyA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXR1cyhtb3VudGluZywgbmV4dFN0YXR1cykge1xuICAgIGlmIChtb3VudGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICBtb3VudGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChuZXh0U3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAvLyBuZXh0U3RhdHVzIHdpbGwgYWx3YXlzIGJlIEVOVEVSSU5HIG9yIEVYSVRJTkcuXG4gICAgICB0aGlzLmNhbmNlbE5leHRDYWxsYmFjaygpO1xuXG4gICAgICBpZiAobmV4dFN0YXR1cyA9PT0gRU5URVJJTkcpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtRW50ZXIobW91bnRpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtRXhpdCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy51bm1vdW50T25FeGl0ICYmIHRoaXMuc3RhdGUuc3RhdHVzID09PSBFWElURUQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IFVOTU9VTlRFRFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wZXJmb3JtRW50ZXIgPSBmdW5jdGlvbiBwZXJmb3JtRW50ZXIobW91bnRpbmcpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBlbnRlciA9IHRoaXMucHJvcHMuZW50ZXI7XG4gICAgdmFyIGFwcGVhcmluZyA9IHRoaXMuY29udGV4dCA/IHRoaXMuY29udGV4dC5pc01vdW50aW5nIDogbW91bnRpbmc7XG5cbiAgICB2YXIgX3JlZjIgPSB0aGlzLnByb3BzLm5vZGVSZWYgPyBbYXBwZWFyaW5nXSA6IFtSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSwgYXBwZWFyaW5nXSxcbiAgICAgICAgbWF5YmVOb2RlID0gX3JlZjJbMF0sXG4gICAgICAgIG1heWJlQXBwZWFyaW5nID0gX3JlZjJbMV07XG5cbiAgICB2YXIgdGltZW91dHMgPSB0aGlzLmdldFRpbWVvdXRzKCk7XG4gICAgdmFyIGVudGVyVGltZW91dCA9IGFwcGVhcmluZyA/IHRpbWVvdXRzLmFwcGVhciA6IHRpbWVvdXRzLmVudGVyOyAvLyBubyBlbnRlciBhbmltYXRpb24gc2tpcCByaWdodCB0byBFTlRFUkVEXG4gICAgLy8gaWYgd2UgYXJlIG1vdW50aW5nIGFuZCBydW5uaW5nIHRoaXMgaXQgbWVhbnMgYXBwZWFyIF9tdXN0XyBiZSBzZXRcblxuICAgIGlmICghbW91bnRpbmcgJiYgIWVudGVyIHx8IGNvbmZpZy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IEVOVEVSRURcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnByb3BzLm9uRW50ZXJlZChtYXliZU5vZGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcm9wcy5vbkVudGVyKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpO1xuICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgIHN0YXR1czogRU5URVJJTkdcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczIucHJvcHMub25FbnRlcmluZyhtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKTtcblxuICAgICAgX3RoaXMyLm9uVHJhbnNpdGlvbkVuZChlbnRlclRpbWVvdXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiBFTlRFUkVEXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIucHJvcHMub25FbnRlcmVkKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5wZXJmb3JtRXhpdCA9IGZ1bmN0aW9uIHBlcmZvcm1FeGl0KCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIGV4aXQgPSB0aGlzLnByb3BzLmV4aXQ7XG4gICAgdmFyIHRpbWVvdXRzID0gdGhpcy5nZXRUaW1lb3V0cygpO1xuICAgIHZhciBtYXliZU5vZGUgPSB0aGlzLnByb3BzLm5vZGVSZWYgPyB1bmRlZmluZWQgOiBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTsgLy8gbm8gZXhpdCBhbmltYXRpb24gc2tpcCByaWdodCB0byBFWElURURcblxuICAgIGlmICghZXhpdCB8fCBjb25maWcuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgc3RhdHVzOiBFWElURURcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLnByb3BzLm9uRXhpdGVkKG1heWJlTm9kZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzLm9uRXhpdChtYXliZU5vZGUpO1xuICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcbiAgICAgIHN0YXR1czogRVhJVElOR1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMy5wcm9wcy5vbkV4aXRpbmcobWF5YmVOb2RlKTtcblxuICAgICAgX3RoaXMzLm9uVHJhbnNpdGlvbkVuZCh0aW1lb3V0cy5leGl0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICAgIHN0YXR1czogRVhJVEVEXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczMucHJvcHMub25FeGl0ZWQobWF5YmVOb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY2FuY2VsTmV4dENhbGxiYWNrID0gZnVuY3Rpb24gY2FuY2VsTmV4dENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLm5leHRDYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5uZXh0Q2FsbGJhY2suY2FuY2VsKCk7XG4gICAgICB0aGlzLm5leHRDYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5zYWZlU2V0U3RhdGUgPSBmdW5jdGlvbiBzYWZlU2V0U3RhdGUobmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICAgIC8vIFRoaXMgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSwgYnV0IHRoZXJlIGFyZSB3ZWlyZCByYWNlIGNvbmRpdGlvbnMgd2l0aFxuICAgIC8vIHNldFN0YXRlIGNhbGxiYWNrcyBhbmQgdW5tb3VudGluZyBpbiB0ZXN0aW5nLCBzbyBhbHdheXMgbWFrZSBzdXJlIHRoYXRcbiAgICAvLyB3ZSBjYW4gY2FuY2VsIGFueSBwZW5kaW5nIHNldFN0YXRlIGNhbGxiYWNrcyBhZnRlciB3ZSB1bm1vdW50LlxuICAgIGNhbGxiYWNrID0gdGhpcy5zZXROZXh0Q2FsbGJhY2soY2FsbGJhY2spO1xuICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgX3Byb3RvLnNldE5leHRDYWxsYmFjayA9IGZ1bmN0aW9uIHNldE5leHRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgdmFyIGFjdGl2ZSA9IHRydWU7XG5cbiAgICB0aGlzLm5leHRDYWxsYmFjayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXM0Lm5leHRDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5uZXh0Q2FsbGJhY2suY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLm5leHRDYWxsYmFjaztcbiAgfTtcblxuICBfcHJvdG8ub25UcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKHRpbWVvdXQsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnNldE5leHRDYWxsYmFjayhoYW5kbGVyKTtcbiAgICB2YXIgbm9kZSA9IHRoaXMucHJvcHMubm9kZVJlZiA/IHRoaXMucHJvcHMubm9kZVJlZi5jdXJyZW50IDogUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG4gICAgdmFyIGRvZXNOb3RIYXZlVGltZW91dE9yTGlzdGVuZXIgPSB0aW1lb3V0ID09IG51bGwgJiYgIXRoaXMucHJvcHMuYWRkRW5kTGlzdGVuZXI7XG5cbiAgICBpZiAoIW5vZGUgfHwgZG9lc05vdEhhdmVUaW1lb3V0T3JMaXN0ZW5lcikge1xuICAgICAgc2V0VGltZW91dCh0aGlzLm5leHRDYWxsYmFjaywgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMuYWRkRW5kTGlzdGVuZXIpIHtcbiAgICAgIHZhciBfcmVmMyA9IHRoaXMucHJvcHMubm9kZVJlZiA/IFt0aGlzLm5leHRDYWxsYmFja10gOiBbbm9kZSwgdGhpcy5uZXh0Q2FsbGJhY2tdLFxuICAgICAgICAgIG1heWJlTm9kZSA9IF9yZWYzWzBdLFxuICAgICAgICAgIG1heWJlTmV4dENhbGxiYWNrID0gX3JlZjNbMV07XG5cbiAgICAgIHRoaXMucHJvcHMuYWRkRW5kTGlzdGVuZXIobWF5YmVOb2RlLCBtYXliZU5leHRDYWxsYmFjayk7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgc2V0VGltZW91dCh0aGlzLm5leHRDYWxsYmFjaywgdGltZW91dCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHN0YXR1cyA9IHRoaXMuc3RhdGUuc3RhdHVzO1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gVU5NT1VOVEVEKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBfaW4gPSBfdGhpcyRwcm9wcy5pbixcbiAgICAgICAgX21vdW50T25FbnRlciA9IF90aGlzJHByb3BzLm1vdW50T25FbnRlcixcbiAgICAgICAgX3VubW91bnRPbkV4aXQgPSBfdGhpcyRwcm9wcy51bm1vdW50T25FeGl0LFxuICAgICAgICBfYXBwZWFyID0gX3RoaXMkcHJvcHMuYXBwZWFyLFxuICAgICAgICBfZW50ZXIgPSBfdGhpcyRwcm9wcy5lbnRlcixcbiAgICAgICAgX2V4aXQgPSBfdGhpcyRwcm9wcy5leGl0LFxuICAgICAgICBfdGltZW91dCA9IF90aGlzJHByb3BzLnRpbWVvdXQsXG4gICAgICAgIF9hZGRFbmRMaXN0ZW5lciA9IF90aGlzJHByb3BzLmFkZEVuZExpc3RlbmVyLFxuICAgICAgICBfb25FbnRlciA9IF90aGlzJHByb3BzLm9uRW50ZXIsXG4gICAgICAgIF9vbkVudGVyaW5nID0gX3RoaXMkcHJvcHMub25FbnRlcmluZyxcbiAgICAgICAgX29uRW50ZXJlZCA9IF90aGlzJHByb3BzLm9uRW50ZXJlZCxcbiAgICAgICAgX29uRXhpdCA9IF90aGlzJHByb3BzLm9uRXhpdCxcbiAgICAgICAgX29uRXhpdGluZyA9IF90aGlzJHByb3BzLm9uRXhpdGluZyxcbiAgICAgICAgX29uRXhpdGVkID0gX3RoaXMkcHJvcHMub25FeGl0ZWQsXG4gICAgICAgIF9ub2RlUmVmID0gX3RoaXMkcHJvcHMubm9kZVJlZixcbiAgICAgICAgY2hpbGRQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImluXCIsIFwibW91bnRPbkVudGVyXCIsIFwidW5tb3VudE9uRXhpdFwiLCBcImFwcGVhclwiLCBcImVudGVyXCIsIFwiZXhpdFwiLCBcInRpbWVvdXRcIiwgXCJhZGRFbmRMaXN0ZW5lclwiLCBcIm9uRW50ZXJcIiwgXCJvbkVudGVyaW5nXCIsIFwib25FbnRlcmVkXCIsIFwib25FeGl0XCIsIFwib25FeGl0aW5nXCIsIFwib25FeGl0ZWRcIiwgXCJub2RlUmVmXCJdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAvLyBhbGxvd3MgZm9yIG5lc3RlZCBUcmFuc2l0aW9uc1xuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUcmFuc2l0aW9uR3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9LCB0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicgPyBjaGlsZHJlbihzdGF0dXMsIGNoaWxkUHJvcHMpIDogUmVhY3QuY2xvbmVFbGVtZW50KFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pLCBjaGlsZFByb3BzKSlcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBUcmFuc2l0aW9uO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5UcmFuc2l0aW9uLmNvbnRleHRUeXBlID0gVHJhbnNpdGlvbkdyb3VwQ29udGV4dDtcblRyYW5zaXRpb24ucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICAvKipcbiAgICogQSBSZWFjdCByZWZlcmVuY2UgdG8gRE9NIGVsZW1lbnQgdGhhdCBuZWVkIHRvIHRyYW5zaXRpb246XG4gICAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81MTEyNzEzMC80NjcxOTMyXG4gICAqXG4gICAqICAgLSBXaGVuIGBub2RlUmVmYCBwcm9wIGlzIHVzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkIHRvIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgKiAgICAgIChlLmcuIGBvbkVudGVyYCkgYmVjYXVzZSB1c2VyIGFscmVhZHkgaGFzIGRpcmVjdCBhY2Nlc3MgdG8gdGhlIG5vZGUuXG4gICAqICAgLSBXaGVuIGNoYW5naW5nIGBrZXlgIHByb3Agb2YgYFRyYW5zaXRpb25gIGluIGEgYFRyYW5zaXRpb25Hcm91cGAgYSBuZXdcbiAgICogICAgIGBub2RlUmVmYCBuZWVkIHRvIGJlIHByb3ZpZGVkIHRvIGBUcmFuc2l0aW9uYCB3aXRoIGNoYW5nZWQgYGtleWAgcHJvcFxuICAgKiAgICAgKHNlZVxuICAgKiAgICAgW3Rlc3QvQ1NTVHJhbnNpdGlvbi10ZXN0LmpzXShodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2Jsb2IvMTM0MzVmODk3YjNhYjcxZjZlMTlkNzI0ZjE0NTU5NmY1OTEwNTgxYy90ZXN0L0NTU1RyYW5zaXRpb24tdGVzdC5qcyNMMzYyLUw0MzcpKS5cbiAgICovXG4gIG5vZGVSZWY6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgY3VycmVudDogdHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnID8gUHJvcFR5cGVzLmFueSA6IGZ1bmN0aW9uIChwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wVmFsdWVba2V5XTtcbiAgICAgIHJldHVybiBQcm9wVHlwZXMuaW5zdGFuY2VPZih2YWx1ZSAmJiAnb3duZXJEb2N1bWVudCcgaW4gdmFsdWUgPyB2YWx1ZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LkVsZW1lbnQgOiBFbGVtZW50KShwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KTtcbiAgICB9XG4gIH0pLFxuXG4gIC8qKlxuICAgKiBBIGBmdW5jdGlvbmAgY2hpbGQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiBhIFJlYWN0IGVsZW1lbnQuIFRoaXMgZnVuY3Rpb24gaXNcbiAgICogY2FsbGVkIHdpdGggdGhlIGN1cnJlbnQgdHJhbnNpdGlvbiBzdGF0dXMgKGAnZW50ZXJpbmcnYCwgYCdlbnRlcmVkJ2AsXG4gICAqIGAnZXhpdGluZydgLCBgJ2V4aXRlZCdgKSwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gYXBwbHkgY29udGV4dFxuICAgKiBzcGVjaWZpYyBwcm9wcyB0byBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogYGBganN4XG4gICAqIDxUcmFuc2l0aW9uIGluPXt0aGlzLnN0YXRlLmlufSB0aW1lb3V0PXsxNTB9PlxuICAgKiAgIHtzdGF0ZSA9PiAoXG4gICAqICAgICA8TXlDb21wb25lbnQgY2xhc3NOYW1lPXtgZmFkZSBmYWRlLSR7c3RhdGV9YH0gLz5cbiAgICogICApfVxuICAgKiA8L1RyYW5zaXRpb24+XG4gICAqIGBgYFxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsIFByb3BUeXBlcy5lbGVtZW50LmlzUmVxdWlyZWRdKS5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBjb21wb25lbnQ7IHRyaWdnZXJzIHRoZSBlbnRlciBvciBleGl0IHN0YXRlc1xuICAgKi9cbiAgaW46IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IHRoZSBjaGlsZCBjb21wb25lbnQgaXMgbW91bnRlZCBpbW1lZGlhdGVseSBhbG9uZyB3aXRoXG4gICAqIHRoZSBwYXJlbnQgYFRyYW5zaXRpb25gIGNvbXBvbmVudC4gSWYgeW91IHdhbnQgdG8gXCJsYXp5IG1vdW50XCIgdGhlIGNvbXBvbmVudCBvbiB0aGVcbiAgICogZmlyc3QgYGluPXt0cnVlfWAgeW91IGNhbiBzZXQgYG1vdW50T25FbnRlcmAuIEFmdGVyIHRoZSBmaXJzdCBlbnRlciB0cmFuc2l0aW9uIHRoZSBjb21wb25lbnQgd2lsbCBzdGF5XG4gICAqIG1vdW50ZWQsIGV2ZW4gb24gXCJleGl0ZWRcIiwgdW5sZXNzIHlvdSBhbHNvIHNwZWNpZnkgYHVubW91bnRPbkV4aXRgLlxuICAgKi9cbiAgbW91bnRPbkVudGVyOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQnkgZGVmYXVsdCB0aGUgY2hpbGQgY29tcG9uZW50IHN0YXlzIG1vdW50ZWQgYWZ0ZXIgaXQgcmVhY2hlcyB0aGUgYCdleGl0ZWQnYCBzdGF0ZS5cbiAgICogU2V0IGB1bm1vdW50T25FeGl0YCBpZiB5b3UnZCBwcmVmZXIgdG8gdW5tb3VudCB0aGUgY29tcG9uZW50IGFmdGVyIGl0IGZpbmlzaGVzIGV4aXRpbmcuXG4gICAqL1xuICB1bm1vdW50T25FeGl0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQnkgZGVmYXVsdCB0aGUgY2hpbGQgY29tcG9uZW50IGRvZXMgbm90IHBlcmZvcm0gdGhlIGVudGVyIHRyYW5zaXRpb24gd2hlblxuICAgKiBpdCBmaXJzdCBtb3VudHMsIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIGBpbmAuIElmIHlvdSB3YW50IHRoaXNcbiAgICogYmVoYXZpb3IsIHNldCBib3RoIGBhcHBlYXJgIGFuZCBgaW5gIHRvIGB0cnVlYC5cbiAgICpcbiAgICogPiAqKk5vdGUqKjogdGhlcmUgYXJlIG5vIHNwZWNpYWwgYXBwZWFyIHN0YXRlcyBsaWtlIGBhcHBlYXJpbmdgL2BhcHBlYXJlZGAsIHRoaXMgcHJvcFxuICAgKiA+IG9ubHkgYWRkcyBhbiBhZGRpdGlvbmFsIGVudGVyIHRyYW5zaXRpb24uIEhvd2V2ZXIsIGluIHRoZVxuICAgKiA+IGA8Q1NTVHJhbnNpdGlvbj5gIGNvbXBvbmVudCB0aGF0IGZpcnN0IGVudGVyIHRyYW5zaXRpb24gZG9lcyByZXN1bHQgaW5cbiAgICogPiBhZGRpdGlvbmFsIGAuYXBwZWFyLSpgIGNsYXNzZXMsIHRoYXQgd2F5IHlvdSBjYW4gY2hvb3NlIHRvIHN0eWxlIGl0XG4gICAqID4gZGlmZmVyZW50bHkuXG4gICAqL1xuICBhcHBlYXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBlbnRlciB0cmFuc2l0aW9ucy5cbiAgICovXG4gIGVudGVyOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgZXhpdCB0cmFuc2l0aW9ucy5cbiAgICovXG4gIGV4aXQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24sIGluIG1pbGxpc2Vjb25kcy5cbiAgICogUmVxdWlyZWQgdW5sZXNzIGBhZGRFbmRMaXN0ZW5lcmAgaXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIFlvdSBtYXkgc3BlY2lmeSBhIHNpbmdsZSB0aW1lb3V0IGZvciBhbGwgdHJhbnNpdGlvbnM6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiB0aW1lb3V0PXs1MDB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBvciBpbmRpdmlkdWFsbHk6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiB0aW1lb3V0PXt7XG4gICAqICBhcHBlYXI6IDUwMCxcbiAgICogIGVudGVyOiAzMDAsXG4gICAqICBleGl0OiA1MDAsXG4gICAqIH19XG4gICAqIGBgYFxuICAgKlxuICAgKiAtIGBhcHBlYXJgIGRlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiBgZW50ZXJgXG4gICAqIC0gYGVudGVyYCBkZWZhdWx0cyB0byBgMGBcbiAgICogLSBgZXhpdGAgZGVmYXVsdHMgdG8gYDBgXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXIgfCB7IGVudGVyPzogbnVtYmVyLCBleGl0PzogbnVtYmVyLCBhcHBlYXI/OiBudW1iZXIgfX1cbiAgICovXG4gIHRpbWVvdXQ6IGZ1bmN0aW9uIHRpbWVvdXQocHJvcHMpIHtcbiAgICB2YXIgcHQgPSB0aW1lb3V0c1NoYXBlO1xuICAgIGlmICghcHJvcHMuYWRkRW5kTGlzdGVuZXIpIHB0ID0gcHQuaXNSZXF1aXJlZDtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBwdC5hcHBseSh2b2lkIDAsIFtwcm9wc10uY29uY2F0KGFyZ3MpKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGEgY3VzdG9tIHRyYW5zaXRpb24gZW5kIHRyaWdnZXIuIENhbGxlZCB3aXRoIHRoZSB0cmFuc2l0aW9uaW5nXG4gICAqIERPTSBub2RlIGFuZCBhIGBkb25lYCBjYWxsYmFjay4gQWxsb3dzIGZvciBtb3JlIGZpbmUgZ3JhaW5lZCB0cmFuc2l0aW9uIGVuZFxuICAgKiBsb2dpYy4gVGltZW91dHMgYXJlIHN0aWxsIHVzZWQgYXMgYSBmYWxsYmFjayBpZiBwcm92aWRlZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogYGBganN4XG4gICAqIGFkZEVuZExpc3RlbmVyPXsobm9kZSwgZG9uZSkgPT4ge1xuICAgKiAgIC8vIHVzZSB0aGUgY3NzIHRyYW5zaXRpb25lbmQgZXZlbnQgdG8gbWFyayB0aGUgZmluaXNoIG9mIGEgdHJhbnNpdGlvblxuICAgKiAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGRvbmUsIGZhbHNlKTtcbiAgICogfX1cbiAgICogYGBgXG4gICAqL1xuICBhZGRFbmRMaXN0ZW5lcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgXCJlbnRlcmluZ1wiIHN0YXR1cyBpcyBhcHBsaWVkLiBBbiBleHRyYSBwYXJhbWV0ZXJcbiAgICogYGlzQXBwZWFyaW5nYCBpcyBzdXBwbGllZCB0byBpbmRpY2F0ZSBpZiB0aGUgZW50ZXIgc3RhZ2UgaXMgb2NjdXJyaW5nIG9uIHRoZSBpbml0aWFsIG1vdW50XG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbCkgLT4gdm9pZFxuICAgKi9cbiAgb25FbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImVudGVyaW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuIEFuIGV4dHJhIHBhcmFtZXRlclxuICAgKiBgaXNBcHBlYXJpbmdgIGlzIHN1cHBsaWVkIHRvIGluZGljYXRlIGlmIHRoZSBlbnRlciBzdGFnZSBpcyBvY2N1cnJpbmcgb24gdGhlIGluaXRpYWwgbW91bnRcbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKVxuICAgKi9cbiAgb25FbnRlcmluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImVudGVyZWRcIiBzdGF0dXMgaXMgYXBwbGllZC4gQW4gZXh0cmEgcGFyYW1ldGVyXG4gICAqIGBpc0FwcGVhcmluZ2AgaXMgc3VwcGxpZWQgdG8gaW5kaWNhdGUgaWYgdGhlIGVudGVyIHN0YWdlIGlzIG9jY3VycmluZyBvbiB0aGUgaW5pdGlhbCBtb3VudFxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpIC0+IHZvaWRcbiAgICovXG4gIG9uRW50ZXJlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgXCJleGl0aW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KSAtPiB2b2lkXG4gICAqL1xuICBvbkV4aXQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJleGl0aW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KSAtPiB2b2lkXG4gICAqL1xuICBvbkV4aXRpbmc6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciB0aGUgXCJleGl0ZWRcIiBzdGF0dXMgaXMgYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZFxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCkgLT4gdm9pZFxuICAgKi9cbiAgb25FeGl0ZWQ6IFByb3BUeXBlcy5mdW5jXG59IDoge307IC8vIE5hbWUgdGhlIGZ1bmN0aW9uIHNvIGl0IGlzIGNsZWFyZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cblRyYW5zaXRpb24uZGVmYXVsdFByb3BzID0ge1xuICBpbjogZmFsc2UsXG4gIG1vdW50T25FbnRlcjogZmFsc2UsXG4gIHVubW91bnRPbkV4aXQ6IGZhbHNlLFxuICBhcHBlYXI6IGZhbHNlLFxuICBlbnRlcjogdHJ1ZSxcbiAgZXhpdDogdHJ1ZSxcbiAgb25FbnRlcjogbm9vcCxcbiAgb25FbnRlcmluZzogbm9vcCxcbiAgb25FbnRlcmVkOiBub29wLFxuICBvbkV4aXQ6IG5vb3AsXG4gIG9uRXhpdGluZzogbm9vcCxcbiAgb25FeGl0ZWQ6IG5vb3Bcbn07XG5UcmFuc2l0aW9uLlVOTU9VTlRFRCA9IFVOTU9VTlRFRDtcblRyYW5zaXRpb24uRVhJVEVEID0gRVhJVEVEO1xuVHJhbnNpdGlvbi5FTlRFUklORyA9IEVOVEVSSU5HO1xuVHJhbnNpdGlvbi5FTlRFUkVEID0gRU5URVJFRDtcblRyYW5zaXRpb24uRVhJVElORyA9IEVYSVRJTkc7XG5leHBvcnQgZGVmYXVsdCBUcmFuc2l0aW9uOyIsImltcG9ydCB7IENoaWxkcmVuLCBjbG9uZUVsZW1lbnQsIGlzVmFsaWRFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuLyoqXG4gKiBHaXZlbiBgdGhpcy5wcm9wcy5jaGlsZHJlbmAsIHJldHVybiBhbiBvYmplY3QgbWFwcGluZyBrZXkgdG8gY2hpbGQuXG4gKlxuICogQHBhcmFtIHsqfSBjaGlsZHJlbiBgdGhpcy5wcm9wcy5jaGlsZHJlbmBcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwcGluZyBvZiBrZXkgdG8gY2hpbGRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hpbGRNYXBwaW5nKGNoaWxkcmVuLCBtYXBGbikge1xuICB2YXIgbWFwcGVyID0gZnVuY3Rpb24gbWFwcGVyKGNoaWxkKSB7XG4gICAgcmV0dXJuIG1hcEZuICYmIGlzVmFsaWRFbGVtZW50KGNoaWxkKSA/IG1hcEZuKGNoaWxkKSA6IGNoaWxkO1xuICB9O1xuXG4gIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoY2hpbGRyZW4pIENoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gYztcbiAgfSkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAvLyBydW4gdGhlIG1hcCBmdW5jdGlvbiBoZXJlIGluc3RlYWQgc28gdGhhdCB0aGUga2V5IGlzIHRoZSBjb21wdXRlZCBvbmVcbiAgICByZXN1bHRbY2hpbGQua2V5XSA9IG1hcHBlcihjaGlsZCk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBXaGVuIHlvdSdyZSBhZGRpbmcgb3IgcmVtb3ZpbmcgY2hpbGRyZW4gc29tZSBtYXkgYmUgYWRkZWQgb3IgcmVtb3ZlZCBpbiB0aGVcbiAqIHNhbWUgcmVuZGVyIHBhc3MuIFdlIHdhbnQgdG8gc2hvdyAqYm90aCogc2luY2Ugd2Ugd2FudCB0byBzaW11bHRhbmVvdXNseVxuICogYW5pbWF0ZSBlbGVtZW50cyBpbiBhbmQgb3V0LiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgcHJldmlvdXMgc2V0IG9mIGtleXNcbiAqIGFuZCBhIG5ldyBzZXQgb2Yga2V5cyBhbmQgbWVyZ2VzIHRoZW0gd2l0aCBpdHMgYmVzdCBndWVzcyBvZiB0aGUgY29ycmVjdFxuICogb3JkZXJpbmcuIEluIHRoZSBmdXR1cmUgd2UgbWF5IGV4cG9zZSBzb21lIG9mIHRoZSB1dGlsaXRpZXMgaW5cbiAqIFJlYWN0TXVsdGlDaGlsZCB0byBtYWtlIHRoaXMgZWFzeSwgYnV0IGZvciBub3cgUmVhY3QgaXRzZWxmIGRvZXMgbm90XG4gKiBkaXJlY3RseSBoYXZlIHRoaXMgY29uY2VwdCBvZiB0aGUgdW5pb24gb2YgcHJldkNoaWxkcmVuIGFuZCBuZXh0Q2hpbGRyZW5cbiAqIHNvIHdlIGltcGxlbWVudCBpdCBoZXJlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2IHByZXYgY2hpbGRyZW4gYXMgcmV0dXJuZWQgZnJvbVxuICogYFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcoKWAuXG4gKiBAcGFyYW0ge29iamVjdH0gbmV4dCBuZXh0IGNoaWxkcmVuIGFzIHJldHVybmVkIGZyb21cbiAqIGBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKClgLlxuICogQHJldHVybiB7b2JqZWN0fSBhIGtleSBzZXQgdGhhdCBjb250YWlucyBhbGwga2V5cyBpbiBgcHJldmAgYW5kIGFsbCBrZXlzXG4gKiBpbiBgbmV4dGAgaW4gYSByZWFzb25hYmxlIG9yZGVyLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUNoaWxkTWFwcGluZ3MocHJldiwgbmV4dCkge1xuICBwcmV2ID0gcHJldiB8fCB7fTtcbiAgbmV4dCA9IG5leHQgfHwge307XG5cbiAgZnVuY3Rpb24gZ2V0VmFsdWVGb3JLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleSBpbiBuZXh0ID8gbmV4dFtrZXldIDogcHJldltrZXldO1xuICB9IC8vIEZvciBlYWNoIGtleSBvZiBgbmV4dGAsIHRoZSBsaXN0IG9mIGtleXMgdG8gaW5zZXJ0IGJlZm9yZSB0aGF0IGtleSBpblxuICAvLyB0aGUgY29tYmluZWQgbGlzdFxuXG5cbiAgdmFyIG5leHRLZXlzUGVuZGluZyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBwZW5kaW5nS2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIHByZXZLZXkgaW4gcHJldikge1xuICAgIGlmIChwcmV2S2V5IGluIG5leHQpIHtcbiAgICAgIGlmIChwZW5kaW5nS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgbmV4dEtleXNQZW5kaW5nW3ByZXZLZXldID0gcGVuZGluZ0tleXM7XG4gICAgICAgIHBlbmRpbmdLZXlzID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdLZXlzLnB1c2gocHJldktleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGk7XG4gIHZhciBjaGlsZE1hcHBpbmcgPSB7fTtcblxuICBmb3IgKHZhciBuZXh0S2V5IGluIG5leHQpIHtcbiAgICBpZiAobmV4dEtleXNQZW5kaW5nW25leHRLZXldKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbmV4dEtleXNQZW5kaW5nW25leHRLZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwZW5kaW5nTmV4dEtleSA9IG5leHRLZXlzUGVuZGluZ1tuZXh0S2V5XVtpXTtcbiAgICAgICAgY2hpbGRNYXBwaW5nW25leHRLZXlzUGVuZGluZ1tuZXh0S2V5XVtpXV0gPSBnZXRWYWx1ZUZvcktleShwZW5kaW5nTmV4dEtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGRNYXBwaW5nW25leHRLZXldID0gZ2V0VmFsdWVGb3JLZXkobmV4dEtleSk7XG4gIH0gLy8gRmluYWxseSwgYWRkIHRoZSBrZXlzIHdoaWNoIGRpZG4ndCBhcHBlYXIgYmVmb3JlIGFueSBrZXkgaW4gYG5leHRgXG5cblxuICBmb3IgKGkgPSAwOyBpIDwgcGVuZGluZ0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGlsZE1hcHBpbmdbcGVuZGluZ0tleXNbaV1dID0gZ2V0VmFsdWVGb3JLZXkocGVuZGluZ0tleXNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkTWFwcGluZztcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcChjaGlsZCwgcHJvcCwgcHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzW3Byb3BdICE9IG51bGwgPyBwcm9wc1twcm9wXSA6IGNoaWxkLnByb3BzW3Byb3BdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5pdGlhbENoaWxkTWFwcGluZyhwcm9wcywgb25FeGl0ZWQpIHtcbiAgcmV0dXJuIGdldENoaWxkTWFwcGluZyhwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgb25FeGl0ZWQ6IG9uRXhpdGVkLmJpbmQobnVsbCwgY2hpbGQpLFxuICAgICAgaW46IHRydWUsXG4gICAgICBhcHBlYXI6IGdldFByb3AoY2hpbGQsICdhcHBlYXInLCBwcm9wcyksXG4gICAgICBlbnRlcjogZ2V0UHJvcChjaGlsZCwgJ2VudGVyJywgcHJvcHMpLFxuICAgICAgZXhpdDogZ2V0UHJvcChjaGlsZCwgJ2V4aXQnLCBwcm9wcylcbiAgICB9KTtcbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV4dENoaWxkTWFwcGluZyhuZXh0UHJvcHMsIHByZXZDaGlsZE1hcHBpbmcsIG9uRXhpdGVkKSB7XG4gIHZhciBuZXh0Q2hpbGRNYXBwaW5nID0gZ2V0Q2hpbGRNYXBwaW5nKG5leHRQcm9wcy5jaGlsZHJlbik7XG4gIHZhciBjaGlsZHJlbiA9IG1lcmdlQ2hpbGRNYXBwaW5ncyhwcmV2Q2hpbGRNYXBwaW5nLCBuZXh0Q2hpbGRNYXBwaW5nKTtcbiAgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2tleV07XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHJldHVybjtcbiAgICB2YXIgaGFzUHJldiA9IChrZXkgaW4gcHJldkNoaWxkTWFwcGluZyk7XG4gICAgdmFyIGhhc05leHQgPSAoa2V5IGluIG5leHRDaGlsZE1hcHBpbmcpO1xuICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRNYXBwaW5nW2tleV07XG4gICAgdmFyIGlzTGVhdmluZyA9IGlzVmFsaWRFbGVtZW50KHByZXZDaGlsZCkgJiYgIXByZXZDaGlsZC5wcm9wcy5pbjsgLy8gaXRlbSBpcyBuZXcgKGVudGVyaW5nKVxuXG4gICAgaWYgKGhhc05leHQgJiYgKCFoYXNQcmV2IHx8IGlzTGVhdmluZykpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdlbnRlcmluZycsIGtleSlcbiAgICAgIGNoaWxkcmVuW2tleV0gPSBjbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgb25FeGl0ZWQ6IG9uRXhpdGVkLmJpbmQobnVsbCwgY2hpbGQpLFxuICAgICAgICBpbjogdHJ1ZSxcbiAgICAgICAgZXhpdDogZ2V0UHJvcChjaGlsZCwgJ2V4aXQnLCBuZXh0UHJvcHMpLFxuICAgICAgICBlbnRlcjogZ2V0UHJvcChjaGlsZCwgJ2VudGVyJywgbmV4dFByb3BzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghaGFzTmV4dCAmJiBoYXNQcmV2ICYmICFpc0xlYXZpbmcpIHtcbiAgICAgIC8vIGl0ZW0gaXMgb2xkIChleGl0aW5nKVxuICAgICAgLy8gY29uc29sZS5sb2coJ2xlYXZpbmcnLCBrZXkpXG4gICAgICBjaGlsZHJlbltrZXldID0gY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgIGluOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChoYXNOZXh0ICYmIGhhc1ByZXYgJiYgaXNWYWxpZEVsZW1lbnQocHJldkNoaWxkKSkge1xuICAgICAgLy8gaXRlbSBoYXNuJ3QgY2hhbmdlZCB0cmFuc2l0aW9uIHN0YXRlc1xuICAgICAgLy8gY29weSBvdmVyIHRoZSBsYXN0IHRyYW5zaXRpb24gcHJvcHM7XG4gICAgICAvLyBjb25zb2xlLmxvZygndW5jaGFuZ2VkJywga2V5KVxuICAgICAgY2hpbGRyZW5ba2V5XSA9IGNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICBvbkV4aXRlZDogb25FeGl0ZWQuYmluZChudWxsLCBjaGlsZCksXG4gICAgICAgIGluOiBwcmV2Q2hpbGQucHJvcHMuaW4sXG4gICAgICAgIGV4aXQ6IGdldFByb3AoY2hpbGQsICdleGl0JywgbmV4dFByb3BzKSxcbiAgICAgICAgZW50ZXI6IGdldFByb3AoY2hpbGQsICdlbnRlcicsIG5leHRQcm9wcylcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjaGlsZHJlbjtcbn0iLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlXCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBUcmFuc2l0aW9uR3JvdXBDb250ZXh0IGZyb20gJy4vVHJhbnNpdGlvbkdyb3VwQ29udGV4dCc7XG5pbXBvcnQgeyBnZXRDaGlsZE1hcHBpbmcsIGdldEluaXRpYWxDaGlsZE1hcHBpbmcsIGdldE5leHRDaGlsZE1hcHBpbmcgfSBmcm9tICcuL3V0aWxzL0NoaWxkTWFwcGluZyc7XG5cbnZhciB2YWx1ZXMgPSBPYmplY3QudmFsdWVzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIG9ialtrXTtcbiAgfSk7XG59O1xuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBjb21wb25lbnQ6ICdkaXYnLFxuICBjaGlsZEZhY3Rvcnk6IGZ1bmN0aW9uIGNoaWxkRmFjdG9yeShjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfVxufTtcbi8qKlxuICogVGhlIGA8VHJhbnNpdGlvbkdyb3VwPmAgY29tcG9uZW50IG1hbmFnZXMgYSBzZXQgb2YgdHJhbnNpdGlvbiBjb21wb25lbnRzXG4gKiAoYDxUcmFuc2l0aW9uPmAgYW5kIGA8Q1NTVHJhbnNpdGlvbj5gKSBpbiBhIGxpc3QuIExpa2Ugd2l0aCB0aGUgdHJhbnNpdGlvblxuICogY29tcG9uZW50cywgYDxUcmFuc2l0aW9uR3JvdXA+YCBpcyBhIHN0YXRlIG1hY2hpbmUgZm9yIG1hbmFnaW5nIHRoZSBtb3VudGluZ1xuICogYW5kIHVubW91bnRpbmcgb2YgY29tcG9uZW50cyBvdmVyIHRpbWUuXG4gKlxuICogQ29uc2lkZXIgdGhlIGV4YW1wbGUgYmVsb3cuIEFzIGl0ZW1zIGFyZSByZW1vdmVkIG9yIGFkZGVkIHRvIHRoZSBUb2RvTGlzdCB0aGVcbiAqIGBpbmAgcHJvcCBpcyB0b2dnbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIGA8VHJhbnNpdGlvbkdyb3VwPmAuXG4gKlxuICogTm90ZSB0aGF0IGA8VHJhbnNpdGlvbkdyb3VwPmAgIGRvZXMgbm90IGRlZmluZSBhbnkgYW5pbWF0aW9uIGJlaGF2aW9yIVxuICogRXhhY3RseSBfaG93XyBhIGxpc3QgaXRlbSBhbmltYXRlcyBpcyB1cCB0byB0aGUgaW5kaXZpZHVhbCB0cmFuc2l0aW9uXG4gKiBjb21wb25lbnQuIFRoaXMgbWVhbnMgeW91IGNhbiBtaXggYW5kIG1hdGNoIGFuaW1hdGlvbnMgYWNyb3NzIGRpZmZlcmVudCBsaXN0XG4gKiBpdGVtcy5cbiAqL1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRyYW5zaXRpb25Hcm91cCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVHJhbnNpdGlvbkdyb3VwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpIHx8IHRoaXM7XG5cbiAgICB2YXIgaGFuZGxlRXhpdGVkID0gX3RoaXMuaGFuZGxlRXhpdGVkLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpOyAvLyBJbml0aWFsIGNoaWxkcmVuIHNob3VsZCBhbGwgYmUgZW50ZXJpbmcsIGRlcGVuZGVudCBvbiBhcHBlYXJcblxuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBjb250ZXh0VmFsdWU6IHtcbiAgICAgICAgaXNNb3VudGluZzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGhhbmRsZUV4aXRlZDogaGFuZGxlRXhpdGVkLFxuICAgICAgZmlyc3RSZW5kZXI6IHRydWVcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUcmFuc2l0aW9uR3JvdXAucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjb250ZXh0VmFsdWU6IHtcbiAgICAgICAgaXNNb3VudGluZzogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgfTtcblxuICBUcmFuc2l0aW9uR3JvdXAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgX3JlZikge1xuICAgIHZhciBwcmV2Q2hpbGRNYXBwaW5nID0gX3JlZi5jaGlsZHJlbixcbiAgICAgICAgaGFuZGxlRXhpdGVkID0gX3JlZi5oYW5kbGVFeGl0ZWQsXG4gICAgICAgIGZpcnN0UmVuZGVyID0gX3JlZi5maXJzdFJlbmRlcjtcbiAgICByZXR1cm4ge1xuICAgICAgY2hpbGRyZW46IGZpcnN0UmVuZGVyID8gZ2V0SW5pdGlhbENoaWxkTWFwcGluZyhuZXh0UHJvcHMsIGhhbmRsZUV4aXRlZCkgOiBnZXROZXh0Q2hpbGRNYXBwaW5nKG5leHRQcm9wcywgcHJldkNoaWxkTWFwcGluZywgaGFuZGxlRXhpdGVkKSxcbiAgICAgIGZpcnN0UmVuZGVyOiBmYWxzZVxuICAgIH07XG4gIH0gLy8gbm9kZSBpcyBgdW5kZWZpbmVkYCB3aGVuIHVzZXIgcHJvdmlkZWQgYG5vZGVSZWZgIHByb3BcbiAgO1xuXG4gIF9wcm90by5oYW5kbGVFeGl0ZWQgPSBmdW5jdGlvbiBoYW5kbGVFeGl0ZWQoY2hpbGQsIG5vZGUpIHtcbiAgICB2YXIgY3VycmVudENoaWxkTWFwcGluZyA9IGdldENoaWxkTWFwcGluZyh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICBpZiAoY2hpbGQua2V5IGluIGN1cnJlbnRDaGlsZE1hcHBpbmcpIHJldHVybjtcblxuICAgIGlmIChjaGlsZC5wcm9wcy5vbkV4aXRlZCkge1xuICAgICAgY2hpbGQucHJvcHMub25FeGl0ZWQobm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubW91bnRlZCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gX2V4dGVuZHMoe30sIHN0YXRlLmNoaWxkcmVuKTtcblxuICAgICAgICBkZWxldGUgY2hpbGRyZW5bY2hpbGQua2V5XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIENvbXBvbmVudCA9IF90aGlzJHByb3BzLmNvbXBvbmVudCxcbiAgICAgICAgY2hpbGRGYWN0b3J5ID0gX3RoaXMkcHJvcHMuY2hpbGRGYWN0b3J5LFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJjb21wb25lbnRcIiwgXCJjaGlsZEZhY3RvcnlcIl0pO1xuXG4gICAgdmFyIGNvbnRleHRWYWx1ZSA9IHRoaXMuc3RhdGUuY29udGV4dFZhbHVlO1xuICAgIHZhciBjaGlsZHJlbiA9IHZhbHVlcyh0aGlzLnN0YXRlLmNoaWxkcmVuKS5tYXAoY2hpbGRGYWN0b3J5KTtcbiAgICBkZWxldGUgcHJvcHMuYXBwZWFyO1xuICAgIGRlbGV0ZSBwcm9wcy5lbnRlcjtcbiAgICBkZWxldGUgcHJvcHMuZXhpdDtcblxuICAgIGlmIChDb21wb25lbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUcmFuc2l0aW9uR3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBjb250ZXh0VmFsdWVcbiAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbkdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGNvbnRleHRWYWx1ZVxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgcHJvcHMsIGNoaWxkcmVuKSk7XG4gIH07XG5cbiAgcmV0dXJuIFRyYW5zaXRpb25Hcm91cDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuVHJhbnNpdGlvbkdyb3VwLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgLyoqXG4gICAqIGA8VHJhbnNpdGlvbkdyb3VwPmAgcmVuZGVycyBhIGA8ZGl2PmAgYnkgZGVmYXVsdC4gWW91IGNhbiBjaGFuZ2UgdGhpc1xuICAgKiBiZWhhdmlvciBieSBwcm92aWRpbmcgYSBgY29tcG9uZW50YCBwcm9wLlxuICAgKiBJZiB5b3UgdXNlIFJlYWN0IHYxNisgYW5kIHdvdWxkIGxpa2UgdG8gYXZvaWQgYSB3cmFwcGluZyBgPGRpdj5gIGVsZW1lbnRcbiAgICogeW91IGNhbiBwYXNzIGluIGBjb21wb25lbnQ9e251bGx9YC4gVGhpcyBpcyB1c2VmdWwgaWYgdGhlIHdyYXBwaW5nIGRpdlxuICAgKiBib3JrcyB5b3VyIGNzcyBzdHlsZXMuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIGA8VHJhbnNpdGlvbj5gIGNvbXBvbmVudHMsIHRoYXQgYXJlIHRvZ2dsZWQgYGluYCBhbmQgb3V0IGFzIHRoZXlcbiAgICogbGVhdmUuIHRoZSBgPFRyYW5zaXRpb25Hcm91cD5gIHdpbGwgaW5qZWN0IHNwZWNpZmljIHRyYW5zaXRpb24gcHJvcHMsIHNvXG4gICAqIHJlbWVtYmVyIHRvIHNwcmVhZCB0aGVtIHRocm91Z2ggaWYgeW91IGFyZSB3cmFwcGluZyB0aGUgYDxUcmFuc2l0aW9uPmAgYXNcbiAgICogd2l0aCBvdXIgYDxGYWRlPmAgZXhhbXBsZS5cbiAgICpcbiAgICogV2hpbGUgdGhpcyBjb21wb25lbnQgaXMgbWVhbnQgZm9yIG11bHRpcGxlIGBUcmFuc2l0aW9uYCBvciBgQ1NTVHJhbnNpdGlvbmBcbiAgICogY2hpbGRyZW4sIHNvbWV0aW1lcyB5b3UgbWF5IHdhbnQgdG8gaGF2ZSBhIHNpbmdsZSB0cmFuc2l0aW9uIGNoaWxkIHdpdGhcbiAgICogY29udGVudCB0aGF0IHlvdSB3YW50IHRvIGJlIHRyYW5zaXRpb25lZCBvdXQgYW5kIGluIHdoZW4geW91IGNoYW5nZSBpdFxuICAgKiAoZS5nLiByb3V0ZXMsIGltYWdlcyBldGMuKSBJbiB0aGF0IGNhc2UgeW91IGNhbiBjaGFuZ2UgdGhlIGBrZXlgIHByb3Agb2ZcbiAgICogdGhlIHRyYW5zaXRpb24gY2hpbGQgYXMgeW91IGNoYW5nZSBpdHMgY29udGVudCwgdGhpcyB3aWxsIGNhdXNlXG4gICAqIGBUcmFuc2l0aW9uR3JvdXBgIHRvIHRyYW5zaXRpb24gdGhlIGNoaWxkIG91dCBhbmQgYmFjayBpbi5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogQSBjb252ZW5pZW5jZSBwcm9wIHRoYXQgZW5hYmxlcyBvciBkaXNhYmxlcyBhcHBlYXIgYW5pbWF0aW9uc1xuICAgKiBmb3IgYWxsIGNoaWxkcmVuLiBOb3RlIHRoYXQgc3BlY2lmeWluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IGRlZmF1bHRzIHNldFxuICAgKiBvbiBpbmRpdmlkdWFsIGNoaWxkcmVuIFRyYW5zaXRpb25zLlxuICAgKi9cbiAgYXBwZWFyOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQSBjb252ZW5pZW5jZSBwcm9wIHRoYXQgZW5hYmxlcyBvciBkaXNhYmxlcyBlbnRlciBhbmltYXRpb25zXG4gICAqIGZvciBhbGwgY2hpbGRyZW4uIE5vdGUgdGhhdCBzcGVjaWZ5aW5nIHRoaXMgd2lsbCBvdmVycmlkZSBhbnkgZGVmYXVsdHMgc2V0XG4gICAqIG9uIGluZGl2aWR1YWwgY2hpbGRyZW4gVHJhbnNpdGlvbnMuXG4gICAqL1xuICBlbnRlcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgcHJvcCB0aGF0IGVuYWJsZXMgb3IgZGlzYWJsZXMgZXhpdCBhbmltYXRpb25zXG4gICAqIGZvciBhbGwgY2hpbGRyZW4uIE5vdGUgdGhhdCBzcGVjaWZ5aW5nIHRoaXMgd2lsbCBvdmVycmlkZSBhbnkgZGVmYXVsdHMgc2V0XG4gICAqIG9uIGluZGl2aWR1YWwgY2hpbGRyZW4gVHJhbnNpdGlvbnMuXG4gICAqL1xuICBleGl0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogWW91IG1heSBuZWVkIHRvIGFwcGx5IHJlYWN0aXZlIHVwZGF0ZXMgdG8gYSBjaGlsZCBhcyBpdCBpcyBleGl0aW5nLlxuICAgKiBUaGlzIGlzIGdlbmVyYWxseSBkb25lIGJ5IHVzaW5nIGBjbG9uZUVsZW1lbnRgIGhvd2V2ZXIgaW4gdGhlIGNhc2Ugb2YgYW4gZXhpdGluZ1xuICAgKiBjaGlsZCB0aGUgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQgYW5kIG5vdCBhY2Nlc3NpYmxlIHRvIHRoZSBjb25zdW1lci5cbiAgICpcbiAgICogSWYgeW91IGRvIG5lZWQgdG8gdXBkYXRlIGEgY2hpbGQgYXMgaXQgbGVhdmVzIHlvdSBjYW4gcHJvdmlkZSBhIGBjaGlsZEZhY3RvcnlgXG4gICAqIHRvIHdyYXAgZXZlcnkgY2hpbGQsIGV2ZW4gdGhlIG9uZXMgdGhhdCBhcmUgbGVhdmluZy5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24oY2hpbGQ6IFJlYWN0RWxlbWVudCkgLT4gUmVhY3RFbGVtZW50XG4gICAqL1xuICBjaGlsZEZhY3Rvcnk6IFByb3BUeXBlcy5mdW5jXG59IDoge307XG5UcmFuc2l0aW9uR3JvdXAuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuZXhwb3J0IGRlZmF1bHQgVHJhbnNpdGlvbkdyb3VwOyIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB1c2VFdmVudENhbGxiYWNrIGZyb20gJy4uL3V0aWxzL3VzZUV2ZW50Q2FsbGJhY2snO1xudmFyIHVzZUVuaGFuY2VkRWZmZWN0ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBSZWFjdC51c2VFZmZlY3QgOiBSZWFjdC51c2VMYXlvdXRFZmZlY3Q7XG4vKipcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXG4gKi9cblxuZnVuY3Rpb24gUmlwcGxlKHByb3BzKSB7XG4gIHZhciBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIF9wcm9wcyRwdWxzYXRlID0gcHJvcHMucHVsc2F0ZSxcbiAgICAgIHB1bHNhdGUgPSBfcHJvcHMkcHVsc2F0ZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkcHVsc2F0ZSxcbiAgICAgIHJpcHBsZVggPSBwcm9wcy5yaXBwbGVYLFxuICAgICAgcmlwcGxlWSA9IHByb3BzLnJpcHBsZVksXG4gICAgICByaXBwbGVTaXplID0gcHJvcHMucmlwcGxlU2l6ZSxcbiAgICAgIGluUHJvcCA9IHByb3BzLmluLFxuICAgICAgX3Byb3BzJG9uRXhpdGVkID0gcHJvcHMub25FeGl0ZWQsXG4gICAgICBvbkV4aXRlZCA9IF9wcm9wcyRvbkV4aXRlZCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge30gOiBfcHJvcHMkb25FeGl0ZWQsXG4gICAgICB0aW1lb3V0ID0gcHJvcHMudGltZW91dDtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgbGVhdmluZyA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldExlYXZpbmcgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIHJpcHBsZUNsYXNzTmFtZSA9IGNsc3goY2xhc3Nlcy5yaXBwbGUsIGNsYXNzZXMucmlwcGxlVmlzaWJsZSwgcHVsc2F0ZSAmJiBjbGFzc2VzLnJpcHBsZVB1bHNhdGUpO1xuICB2YXIgcmlwcGxlU3R5bGVzID0ge1xuICAgIHdpZHRoOiByaXBwbGVTaXplLFxuICAgIGhlaWdodDogcmlwcGxlU2l6ZSxcbiAgICB0b3A6IC0ocmlwcGxlU2l6ZSAvIDIpICsgcmlwcGxlWSxcbiAgICBsZWZ0OiAtKHJpcHBsZVNpemUgLyAyKSArIHJpcHBsZVhcbiAgfTtcbiAgdmFyIGNoaWxkQ2xhc3NOYW1lID0gY2xzeChjbGFzc2VzLmNoaWxkLCBsZWF2aW5nICYmIGNsYXNzZXMuY2hpbGRMZWF2aW5nLCBwdWxzYXRlICYmIGNsYXNzZXMuY2hpbGRQdWxzYXRlKTtcbiAgdmFyIGhhbmRsZUV4aXRlZCA9IHVzZUV2ZW50Q2FsbGJhY2sob25FeGl0ZWQpOyAvLyBSaXBwbGUgaXMgdXNlZCBmb3IgdXNlciBmZWVkYmFjayAoZS5nLiBjbGljayBvciBwcmVzcykgc28gd2Ugd2FudCB0byBhcHBseSBzdHlsZXMgd2l0aCB0aGUgaGlnaGVzdCBwcmlvcml0eVxuXG4gIHVzZUVuaGFuY2VkRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWluUHJvcCkge1xuICAgICAgLy8gcmVhY3QtdHJhbnNpdGlvbi1ncm91cCNvbkV4aXRcbiAgICAgIHNldExlYXZpbmcodHJ1ZSk7IC8vIHJlYWN0LXRyYW5zaXRpb24tZ3JvdXAjb25FeGl0ZWRcblxuICAgICAgdmFyIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoaGFuZGxlRXhpdGVkLCB0aW1lb3V0KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LCBbaGFuZGxlRXhpdGVkLCBpblByb3AsIHRpbWVvdXRdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiByaXBwbGVDbGFzc05hbWUsXG4gICAgc3R5bGU6IHJpcHBsZVN0eWxlc1xuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogY2hpbGRDbGFzc05hbWVcbiAgfSkpO1xufVxuXG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBSaXBwbGUucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmUgLSBpbmplY3RlZCBmcm9tIFRyYW5zaXRpb25Hcm91cFxuICAgKi9cbiAgaW46IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlIC0gaW5qZWN0ZWQgZnJvbSBUcmFuc2l0aW9uR3JvdXBcbiAgICovXG4gIG9uRXhpdGVkOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgcmlwcGxlIHB1bHNhdGVzLCB0eXBpY2FsbHkgaW5kaWNhdGluZyB0aGUga2V5Ym9hcmQgZm9jdXMgc3RhdGUgb2YgYW4gZWxlbWVudC5cbiAgICovXG4gIHB1bHNhdGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBEaWFtZXRlciBvZiB0aGUgcmlwcGxlLlxuICAgKi9cbiAgcmlwcGxlU2l6ZTogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgcmlwcGxlIGNlbnRlci5cbiAgICovXG4gIHJpcHBsZVg6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSByaXBwbGUgY2VudGVyLlxuICAgKi9cbiAgcmlwcGxlWTogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogZXhpdCBkZWxheVxuICAgKi9cbiAgdGltZW91dDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgUmlwcGxlOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXlcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgVHJhbnNpdGlvbkdyb3VwIH0gZnJvbSAncmVhY3QtdHJhbnNpdGlvbi1ncm91cCc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCBSaXBwbGUgZnJvbSAnLi9SaXBwbGUnO1xudmFyIERVUkFUSU9OID0gNTUwO1xuZXhwb3J0IHZhciBERUxBWV9SSVBQTEUgPSA4MDtcbmV4cG9ydCB2YXIgc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKHRoZW1lKSB7XG4gIHJldHVybiB7XG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgICByb290OiB7XG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHpJbmRleDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIGJvcmRlclJhZGl1czogJ2luaGVyaXQnXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBpbnRlcm5hbCBgUmlwcGxlYCBjb21wb25lbnRzIGByaXBwbGVgIGNsYXNzLiAqL1xuICAgIHJpcHBsZToge1xuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBpbnRlcm5hbCBgUmlwcGxlYCBjb21wb25lbnRzIGByaXBwbGVWaXNpYmxlYCBjbGFzcy4gKi9cbiAgICByaXBwbGVWaXNpYmxlOiB7XG4gICAgICBvcGFjaXR5OiAwLjMsXG4gICAgICB0cmFuc2Zvcm06ICdzY2FsZSgxKScsXG4gICAgICBhbmltYXRpb246IFwiJGVudGVyIFwiLmNvbmNhdChEVVJBVElPTiwgXCJtcyBcIikuY29uY2F0KHRoZW1lLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlSW5PdXQpXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBpbnRlcm5hbCBgUmlwcGxlYCBjb21wb25lbnRzIGByaXBwbGVQdWxzYXRlYCBjbGFzcy4gKi9cbiAgICByaXBwbGVQdWxzYXRlOiB7XG4gICAgICBhbmltYXRpb25EdXJhdGlvbjogXCJcIi5jb25jYXQodGhlbWUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlciwgXCJtc1wiKVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaW50ZXJuYWwgYFJpcHBsZWAgY29tcG9uZW50cyBgY2hpbGRgIGNsYXNzLiAqL1xuICAgIGNoaWxkOiB7XG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzUwJScsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBpbnRlcm5hbCBgUmlwcGxlYCBjb21wb25lbnRzIGBjaGlsZExlYXZpbmdgIGNsYXNzLiAqL1xuICAgIGNoaWxkTGVhdmluZzoge1xuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIGFuaW1hdGlvbjogXCIkZXhpdCBcIi5jb25jYXQoRFVSQVRJT04sIFwibXMgXCIpLmNvbmNhdCh0aGVtZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZUluT3V0KVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaW50ZXJuYWwgYFJpcHBsZWAgY29tcG9uZW50cyBgY2hpbGRQdWxzYXRlYCBjbGFzcy4gKi9cbiAgICBjaGlsZFB1bHNhdGU6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGFuaW1hdGlvbjogXCIkcHVsc2F0ZSAyNTAwbXMgXCIuY29uY2F0KHRoZW1lLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlSW5PdXQsIFwiIDIwMG1zIGluZmluaXRlXCIpXG4gICAgfSxcbiAgICAnQGtleWZyYW1lcyBlbnRlcic6IHtcbiAgICAgICcwJSc6IHtcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMCknLFxuICAgICAgICBvcGFjaXR5OiAwLjFcbiAgICAgIH0sXG4gICAgICAnMTAwJSc6IHtcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknLFxuICAgICAgICBvcGFjaXR5OiAwLjNcbiAgICAgIH1cbiAgICB9LFxuICAgICdAa2V5ZnJhbWVzIGV4aXQnOiB7XG4gICAgICAnMCUnOiB7XG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH0sXG4gICAgICAnMTAwJSc6IHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfVxuICAgIH0sXG4gICAgJ0BrZXlmcmFtZXMgcHVsc2F0ZSc6IHtcbiAgICAgICcwJSc6IHtcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknXG4gICAgICB9LFxuICAgICAgJzUwJSc6IHtcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMC45MiknXG4gICAgICB9LFxuICAgICAgJzEwMCUnOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJ1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXG4gKlxuICogVE9ETyB2NTogTWFrZSBwcml2YXRlXG4gKi9cblxudmFyIFRvdWNoUmlwcGxlID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gVG91Y2hSaXBwbGUocHJvcHMsIHJlZikge1xuICB2YXIgX3Byb3BzJGNlbnRlciA9IHByb3BzLmNlbnRlcixcbiAgICAgIGNlbnRlclByb3AgPSBfcHJvcHMkY2VudGVyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRjZW50ZXIsXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjZW50ZXJcIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCJdKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoW10pLFxuICAgICAgcmlwcGxlcyA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldFJpcHBsZXMgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIG5leHRLZXkgPSBSZWFjdC51c2VSZWYoMCk7XG4gIHZhciByaXBwbGVDYWxsYmFjayA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmlwcGxlQ2FsbGJhY2suY3VycmVudCkge1xuICAgICAgcmlwcGxlQ2FsbGJhY2suY3VycmVudCgpO1xuICAgICAgcmlwcGxlQ2FsbGJhY2suY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbcmlwcGxlc10pOyAvLyBVc2VkIHRvIGZpbHRlciBvdXQgbW91c2UgZW11bGF0ZWQgZXZlbnRzIG9uIG1vYmlsZS5cblxuICB2YXIgaWdub3JpbmdNb3VzZURvd24gPSBSZWFjdC51c2VSZWYoZmFsc2UpOyAvLyBXZSB1c2UgYSB0aW1lciBpbiBvcmRlciB0byBvbmx5IHNob3cgdGhlIHJpcHBsZXMgZm9yIHRvdWNoIFwiY2xpY2tcIiBsaWtlIGV2ZW50cy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCB0byBkaXNwbGF5IHRoZSByaXBwbGUgZm9yIHRvdWNoIHNjcm9sbCBldmVudHMuXG5cbiAgdmFyIHN0YXJ0VGltZXIgPSBSZWFjdC51c2VSZWYobnVsbCk7IC8vIFRoaXMgaXMgdGhlIGhvb2sgY2FsbGVkIG9uY2UgdGhlIHByZXZpb3VzIHRpbWVvdXQgaXMgcmVhZHkuXG5cbiAgdmFyIHN0YXJ0VGltZXJDb21taXQgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBjb250YWluZXIgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsZWFyVGltZW91dChzdGFydFRpbWVyLmN1cnJlbnQpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgdmFyIHN0YXJ0Q29tbWl0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciBwdWxzYXRlID0gcGFyYW1zLnB1bHNhdGUsXG4gICAgICAgIHJpcHBsZVggPSBwYXJhbXMucmlwcGxlWCxcbiAgICAgICAgcmlwcGxlWSA9IHBhcmFtcy5yaXBwbGVZLFxuICAgICAgICByaXBwbGVTaXplID0gcGFyYW1zLnJpcHBsZVNpemUsXG4gICAgICAgIGNiID0gcGFyYW1zLmNiO1xuICAgIHNldFJpcHBsZXMoZnVuY3Rpb24gKG9sZFJpcHBsZXMpIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG9sZFJpcHBsZXMpLCBbLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmlwcGxlLCB7XG4gICAgICAgIGtleTogbmV4dEtleS5jdXJyZW50LFxuICAgICAgICBjbGFzc2VzOiBjbGFzc2VzLFxuICAgICAgICB0aW1lb3V0OiBEVVJBVElPTixcbiAgICAgICAgcHVsc2F0ZTogcHVsc2F0ZSxcbiAgICAgICAgcmlwcGxlWDogcmlwcGxlWCxcbiAgICAgICAgcmlwcGxlWTogcmlwcGxlWSxcbiAgICAgICAgcmlwcGxlU2l6ZTogcmlwcGxlU2l6ZVxuICAgICAgfSldKTtcbiAgICB9KTtcbiAgICBuZXh0S2V5LmN1cnJlbnQgKz0gMTtcbiAgICByaXBwbGVDYWxsYmFjay5jdXJyZW50ID0gY2I7XG4gIH0sIFtjbGFzc2VzXSk7XG4gIHZhciBzdGFydCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgY2IgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgX29wdGlvbnMkcHVsc2F0ZSA9IG9wdGlvbnMucHVsc2F0ZSxcbiAgICAgICAgcHVsc2F0ZSA9IF9vcHRpb25zJHB1bHNhdGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkcHVsc2F0ZSxcbiAgICAgICAgX29wdGlvbnMkY2VudGVyID0gb3B0aW9ucy5jZW50ZXIsXG4gICAgICAgIGNlbnRlciA9IF9vcHRpb25zJGNlbnRlciA9PT0gdm9pZCAwID8gY2VudGVyUHJvcCB8fCBvcHRpb25zLnB1bHNhdGUgOiBfb3B0aW9ucyRjZW50ZXIsXG4gICAgICAgIF9vcHRpb25zJGZha2VFbGVtZW50ID0gb3B0aW9ucy5mYWtlRWxlbWVudCxcbiAgICAgICAgZmFrZUVsZW1lbnQgPSBfb3B0aW9ucyRmYWtlRWxlbWVudCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRmYWtlRWxlbWVudDtcblxuICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2Vkb3duJyAmJiBpZ25vcmluZ01vdXNlRG93bi5jdXJyZW50KSB7XG4gICAgICBpZ25vcmluZ01vdXNlRG93bi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgaWdub3JpbmdNb3VzZURvd24uY3VycmVudCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBmYWtlRWxlbWVudCA/IG51bGwgOiBjb250YWluZXIuY3VycmVudDtcbiAgICB2YXIgcmVjdCA9IGVsZW1lbnQgPyBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTsgLy8gR2V0IHRoZSBzaXplIG9mIHRoZSByaXBwbGVcblxuICAgIHZhciByaXBwbGVYO1xuICAgIHZhciByaXBwbGVZO1xuICAgIHZhciByaXBwbGVTaXplO1xuXG4gICAgaWYgKGNlbnRlciB8fCBldmVudC5jbGllbnRYID09PSAwICYmIGV2ZW50LmNsaWVudFkgPT09IDAgfHwgIWV2ZW50LmNsaWVudFggJiYgIWV2ZW50LnRvdWNoZXMpIHtcbiAgICAgIHJpcHBsZVggPSBNYXRoLnJvdW5kKHJlY3Qud2lkdGggLyAyKTtcbiAgICAgIHJpcHBsZVkgPSBNYXRoLnJvdW5kKHJlY3QuaGVpZ2h0IC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfcmVmID0gZXZlbnQudG91Y2hlcyA/IGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudCxcbiAgICAgICAgICBjbGllbnRYID0gX3JlZi5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFkgPSBfcmVmLmNsaWVudFk7XG5cbiAgICAgIHJpcHBsZVggPSBNYXRoLnJvdW5kKGNsaWVudFggLSByZWN0LmxlZnQpO1xuICAgICAgcmlwcGxlWSA9IE1hdGgucm91bmQoY2xpZW50WSAtIHJlY3QudG9wKTtcbiAgICB9XG5cbiAgICBpZiAoY2VudGVyKSB7XG4gICAgICByaXBwbGVTaXplID0gTWF0aC5zcXJ0KCgyICogTWF0aC5wb3cocmVjdC53aWR0aCwgMikgKyBNYXRoLnBvdyhyZWN0LmhlaWdodCwgMikpIC8gMyk7IC8vIEZvciBzb21lIHJlYXNvbiB0aGUgYW5pbWF0aW9uIGlzIGJyb2tlbiBvbiBNb2JpbGUgQ2hyb21lIGlmIHRoZSBzaXplIGlmIGV2ZW4uXG5cbiAgICAgIGlmIChyaXBwbGVTaXplICUgMiA9PT0gMCkge1xuICAgICAgICByaXBwbGVTaXplICs9IDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzaXplWCA9IE1hdGgubWF4KE1hdGguYWJzKChlbGVtZW50ID8gZWxlbWVudC5jbGllbnRXaWR0aCA6IDApIC0gcmlwcGxlWCksIHJpcHBsZVgpICogMiArIDI7XG4gICAgICB2YXIgc2l6ZVkgPSBNYXRoLm1heChNYXRoLmFicygoZWxlbWVudCA/IGVsZW1lbnQuY2xpZW50SGVpZ2h0IDogMCkgLSByaXBwbGVZKSwgcmlwcGxlWSkgKiAyICsgMjtcbiAgICAgIHJpcHBsZVNpemUgPSBNYXRoLnNxcnQoTWF0aC5wb3coc2l6ZVgsIDIpICsgTWF0aC5wb3coc2l6ZVksIDIpKTtcbiAgICB9IC8vIFRvdWNoZSBkZXZpY2VzXG5cblxuICAgIGlmIChldmVudC50b3VjaGVzKSB7XG4gICAgICAvLyBjaGVjayB0aGF0IHRoaXMgaXNuJ3QgYW5vdGhlciB0b3VjaHN0YXJ0IGR1ZSB0byBtdWx0aXRvdWNoXG4gICAgICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCBvbmx5IGNsZWFyIGEgc2luZ2xlIHRpbWVyIHdoZW4gdW5tb3VudGluZyB3aGlsZSB0d29cbiAgICAgIC8vIGFyZSBydW5uaW5nXG4gICAgICBpZiAoc3RhcnRUaW1lckNvbW1pdC5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIC8vIFByZXBhcmUgdGhlIHJpcHBsZSBlZmZlY3QuXG4gICAgICAgIHN0YXJ0VGltZXJDb21taXQuY3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGFydENvbW1pdCh7XG4gICAgICAgICAgICBwdWxzYXRlOiBwdWxzYXRlLFxuICAgICAgICAgICAgcmlwcGxlWDogcmlwcGxlWCxcbiAgICAgICAgICAgIHJpcHBsZVk6IHJpcHBsZVksXG4gICAgICAgICAgICByaXBwbGVTaXplOiByaXBwbGVTaXplLFxuICAgICAgICAgICAgY2I6IGNiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07IC8vIERlbGF5IHRoZSBleGVjdXRpb24gb2YgdGhlIHJpcHBsZSBlZmZlY3QuXG5cblxuICAgICAgICBzdGFydFRpbWVyLmN1cnJlbnQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoc3RhcnRUaW1lckNvbW1pdC5jdXJyZW50KSB7XG4gICAgICAgICAgICBzdGFydFRpbWVyQ29tbWl0LmN1cnJlbnQoKTtcbiAgICAgICAgICAgIHN0YXJ0VGltZXJDb21taXQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBERUxBWV9SSVBQTEUpOyAvLyBXZSBoYXZlIHRvIG1ha2UgYSB0cmFkZW9mZiB3aXRoIHRoaXMgdmFsdWUuXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0Q29tbWl0KHtcbiAgICAgICAgcHVsc2F0ZTogcHVsc2F0ZSxcbiAgICAgICAgcmlwcGxlWDogcmlwcGxlWCxcbiAgICAgICAgcmlwcGxlWTogcmlwcGxlWSxcbiAgICAgICAgcmlwcGxlU2l6ZTogcmlwcGxlU2l6ZSxcbiAgICAgICAgY2I6IGNiXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtjZW50ZXJQcm9wLCBzdGFydENvbW1pdF0pO1xuICB2YXIgcHVsc2F0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzdGFydCh7fSwge1xuICAgICAgcHVsc2F0ZTogdHJ1ZVxuICAgIH0pO1xuICB9LCBbc3RhcnRdKTtcbiAgdmFyIHN0b3AgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQsIGNiKSB7XG4gICAgY2xlYXJUaW1lb3V0KHN0YXJ0VGltZXIuY3VycmVudCk7IC8vIFRoZSB0b3VjaCBpbnRlcmFjdGlvbiBvY2N1cnMgdG9vIHF1aWNrbHkuXG4gICAgLy8gV2Ugc3RpbGwgd2FudCB0byBzaG93IHJpcHBsZSBlZmZlY3QuXG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3RvdWNoZW5kJyAmJiBzdGFydFRpbWVyQ29tbWl0LmN1cnJlbnQpIHtcbiAgICAgIGV2ZW50LnBlcnNpc3QoKTtcbiAgICAgIHN0YXJ0VGltZXJDb21taXQuY3VycmVudCgpO1xuICAgICAgc3RhcnRUaW1lckNvbW1pdC5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHN0YXJ0VGltZXIuY3VycmVudCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzdG9wKGV2ZW50LCBjYik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdGFydFRpbWVyQ29tbWl0LmN1cnJlbnQgPSBudWxsO1xuICAgIHNldFJpcHBsZXMoZnVuY3Rpb24gKG9sZFJpcHBsZXMpIHtcbiAgICAgIGlmIChvbGRSaXBwbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIG9sZFJpcHBsZXMuc2xpY2UoMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvbGRSaXBwbGVzO1xuICAgIH0pO1xuICAgIHJpcHBsZUNhbGxiYWNrLmN1cnJlbnQgPSBjYjtcbiAgfSwgW10pO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwdWxzYXRlOiBwdWxzYXRlLFxuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgc3RvcDogc3RvcFxuICAgIH07XG4gIH0sIFtwdWxzYXRlLCBzdGFydCwgc3RvcF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUpLFxuICAgIHJlZjogY29udGFpbmVyXG4gIH0sIG90aGVyKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbkdyb3VwLCB7XG4gICAgY29tcG9uZW50OiBudWxsLFxuICAgIGV4aXQ6IHRydWVcbiAgfSwgcmlwcGxlcykpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBUb3VjaFJpcHBsZS5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSByaXBwbGUgc3RhcnRzIGF0IHRoZSBjZW50ZXIgb2YgdGhlIGNvbXBvbmVudFxuICAgKiByYXRoZXIgdGhhbiBhdCB0aGUgcG9pbnQgb2YgaW50ZXJhY3Rpb24uXG4gICAqL1xuICBjZW50ZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgZmxpcDogZmFsc2UsXG4gIG5hbWU6ICdNdWlUb3VjaFJpcHBsZSdcbn0pKCAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhUb3VjaFJpcHBsZSkpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyBlbGVtZW50VHlwZUFjY2VwdGluZ1JlZiwgcmVmVHlwZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgdXNlRm9ya1JlZiBmcm9tICcuLi91dGlscy91c2VGb3JrUmVmJztcbmltcG9ydCB1c2VFdmVudENhbGxiYWNrIGZyb20gJy4uL3V0aWxzL3VzZUV2ZW50Q2FsbGJhY2snO1xuaW1wb3J0IGRlcHJlY2F0ZWRQcm9wVHlwZSBmcm9tICcuLi91dGlscy9kZXByZWNhdGVkUHJvcFR5cGUnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IHVzZUlzRm9jdXNWaXNpYmxlIGZyb20gJy4uL3V0aWxzL3VzZUlzRm9jdXNWaXNpYmxlJztcbmltcG9ydCBUb3VjaFJpcHBsZSBmcm9tICcuL1RvdWNoUmlwcGxlJztcbmV4cG9ydCB2YXIgc3R5bGVzID0ge1xuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICByb290OiB7XG4gICAgZGlzcGxheTogJ2lubGluZS1mbGV4JyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgV2Via2l0VGFwSGlnaGxpZ2h0Q29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgIC8vIFJlc2V0IGRlZmF1bHQgdmFsdWVcbiAgICAvLyBXZSBkaXNhYmxlIHRoZSBmb2N1cyByaW5nIGZvciBtb3VzZSwgdG91Y2ggYW5kIGtleWJvYXJkIHVzZXJzLlxuICAgIG91dGxpbmU6IDAsXG4gICAgYm9yZGVyOiAwLFxuICAgIG1hcmdpbjogMCxcbiAgICAvLyBSZW1vdmUgdGhlIG1hcmdpbiBpbiBTYWZhcmlcbiAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICAvLyBSZW1vdmUgdGhlIHBhZGRpbmcgaW4gRmlyZWZveFxuICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJyxcbiAgICAnLW1vei1hcHBlYXJhbmNlJzogJ25vbmUnLFxuICAgIC8vIFJlc2V0XG4gICAgJy13ZWJraXQtYXBwZWFyYW5jZSc6ICdub25lJyxcbiAgICAvLyBSZXNldFxuICAgIHRleHREZWNvcmF0aW9uOiAnbm9uZScsXG4gICAgLy8gU28gd2UgdGFrZSBwcmVjZWRlbnQgb3ZlciB0aGUgc3R5bGUgb2YgYSBuYXRpdmUgPGEgLz4gZWxlbWVudC5cbiAgICBjb2xvcjogJ2luaGVyaXQnLFxuICAgICcmOjotbW96LWZvY3VzLWlubmVyJzoge1xuICAgICAgYm9yZGVyU3R5bGU6ICdub25lJyAvLyBSZW1vdmUgRmlyZWZveCBkb3R0ZWQgb3V0bGluZS5cblxuICAgIH0sXG4gICAgJyYkZGlzYWJsZWQnOiB7XG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAvLyBEaXNhYmxlIGxpbmsgaW50ZXJhY3Rpb25zXG4gICAgICBjdXJzb3I6ICdkZWZhdWx0J1xuICAgIH0sXG4gICAgJ0BtZWRpYSBwcmludCc6IHtcbiAgICAgIGNvbG9yQWRqdXN0OiAnZXhhY3QnXG4gICAgfVxuICB9LFxuXG4gIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVkPXt0cnVlfWAuICovXG4gIGRpc2FibGVkOiB7fSxcblxuICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGtleWJvYXJkIGZvY3VzZWQuICovXG4gIGZvY3VzVmlzaWJsZToge31cbn07XG4vKipcbiAqIGBCdXR0b25CYXNlYCBjb250YWlucyBhcyBmZXcgc3R5bGVzIGFzIHBvc3NpYmxlLlxuICogSXQgYWltcyB0byBiZSBhIHNpbXBsZSBidWlsZGluZyBibG9jayBmb3IgY3JlYXRpbmcgYSBidXR0b24uXG4gKiBJdCBjb250YWlucyBhIGxvYWQgb2Ygc3R5bGUgcmVzZXQgYW5kIHNvbWUgZm9jdXMvcmlwcGxlIGxvZ2ljLlxuICovXG5cbnZhciBCdXR0b25CYXNlID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQnV0dG9uQmFzZShwcm9wcywgcmVmKSB7XG4gIHZhciBhY3Rpb24gPSBwcm9wcy5hY3Rpb24sXG4gICAgICBidXR0b25SZWZQcm9wID0gcHJvcHMuYnV0dG9uUmVmLFxuICAgICAgX3Byb3BzJGNlbnRlclJpcHBsZSA9IHByb3BzLmNlbnRlclJpcHBsZSxcbiAgICAgIGNlbnRlclJpcHBsZSA9IF9wcm9wcyRjZW50ZXJSaXBwbGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGNlbnRlclJpcHBsZSxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRjb21wb25lbnQgPSBwcm9wcy5jb21wb25lbnQsXG4gICAgICBjb21wb25lbnQgPSBfcHJvcHMkY29tcG9uZW50ID09PSB2b2lkIDAgPyAnYnV0dG9uJyA6IF9wcm9wcyRjb21wb25lbnQsXG4gICAgICBfcHJvcHMkZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGRpc2FibGVkID0gX3Byb3BzJGRpc2FibGVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlZCxcbiAgICAgIF9wcm9wcyRkaXNhYmxlUmlwcGxlID0gcHJvcHMuZGlzYWJsZVJpcHBsZSxcbiAgICAgIGRpc2FibGVSaXBwbGUgPSBfcHJvcHMkZGlzYWJsZVJpcHBsZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZVJpcHBsZSxcbiAgICAgIF9wcm9wcyRkaXNhYmxlVG91Y2hSaSA9IHByb3BzLmRpc2FibGVUb3VjaFJpcHBsZSxcbiAgICAgIGRpc2FibGVUb3VjaFJpcHBsZSA9IF9wcm9wcyRkaXNhYmxlVG91Y2hSaSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZVRvdWNoUmksXG4gICAgICBfcHJvcHMkZm9jdXNSaXBwbGUgPSBwcm9wcy5mb2N1c1JpcHBsZSxcbiAgICAgIGZvY3VzUmlwcGxlID0gX3Byb3BzJGZvY3VzUmlwcGxlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRmb2N1c1JpcHBsZSxcbiAgICAgIGZvY3VzVmlzaWJsZUNsYXNzTmFtZSA9IHByb3BzLmZvY3VzVmlzaWJsZUNsYXNzTmFtZSxcbiAgICAgIG9uQmx1ciA9IHByb3BzLm9uQmx1cixcbiAgICAgIG9uQ2xpY2sgPSBwcm9wcy5vbkNsaWNrLFxuICAgICAgb25Gb2N1cyA9IHByb3BzLm9uRm9jdXMsXG4gICAgICBvbkZvY3VzVmlzaWJsZSA9IHByb3BzLm9uRm9jdXNWaXNpYmxlLFxuICAgICAgb25LZXlEb3duID0gcHJvcHMub25LZXlEb3duLFxuICAgICAgb25LZXlVcCA9IHByb3BzLm9uS2V5VXAsXG4gICAgICBvbk1vdXNlRG93biA9IHByb3BzLm9uTW91c2VEb3duLFxuICAgICAgb25Nb3VzZUxlYXZlID0gcHJvcHMub25Nb3VzZUxlYXZlLFxuICAgICAgb25Nb3VzZVVwID0gcHJvcHMub25Nb3VzZVVwLFxuICAgICAgb25Ub3VjaEVuZCA9IHByb3BzLm9uVG91Y2hFbmQsXG4gICAgICBvblRvdWNoTW92ZSA9IHByb3BzLm9uVG91Y2hNb3ZlLFxuICAgICAgb25Ub3VjaFN0YXJ0ID0gcHJvcHMub25Ub3VjaFN0YXJ0LFxuICAgICAgb25EcmFnTGVhdmUgPSBwcm9wcy5vbkRyYWdMZWF2ZSxcbiAgICAgIF9wcm9wcyR0YWJJbmRleCA9IHByb3BzLnRhYkluZGV4LFxuICAgICAgdGFiSW5kZXggPSBfcHJvcHMkdGFiSW5kZXggPT09IHZvaWQgMCA/IDAgOiBfcHJvcHMkdGFiSW5kZXgsXG4gICAgICBUb3VjaFJpcHBsZVByb3BzID0gcHJvcHMuVG91Y2hSaXBwbGVQcm9wcyxcbiAgICAgIF9wcm9wcyR0eXBlID0gcHJvcHMudHlwZSxcbiAgICAgIHR5cGUgPSBfcHJvcHMkdHlwZSA9PT0gdm9pZCAwID8gJ2J1dHRvbicgOiBfcHJvcHMkdHlwZSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJhY3Rpb25cIiwgXCJidXR0b25SZWZcIiwgXCJjZW50ZXJSaXBwbGVcIiwgXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjb21wb25lbnRcIiwgXCJkaXNhYmxlZFwiLCBcImRpc2FibGVSaXBwbGVcIiwgXCJkaXNhYmxlVG91Y2hSaXBwbGVcIiwgXCJmb2N1c1JpcHBsZVwiLCBcImZvY3VzVmlzaWJsZUNsYXNzTmFtZVwiLCBcIm9uQmx1clwiLCBcIm9uQ2xpY2tcIiwgXCJvbkZvY3VzXCIsIFwib25Gb2N1c1Zpc2libGVcIiwgXCJvbktleURvd25cIiwgXCJvbktleVVwXCIsIFwib25Nb3VzZURvd25cIiwgXCJvbk1vdXNlTGVhdmVcIiwgXCJvbk1vdXNlVXBcIiwgXCJvblRvdWNoRW5kXCIsIFwib25Ub3VjaE1vdmVcIiwgXCJvblRvdWNoU3RhcnRcIiwgXCJvbkRyYWdMZWF2ZVwiLCBcInRhYkluZGV4XCIsIFwiVG91Y2hSaXBwbGVQcm9wc1wiLCBcInR5cGVcIl0pO1xuXG4gIHZhciBidXR0b25SZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG5cbiAgZnVuY3Rpb24gZ2V0QnV0dG9uTm9kZSgpIHtcbiAgICAvLyAjU3RyaWN0TW9kZSByZWFkeVxuICAgIHJldHVybiBSZWFjdERPTS5maW5kRE9NTm9kZShidXR0b25SZWYuY3VycmVudCk7XG4gIH1cblxuICB2YXIgcmlwcGxlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgICBmb2N1c1Zpc2libGUgPSBfUmVhY3QkdXNlU3RhdGVbMF0sXG4gICAgICBzZXRGb2N1c1Zpc2libGUgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgaWYgKGRpc2FibGVkICYmIGZvY3VzVmlzaWJsZSkge1xuICAgIHNldEZvY3VzVmlzaWJsZShmYWxzZSk7XG4gIH1cblxuICB2YXIgX3VzZUlzRm9jdXNWaXNpYmxlID0gdXNlSXNGb2N1c1Zpc2libGUoKSxcbiAgICAgIGlzRm9jdXNWaXNpYmxlID0gX3VzZUlzRm9jdXNWaXNpYmxlLmlzRm9jdXNWaXNpYmxlLFxuICAgICAgb25CbHVyVmlzaWJsZSA9IF91c2VJc0ZvY3VzVmlzaWJsZS5vbkJsdXJWaXNpYmxlLFxuICAgICAgZm9jdXNWaXNpYmxlUmVmID0gX3VzZUlzRm9jdXNWaXNpYmxlLnJlZjtcblxuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGFjdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb2N1c1Zpc2libGU6IGZ1bmN0aW9uIGZvY3VzVmlzaWJsZSgpIHtcbiAgICAgICAgc2V0Rm9jdXNWaXNpYmxlKHRydWUpO1xuICAgICAgICBidXR0b25SZWYuY3VycmVudC5mb2N1cygpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZm9jdXNWaXNpYmxlICYmIGZvY3VzUmlwcGxlICYmICFkaXNhYmxlUmlwcGxlKSB7XG4gICAgICByaXBwbGVSZWYuY3VycmVudC5wdWxzYXRlKCk7XG4gICAgfVxuICB9LCBbZGlzYWJsZVJpcHBsZSwgZm9jdXNSaXBwbGUsIGZvY3VzVmlzaWJsZV0pO1xuXG4gIGZ1bmN0aW9uIHVzZVJpcHBsZUhhbmRsZXIocmlwcGxlQWN0aW9uLCBldmVudENhbGxiYWNrKSB7XG4gICAgdmFyIHNraXBSaXBwbGVBY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGRpc2FibGVUb3VjaFJpcHBsZTtcbiAgICByZXR1cm4gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudENhbGxiYWNrKSB7XG4gICAgICAgIGV2ZW50Q2FsbGJhY2soZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWdub3JlID0gc2tpcFJpcHBsZUFjdGlvbjtcblxuICAgICAgaWYgKCFpZ25vcmUgJiYgcmlwcGxlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmlwcGxlUmVmLmN1cnJlbnRbcmlwcGxlQWN0aW9uXShldmVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhbmRsZU1vdXNlRG93biA9IHVzZVJpcHBsZUhhbmRsZXIoJ3N0YXJ0Jywgb25Nb3VzZURvd24pO1xuICB2YXIgaGFuZGxlRHJhZ0xlYXZlID0gdXNlUmlwcGxlSGFuZGxlcignc3RvcCcsIG9uRHJhZ0xlYXZlKTtcbiAgdmFyIGhhbmRsZU1vdXNlVXAgPSB1c2VSaXBwbGVIYW5kbGVyKCdzdG9wJywgb25Nb3VzZVVwKTtcbiAgdmFyIGhhbmRsZU1vdXNlTGVhdmUgPSB1c2VSaXBwbGVIYW5kbGVyKCdzdG9wJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGZvY3VzVmlzaWJsZSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAob25Nb3VzZUxlYXZlKSB7XG4gICAgICBvbk1vdXNlTGVhdmUoZXZlbnQpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBoYW5kbGVUb3VjaFN0YXJ0ID0gdXNlUmlwcGxlSGFuZGxlcignc3RhcnQnLCBvblRvdWNoU3RhcnQpO1xuICB2YXIgaGFuZGxlVG91Y2hFbmQgPSB1c2VSaXBwbGVIYW5kbGVyKCdzdG9wJywgb25Ub3VjaEVuZCk7XG4gIHZhciBoYW5kbGVUb3VjaE1vdmUgPSB1c2VSaXBwbGVIYW5kbGVyKCdzdG9wJywgb25Ub3VjaE1vdmUpO1xuICB2YXIgaGFuZGxlQmx1ciA9IHVzZVJpcHBsZUhhbmRsZXIoJ3N0b3AnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZm9jdXNWaXNpYmxlKSB7XG4gICAgICBvbkJsdXJWaXNpYmxlKGV2ZW50KTtcbiAgICAgIHNldEZvY3VzVmlzaWJsZShmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKG9uQmx1cikge1xuICAgICAgb25CbHVyKGV2ZW50KTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbiAgdmFyIGhhbmRsZUZvY3VzID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBGaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzc2OVxuICAgIGlmICghYnV0dG9uUmVmLmN1cnJlbnQpIHtcbiAgICAgIGJ1dHRvblJlZi5jdXJyZW50ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAoaXNGb2N1c1Zpc2libGUoZXZlbnQpKSB7XG4gICAgICBzZXRGb2N1c1Zpc2libGUodHJ1ZSk7XG5cbiAgICAgIGlmIChvbkZvY3VzVmlzaWJsZSkge1xuICAgICAgICBvbkZvY3VzVmlzaWJsZShldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9uRm9jdXMpIHtcbiAgICAgIG9uRm9jdXMoZXZlbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGlzTm9uTmF0aXZlQnV0dG9uID0gZnVuY3Rpb24gaXNOb25OYXRpdmVCdXR0b24oKSB7XG4gICAgdmFyIGJ1dHRvbiA9IGdldEJ1dHRvbk5vZGUoKTtcbiAgICByZXR1cm4gY29tcG9uZW50ICYmIGNvbXBvbmVudCAhPT0gJ2J1dHRvbicgJiYgIShidXR0b24udGFnTmFtZSA9PT0gJ0EnICYmIGJ1dHRvbi5ocmVmKTtcbiAgfTtcbiAgLyoqXG4gICAqIElFIDExIHNoaW0gZm9yIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L3JlcGVhdFxuICAgKi9cblxuXG4gIHZhciBrZXlkb3duUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgdmFyIGhhbmRsZUtleURvd24gPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIENoZWNrIGlmIGtleSBpcyBhbHJlYWR5IGRvd24gdG8gYXZvaWQgcmVwZWF0cyBiZWluZyBjb3VudGVkIGFzIG11bHRpcGxlIGFjdGl2YXRpb25zXG4gICAgaWYgKGZvY3VzUmlwcGxlICYmICFrZXlkb3duUmVmLmN1cnJlbnQgJiYgZm9jdXNWaXNpYmxlICYmIHJpcHBsZVJlZi5jdXJyZW50ICYmIGV2ZW50LmtleSA9PT0gJyAnKSB7XG4gICAgICBrZXlkb3duUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgZXZlbnQucGVyc2lzdCgpO1xuICAgICAgcmlwcGxlUmVmLmN1cnJlbnQuc3RvcChldmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByaXBwbGVSZWYuY3VycmVudC5zdGFydChldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBldmVudC5jdXJyZW50VGFyZ2V0ICYmIGlzTm9uTmF0aXZlQnV0dG9uKCkgJiYgZXZlbnQua2V5ID09PSAnICcpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgaWYgKG9uS2V5RG93bikge1xuICAgICAgb25LZXlEb3duKGV2ZW50KTtcbiAgICB9IC8vIEtleWJvYXJkIGFjY2Vzc2liaWxpdHkgZm9yIG5vbiBpbnRlcmFjdGl2ZSBlbGVtZW50c1xuXG5cbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBldmVudC5jdXJyZW50VGFyZ2V0ICYmIGlzTm9uTmF0aXZlQnV0dG9uKCkgJiYgZXZlbnQua2V5ID09PSAnRW50ZXInICYmICFkaXNhYmxlZCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIGhhbmRsZUtleVVwID0gdXNlRXZlbnRDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBjYWxsaW5nIHByZXZlbnREZWZhdWx0IGluIGtleVVwIG9uIGEgPGJ1dHRvbj4gd2lsbCBub3QgZGlzcGF0Y2ggYSBjbGljayBldmVudCBpZiBTcGFjZSBpcyBwcmVzc2VkXG4gICAgLy8gaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL2J1dHRvbi1rZXl1cC1wcmV2ZW50ZGVmYXVsdC1kbjdmMFxuICAgIGlmIChmb2N1c1JpcHBsZSAmJiBldmVudC5rZXkgPT09ICcgJyAmJiByaXBwbGVSZWYuY3VycmVudCAmJiBmb2N1c1Zpc2libGUgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIGtleWRvd25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgZXZlbnQucGVyc2lzdCgpO1xuICAgICAgcmlwcGxlUmVmLmN1cnJlbnQuc3RvcChldmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByaXBwbGVSZWYuY3VycmVudC5wdWxzYXRlKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvbktleVVwKSB7XG4gICAgICBvbktleVVwKGV2ZW50KTtcbiAgICB9IC8vIEtleWJvYXJkIGFjY2Vzc2liaWxpdHkgZm9yIG5vbiBpbnRlcmFjdGl2ZSBlbGVtZW50c1xuXG5cbiAgICBpZiAob25DbGljayAmJiBldmVudC50YXJnZXQgPT09IGV2ZW50LmN1cnJlbnRUYXJnZXQgJiYgaXNOb25OYXRpdmVCdXR0b24oKSAmJiBldmVudC5rZXkgPT09ICcgJyAmJiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgb25DbGljayhldmVudCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIENvbXBvbmVudFByb3AgPSBjb21wb25lbnQ7XG5cbiAgaWYgKENvbXBvbmVudFByb3AgPT09ICdidXR0b24nICYmIG90aGVyLmhyZWYpIHtcbiAgICBDb21wb25lbnRQcm9wID0gJ2EnO1xuICB9XG5cbiAgdmFyIGJ1dHRvblByb3BzID0ge307XG5cbiAgaWYgKENvbXBvbmVudFByb3AgPT09ICdidXR0b24nKSB7XG4gICAgYnV0dG9uUHJvcHMudHlwZSA9IHR5cGU7XG4gICAgYnV0dG9uUHJvcHMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoQ29tcG9uZW50UHJvcCAhPT0gJ2EnIHx8ICFvdGhlci5ocmVmKSB7XG4gICAgICBidXR0b25Qcm9wcy5yb2xlID0gJ2J1dHRvbic7XG4gICAgfVxuXG4gICAgYnV0dG9uUHJvcHNbJ2FyaWEtZGlzYWJsZWQnXSA9IGRpc2FibGVkO1xuICB9XG5cbiAgdmFyIGhhbmRsZVVzZXJSZWYgPSB1c2VGb3JrUmVmKGJ1dHRvblJlZlByb3AsIHJlZik7XG4gIHZhciBoYW5kbGVPd25SZWYgPSB1c2VGb3JrUmVmKGZvY3VzVmlzaWJsZVJlZiwgYnV0dG9uUmVmKTtcbiAgdmFyIGhhbmRsZVJlZiA9IHVzZUZvcmtSZWYoaGFuZGxlVXNlclJlZiwgaGFuZGxlT3duUmVmKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlMiA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIG1vdW50ZWRTdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRNb3VudGVkU3RhdGUgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgc2V0TW91bnRlZFN0YXRlKHRydWUpO1xuICB9LCBbXSk7XG4gIHZhciBlbmFibGVUb3VjaFJpcHBsZSA9IG1vdW50ZWRTdGF0ZSAmJiAhZGlzYWJsZVJpcHBsZSAmJiAhZGlzYWJsZWQ7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGVuYWJsZVRvdWNoUmlwcGxlICYmICFyaXBwbGVSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFsnTWF0ZXJpYWwtVUk6IFRoZSBgY29tcG9uZW50YCBwcm9wIHByb3ZpZGVkIHRvIEJ1dHRvbkJhc2UgaXMgaW52YWxpZC4nLCAnUGxlYXNlIG1ha2Ugc3VyZSB0aGUgY2hpbGRyZW4gcHJvcCBpcyByZW5kZXJlZCBpbiB0aGlzIGN1c3RvbSBjb21wb25lbnQuJ10uam9pbignXFxuJykpO1xuICAgICAgfVxuICAgIH0sIFtlbmFibGVUb3VjaFJpcHBsZV0pO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudFByb3AsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUsIGZvY3VzVmlzaWJsZSAmJiBbY2xhc3Nlcy5mb2N1c1Zpc2libGUsIGZvY3VzVmlzaWJsZUNsYXNzTmFtZV0sIGRpc2FibGVkICYmIGNsYXNzZXMuZGlzYWJsZWQpLFxuICAgIG9uQmx1cjogaGFuZGxlQmx1cixcbiAgICBvbkNsaWNrOiBvbkNsaWNrLFxuICAgIG9uRm9jdXM6IGhhbmRsZUZvY3VzLFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICBvbktleVVwOiBoYW5kbGVLZXlVcCxcbiAgICBvbk1vdXNlRG93bjogaGFuZGxlTW91c2VEb3duLFxuICAgIG9uTW91c2VMZWF2ZTogaGFuZGxlTW91c2VMZWF2ZSxcbiAgICBvbk1vdXNlVXA6IGhhbmRsZU1vdXNlVXAsXG4gICAgb25EcmFnTGVhdmU6IGhhbmRsZURyYWdMZWF2ZSxcbiAgICBvblRvdWNoRW5kOiBoYW5kbGVUb3VjaEVuZCxcbiAgICBvblRvdWNoTW92ZTogaGFuZGxlVG91Y2hNb3ZlLFxuICAgIG9uVG91Y2hTdGFydDogaGFuZGxlVG91Y2hTdGFydCxcbiAgICByZWY6IGhhbmRsZVJlZixcbiAgICB0YWJJbmRleDogZGlzYWJsZWQgPyAtMSA6IHRhYkluZGV4XG4gIH0sIGJ1dHRvblByb3BzLCBvdGhlciksIGNoaWxkcmVuLCBlbmFibGVUb3VjaFJpcHBsZSA/XG4gIC8qI19fUFVSRV9fKi9cblxuICAvKiBUb3VjaFJpcHBsZSBpcyBvbmx5IG5lZWRlZCBjbGllbnQtc2lkZSwgeDIgYm9vc3Qgb24gdGhlIHNlcnZlci4gKi9cbiAgUmVhY3QuY3JlYXRlRWxlbWVudChUb3VjaFJpcHBsZSwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmlwcGxlUmVmLFxuICAgIGNlbnRlcjogY2VudGVyUmlwcGxlXG4gIH0sIFRvdWNoUmlwcGxlUHJvcHMpKSA6IG51bGwpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBCdXR0b25CYXNlLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIEEgcmVmIGZvciBpbXBlcmF0aXZlIGFjdGlvbnMuXG4gICAqIEl0IGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIGBmb2N1c1Zpc2libGUoKWAgYWN0aW9uLlxuICAgKi9cbiAgYWN0aW9uOiByZWZUeXBlLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqXG4gICAqIFVzZSB0aGF0IHByb3AgdG8gcGFzcyBhIHJlZiB0byB0aGUgbmF0aXZlIGJ1dHRvbiBjb21wb25lbnQuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgcmVmYCBpbnN0ZWFkLlxuICAgKi9cbiAgYnV0dG9uUmVmOiBkZXByZWNhdGVkUHJvcFR5cGUocmVmVHlwZSwgJ1VzZSBgcmVmYCBpbnN0ZWFkLicpLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSByaXBwbGVzIHdpbGwgYmUgY2VudGVyZWQuXG4gICAqIFRoZXkgd29uJ3Qgc3RhcnQgYXQgdGhlIGN1cnNvciBpbnRlcmFjdGlvbiBwb3NpdGlvbi5cbiAgICovXG4gIGNlbnRlclJpcHBsZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IGVsZW1lbnRUeXBlQWNjZXB0aW5nUmVmLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBiYXNlIGJ1dHRvbiB3aWxsIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSByaXBwbGUgZWZmZWN0IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqXG4gICAqIOKaoO+4jyBXaXRob3V0IGEgcmlwcGxlIHRoZXJlIGlzIG5vIHN0eWxpbmcgZm9yIDpmb2N1cy12aXNpYmxlIGJ5IGRlZmF1bHQuIEJlIHN1cmVcbiAgICogdG8gaGlnaGxpZ2h0IHRoZSBlbGVtZW50IGJ5IGFwcGx5aW5nIHNlcGFyYXRlIHN0eWxlcyB3aXRoIHRoZSBgZm9jdXNWaXNpYmxlQ2xhc3NOYW1lYC5cbiAgICovXG4gIGRpc2FibGVSaXBwbGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSB0b3VjaCByaXBwbGUgZWZmZWN0IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlVG91Y2hSaXBwbGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBiYXNlIGJ1dHRvbiB3aWxsIGhhdmUgYSBrZXlib2FyZCBmb2N1cyByaXBwbGUuXG4gICAqL1xuICBmb2N1c1JpcHBsZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoaXMgcHJvcCBjYW4gaGVscCBpZGVudGlmeSB3aGljaCBlbGVtZW50IGhhcyBrZXlib2FyZCBmb2N1cy5cbiAgICogVGhlIGNsYXNzIG5hbWUgd2lsbCBiZSBhcHBsaWVkIHdoZW4gdGhlIGVsZW1lbnQgZ2FpbnMgdGhlIGZvY3VzIHRocm91Z2gga2V5Ym9hcmQgaW50ZXJhY3Rpb24uXG4gICAqIEl0J3MgYSBwb2x5ZmlsbCBmb3IgdGhlIFtDU1MgOmZvY3VzLXZpc2libGUgc2VsZWN0b3JdKGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9zZWxlY3RvcnMtNC8jdGhlLWZvY3VzLXZpc2libGUtcHNldWRvKS5cbiAgICogVGhlIHJhdGlvbmFsZSBmb3IgdXNpbmcgdGhpcyBmZWF0dXJlIFtpcyBleHBsYWluZWQgaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvZm9jdXMtdmlzaWJsZS9ibG9iL21hc3Rlci9leHBsYWluZXIubWQpLlxuICAgKiBBIFtwb2x5ZmlsbCBjYW4gYmUgdXNlZF0oaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvZm9jdXMtdmlzaWJsZSkgdG8gYXBwbHkgYSBgZm9jdXMtdmlzaWJsZWAgY2xhc3MgdG8gb3RoZXIgY29tcG9uZW50c1xuICAgKiBpZiBuZWVkZWQuXG4gICAqL1xuICBmb2N1c1Zpc2libGVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGhyZWY6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uQmx1cjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkRyYWdMZWF2ZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZm9jdXNlZCB3aXRoIGEga2V5Ym9hcmQuXG4gICAqIFdlIHRyaWdnZXIgYSBgb25Gb2N1c2AgY2FsbGJhY2sgdG9vLlxuICAgKi9cbiAgb25Gb2N1c1Zpc2libGU6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbktleURvd246IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbktleVVwOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Nb3VzZURvd246IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbk1vdXNlTGVhdmU6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbk1vdXNlVXA6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvblRvdWNoRW5kOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Ub3VjaE1vdmU6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvblRvdWNoU3RhcnQ6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICB0YWJJbmRleDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBgVG91Y2hSaXBwbGVgIGVsZW1lbnQuXG4gICAqL1xuICBUb3VjaFJpcHBsZVByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICB0eXBlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub25lT2YoWydidXR0b24nLCAncmVzZXQnLCAnc3VibWl0J10pLCBQcm9wVHlwZXMuc3RyaW5nXSlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpQnV0dG9uQmFzZSdcbn0pKEJ1dHRvbkJhc2UpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IGNoYWluUHJvcFR5cGVzIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCB7IGFscGhhIH0gZnJvbSAnLi4vc3R5bGVzL2NvbG9yTWFuaXB1bGF0b3InO1xuaW1wb3J0IEJ1dHRvbkJhc2UgZnJvbSAnLi4vQnV0dG9uQmFzZSc7XG5pbXBvcnQgY2FwaXRhbGl6ZSBmcm9tICcuLi91dGlscy9jYXBpdGFsaXplJztcbmV4cG9ydCB2YXIgc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKHRoZW1lKSB7XG4gIHJldHVybiB7XG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgICByb290OiB7XG4gICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgZmxleDogJzAgMCBhdXRvJyxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LnB4VG9SZW0oMjQpLFxuICAgICAgcGFkZGluZzogMTIsXG4gICAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxuICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJyxcbiAgICAgIC8vIEV4cGxpY2l0bHkgc2V0IHRoZSBkZWZhdWx0IHZhbHVlIHRvIHNvbHZlIGEgYnVnIG9uIElFIDExLlxuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuYWN0aW9uLmFjdGl2ZSxcbiAgICAgIHRyYW5zaXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgnYmFja2dyb3VuZC1jb2xvcicsIHtcbiAgICAgICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXN0XG4gICAgICB9KSxcbiAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGFscGhhKHRoZW1lLnBhbGV0dGUuYWN0aW9uLmFjdGl2ZSwgdGhlbWUucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5KSxcbiAgICAgICAgLy8gUmVzZXQgb24gdG91Y2ggZGV2aWNlcywgaXQgZG9lc24ndCBhZGQgc3BlY2lmaWNpdHlcbiAgICAgICAgJ0BtZWRpYSAoaG92ZXI6IG5vbmUpJzoge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50J1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJyYkZGlzYWJsZWQnOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGVkZ2U9XCJzdGFydFwiYC4gKi9cbiAgICBlZGdlU3RhcnQ6IHtcbiAgICAgIG1hcmdpbkxlZnQ6IC0xMixcbiAgICAgICckc2l6ZVNtYWxsJic6IHtcbiAgICAgICAgbWFyZ2luTGVmdDogLTNcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZWRnZT1cImVuZFwiYC4gKi9cbiAgICBlZGdlRW5kOiB7XG4gICAgICBtYXJnaW5SaWdodDogLTEyLFxuICAgICAgJyRzaXplU21hbGwmJzoge1xuICAgICAgICBtYXJnaW5SaWdodDogLTNcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgY29sb3I9XCJpbmhlcml0XCJgLiAqL1xuICAgIGNvbG9ySW5oZXJpdDoge1xuICAgICAgY29sb3I6ICdpbmhlcml0J1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBjb2xvcj1cInByaW1hcnlcImAuICovXG4gICAgY29sb3JQcmltYXJ5OiB7XG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW4sXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBhbHBoYSh0aGVtZS5wYWxldHRlLnByaW1hcnkubWFpbiwgdGhlbWUucGFsZXR0ZS5hY3Rpb24uaG92ZXJPcGFjaXR5KSxcbiAgICAgICAgLy8gUmVzZXQgb24gdG91Y2ggZGV2aWNlcywgaXQgZG9lc24ndCBhZGQgc3BlY2lmaWNpdHlcbiAgICAgICAgJ0BtZWRpYSAoaG92ZXI6IG5vbmUpJzoge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbG9yPVwic2Vjb25kYXJ5XCJgLiAqL1xuICAgIGNvbG9yU2Vjb25kYXJ5OiB7XG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkubWFpbixcbiAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGFscGhhKHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW4sIHRoZW1lLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSksXG4gICAgICAgIC8vIFJlc2V0IG9uIHRvdWNoIGRldmljZXMsIGl0IGRvZXNuJ3QgYWRkIHNwZWNpZmljaXR5XG4gICAgICAgICdAbWVkaWEgKGhvdmVyOiBub25lKSc6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBkaXNhYmxlZD17dHJ1ZX1gLiAqL1xuICAgIGRpc2FibGVkOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHNpemU9XCJzbWFsbFwiYC4gKi9cbiAgICBzaXplU21hbGw6IHtcbiAgICAgIHBhZGRpbmc6IDMsXG4gICAgICBmb250U2l6ZTogdGhlbWUudHlwb2dyYXBoeS5weFRvUmVtKDE4KVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgY2hpbGRyZW4gY29udGFpbmVyIGVsZW1lbnQuICovXG4gICAgbGFiZWw6IHtcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBhbGlnbkl0ZW1zOiAnaW5oZXJpdCcsXG4gICAgICBqdXN0aWZ5Q29udGVudDogJ2luaGVyaXQnXG4gICAgfVxuICB9O1xufTtcbi8qKlxuICogUmVmZXIgdG8gdGhlIFtJY29uc10oL2NvbXBvbmVudHMvaWNvbnMvKSBzZWN0aW9uIG9mIHRoZSBkb2N1bWVudGF0aW9uXG4gKiByZWdhcmRpbmcgdGhlIGF2YWlsYWJsZSBpY29uIG9wdGlvbnMuXG4gKi9cblxudmFyIEljb25CdXR0b24gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBJY29uQnV0dG9uKHByb3BzLCByZWYpIHtcbiAgdmFyIF9wcm9wcyRlZGdlID0gcHJvcHMuZWRnZSxcbiAgICAgIGVkZ2UgPSBfcHJvcHMkZWRnZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZWRnZSxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRjb2xvciA9IHByb3BzLmNvbG9yLFxuICAgICAgY29sb3IgPSBfcHJvcHMkY29sb3IgPT09IHZvaWQgMCA/ICdkZWZhdWx0JyA6IF9wcm9wcyRjb2xvcixcbiAgICAgIF9wcm9wcyRkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkLFxuICAgICAgZGlzYWJsZWQgPSBfcHJvcHMkZGlzYWJsZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVkLFxuICAgICAgX3Byb3BzJGRpc2FibGVGb2N1c1JpID0gcHJvcHMuZGlzYWJsZUZvY3VzUmlwcGxlLFxuICAgICAgZGlzYWJsZUZvY3VzUmlwcGxlID0gX3Byb3BzJGRpc2FibGVGb2N1c1JpID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlRm9jdXNSaSxcbiAgICAgIF9wcm9wcyRzaXplID0gcHJvcHMuc2l6ZSxcbiAgICAgIHNpemUgPSBfcHJvcHMkc2l6ZSA9PT0gdm9pZCAwID8gJ21lZGl1bScgOiBfcHJvcHMkc2l6ZSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJlZGdlXCIsIFwiY2hpbGRyZW5cIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29sb3JcIiwgXCJkaXNhYmxlZFwiLCBcImRpc2FibGVGb2N1c1JpcHBsZVwiLCBcInNpemVcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChCdXR0b25CYXNlLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lLCBjb2xvciAhPT0gJ2RlZmF1bHQnICYmIGNsYXNzZXNbXCJjb2xvclwiLmNvbmNhdChjYXBpdGFsaXplKGNvbG9yKSldLCBkaXNhYmxlZCAmJiBjbGFzc2VzLmRpc2FibGVkLCBzaXplID09PSBcInNtYWxsXCIgJiYgY2xhc3Nlc1tcInNpemVcIi5jb25jYXQoY2FwaXRhbGl6ZShzaXplKSldLCB7XG4gICAgICAnc3RhcnQnOiBjbGFzc2VzLmVkZ2VTdGFydCxcbiAgICAgICdlbmQnOiBjbGFzc2VzLmVkZ2VFbmRcbiAgICB9W2VkZ2VdKSxcbiAgICBjZW50ZXJSaXBwbGU6IHRydWUsXG4gICAgZm9jdXNSaXBwbGU6ICFkaXNhYmxlRm9jdXNSaXBwbGUsXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMubGFiZWxcbiAgfSwgY2hpbGRyZW4pKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gSWNvbkJ1dHRvbi5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBUaGUgaWNvbiBlbGVtZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IGNoYWluUHJvcFR5cGVzKFByb3BUeXBlcy5ub2RlLCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgZm91bmQgPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KHByb3BzLmNoaWxkcmVuKS5zb21lKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkgJiYgY2hpbGQucHJvcHMub25DbGljaztcbiAgICB9KTtcblxuICAgIGlmIChmb3VuZCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihbJ01hdGVyaWFsLVVJOiBZb3UgYXJlIHByb3ZpZGluZyBhbiBvbkNsaWNrIGV2ZW50IGxpc3RlbmVyICcgKyAndG8gYSBjaGlsZCBvZiBhIGJ1dHRvbiBlbGVtZW50LicsICdGaXJlZm94IHdpbGwgbmV2ZXIgdHJpZ2dlciB0aGUgZXZlbnQuJywgJ1lvdSBzaG91bGQgbW92ZSB0aGUgb25DbGljayBsaXN0ZW5lciB0byB0aGUgcGFyZW50IGJ1dHRvbiBlbGVtZW50LicsICdodHRwczovL2dpdGh1Yi5jb20vbXVpLW9yZy9tYXRlcmlhbC11aS9pc3N1ZXMvMTM5NTcnXS5qb2luKCdcXG4nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0pLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2YgdGhlIGNvbXBvbmVudC4gSXQgc3VwcG9ydHMgdGhvc2UgdGhlbWUgY29sb3JzIHRoYXQgbWFrZSBzZW5zZSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnZGVmYXVsdCcsICdpbmhlcml0JywgJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBidXR0b24gd2lsbCBiZSBkaXNhYmxlZC5cbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgIGtleWJvYXJkIGZvY3VzIHJpcHBsZSB3aWxsIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgZGlzYWJsZUZvY3VzUmlwcGxlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgcmlwcGxlIGVmZmVjdCB3aWxsIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgZGlzYWJsZVJpcHBsZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGdpdmVuLCB1c2VzIGEgbmVnYXRpdmUgbWFyZ2luIHRvIGNvdW50ZXJhY3QgdGhlIHBhZGRpbmcgb24gb25lXG4gICAqIHNpZGUgKHRoaXMgaXMgb2Z0ZW4gaGVscGZ1bCBmb3IgYWxpZ25pbmcgdGhlIGxlZnQgb3IgcmlnaHRcbiAgICogc2lkZSBvZiB0aGUgaWNvbiB3aXRoIGNvbnRlbnQgYWJvdmUgb3IgYmVsb3csIHdpdGhvdXQgcnVpbmluZyB0aGUgYm9yZGVyXG4gICAqIHNpemUgYW5kIHNoYXBlKS5cbiAgICovXG4gIGVkZ2U6IFByb3BUeXBlcy5vbmVPZihbJ3N0YXJ0JywgJ2VuZCcsIGZhbHNlXSksXG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBidXR0b24uXG4gICAqIGBzbWFsbGAgaXMgZXF1aXZhbGVudCB0byB0aGUgZGVuc2UgYnV0dG9uIHN0eWxpbmcuXG4gICAqL1xuICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydzbWFsbCcsICdtZWRpdW0nXSlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpSWNvbkJ1dHRvbidcbn0pKEljb25CdXR0b24pOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IGNoYWluUHJvcFR5cGVzIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCBjYXBpdGFsaXplIGZyb20gJy4uL3V0aWxzL2NhcGl0YWxpemUnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IHtcbiAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgIHdpZHRoOiAnMWVtJyxcbiAgICAgIGhlaWdodDogJzFlbScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgZmxleFNocmluazogMCxcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LnB4VG9SZW0oMjQpLFxuICAgICAgdHJhbnNpdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKCdmaWxsJywge1xuICAgICAgICBkdXJhdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlclxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgY29sb3I9XCJwcmltYXJ5XCJgLiAqL1xuICAgIGNvbG9yUHJpbWFyeToge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbG9yPVwic2Vjb25kYXJ5XCJgLiAqL1xuICAgIGNvbG9yU2Vjb25kYXJ5OiB7XG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkubWFpblxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBjb2xvcj1cImFjdGlvblwiYC4gKi9cbiAgICBjb2xvckFjdGlvbjoge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuYWN0aW9uLmFjdGl2ZVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBjb2xvcj1cImVycm9yXCJgLiAqL1xuICAgIGNvbG9yRXJyb3I6IHtcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmVycm9yLm1haW5cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgY29sb3I9XCJkaXNhYmxlZFwiYC4gKi9cbiAgICBjb2xvckRpc2FibGVkOiB7XG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5hY3Rpb24uZGlzYWJsZWRcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZm9udFNpemU9XCJpbmhlcml0XCJgLiAqL1xuICAgIGZvbnRTaXplSW5oZXJpdDoge1xuICAgICAgZm9udFNpemU6ICdpbmhlcml0J1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBmb250U2l6ZT1cInNtYWxsXCJgLiAqL1xuICAgIGZvbnRTaXplU21hbGw6IHtcbiAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LnB4VG9SZW0oMjApXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGZvbnRTaXplPVwibGFyZ2VcImAuICovXG4gICAgZm9udFNpemVMYXJnZToge1xuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkucHhUb1JlbSgzNSlcbiAgICB9XG4gIH07XG59O1xudmFyIFN2Z0ljb24gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBTdmdJY29uKHByb3BzLCByZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRjb2xvciA9IHByb3BzLmNvbG9yLFxuICAgICAgY29sb3IgPSBfcHJvcHMkY29sb3IgPT09IHZvaWQgMCA/ICdpbmhlcml0JyA6IF9wcm9wcyRjb2xvcixcbiAgICAgIF9wcm9wcyRjb21wb25lbnQgPSBwcm9wcy5jb21wb25lbnQsXG4gICAgICBDb21wb25lbnQgPSBfcHJvcHMkY29tcG9uZW50ID09PSB2b2lkIDAgPyAnc3ZnJyA6IF9wcm9wcyRjb21wb25lbnQsXG4gICAgICBfcHJvcHMkZm9udFNpemUgPSBwcm9wcy5mb250U2l6ZSxcbiAgICAgIGZvbnRTaXplID0gX3Byb3BzJGZvbnRTaXplID09PSB2b2lkIDAgPyAnbWVkaXVtJyA6IF9wcm9wcyRmb250U2l6ZSxcbiAgICAgIGh0bWxDb2xvciA9IHByb3BzLmh0bWxDb2xvcixcbiAgICAgIHRpdGxlQWNjZXNzID0gcHJvcHMudGl0bGVBY2Nlc3MsXG4gICAgICBfcHJvcHMkdmlld0JveCA9IHByb3BzLnZpZXdCb3gsXG4gICAgICB2aWV3Qm94ID0gX3Byb3BzJHZpZXdCb3ggPT09IHZvaWQgMCA/ICcwIDAgMjQgMjQnIDogX3Byb3BzJHZpZXdCb3gsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29sb3JcIiwgXCJjb21wb25lbnRcIiwgXCJmb250U2l6ZVwiLCBcImh0bWxDb2xvclwiLCBcInRpdGxlQWNjZXNzXCIsIFwidmlld0JveFwiXSk7XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSwgY29sb3IgIT09ICdpbmhlcml0JyAmJiBjbGFzc2VzW1wiY29sb3JcIi5jb25jYXQoY2FwaXRhbGl6ZShjb2xvcikpXSwgZm9udFNpemUgIT09ICdkZWZhdWx0JyAmJiBmb250U2l6ZSAhPT0gJ21lZGl1bScgJiYgY2xhc3Nlc1tcImZvbnRTaXplXCIuY29uY2F0KGNhcGl0YWxpemUoZm9udFNpemUpKV0pLFxuICAgIGZvY3VzYWJsZTogXCJmYWxzZVwiLFxuICAgIHZpZXdCb3g6IHZpZXdCb3gsXG4gICAgY29sb3I6IGh0bWxDb2xvcixcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRpdGxlQWNjZXNzID8gdW5kZWZpbmVkIDogdHJ1ZSxcbiAgICByb2xlOiB0aXRsZUFjY2VzcyA/ICdpbWcnIDogdW5kZWZpbmVkLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSwgY2hpbGRyZW4sIHRpdGxlQWNjZXNzID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCB0aXRsZUFjY2VzcykgOiBudWxsKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gU3ZnSWNvbi5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBOb2RlIHBhc3NlZCBpbnRvIHRoZSBTVkcgZWxlbWVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29tcG9uZW50LiBJdCBzdXBwb3J0cyB0aG9zZSB0aGVtZSBjb2xvcnMgdGhhdCBtYWtlIHNlbnNlIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICogWW91IGNhbiB1c2UgdGhlIGBodG1sQ29sb3JgIHByb3AgdG8gYXBwbHkgYSBjb2xvciBhdHRyaWJ1dGUgdG8gdGhlIFNWRyBlbGVtZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ2FjdGlvbicsICdkaXNhYmxlZCcsICdlcnJvcicsICdpbmhlcml0JywgJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogVGhlIGZvbnRTaXplIGFwcGxpZWQgdG8gdGhlIGljb24uIERlZmF1bHRzIHRvIDI0cHgsIGJ1dCBjYW4gYmUgY29uZmlndXJlIHRvIGluaGVyaXQgZm9udCBzaXplLlxuICAgKi9cbiAgZm9udFNpemU6IGNoYWluUHJvcFR5cGVzKFByb3BUeXBlcy5vbmVPZihbJ2RlZmF1bHQnLCAnaW5oZXJpdCcsICdsYXJnZScsICdtZWRpdW0nLCAnc21hbGwnXSksIGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBmb250U2l6ZSA9IHByb3BzLmZvbnRTaXplO1xuXG4gICAgaWYgKGZvbnRTaXplID09PSAnZGVmYXVsdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWF0ZXJpYWwtVUk6IGBmb250U2l6ZT1cImRlZmF1bHRcImAgaXMgZGVwcmVjYXRlZC4gVXNlIGBmb250U2l6ZT1cIm1lZGl1bVwiYCBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9KSxcblxuICAvKipcbiAgICogQXBwbGllcyBhIGNvbG9yIGF0dHJpYnV0ZSB0byB0aGUgU1ZHIGVsZW1lbnQuXG4gICAqL1xuICBodG1sQ29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBzaGFwZS1yZW5kZXJpbmcgYXR0cmlidXRlLiBUaGUgYmVoYXZpb3Igb2YgdGhlIGRpZmZlcmVudCBvcHRpb25zIGlzIGRlc2NyaWJlZCBvbiB0aGVcbiAgICogW01ETiBXZWIgRG9jc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zaGFwZS1yZW5kZXJpbmcpLlxuICAgKiBJZiB5b3UgYXJlIGhhdmluZyBpc3N1ZXMgd2l0aCBibHVycnkgaWNvbnMgeW91IHNob3VsZCBpbnZlc3RpZ2F0ZSB0aGlzIHByb3BlcnR5LlxuICAgKi9cbiAgc2hhcGVSZW5kZXJpbmc6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgaHVtYW4tcmVhZGFibGUgdGl0bGUgZm9yIHRoZSBlbGVtZW50IHRoYXQgY29udGFpbnMgaXQuXG4gICAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkctYWNjZXNzLyNFcXVpdmFsZW50XG4gICAqL1xuICB0aXRsZUFjY2VzczogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQWxsb3dzIHlvdSB0byByZWRlZmluZSB3aGF0IHRoZSBjb29yZGluYXRlcyB3aXRob3V0IHVuaXRzIG1lYW4gaW5zaWRlIGFuIFNWRyBlbGVtZW50LlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIFNWRyBlbGVtZW50IGlzIDUwMCAod2lkdGgpIGJ5IDIwMCAoaGVpZ2h0KSxcbiAgICogYW5kIHlvdSBwYXNzIHZpZXdCb3g9XCIwIDAgNTAgMjBcIixcbiAgICogdGhpcyBtZWFucyB0aGF0IHRoZSBjb29yZGluYXRlcyBpbnNpZGUgdGhlIFNWRyB3aWxsIGdvIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciAoMCwwKVxuICAgKiB0byBib3R0b20gcmlnaHQgKDUwLDIwKSBhbmQgZWFjaCB1bml0IHdpbGwgYmUgd29ydGggMTBweC5cbiAgICovXG4gIHZpZXdCb3g6IFByb3BUeXBlcy5zdHJpbmdcbn0gOiB2b2lkIDA7XG5TdmdJY29uLm11aU5hbWUgPSAnU3ZnSWNvbic7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpU3ZnSWNvbidcbn0pKFN2Z0ljb24pOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBTdmdJY29uIGZyb20gJy4uL1N2Z0ljb24nO1xuLyoqXG4gKiBQcml2YXRlIG1vZHVsZSByZXNlcnZlZCBmb3IgQG1hdGVyaWFsLXVpL3ggcGFja2FnZXMuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlU3ZnSWNvbihwYXRoLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCByZWYpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU3ZnSWNvbiwgX2V4dGVuZHMoe1xuICAgICAgcmVmOiByZWZcbiAgICB9LCBwcm9wcyksIHBhdGgpO1xuICB9O1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gTmVlZCB0byBzZXQgYGRpc3BsYXlOYW1lYCBvbiB0aGUgaW5uZXIgY29tcG9uZW50IGZvciBSZWFjdC5tZW1vLlxuICAgIC8vIFJlYWN0IHByaW9yIHRvIDE2LjE0IGlnbm9yZXMgYGRpc3BsYXlOYW1lYCBvbiB0aGUgd3JhcHBlci5cbiAgICBDb21wb25lbnQuZGlzcGxheU5hbWUgPSBcIlwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCJJY29uXCIpO1xuICB9XG5cbiAgQ29tcG9uZW50Lm11aU5hbWUgPSBTdmdJY29uLm11aU5hbWU7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyggLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoQ29tcG9uZW50KSk7XG59IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNyZWF0ZVN2Z0ljb24gZnJvbSAnLi4vLi4vdXRpbHMvY3JlYXRlU3ZnSWNvbic7XG4vKipcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlU3ZnSWNvbiggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgZDogXCJNMTIgMkM2LjQ3IDIgMiA2LjQ3IDIgMTJzNC40NyAxMCAxMCAxMCAxMC00LjQ3IDEwLTEwUzE3LjUzIDIgMTIgMnptNSAxMy41OUwxNS41OSAxNyAxMiAxMy40MSA4LjQxIDE3IDcgMTUuNTkgMTAuNTkgMTIgNyA4LjQxIDguNDEgNyAxMiAxMC41OSAxNS41OSA3IDE3IDguNDEgMTMuNDEgMTIgMTcgMTUuNTl6XCJcbn0pLCAnQ2FuY2VsJyk7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdW5zdXBwb3J0ZWRQcm9wKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHByb3BGdWxsTmFtZVNhZmUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgaWYgKHR5cGVvZiBwcm9wc1twcm9wTmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIlRoZSBwcm9wIGBcIi5jb25jYXQocHJvcEZ1bGxOYW1lU2FmZSwgXCJgIGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSByZW1vdmUgaXQuXCIpKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCBDYW5jZWxJY29uIGZyb20gJy4uL2ludGVybmFsL3N2Zy1pY29ucy9DYW5jZWwnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IHsgZW1waGFzaXplLCBhbHBoYSB9IGZyb20gJy4uL3N0eWxlcy9jb2xvck1hbmlwdWxhdG9yJztcbmltcG9ydCB1c2VGb3JrUmVmIGZyb20gJy4uL3V0aWxzL3VzZUZvcmtSZWYnO1xuaW1wb3J0IHVuc3VwcG9ydGVkUHJvcCBmcm9tICcuLi91dGlscy91bnN1cHBvcnRlZFByb3AnO1xuaW1wb3J0IGNhcGl0YWxpemUgZnJvbSAnLi4vdXRpbHMvY2FwaXRhbGl6ZSc7XG5pbXBvcnQgQnV0dG9uQmFzZSBmcm9tICcuLi9CdXR0b25CYXNlJztcbmV4cG9ydCB2YXIgc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKHRoZW1lKSB7XG4gIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSB0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCcgPyB0aGVtZS5wYWxldHRlLmdyZXlbMzAwXSA6IHRoZW1lLnBhbGV0dGUuZ3JleVs3MDBdO1xuICB2YXIgZGVsZXRlSWNvbkNvbG9yID0gYWxwaGEodGhlbWUucGFsZXR0ZS50ZXh0LnByaW1hcnksIDAuMjYpO1xuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gICAgcm9vdDoge1xuICAgICAgZm9udEZhbWlseTogdGhlbWUudHlwb2dyYXBoeS5mb250RmFtaWx5LFxuICAgICAgZm9udFNpemU6IHRoZW1lLnR5cG9ncmFwaHkucHhUb1JlbSgxMyksXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWZsZXgnLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICBoZWlnaHQ6IDMyLFxuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuZ2V0Q29udHJhc3RUZXh0KGJhY2tncm91bmRDb2xvciksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvcixcbiAgICAgIGJvcmRlclJhZGl1czogMzIgLyAyLFxuICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoWydiYWNrZ3JvdW5kLWNvbG9yJywgJ2JveC1zaGFkb3cnXSksXG4gICAgICAvLyBsYWJlbCB3aWxsIGluaGVyaXQgdGhpcyBmcm9tIHJvb3QsIHRoZW4gYGNsaWNrYWJsZWAgY2xhc3Mgb3ZlcnJpZGVzIHRoaXMgZm9yIGJvdGhcbiAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxuICAgICAgLy8gV2UgZGlzYWJsZSB0aGUgZm9jdXMgcmluZyBmb3IgbW91c2UsIHRvdWNoIGFuZCBrZXlib2FyZCB1c2Vycy5cbiAgICAgIG91dGxpbmU6IDAsXG4gICAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnLFxuICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAvLyBSZW1vdmUgYGJ1dHRvbmAgYm9yZGVyXG4gICAgICBwYWRkaW5nOiAwLFxuICAgICAgLy8gUmVtb3ZlIGBidXR0b25gIHBhZGRpbmdcbiAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAnJiRkaXNhYmxlZCc6IHtcbiAgICAgICAgb3BhY2l0eTogMC41LFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgICAgIH0sXG4gICAgICAnJiAkYXZhdGFyJzoge1xuICAgICAgICBtYXJnaW5MZWZ0OiA1LFxuICAgICAgICBtYXJnaW5SaWdodDogLTYsXG4gICAgICAgIHdpZHRoOiAyNCxcbiAgICAgICAgaGVpZ2h0OiAyNCxcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudHlwZSA9PT0gJ2xpZ2h0JyA/IHRoZW1lLnBhbGV0dGUuZ3JleVs3MDBdIDogdGhlbWUucGFsZXR0ZS5ncmV5WzMwMF0sXG4gICAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LnB4VG9SZW0oMTIpXG4gICAgICB9LFxuICAgICAgJyYgJGF2YXRhckNvbG9yUHJpbWFyeSc6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUucHJpbWFyeS5jb250cmFzdFRleHQsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5wcmltYXJ5LmRhcmtcbiAgICAgIH0sXG4gICAgICAnJiAkYXZhdGFyQ29sb3JTZWNvbmRhcnknOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnNlY29uZGFyeS5jb250cmFzdFRleHQsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkuZGFya1xuICAgICAgfSxcbiAgICAgICcmICRhdmF0YXJTbWFsbCc6IHtcbiAgICAgICAgbWFyZ2luTGVmdDogNCxcbiAgICAgICAgbWFyZ2luUmlnaHQ6IC00LFxuICAgICAgICB3aWR0aDogMTgsXG4gICAgICAgIGhlaWdodDogMTgsXG4gICAgICAgIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LnB4VG9SZW0oMTApXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHNpemU9XCJzbWFsbFwiYC4gKi9cbiAgICBzaXplU21hbGw6IHtcbiAgICAgIGhlaWdodDogMjRcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgY29sb3I9XCJwcmltYXJ5XCJgLiAqL1xuICAgIGNvbG9yUHJpbWFyeToge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLnByaW1hcnkubWFpbixcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnByaW1hcnkuY29udHJhc3RUZXh0XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbG9yPVwic2Vjb25kYXJ5XCJgLiAqL1xuICAgIGNvbG9yU2Vjb25kYXJ5OiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW4sXG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkuY29udHJhc3RUZXh0XG4gICAgfSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVkPXt0cnVlfWAuICovXG4gICAgZGlzYWJsZWQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgb25DbGlja2AgaXMgZGVmaW5lZCBvciBgY2xpY2thYmxlPXt0cnVlfWAuICovXG4gICAgY2xpY2thYmxlOiB7XG4gICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICBXZWJraXRUYXBIaWdobGlnaHRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgJyY6aG92ZXIsICY6Zm9jdXMnOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogZW1waGFzaXplKGJhY2tncm91bmRDb2xvciwgMC4wOClcbiAgICAgIH0sXG4gICAgICAnJjphY3RpdmUnOiB7XG4gICAgICAgIGJveFNoYWRvdzogdGhlbWUuc2hhZG93c1sxXVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBvbkNsaWNrYCBhbmQgYGNvbG9yPVwicHJpbWFyeVwiYCBpcyBkZWZpbmVkIG9yIGBjbGlja2FibGU9e3RydWV9YC4gKi9cbiAgICBjbGlja2FibGVDb2xvclByaW1hcnk6IHtcbiAgICAgICcmOmhvdmVyLCAmOmZvY3VzJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGVtcGhhc2l6ZSh0aGVtZS5wYWxldHRlLnByaW1hcnkubWFpbiwgMC4wOClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgb25DbGlja2AgYW5kIGBjb2xvcj1cInNlY29uZGFyeVwiYCBpcyBkZWZpbmVkIG9yIGBjbGlja2FibGU9e3RydWV9YC4gKi9cbiAgICBjbGlja2FibGVDb2xvclNlY29uZGFyeToge1xuICAgICAgJyY6aG92ZXIsICY6Zm9jdXMnOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogZW1waGFzaXplKHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW4sIDAuMDgpXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYG9uRGVsZXRlYCBpcyBkZWZpbmVkLiAqL1xuICAgIGRlbGV0YWJsZToge1xuICAgICAgJyY6Zm9jdXMnOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogZW1waGFzaXplKGJhY2tncm91bmRDb2xvciwgMC4wOClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgb25EZWxldGVgIGFuZCBgY29sb3I9XCJwcmltYXJ5XCJgIGlzIGRlZmluZWQuICovXG4gICAgZGVsZXRhYmxlQ29sb3JQcmltYXJ5OiB7XG4gICAgICAnJjpmb2N1cyc6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBlbXBoYXNpemUodGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW4sIDAuMilcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgb25EZWxldGVgIGFuZCBgY29sb3I9XCJzZWNvbmRhcnlcImAgaXMgZGVmaW5lZC4gKi9cbiAgICBkZWxldGFibGVDb2xvclNlY29uZGFyeToge1xuICAgICAgJyY6Zm9jdXMnOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogZW1waGFzaXplKHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW4sIDAuMilcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cIm91dGxpbmVkXCJgLiAqL1xuICAgIG91dGxpbmVkOiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIFwiLmNvbmNhdCh0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCcgPyAncmdiYSgwLCAwLCAwLCAwLjIzKScgOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIzKScpLFxuICAgICAgJyRjbGlja2FibGUmOmhvdmVyLCAkY2xpY2thYmxlJjpmb2N1cywgJGRlbGV0YWJsZSY6Zm9jdXMnOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYWxwaGEodGhlbWUucGFsZXR0ZS50ZXh0LnByaW1hcnksIHRoZW1lLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSlcbiAgICAgIH0sXG4gICAgICAnJiAkYXZhdGFyJzoge1xuICAgICAgICBtYXJnaW5MZWZ0OiA0XG4gICAgICB9LFxuICAgICAgJyYgJGF2YXRhclNtYWxsJzoge1xuICAgICAgICBtYXJnaW5MZWZ0OiAyXG4gICAgICB9LFxuICAgICAgJyYgJGljb24nOiB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IDRcbiAgICAgIH0sXG4gICAgICAnJiAkaWNvblNtYWxsJzoge1xuICAgICAgICBtYXJnaW5MZWZ0OiAyXG4gICAgICB9LFxuICAgICAgJyYgJGRlbGV0ZUljb24nOiB7XG4gICAgICAgIG1hcmdpblJpZ2h0OiA1XG4gICAgICB9LFxuICAgICAgJyYgJGRlbGV0ZUljb25TbWFsbCc6IHtcbiAgICAgICAgbWFyZ2luUmlnaHQ6IDNcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cIm91dGxpbmVkXCJgIGFuZCBgY29sb3I9XCJwcmltYXJ5XCJgLiAqL1xuICAgIG91dGxpbmVkUHJpbWFyeToge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluLFxuICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCBcIi5jb25jYXQodGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW4pLFxuICAgICAgJyRjbGlja2FibGUmOmhvdmVyLCAkY2xpY2thYmxlJjpmb2N1cywgJGRlbGV0YWJsZSY6Zm9jdXMnOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYWxwaGEodGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW4sIHRoZW1lLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cIm91dGxpbmVkXCJgIGFuZCBgY29sb3I9XCJzZWNvbmRhcnlcImAuICovXG4gICAgb3V0bGluZWRTZWNvbmRhcnk6IHtcbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnNlY29uZGFyeS5tYWluLFxuICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCBcIi5jb25jYXQodGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkubWFpbiksXG4gICAgICAnJGNsaWNrYWJsZSY6aG92ZXIsICRjbGlja2FibGUmOmZvY3VzLCAkZGVsZXRhYmxlJjpmb2N1cyc6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBhbHBoYSh0aGVtZS5wYWxldHRlLnNlY29uZGFyeS5tYWluLCB0aGVtZS5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHkpXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBUT0RPIHY1OiByZW1vdmVcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgYXZhdGFyYCBlbGVtZW50LiAqL1xuICAgIGF2YXRhcjoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGF2YXRhcmAgZWxlbWVudCBpZiBgc2l6ZT1cInNtYWxsXCJgLiAqL1xuICAgIGF2YXRhclNtYWxsOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgYXZhdGFyYCBlbGVtZW50IGlmIGBjb2xvcj1cInByaW1hcnlcImAuICovXG4gICAgYXZhdGFyQ29sb3JQcmltYXJ5OiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgYXZhdGFyYCBlbGVtZW50IGlmIGBjb2xvcj1cInNlY29uZGFyeVwiYC4gKi9cbiAgICBhdmF0YXJDb2xvclNlY29uZGFyeToge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGljb25gIGVsZW1lbnQuICovXG4gICAgaWNvbjoge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudHlwZSA9PT0gJ2xpZ2h0JyA/IHRoZW1lLnBhbGV0dGUuZ3JleVs3MDBdIDogdGhlbWUucGFsZXR0ZS5ncmV5WzMwMF0sXG4gICAgICBtYXJnaW5MZWZ0OiA1LFxuICAgICAgbWFyZ2luUmlnaHQ6IC02XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaWNvbmAgZWxlbWVudCBpZiBgc2l6ZT1cInNtYWxsXCJgLiAqL1xuICAgIGljb25TbWFsbDoge1xuICAgICAgd2lkdGg6IDE4LFxuICAgICAgaGVpZ2h0OiAxOCxcbiAgICAgIG1hcmdpbkxlZnQ6IDQsXG4gICAgICBtYXJnaW5SaWdodDogLTRcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpY29uYCBlbGVtZW50IGlmIGBjb2xvcj1cInByaW1hcnlcImAuICovXG4gICAgaWNvbkNvbG9yUHJpbWFyeToge1xuICAgICAgY29sb3I6ICdpbmhlcml0J1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGljb25gIGVsZW1lbnQgaWYgYGNvbG9yPVwic2Vjb25kYXJ5XCJgLiAqL1xuICAgIGljb25Db2xvclNlY29uZGFyeToge1xuICAgICAgY29sb3I6ICdpbmhlcml0J1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgbGFiZWwgYHNwYW5gIGVsZW1lbnQuICovXG4gICAgbGFiZWw6IHtcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICAgIHBhZGRpbmdMZWZ0OiAxMixcbiAgICAgIHBhZGRpbmdSaWdodDogMTIsXG4gICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJ1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgbGFiZWwgYHNwYW5gIGVsZW1lbnQgaWYgYHNpemU9XCJzbWFsbFwiYC4gKi9cbiAgICBsYWJlbFNtYWxsOiB7XG4gICAgICBwYWRkaW5nTGVmdDogOCxcbiAgICAgIHBhZGRpbmdSaWdodDogOFxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGRlbGV0ZUljb25gIGVsZW1lbnQuICovXG4gICAgZGVsZXRlSWNvbjoge1xuICAgICAgV2Via2l0VGFwSGlnaGxpZ2h0Q29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICBjb2xvcjogZGVsZXRlSWNvbkNvbG9yLFxuICAgICAgaGVpZ2h0OiAyMixcbiAgICAgIHdpZHRoOiAyMixcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgbWFyZ2luOiAnMCA1cHggMCAtNnB4JyxcbiAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICBjb2xvcjogYWxwaGEoZGVsZXRlSWNvbkNvbG9yLCAwLjQpXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgZGVsZXRlSWNvbmAgZWxlbWVudCBpZiBgc2l6ZT1cInNtYWxsXCJgLiAqL1xuICAgIGRlbGV0ZUljb25TbWFsbDoge1xuICAgICAgaGVpZ2h0OiAxNixcbiAgICAgIHdpZHRoOiAxNixcbiAgICAgIG1hcmdpblJpZ2h0OiA0LFxuICAgICAgbWFyZ2luTGVmdDogLTRcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGRlbGV0ZUljb24gZWxlbWVudCBpZiBgY29sb3I9XCJwcmltYXJ5XCJgIGFuZCBgdmFyaWFudD1cImRlZmF1bHRcImAuICovXG4gICAgZGVsZXRlSWNvbkNvbG9yUHJpbWFyeToge1xuICAgICAgY29sb3I6IGFscGhhKHRoZW1lLnBhbGV0dGUucHJpbWFyeS5jb250cmFzdFRleHQsIDAuNyksXG4gICAgICAnJjpob3ZlciwgJjphY3RpdmUnOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnByaW1hcnkuY29udHJhc3RUZXh0XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBkZWxldGVJY29uIGVsZW1lbnQgaWYgYGNvbG9yPVwic2Vjb25kYXJ5XCJgIGFuZCBgdmFyaWFudD1cImRlZmF1bHRcImAuICovXG4gICAgZGVsZXRlSWNvbkNvbG9yU2Vjb25kYXJ5OiB7XG4gICAgICBjb2xvcjogYWxwaGEodGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkuY29udHJhc3RUZXh0LCAwLjcpLFxuICAgICAgJyY6aG92ZXIsICY6YWN0aXZlJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkuY29udHJhc3RUZXh0XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBkZWxldGVJY29uIGVsZW1lbnQgaWYgYGNvbG9yPVwicHJpbWFyeVwiYCBhbmQgYHZhcmlhbnQ9XCJvdXRsaW5lZFwiYC4gKi9cbiAgICBkZWxldGVJY29uT3V0bGluZWRDb2xvclByaW1hcnk6IHtcbiAgICAgIGNvbG9yOiBhbHBoYSh0aGVtZS5wYWxldHRlLnByaW1hcnkubWFpbiwgMC43KSxcbiAgICAgICcmOmhvdmVyLCAmOmFjdGl2ZSc6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBkZWxldGVJY29uIGVsZW1lbnQgaWYgYGNvbG9yPVwic2Vjb25kYXJ5XCJgIGFuZCBgdmFyaWFudD1cIm91dGxpbmVkXCJgLiAqL1xuICAgIGRlbGV0ZUljb25PdXRsaW5lZENvbG9yU2Vjb25kYXJ5OiB7XG4gICAgICBjb2xvcjogYWxwaGEodGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkubWFpbiwgMC43KSxcbiAgICAgICcmOmhvdmVyLCAmOmFjdGl2ZSc6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW5cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBpc0RlbGV0ZUtleWJvYXJkRXZlbnQoa2V5Ym9hcmRFdmVudCkge1xuICByZXR1cm4ga2V5Ym9hcmRFdmVudC5rZXkgPT09ICdCYWNrc3BhY2UnIHx8IGtleWJvYXJkRXZlbnQua2V5ID09PSAnRGVsZXRlJztcbn1cbi8qKlxuICogQ2hpcHMgcmVwcmVzZW50IGNvbXBsZXggZW50aXRpZXMgaW4gc21hbGwgYmxvY2tzLCBzdWNoIGFzIGEgY29udGFjdC5cbiAqL1xuXG5cbnZhciBDaGlwID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQ2hpcChwcm9wcywgcmVmKSB7XG4gIHZhciBhdmF0YXJQcm9wID0gcHJvcHMuYXZhdGFyLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjbGlja2FibGVQcm9wID0gcHJvcHMuY2xpY2thYmxlLFxuICAgICAgX3Byb3BzJGNvbG9yID0gcHJvcHMuY29sb3IsXG4gICAgICBjb2xvciA9IF9wcm9wcyRjb2xvciA9PT0gdm9pZCAwID8gJ2RlZmF1bHQnIDogX3Byb3BzJGNvbG9yLFxuICAgICAgQ29tcG9uZW50UHJvcCA9IHByb3BzLmNvbXBvbmVudCxcbiAgICAgIGRlbGV0ZUljb25Qcm9wID0gcHJvcHMuZGVsZXRlSWNvbixcbiAgICAgIF9wcm9wcyRkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkLFxuICAgICAgZGlzYWJsZWQgPSBfcHJvcHMkZGlzYWJsZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVkLFxuICAgICAgaWNvblByb3AgPSBwcm9wcy5pY29uLFxuICAgICAgbGFiZWwgPSBwcm9wcy5sYWJlbCxcbiAgICAgIG9uQ2xpY2sgPSBwcm9wcy5vbkNsaWNrLFxuICAgICAgb25EZWxldGUgPSBwcm9wcy5vbkRlbGV0ZSxcbiAgICAgIG9uS2V5RG93biA9IHByb3BzLm9uS2V5RG93bixcbiAgICAgIG9uS2V5VXAgPSBwcm9wcy5vbktleVVwLFxuICAgICAgX3Byb3BzJHNpemUgPSBwcm9wcy5zaXplLFxuICAgICAgc2l6ZSA9IF9wcm9wcyRzaXplID09PSB2b2lkIDAgPyAnbWVkaXVtJyA6IF9wcm9wcyRzaXplLFxuICAgICAgX3Byb3BzJHZhcmlhbnQgPSBwcm9wcy52YXJpYW50LFxuICAgICAgdmFyaWFudCA9IF9wcm9wcyR2YXJpYW50ID09PSB2b2lkIDAgPyAnZGVmYXVsdCcgOiBfcHJvcHMkdmFyaWFudCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJhdmF0YXJcIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY2xpY2thYmxlXCIsIFwiY29sb3JcIiwgXCJjb21wb25lbnRcIiwgXCJkZWxldGVJY29uXCIsIFwiZGlzYWJsZWRcIiwgXCJpY29uXCIsIFwibGFiZWxcIiwgXCJvbkNsaWNrXCIsIFwib25EZWxldGVcIiwgXCJvbktleURvd25cIiwgXCJvbktleVVwXCIsIFwic2l6ZVwiLCBcInZhcmlhbnRcIl0pO1xuXG4gIHZhciBjaGlwUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgaGFuZGxlUmVmID0gdXNlRm9ya1JlZihjaGlwUmVmLCByZWYpO1xuXG4gIHZhciBoYW5kbGVEZWxldGVJY29uQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVEZWxldGVJY29uQ2xpY2soZXZlbnQpIHtcbiAgICAvLyBTdG9wIHRoZSBldmVudCBmcm9tIGJ1YmJsaW5nIHVwIHRvIHRoZSBgQ2hpcGBcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGlmIChvbkRlbGV0ZSkge1xuICAgICAgb25EZWxldGUoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgZXZlbnRzIGZyb20gY2hpbGRyZW4gb2YgYENoaXBgLlxuICAgIGlmIChldmVudC5jdXJyZW50VGFyZ2V0ID09PSBldmVudC50YXJnZXQgJiYgaXNEZWxldGVLZXlib2FyZEV2ZW50KGV2ZW50KSkge1xuICAgICAgLy8gd2lsbCBiZSBoYW5kbGVkIGluIGtleVVwLCBvdGhlcndpc2Ugc29tZSBicm93c2Vyc1xuICAgICAgLy8gbWlnaHQgaW5pdCBuYXZpZ2F0aW9uXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGlmIChvbktleURvd24pIHtcbiAgICAgIG9uS2V5RG93bihldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVLZXlVcCA9IGZ1bmN0aW9uIGhhbmRsZUtleVVwKGV2ZW50KSB7XG4gICAgLy8gSWdub3JlIGV2ZW50cyBmcm9tIGNoaWxkcmVuIG9mIGBDaGlwYC5cbiAgICBpZiAoZXZlbnQuY3VycmVudFRhcmdldCA9PT0gZXZlbnQudGFyZ2V0KSB7XG4gICAgICBpZiAob25EZWxldGUgJiYgaXNEZWxldGVLZXlib2FyZEV2ZW50KGV2ZW50KSkge1xuICAgICAgICBvbkRlbGV0ZShldmVudCk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ0VzY2FwZScgJiYgY2hpcFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNoaXBSZWYuY3VycmVudC5ibHVyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9uS2V5VXApIHtcbiAgICAgIG9uS2V5VXAoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY2xpY2thYmxlID0gY2xpY2thYmxlUHJvcCAhPT0gZmFsc2UgJiYgb25DbGljayA/IHRydWUgOiBjbGlja2FibGVQcm9wO1xuICB2YXIgc21hbGwgPSBzaXplID09PSAnc21hbGwnO1xuICB2YXIgQ29tcG9uZW50ID0gQ29tcG9uZW50UHJvcCB8fCAoY2xpY2thYmxlID8gQnV0dG9uQmFzZSA6ICdkaXYnKTtcbiAgdmFyIG1vcmVQcm9wcyA9IENvbXBvbmVudCA9PT0gQnV0dG9uQmFzZSA/IHtcbiAgICBjb21wb25lbnQ6ICdkaXYnXG4gIH0gOiB7fTtcbiAgdmFyIGRlbGV0ZUljb24gPSBudWxsO1xuXG4gIGlmIChvbkRlbGV0ZSkge1xuICAgIHZhciBjdXN0b21DbGFzc2VzID0gY2xzeChjb2xvciAhPT0gJ2RlZmF1bHQnICYmICh2YXJpYW50ID09PSBcImRlZmF1bHRcIiA/IGNsYXNzZXNbXCJkZWxldGVJY29uQ29sb3JcIi5jb25jYXQoY2FwaXRhbGl6ZShjb2xvcikpXSA6IGNsYXNzZXNbXCJkZWxldGVJY29uT3V0bGluZWRDb2xvclwiLmNvbmNhdChjYXBpdGFsaXplKGNvbG9yKSldKSwgc21hbGwgJiYgY2xhc3Nlcy5kZWxldGVJY29uU21hbGwpO1xuICAgIGRlbGV0ZUljb24gPSBkZWxldGVJY29uUHJvcCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoZGVsZXRlSWNvblByb3ApID8gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChkZWxldGVJY29uUHJvcCwge1xuICAgICAgY2xhc3NOYW1lOiBjbHN4KGRlbGV0ZUljb25Qcm9wLnByb3BzLmNsYXNzTmFtZSwgY2xhc3Nlcy5kZWxldGVJY29uLCBjdXN0b21DbGFzc2VzKSxcbiAgICAgIG9uQ2xpY2s6IGhhbmRsZURlbGV0ZUljb25DbGlja1xuICAgIH0pIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FuY2VsSWNvbiwge1xuICAgICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMuZGVsZXRlSWNvbiwgY3VzdG9tQ2xhc3NlcyksXG4gICAgICBvbkNsaWNrOiBoYW5kbGVEZWxldGVJY29uQ2xpY2tcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBhdmF0YXIgPSBudWxsO1xuXG4gIGlmIChhdmF0YXJQcm9wICYmIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChhdmF0YXJQcm9wKSkge1xuICAgIGF2YXRhciA9IC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoYXZhdGFyUHJvcCwge1xuICAgICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMuYXZhdGFyLCBhdmF0YXJQcm9wLnByb3BzLmNsYXNzTmFtZSwgc21hbGwgJiYgY2xhc3Nlcy5hdmF0YXJTbWFsbCwgY29sb3IgIT09ICdkZWZhdWx0JyAmJiBjbGFzc2VzW1wiYXZhdGFyQ29sb3JcIi5jb25jYXQoY2FwaXRhbGl6ZShjb2xvcikpXSlcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBpY29uID0gbnVsbDtcblxuICBpZiAoaWNvblByb3AgJiYgLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGljb25Qcm9wKSkge1xuICAgIGljb24gPSAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGljb25Qcm9wLCB7XG4gICAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5pY29uLCBpY29uUHJvcC5wcm9wcy5jbGFzc05hbWUsIHNtYWxsICYmIGNsYXNzZXMuaWNvblNtYWxsLCBjb2xvciAhPT0gJ2RlZmF1bHQnICYmIGNsYXNzZXNbXCJpY29uQ29sb3JcIi5jb25jYXQoY2FwaXRhbGl6ZShjb2xvcikpXSlcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGF2YXRhciAmJiBpY29uKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNYXRlcmlhbC1VSTogVGhlIENoaXAgY29tcG9uZW50IGNhbiBub3QgaGFuZGxlIHRoZSBhdmF0YXIgJyArICdhbmQgdGhlIGljb24gcHJvcCBhdCB0aGUgc2FtZSB0aW1lLiBQaWNrIG9uZS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgcm9sZTogY2xpY2thYmxlIHx8IG9uRGVsZXRlID8gJ2J1dHRvbicgOiB1bmRlZmluZWQsXG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lLCBjb2xvciAhPT0gJ2RlZmF1bHQnICYmIFtjbGFzc2VzW1wiY29sb3JcIi5jb25jYXQoY2FwaXRhbGl6ZShjb2xvcikpXSwgY2xpY2thYmxlICYmIGNsYXNzZXNbXCJjbGlja2FibGVDb2xvclwiLmNvbmNhdChjYXBpdGFsaXplKGNvbG9yKSldLCBvbkRlbGV0ZSAmJiBjbGFzc2VzW1wiZGVsZXRhYmxlQ29sb3JcIi5jb25jYXQoY2FwaXRhbGl6ZShjb2xvcikpXV0sIHZhcmlhbnQgIT09IFwiZGVmYXVsdFwiICYmIFtjbGFzc2VzLm91dGxpbmVkLCB7XG4gICAgICAncHJpbWFyeSc6IGNsYXNzZXMub3V0bGluZWRQcmltYXJ5LFxuICAgICAgJ3NlY29uZGFyeSc6IGNsYXNzZXMub3V0bGluZWRTZWNvbmRhcnlcbiAgICB9W2NvbG9yXV0sIGRpc2FibGVkICYmIGNsYXNzZXMuZGlzYWJsZWQsIHNtYWxsICYmIGNsYXNzZXMuc2l6ZVNtYWxsLCBjbGlja2FibGUgJiYgY2xhc3Nlcy5jbGlja2FibGUsIG9uRGVsZXRlICYmIGNsYXNzZXMuZGVsZXRhYmxlKSxcbiAgICBcImFyaWEtZGlzYWJsZWRcIjogZGlzYWJsZWQgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgIHRhYkluZGV4OiBjbGlja2FibGUgfHwgb25EZWxldGUgPyAwIDogdW5kZWZpbmVkLFxuICAgIG9uQ2xpY2s6IG9uQ2xpY2ssXG4gICAgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duLFxuICAgIG9uS2V5VXA6IGhhbmRsZUtleVVwLFxuICAgIHJlZjogaGFuZGxlUmVmXG4gIH0sIG1vcmVQcm9wcywgb3RoZXIpLCBhdmF0YXIgfHwgaWNvbiwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5sYWJlbCwgc21hbGwgJiYgY2xhc3Nlcy5sYWJlbFNtYWxsKVxuICB9LCBsYWJlbCksIGRlbGV0ZUljb24pO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBDaGlwLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIEF2YXRhciBlbGVtZW50LlxuICAgKi9cbiAgYXZhdGFyOiBQcm9wVHlwZXMuZWxlbWVudCxcblxuICAvKipcbiAgICogVGhpcyBwcm9wIGlzbid0IHN1cHBvcnRlZC5cbiAgICogVXNlIHRoZSBgY29tcG9uZW50YCBwcm9wIGlmIHlvdSBuZWVkIHRvIGNoYW5nZSB0aGUgY2hpbGRyZW4gc3RydWN0dXJlLlxuICAgKi9cbiAgY2hpbGRyZW46IHVuc3VwcG9ydGVkUHJvcCxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNoaXAgd2lsbCBhcHBlYXIgY2xpY2thYmxlLCBhbmQgd2lsbCByYWlzZSB3aGVuIHByZXNzZWQsXG4gICAqIGV2ZW4gaWYgdGhlIG9uQ2xpY2sgcHJvcCBpcyBub3QgZGVmaW5lZC5cbiAgICogSWYgZmFsc2UsIHRoZSBjaGlwIHdpbGwgbm90IGJlIGNsaWNrYWJsZSwgZXZlbiBpZiBvbkNsaWNrIHByb3AgaXMgZGVmaW5lZC5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsXG4gICAqIGFsb25nIHdpdGggdGhlIGNvbXBvbmVudCBwcm9wIHRvIGluZGljYXRlIGFuIGFuY2hvciBDaGlwIGlzIGNsaWNrYWJsZS5cbiAgICovXG4gIGNsaWNrYWJsZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29tcG9uZW50LiBJdCBzdXBwb3J0cyB0aG9zZSB0aGVtZSBjb2xvcnMgdGhhdCBtYWtlIHNlbnNlIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoWydkZWZhdWx0JywgJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgZGVsZXRlIGljb24gZWxlbWVudC4gU2hvd24gb25seSBpZiBgb25EZWxldGVgIGlzIHNldC5cbiAgICovXG4gIGRlbGV0ZUljb246IFByb3BUeXBlcy5lbGVtZW50LFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjaGlwIHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gYSBkaXNhYmxlZCBzdGF0ZS5cbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWNvbiBlbGVtZW50LlxuICAgKi9cbiAgaWNvbjogUHJvcFR5cGVzLmVsZW1lbnQsXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBsYWJlbC5cbiAgICovXG4gIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIGZpcmVkIHdoZW4gdGhlIGRlbGV0ZSBpY29uIGlzIGNsaWNrZWQuXG4gICAqIElmIHNldCwgdGhlIGRlbGV0ZSBpY29uIHdpbGwgYmUgc2hvd24uXG4gICAqL1xuICBvbkRlbGV0ZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uS2V5RG93bjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uS2V5VXA6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgY2hpcC5cbiAgICovXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ21lZGl1bScsICdzbWFsbCddKSxcblxuICAvKipcbiAgICogVGhlIHZhcmlhbnQgdG8gdXNlLlxuICAgKi9cbiAgdmFyaWFudDogUHJvcFR5cGVzLm9uZU9mKFsnZGVmYXVsdCcsICdvdXRsaW5lZCddKVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlDaGlwJ1xufSkoQ2hpcCk7IiwiLy8gQ29ycmVzcG9uZHMgdG8gMTAgZnJhbWVzIGF0IDYwIEh6LlxuLy8gQSBmZXcgYnl0ZXMgcGF5bG9hZCBvdmVyaGVhZCB3aGVuIGxvZGFzaC9kZWJvdW5jZSBpcyB+MyBrQiBhbmQgZGVib3VuY2UgfjMwMCBCLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZnVuYykge1xuICB2YXIgd2FpdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTY2O1xuICB2YXIgdGltZW91dDtcblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXRoaXNcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICAgIGZ1bmMuYXBwbHkodGhhdCwgYXJncyk7XG4gICAgfTtcblxuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gIH1cblxuICBkZWJvdW5jZWQuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICB9O1xuXG4gIHJldHVybiBkZWJvdW5jZWQ7XG59IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNNdWlFbGVtZW50KGVsZW1lbnQsIG11aU5hbWVzKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkgJiYgbXVpTmFtZXMuaW5kZXhPZihlbGVtZW50LnR5cGUubXVpTmFtZSkgIT09IC0xO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG93bmVyRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG59IiwiaW1wb3J0IG93bmVyRG9jdW1lbnQgZnJvbSAnLi9vd25lckRvY3VtZW50JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG93bmVyV2luZG93KG5vZGUpIHtcbiAgdmFyIGRvYyA9IG93bmVyRG9jdW1lbnQobm9kZSk7XG4gIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xufSIsIi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzLCByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZUNvbnRyb2xsZWQoX3JlZikge1xuICB2YXIgY29udHJvbGxlZCA9IF9yZWYuY29udHJvbGxlZCxcbiAgICAgIGRlZmF1bHRQcm9wID0gX3JlZi5kZWZhdWx0LFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIF9yZWYkc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgc3RhdGUgPSBfcmVmJHN0YXRlID09PSB2b2lkIDAgPyAndmFsdWUnIDogX3JlZiRzdGF0ZTtcblxuICB2YXIgX1JlYWN0JHVzZVJlZiA9IFJlYWN0LnVzZVJlZihjb250cm9sbGVkICE9PSB1bmRlZmluZWQpLFxuICAgICAgaXNDb250cm9sbGVkID0gX1JlYWN0JHVzZVJlZi5jdXJyZW50O1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShkZWZhdWx0UHJvcCksXG4gICAgICB2YWx1ZVN0YXRlID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgc2V0VmFsdWUgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIHZhbHVlID0gaXNDb250cm9sbGVkID8gY29udHJvbGxlZCA6IHZhbHVlU3RhdGU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQ29udHJvbGxlZCAhPT0gKGNvbnRyb2xsZWQgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihbXCJNYXRlcmlhbC1VSTogQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgdGhlIFwiLmNvbmNhdChpc0NvbnRyb2xsZWQgPyAnJyA6ICd1bicsIFwiY29udHJvbGxlZCBcIikuY29uY2F0KHN0YXRlLCBcIiBzdGF0ZSBvZiBcIikuY29uY2F0KG5hbWUsIFwiIHRvIGJlIFwiKS5jb25jYXQoaXNDb250cm9sbGVkID8gJ3VuJyA6ICcnLCBcImNvbnRyb2xsZWQuXCIpLCAnRWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuJywgXCJEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIFwiLmNvbmNhdChuYW1lLCBcIiBcIikgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuJywgXCJUaGUgbmF0dXJlIG9mIHRoZSBzdGF0ZSBpcyBkZXRlcm1pbmVkIGR1cmluZyB0aGUgZmlyc3QgcmVuZGVyLCBpdCdzIGNvbnNpZGVyZWQgY29udHJvbGxlZCBpZiB0aGUgdmFsdWUgaXMgbm90IGB1bmRlZmluZWRgLlwiLCAnTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cyddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9LCBbY29udHJvbGxlZF0pO1xuXG4gICAgdmFyIF9SZWFjdCR1c2VSZWYyID0gUmVhY3QudXNlUmVmKGRlZmF1bHRQcm9wKSxcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gX1JlYWN0JHVzZVJlZjIuY3VycmVudDtcblxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWlzQ29udHJvbGxlZCAmJiBkZWZhdWx0VmFsdWUgIT09IGRlZmF1bHRQcm9wKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoW1wiTWF0ZXJpYWwtVUk6IEEgY29tcG9uZW50IGlzIGNoYW5naW5nIHRoZSBkZWZhdWx0IFwiLmNvbmNhdChzdGF0ZSwgXCIgc3RhdGUgb2YgYW4gdW5jb250cm9sbGVkIFwiKS5jb25jYXQobmFtZSwgXCIgYWZ0ZXIgYmVpbmcgaW5pdGlhbGl6ZWQuIFwiKSArIFwiVG8gc3VwcHJlc3MgdGhpcyB3YXJuaW5nIG9wdCB0byB1c2UgYSBjb250cm9sbGVkIFwiLmNvbmNhdChuYW1lLCBcIi5cIildLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9LCBbSlNPTi5zdHJpbmdpZnkoZGVmYXVsdFByb3ApXSk7XG4gIH1cblxuICB2YXIgc2V0VmFsdWVJZlVuY29udHJvbGxlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgIGlmICghaXNDb250cm9sbGVkKSB7XG4gICAgICBzZXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIHJldHVybiBbdmFsdWUsIHNldFZhbHVlSWZVbmNvbnRyb2xsZWRdO1xufSIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0Jztcbi8qKlxuICogUHJpdmF0ZSBtb2R1bGUgcmVzZXJ2ZWQgZm9yIEBtYXRlcmlhbC11aS94IHBhY2thZ2VzLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZUlkKGlkT3ZlcnJpZGUpIHtcbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGlkT3ZlcnJpZGUpLFxuICAgICAgZGVmYXVsdElkID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgc2V0RGVmYXVsdElkID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciBpZCA9IGlkT3ZlcnJpZGUgfHwgZGVmYXVsdElkO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChkZWZhdWx0SWQgPT0gbnVsbCkge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gdGhpcyBkZWZhdWx0IGlkIHdoZW4gcG9zc2libGUuXG4gICAgICAvLyBVc2UgdGhlIHJhbmRvbSB2YWx1ZSBmb3IgY2xpZW50LXNpZGUgcmVuZGVyaW5nIG9ubHkuXG4gICAgICAvLyBXZSBjYW4ndCB1c2UgaXQgc2VydmVyLXNpZGUuXG4gICAgICBzZXREZWZhdWx0SWQoXCJtdWktXCIuY29uY2F0KE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlNSkpKTtcbiAgICB9XG4gIH0sIFtkZWZhdWx0SWRdKTtcbiAgcmV0dXJuIGlkO1xufSIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVN2Z0ljb24gfSBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS91dGlscyc7XG4vKipcclxuICogQGlnbm9yZSAtIGludGVybmFsIGNvbXBvbmVudC5cclxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVN2Z0ljb24oIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gIGQ6IFwiTTE5IDYuNDFMMTcuNTkgNSAxMiAxMC41OSA2LjQxIDUgNSA2LjQxIDEwLjU5IDEyIDUgMTcuNTkgNi40MSAxOSAxMiAxMy40MSAxNy41OSAxOSAxOSAxNy41OSAxMy40MSAxMnpcIlxufSksICdDbG9zZScpOyIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVN2Z0ljb24gfSBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS91dGlscyc7XG4vKipcclxuICogQGlnbm9yZSAtIGludGVybmFsIGNvbXBvbmVudC5cclxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVN2Z0ljb24oIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gIGQ6IFwiTTcgMTBsNSA1IDUtNXpcIlxufSksICdBcnJvd0Ryb3BEb3duJyk7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBfdHlwZW9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2ZcIjtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc3RhbnQtY29uZGl0aW9uICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBzZXRSZWYsIHVzZUV2ZW50Q2FsbGJhY2ssIHVzZUNvbnRyb2xsZWQsIHVuc3RhYmxlX3VzZUlkIGFzIHVzZUlkIH0gZnJvbSAnQG1hdGVyaWFsLXVpL2NvcmUvdXRpbHMnOyAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85OTA5MDQvcmVtb3ZlLWFjY2VudHMtZGlhY3JpdGljcy1pbi1hLXN0cmluZy1pbi1qYXZhc2NyaXB0XG4vLyBHaXZlIHVwIG9uIElFIDExIHN1cHBvcnQgZm9yIHRoaXMgZmVhdHVyZVxuXG5mdW5jdGlvbiBzdHJpcERpYWNyaXRpY3Moc3RyaW5nKSB7XG4gIHJldHVybiB0eXBlb2Ygc3RyaW5nLm5vcm1hbGl6ZSAhPT0gJ3VuZGVmaW5lZCcgPyBzdHJpbmcubm9ybWFsaXplKCdORkQnKS5yZXBsYWNlKC9bXFx1MDMwMC1cXHUwMzZmXS9nLCAnJykgOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWx0ZXJPcHRpb25zKCkge1xuICB2YXIgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIF9jb25maWckaWdub3JlQWNjZW50cyA9IGNvbmZpZy5pZ25vcmVBY2NlbnRzLFxuICAgICAgaWdub3JlQWNjZW50cyA9IF9jb25maWckaWdub3JlQWNjZW50cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jb25maWckaWdub3JlQWNjZW50cyxcbiAgICAgIF9jb25maWckaWdub3JlQ2FzZSA9IGNvbmZpZy5pZ25vcmVDYXNlLFxuICAgICAgaWdub3JlQ2FzZSA9IF9jb25maWckaWdub3JlQ2FzZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jb25maWckaWdub3JlQ2FzZSxcbiAgICAgIGxpbWl0ID0gY29uZmlnLmxpbWl0LFxuICAgICAgX2NvbmZpZyRtYXRjaEZyb20gPSBjb25maWcubWF0Y2hGcm9tLFxuICAgICAgbWF0Y2hGcm9tID0gX2NvbmZpZyRtYXRjaEZyb20gPT09IHZvaWQgMCA/ICdhbnknIDogX2NvbmZpZyRtYXRjaEZyb20sXG4gICAgICBzdHJpbmdpZnkgPSBjb25maWcuc3RyaW5naWZ5LFxuICAgICAgX2NvbmZpZyR0cmltID0gY29uZmlnLnRyaW0sXG4gICAgICB0cmltID0gX2NvbmZpZyR0cmltID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jb25maWckdHJpbTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zLCBfcmVmKSB7XG4gICAgdmFyIGlucHV0VmFsdWUgPSBfcmVmLmlucHV0VmFsdWUsXG4gICAgICAgIGdldE9wdGlvbkxhYmVsID0gX3JlZi5nZXRPcHRpb25MYWJlbDtcbiAgICB2YXIgaW5wdXQgPSB0cmltID8gaW5wdXRWYWx1ZS50cmltKCkgOiBpbnB1dFZhbHVlO1xuXG4gICAgaWYgKGlnbm9yZUNhc2UpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoaWdub3JlQWNjZW50cykge1xuICAgICAgaW5wdXQgPSBzdHJpcERpYWNyaXRpY3MoaW5wdXQpO1xuICAgIH1cblxuICAgIHZhciBmaWx0ZXJlZE9wdGlvbnMgPSBvcHRpb25zLmZpbHRlcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlID0gKHN0cmluZ2lmeSB8fCBnZXRPcHRpb25MYWJlbCkob3B0aW9uKTtcblxuICAgICAgaWYgKGlnbm9yZUNhc2UpIHtcbiAgICAgICAgY2FuZGlkYXRlID0gY2FuZGlkYXRlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpZ25vcmVBY2NlbnRzKSB7XG4gICAgICAgIGNhbmRpZGF0ZSA9IHN0cmlwRGlhY3JpdGljcyhjYW5kaWRhdGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0Y2hGcm9tID09PSAnc3RhcnQnID8gY2FuZGlkYXRlLmluZGV4T2YoaW5wdXQpID09PSAwIDogY2FuZGlkYXRlLmluZGV4T2YoaW5wdXQpID4gLTE7XG4gICAgfSk7XG4gICAgcmV0dXJuIHR5cGVvZiBsaW1pdCA9PT0gJ251bWJlcicgPyBmaWx0ZXJlZE9wdGlvbnMuc2xpY2UoMCwgbGltaXQpIDogZmlsdGVyZWRPcHRpb25zO1xuICB9O1xufSAvLyBUbyByZXBsYWNlIHdpdGggLmZpbmRJbmRleCgpIG9uY2Ugd2Ugc3RvcCBJRSAxMSBzdXBwb3J0LlxuXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIGNvbXApIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChjb21wKGFycmF5W2ldKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG52YXIgZGVmYXVsdEZpbHRlck9wdGlvbnMgPSBjcmVhdGVGaWx0ZXJPcHRpb25zKCk7IC8vIE51bWJlciBvZiBvcHRpb25zIHRvIGp1bXAgaW4gbGlzdCBib3ggd2hlbiBwYWdldXAgYW5kIHBhZ2Vkb3duIGtleXMgYXJlIHVzZWQuXG5cbnZhciBwYWdlU2l6ZSA9IDU7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VBdXRvY29tcGxldGUocHJvcHMpIHtcbiAgdmFyIF9wcm9wcyRhdXRvQ29tcGxldGUgPSBwcm9wcy5hdXRvQ29tcGxldGUsXG4gICAgICBhdXRvQ29tcGxldGUgPSBfcHJvcHMkYXV0b0NvbXBsZXRlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRhdXRvQ29tcGxldGUsXG4gICAgICBfcHJvcHMkYXV0b0hpZ2hsaWdodCA9IHByb3BzLmF1dG9IaWdobGlnaHQsXG4gICAgICBhdXRvSGlnaGxpZ2h0ID0gX3Byb3BzJGF1dG9IaWdobGlnaHQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGF1dG9IaWdobGlnaHQsXG4gICAgICBfcHJvcHMkYXV0b1NlbGVjdCA9IHByb3BzLmF1dG9TZWxlY3QsXG4gICAgICBhdXRvU2VsZWN0ID0gX3Byb3BzJGF1dG9TZWxlY3QgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGF1dG9TZWxlY3QsXG4gICAgICBfcHJvcHMkYmx1ck9uU2VsZWN0ID0gcHJvcHMuYmx1ck9uU2VsZWN0LFxuICAgICAgYmx1ck9uU2VsZWN0ID0gX3Byb3BzJGJsdXJPblNlbGVjdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkYmx1ck9uU2VsZWN0LFxuICAgICAgX3Byb3BzJGNsZWFyT25CbHVyID0gcHJvcHMuY2xlYXJPbkJsdXIsXG4gICAgICBjbGVhck9uQmx1ciA9IF9wcm9wcyRjbGVhck9uQmx1ciA9PT0gdm9pZCAwID8gIXByb3BzLmZyZWVTb2xvIDogX3Byb3BzJGNsZWFyT25CbHVyLFxuICAgICAgX3Byb3BzJGNsZWFyT25Fc2NhcGUgPSBwcm9wcy5jbGVhck9uRXNjYXBlLFxuICAgICAgY2xlYXJPbkVzY2FwZSA9IF9wcm9wcyRjbGVhck9uRXNjYXBlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRjbGVhck9uRXNjYXBlLFxuICAgICAgX3Byb3BzJGNvbXBvbmVudE5hbWUgPSBwcm9wcy5jb21wb25lbnROYW1lLFxuICAgICAgY29tcG9uZW50TmFtZSA9IF9wcm9wcyRjb21wb25lbnROYW1lID09PSB2b2lkIDAgPyAndXNlQXV0b2NvbXBsZXRlJyA6IF9wcm9wcyRjb21wb25lbnROYW1lLFxuICAgICAgX3Byb3BzJGRlYnVnID0gcHJvcHMuZGVidWcsXG4gICAgICBkZWJ1ZyA9IF9wcm9wcyRkZWJ1ZyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGVidWcsXG4gICAgICBfcHJvcHMkZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgZGVmYXVsdFZhbHVlID0gX3Byb3BzJGRlZmF1bHRWYWx1ZSA9PT0gdm9pZCAwID8gcHJvcHMubXVsdGlwbGUgPyBbXSA6IG51bGwgOiBfcHJvcHMkZGVmYXVsdFZhbHVlLFxuICAgICAgX3Byb3BzJGRpc2FibGVDbGVhcmFiID0gcHJvcHMuZGlzYWJsZUNsZWFyYWJsZSxcbiAgICAgIGRpc2FibGVDbGVhcmFibGUgPSBfcHJvcHMkZGlzYWJsZUNsZWFyYWIgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVDbGVhcmFiLFxuICAgICAgX3Byb3BzJGRpc2FibGVDbG9zZU9uID0gcHJvcHMuZGlzYWJsZUNsb3NlT25TZWxlY3QsXG4gICAgICBkaXNhYmxlQ2xvc2VPblNlbGVjdCA9IF9wcm9wcyRkaXNhYmxlQ2xvc2VPbiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZUNsb3NlT24sXG4gICAgICBfcHJvcHMkZGlzYWJsZWRJdGVtc0YgPSBwcm9wcy5kaXNhYmxlZEl0ZW1zRm9jdXNhYmxlLFxuICAgICAgZGlzYWJsZWRJdGVtc0ZvY3VzYWJsZSA9IF9wcm9wcyRkaXNhYmxlZEl0ZW1zRiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZWRJdGVtc0YsXG4gICAgICBfcHJvcHMkZGlzYWJsZUxpc3RXcmEgPSBwcm9wcy5kaXNhYmxlTGlzdFdyYXAsXG4gICAgICBkaXNhYmxlTGlzdFdyYXAgPSBfcHJvcHMkZGlzYWJsZUxpc3RXcmEgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVMaXN0V3JhLFxuICAgICAgX3Byb3BzJGZpbHRlck9wdGlvbnMgPSBwcm9wcy5maWx0ZXJPcHRpb25zLFxuICAgICAgZmlsdGVyT3B0aW9ucyA9IF9wcm9wcyRmaWx0ZXJPcHRpb25zID09PSB2b2lkIDAgPyBkZWZhdWx0RmlsdGVyT3B0aW9ucyA6IF9wcm9wcyRmaWx0ZXJPcHRpb25zLFxuICAgICAgX3Byb3BzJGZpbHRlclNlbGVjdGVkID0gcHJvcHMuZmlsdGVyU2VsZWN0ZWRPcHRpb25zLFxuICAgICAgZmlsdGVyU2VsZWN0ZWRPcHRpb25zID0gX3Byb3BzJGZpbHRlclNlbGVjdGVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRmaWx0ZXJTZWxlY3RlZCxcbiAgICAgIF9wcm9wcyRmcmVlU29sbyA9IHByb3BzLmZyZWVTb2xvLFxuICAgICAgZnJlZVNvbG8gPSBfcHJvcHMkZnJlZVNvbG8gPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGZyZWVTb2xvLFxuICAgICAgZ2V0T3B0aW9uRGlzYWJsZWQgPSBwcm9wcy5nZXRPcHRpb25EaXNhYmxlZCxcbiAgICAgIF9wcm9wcyRnZXRPcHRpb25MYWJlbCA9IHByb3BzLmdldE9wdGlvbkxhYmVsLFxuICAgICAgZ2V0T3B0aW9uTGFiZWxQcm9wID0gX3Byb3BzJGdldE9wdGlvbkxhYmVsID09PSB2b2lkIDAgPyBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgcmV0dXJuIG9wdGlvbjtcbiAgfSA6IF9wcm9wcyRnZXRPcHRpb25MYWJlbCxcbiAgICAgIF9wcm9wcyRnZXRPcHRpb25TZWxlYyA9IHByb3BzLmdldE9wdGlvblNlbGVjdGVkLFxuICAgICAgZ2V0T3B0aW9uU2VsZWN0ZWQgPSBfcHJvcHMkZ2V0T3B0aW9uU2VsZWMgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChvcHRpb24sIHZhbHVlKSB7XG4gICAgcmV0dXJuIG9wdGlvbiA9PT0gdmFsdWU7XG4gIH0gOiBfcHJvcHMkZ2V0T3B0aW9uU2VsZWMsXG4gICAgICBncm91cEJ5ID0gcHJvcHMuZ3JvdXBCeSxcbiAgICAgIF9wcm9wcyRoYW5kbGVIb21lRW5kSyA9IHByb3BzLmhhbmRsZUhvbWVFbmRLZXlzLFxuICAgICAgaGFuZGxlSG9tZUVuZEtleXMgPSBfcHJvcHMkaGFuZGxlSG9tZUVuZEsgPT09IHZvaWQgMCA/ICFwcm9wcy5mcmVlU29sbyA6IF9wcm9wcyRoYW5kbGVIb21lRW5kSyxcbiAgICAgIGlkUHJvcCA9IHByb3BzLmlkLFxuICAgICAgX3Byb3BzJGluY2x1ZGVJbnB1dEluID0gcHJvcHMuaW5jbHVkZUlucHV0SW5MaXN0LFxuICAgICAgaW5jbHVkZUlucHV0SW5MaXN0ID0gX3Byb3BzJGluY2x1ZGVJbnB1dEluID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRpbmNsdWRlSW5wdXRJbixcbiAgICAgIGlucHV0VmFsdWVQcm9wID0gcHJvcHMuaW5wdXRWYWx1ZSxcbiAgICAgIF9wcm9wcyRtdWx0aXBsZSA9IHByb3BzLm11bHRpcGxlLFxuICAgICAgbXVsdGlwbGUgPSBfcHJvcHMkbXVsdGlwbGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJG11bHRpcGxlLFxuICAgICAgb25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZSxcbiAgICAgIG9uQ2xvc2UgPSBwcm9wcy5vbkNsb3NlLFxuICAgICAgb25IaWdobGlnaHRDaGFuZ2UgPSBwcm9wcy5vbkhpZ2hsaWdodENoYW5nZSxcbiAgICAgIG9uSW5wdXRDaGFuZ2UgPSBwcm9wcy5vbklucHV0Q2hhbmdlLFxuICAgICAgb25PcGVuID0gcHJvcHMub25PcGVuLFxuICAgICAgb3BlblByb3AgPSBwcm9wcy5vcGVuLFxuICAgICAgX3Byb3BzJG9wZW5PbkZvY3VzID0gcHJvcHMub3Blbk9uRm9jdXMsXG4gICAgICBvcGVuT25Gb2N1cyA9IF9wcm9wcyRvcGVuT25Gb2N1cyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkb3Blbk9uRm9jdXMsXG4gICAgICBvcHRpb25zID0gcHJvcHMub3B0aW9ucyxcbiAgICAgIF9wcm9wcyRzZWxlY3RPbkZvY3VzID0gcHJvcHMuc2VsZWN0T25Gb2N1cyxcbiAgICAgIHNlbGVjdE9uRm9jdXMgPSBfcHJvcHMkc2VsZWN0T25Gb2N1cyA9PT0gdm9pZCAwID8gIXByb3BzLmZyZWVTb2xvIDogX3Byb3BzJHNlbGVjdE9uRm9jdXMsXG4gICAgICB2YWx1ZVByb3AgPSBwcm9wcy52YWx1ZTtcbiAgdmFyIGlkID0gdXNlSWQoaWRQcm9wKTtcbiAgdmFyIGdldE9wdGlvbkxhYmVsID0gZ2V0T3B0aW9uTGFiZWxQcm9wO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZ2V0T3B0aW9uTGFiZWwgPSBmdW5jdGlvbiBnZXRPcHRpb25MYWJlbChvcHRpb24pIHtcbiAgICAgIHZhciBvcHRpb25MYWJlbCA9IGdldE9wdGlvbkxhYmVsUHJvcChvcHRpb24pO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbkxhYmVsICE9PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgZXJyb25lb3VzUmV0dXJuID0gb3B0aW9uTGFiZWwgPT09IHVuZGVmaW5lZCA/ICd1bmRlZmluZWQnIDogXCJcIi5jb25jYXQoX3R5cGVvZihvcHRpb25MYWJlbCksIFwiIChcIikuY29uY2F0KG9wdGlvbkxhYmVsLCBcIilcIik7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNYXRlcmlhbC1VSTogVGhlIGBnZXRPcHRpb25MYWJlbGAgbWV0aG9kIG9mIFwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcIiByZXR1cm5lZCBcIikuY29uY2F0KGVycm9uZW91c1JldHVybiwgXCIgaW5zdGVhZCBvZiBhIHN0cmluZyBmb3IgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShvcHRpb24pLCBcIi5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9uTGFiZWw7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBpZ25vcmVGb2N1cyA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIHZhciBmaXJzdEZvY3VzID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICB2YXIgaW5wdXRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBsaXN0Ym94UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShudWxsKSxcbiAgICAgIGFuY2hvckVsID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgc2V0QW5jaG9yRWwgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTIgPSBSZWFjdC51c2VTdGF0ZSgtMSksXG4gICAgICBmb2N1c2VkVGFnID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldEZvY3VzZWRUYWcgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBkZWZhdWx0SGlnaGxpZ2h0ZWQgPSBhdXRvSGlnaGxpZ2h0ID8gMCA6IC0xO1xuICB2YXIgaGlnaGxpZ2h0ZWRJbmRleFJlZiA9IFJlYWN0LnVzZVJlZihkZWZhdWx0SGlnaGxpZ2h0ZWQpO1xuXG4gIHZhciBfdXNlQ29udHJvbGxlZCA9IHVzZUNvbnRyb2xsZWQoe1xuICAgIGNvbnRyb2xsZWQ6IHZhbHVlUHJvcCxcbiAgICBkZWZhdWx0OiBkZWZhdWx0VmFsdWUsXG4gICAgbmFtZTogY29tcG9uZW50TmFtZVxuICB9KSxcbiAgICAgIF91c2VDb250cm9sbGVkMiA9IF9zbGljZWRUb0FycmF5KF91c2VDb250cm9sbGVkLCAyKSxcbiAgICAgIHZhbHVlID0gX3VzZUNvbnRyb2xsZWQyWzBdLFxuICAgICAgc2V0VmFsdWUgPSBfdXNlQ29udHJvbGxlZDJbMV07XG5cbiAgdmFyIF91c2VDb250cm9sbGVkMyA9IHVzZUNvbnRyb2xsZWQoe1xuICAgIGNvbnRyb2xsZWQ6IGlucHV0VmFsdWVQcm9wLFxuICAgIGRlZmF1bHQ6ICcnLFxuICAgIG5hbWU6IGNvbXBvbmVudE5hbWUsXG4gICAgc3RhdGU6ICdpbnB1dFZhbHVlJ1xuICB9KSxcbiAgICAgIF91c2VDb250cm9sbGVkNCA9IF9zbGljZWRUb0FycmF5KF91c2VDb250cm9sbGVkMywgMiksXG4gICAgICBpbnB1dFZhbHVlID0gX3VzZUNvbnRyb2xsZWQ0WzBdLFxuICAgICAgc2V0SW5wdXRWYWx1ZSA9IF91c2VDb250cm9sbGVkNFsxXTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlMyA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIGZvY3VzZWQgPSBfUmVhY3QkdXNlU3RhdGUzWzBdLFxuICAgICAgc2V0Rm9jdXNlZCA9IF9SZWFjdCR1c2VTdGF0ZTNbMV07XG5cbiAgdmFyIHJlc2V0SW5wdXRWYWx1ZSA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50LCBuZXdWYWx1ZSkge1xuICAgIHZhciBuZXdJbnB1dFZhbHVlO1xuXG4gICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICBuZXdJbnB1dFZhbHVlID0gJyc7XG4gICAgfSBlbHNlIGlmIChuZXdWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBuZXdJbnB1dFZhbHVlID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvcHRpb25MYWJlbCA9IGdldE9wdGlvbkxhYmVsKG5ld1ZhbHVlKTtcbiAgICAgIG5ld0lucHV0VmFsdWUgPSB0eXBlb2Ygb3B0aW9uTGFiZWwgPT09ICdzdHJpbmcnID8gb3B0aW9uTGFiZWwgOiAnJztcbiAgICB9XG5cbiAgICBpZiAoaW5wdXRWYWx1ZSA9PT0gbmV3SW5wdXRWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldElucHV0VmFsdWUobmV3SW5wdXRWYWx1ZSk7XG5cbiAgICBpZiAob25JbnB1dENoYW5nZSkge1xuICAgICAgb25JbnB1dENoYW5nZShldmVudCwgbmV3SW5wdXRWYWx1ZSwgJ3Jlc2V0Jyk7XG4gICAgfVxuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXNldElucHV0VmFsdWUobnVsbCwgdmFsdWUpO1xuICB9LCBbdmFsdWUsIHJlc2V0SW5wdXRWYWx1ZV0pO1xuXG4gIHZhciBfdXNlQ29udHJvbGxlZDUgPSB1c2VDb250cm9sbGVkKHtcbiAgICBjb250cm9sbGVkOiBvcGVuUHJvcCxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICBuYW1lOiBjb21wb25lbnROYW1lLFxuICAgIHN0YXRlOiAnb3BlbidcbiAgfSksXG4gICAgICBfdXNlQ29udHJvbGxlZDYgPSBfc2xpY2VkVG9BcnJheShfdXNlQ29udHJvbGxlZDUsIDIpLFxuICAgICAgb3BlbiA9IF91c2VDb250cm9sbGVkNlswXSxcbiAgICAgIHNldE9wZW5TdGF0ZSA9IF91c2VDb250cm9sbGVkNlsxXTtcblxuICB2YXIgaW5wdXRWYWx1ZUlzU2VsZWN0ZWRWYWx1ZSA9ICFtdWx0aXBsZSAmJiB2YWx1ZSAhPSBudWxsICYmIGlucHV0VmFsdWUgPT09IGdldE9wdGlvbkxhYmVsKHZhbHVlKTtcbiAgdmFyIHBvcHVwT3BlbiA9IG9wZW47XG4gIHZhciBmaWx0ZXJlZE9wdGlvbnMgPSBwb3B1cE9wZW4gPyBmaWx0ZXJPcHRpb25zKG9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBpZiAoZmlsdGVyU2VsZWN0ZWRPcHRpb25zICYmIChtdWx0aXBsZSA/IHZhbHVlIDogW3ZhbHVlXSkuc29tZShmdW5jdGlvbiAodmFsdWUyKSB7XG4gICAgICByZXR1cm4gdmFsdWUyICE9PSBudWxsICYmIGdldE9wdGlvblNlbGVjdGVkKG9wdGlvbiwgdmFsdWUyKTtcbiAgICB9KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KSwgLy8gd2UgdXNlIHRoZSBlbXB0eSBzdHJpbmcgdG8gbWFuaXB1bGF0ZSBgZmlsdGVyT3B0aW9uc2AgdG8gbm90IGZpbHRlciBhbnkgb3B0aW9uc1xuICAvLyBpLmUuIHRoZSBmaWx0ZXIgcHJlZGljYXRlIGFsd2F5cyByZXR1cm5zIHRydWVcbiAge1xuICAgIGlucHV0VmFsdWU6IGlucHV0VmFsdWVJc1NlbGVjdGVkVmFsdWUgPyAnJyA6IGlucHV0VmFsdWUsXG4gICAgZ2V0T3B0aW9uTGFiZWw6IGdldE9wdGlvbkxhYmVsXG4gIH0pIDogW107XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgIWZyZWVTb2xvICYmIG9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIG1pc3NpbmdWYWx1ZSA9IChtdWx0aXBsZSA/IHZhbHVlIDogW3ZhbHVlXSkuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZTIpIHtcbiAgICAgICAgcmV0dXJuICFvcHRpb25zLnNvbWUoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgIHJldHVybiBnZXRPcHRpb25TZWxlY3RlZChvcHRpb24sIHZhbHVlMik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChtaXNzaW5nVmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oW1wiTWF0ZXJpYWwtVUk6IFRoZSB2YWx1ZSBwcm92aWRlZCB0byBcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCIgaXMgaW52YWxpZC5cIiksIFwiTm9uZSBvZiB0aGUgb3B0aW9ucyBtYXRjaCB3aXRoIGBcIi5jb25jYXQobWlzc2luZ1ZhbHVlLmxlbmd0aCA+IDEgPyBKU09OLnN0cmluZ2lmeShtaXNzaW5nVmFsdWUpIDogSlNPTi5zdHJpbmdpZnkobWlzc2luZ1ZhbHVlWzBdKSwgXCJgLlwiKSwgJ1lvdSBjYW4gdXNlIHRoZSBgZ2V0T3B0aW9uU2VsZWN0ZWRgIHByb3AgdG8gY3VzdG9taXplIHRoZSBlcXVhbGl0eSB0ZXN0LiddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZm9jdXNUYWcgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uICh0YWdUb0ZvY3VzKSB7XG4gICAgaWYgKHRhZ1RvRm9jdXMgPT09IC0xKSB7XG4gICAgICBpbnB1dFJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuY2hvckVsLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS10YWctaW5kZXg9XFxcIlwiLmNvbmNhdCh0YWdUb0ZvY3VzLCBcIlxcXCJdXCIpKS5mb2N1cygpO1xuICAgIH1cbiAgfSk7IC8vIEVuc3VyZSB0aGUgZm9jdXNlZFRhZyBpcyBuZXZlciBpbmNvbnNpc3RlbnRcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChtdWx0aXBsZSAmJiBmb2N1c2VkVGFnID4gdmFsdWUubGVuZ3RoIC0gMSkge1xuICAgICAgc2V0Rm9jdXNlZFRhZygtMSk7XG4gICAgICBmb2N1c1RhZygtMSk7XG4gICAgfVxuICB9LCBbdmFsdWUsIG11bHRpcGxlLCBmb2N1c2VkVGFnLCBmb2N1c1RhZ10pO1xuXG4gIGZ1bmN0aW9uIHZhbGlkT3B0aW9uSW5kZXgoaW5kZXgsIGRpcmVjdGlvbikge1xuICAgIGlmICghbGlzdGJveFJlZi5jdXJyZW50IHx8IGluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHZhciBuZXh0Rm9jdXMgPSBpbmRleDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBPdXQgb2YgcmFuZ2VcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICduZXh0JyAmJiBuZXh0Rm9jdXMgPT09IGZpbHRlcmVkT3B0aW9ucy5sZW5ndGggfHwgZGlyZWN0aW9uID09PSAncHJldmlvdXMnICYmIG5leHRGb2N1cyA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3B0aW9uID0gbGlzdGJveFJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1vcHRpb24taW5kZXg9XFxcIlwiLmNvbmNhdChuZXh0Rm9jdXMsIFwiXFxcIl1cIikpOyAvLyBTYW1lIGxvZ2ljIGFzIE1lbnVMaXN0LmpzXG5cbiAgICAgIHZhciBuZXh0Rm9jdXNEaXNhYmxlZCA9IGRpc2FibGVkSXRlbXNGb2N1c2FibGUgPyBmYWxzZSA6IG9wdGlvbiAmJiAob3B0aW9uLmRpc2FibGVkIHx8IG9wdGlvbi5nZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnKSA9PT0gJ3RydWUnKTtcblxuICAgICAgaWYgKG9wdGlvbiAmJiAhb3B0aW9uLmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSB8fCBuZXh0Rm9jdXNEaXNhYmxlZCkge1xuICAgICAgICAvLyBNb3ZlIHRvIHRoZSBuZXh0IGVsZW1lbnQuXG4gICAgICAgIG5leHRGb2N1cyArPSBkaXJlY3Rpb24gPT09ICduZXh0JyA/IDEgOiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXh0Rm9jdXM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHNldEhpZ2hsaWdodGVkSW5kZXggPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciBldmVudCA9IF9yZWYyLmV2ZW50LFxuICAgICAgICBpbmRleCA9IF9yZWYyLmluZGV4LFxuICAgICAgICBfcmVmMiRyZWFzb24gPSBfcmVmMi5yZWFzb24sXG4gICAgICAgIHJlYXNvbiA9IF9yZWYyJHJlYXNvbiA9PT0gdm9pZCAwID8gJ2F1dG8nIDogX3JlZjIkcmVhc29uO1xuICAgIGhpZ2hsaWdodGVkSW5kZXhSZWYuY3VycmVudCA9IGluZGV4OyAvLyBkb2VzIHRoZSBpbmRleCBleGlzdD9cblxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIGlucHV0UmVmLmN1cnJlbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXRSZWYuY3VycmVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIFwiXCIuY29uY2F0KGlkLCBcIi1vcHRpb24tXCIpLmNvbmNhdChpbmRleCkpO1xuICAgIH1cblxuICAgIGlmIChvbkhpZ2hsaWdodENoYW5nZSkge1xuICAgICAgb25IaWdobGlnaHRDaGFuZ2UoZXZlbnQsIGluZGV4ID09PSAtMSA/IG51bGwgOiBmaWx0ZXJlZE9wdGlvbnNbaW5kZXhdLCByZWFzb24pO1xuICAgIH1cblxuICAgIGlmICghbGlzdGJveFJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByZXYgPSBsaXN0Ym94UmVmLmN1cnJlbnQucXVlcnlTZWxlY3RvcignW2RhdGEtZm9jdXNdJyk7XG5cbiAgICBpZiAocHJldikge1xuICAgICAgcHJldi5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtZm9jdXMnKTtcbiAgICB9XG5cbiAgICB2YXIgbGlzdGJveE5vZGUgPSBsaXN0Ym94UmVmLmN1cnJlbnQucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCdbcm9sZT1cImxpc3Rib3hcIl0nKTsgLy8gXCJObyByZXN1bHRzXCJcblxuICAgIGlmICghbGlzdGJveE5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICBsaXN0Ym94Tm9kZS5zY3JvbGxUb3AgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvcHRpb24gPSBsaXN0Ym94UmVmLmN1cnJlbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLW9wdGlvbi1pbmRleD1cXFwiXCIuY29uY2F0KGluZGV4LCBcIlxcXCJdXCIpKTtcblxuICAgIGlmICghb3B0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9uLnNldEF0dHJpYnV0ZSgnZGF0YS1mb2N1cycsICd0cnVlJyk7IC8vIFNjcm9sbCBhY3RpdmUgZGVzY2VuZGFudCBpbnRvIHZpZXcuXG4gICAgLy8gTG9naWMgY29waWVkIGZyb20gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhLXByYWN0aWNlcy9leGFtcGxlcy9saXN0Ym94L2pzL2xpc3Rib3guanNcbiAgICAvL1xuICAgIC8vIENvbnNpZGVyIHRoaXMgQVBJIGluc3RlYWQgb25jZSBpdCBoYXMgYSBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0OlxuICAgIC8vIC5zY3JvbGxJbnRvVmlldyh7IHNjcm9sbE1vZGU6ICdpZi1uZWVkZWQnLCBibG9jazogJ25lYXJlc3QnIH0pO1xuXG4gICAgaWYgKGxpc3Rib3hOb2RlLnNjcm9sbEhlaWdodCA+IGxpc3Rib3hOb2RlLmNsaWVudEhlaWdodCAmJiByZWFzb24gIT09ICdtb3VzZScpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gb3B0aW9uO1xuICAgICAgdmFyIHNjcm9sbEJvdHRvbSA9IGxpc3Rib3hOb2RlLmNsaWVudEhlaWdodCArIGxpc3Rib3hOb2RlLnNjcm9sbFRvcDtcbiAgICAgIHZhciBlbGVtZW50Qm90dG9tID0gZWxlbWVudC5vZmZzZXRUb3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICAgICAgaWYgKGVsZW1lbnRCb3R0b20gPiBzY3JvbGxCb3R0b20pIHtcbiAgICAgICAgbGlzdGJveE5vZGUuc2Nyb2xsVG9wID0gZWxlbWVudEJvdHRvbSAtIGxpc3Rib3hOb2RlLmNsaWVudEhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5vZmZzZXRUb3AgLSBlbGVtZW50Lm9mZnNldEhlaWdodCAqIChncm91cEJ5ID8gMS4zIDogMCkgPCBsaXN0Ym94Tm9kZS5zY3JvbGxUb3ApIHtcbiAgICAgICAgbGlzdGJveE5vZGUuc2Nyb2xsVG9wID0gZWxlbWVudC5vZmZzZXRUb3AgLSBlbGVtZW50Lm9mZnNldEhlaWdodCAqIChncm91cEJ5ID8gMS4zIDogMCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIGNoYW5nZUhpZ2hsaWdodGVkSW5kZXggPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChfcmVmMykge1xuICAgIHZhciBldmVudCA9IF9yZWYzLmV2ZW50LFxuICAgICAgICBkaWZmID0gX3JlZjMuZGlmZixcbiAgICAgICAgX3JlZjMkZGlyZWN0aW9uID0gX3JlZjMuZGlyZWN0aW9uLFxuICAgICAgICBkaXJlY3Rpb24gPSBfcmVmMyRkaXJlY3Rpb24gPT09IHZvaWQgMCA/ICduZXh0JyA6IF9yZWYzJGRpcmVjdGlvbixcbiAgICAgICAgX3JlZjMkcmVhc29uID0gX3JlZjMucmVhc29uLFxuICAgICAgICByZWFzb24gPSBfcmVmMyRyZWFzb24gPT09IHZvaWQgMCA/ICdhdXRvJyA6IF9yZWYzJHJlYXNvbjtcblxuICAgIGlmICghcG9wdXBPcGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdldE5leHRJbmRleCA9IGZ1bmN0aW9uIGdldE5leHRJbmRleCgpIHtcbiAgICAgIHZhciBtYXhJbmRleCA9IGZpbHRlcmVkT3B0aW9ucy5sZW5ndGggLSAxO1xuXG4gICAgICBpZiAoZGlmZiA9PT0gJ3Jlc2V0Jykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEhpZ2hsaWdodGVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlmZiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpZmYgPT09ICdlbmQnKSB7XG4gICAgICAgIHJldHVybiBtYXhJbmRleDtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0luZGV4ID0gaGlnaGxpZ2h0ZWRJbmRleFJlZi5jdXJyZW50ICsgZGlmZjtcblxuICAgICAgaWYgKG5ld0luZGV4IDwgMCkge1xuICAgICAgICBpZiAobmV3SW5kZXggPT09IC0xICYmIGluY2x1ZGVJbnB1dEluTGlzdCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXNhYmxlTGlzdFdyYXAgJiYgaGlnaGxpZ2h0ZWRJbmRleFJlZi5jdXJyZW50ICE9PSAtMSB8fCBNYXRoLmFicyhkaWZmKSA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXhJbmRleDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0luZGV4ID4gbWF4SW5kZXgpIHtcbiAgICAgICAgaWYgKG5ld0luZGV4ID09PSBtYXhJbmRleCArIDEgJiYgaW5jbHVkZUlucHV0SW5MaXN0KSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpc2FibGVMaXN0V3JhcCB8fCBNYXRoLmFicyhkaWZmKSA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gbWF4SW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0luZGV4O1xuICAgIH07XG5cbiAgICB2YXIgbmV4dEluZGV4ID0gdmFsaWRPcHRpb25JbmRleChnZXROZXh0SW5kZXgoKSwgZGlyZWN0aW9uKTtcbiAgICBzZXRIaWdobGlnaHRlZEluZGV4KHtcbiAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICByZWFzb246IHJlYXNvbixcbiAgICAgIGV2ZW50OiBldmVudFxuICAgIH0pOyAvLyBTeW5jIHRoZSBjb250ZW50IG9mIHRoZSBpbnB1dCB3aXRoIHRoZSBoaWdobGlnaHRlZCBvcHRpb24uXG5cbiAgICBpZiAoYXV0b0NvbXBsZXRlICYmIGRpZmYgIT09ICdyZXNldCcpIHtcbiAgICAgIGlmIChuZXh0SW5kZXggPT09IC0xKSB7XG4gICAgICAgIGlucHV0UmVmLmN1cnJlbnQudmFsdWUgPSBpbnB1dFZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9wdGlvbiA9IGdldE9wdGlvbkxhYmVsKGZpbHRlcmVkT3B0aW9uc1tuZXh0SW5kZXhdKTtcbiAgICAgICAgaW5wdXRSZWYuY3VycmVudC52YWx1ZSA9IG9wdGlvbjsgLy8gVGhlIHBvcnRpb24gb2YgdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24gdGhhdCBoYXMgbm90IGJlZW4gdHlwZWQgYnkgdGhlIHVzZXIsXG4gICAgICAgIC8vIGEgY29tcGxldGlvbiBzdHJpbmcsIGFwcGVhcnMgaW5saW5lIGFmdGVyIHRoZSBpbnB1dCBjdXJzb3IgaW4gdGhlIHRleHRib3guXG5cbiAgICAgICAgdmFyIGluZGV4ID0gb3B0aW9uLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihpbnB1dFZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiBpbnB1dFZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpbnB1dFJlZi5jdXJyZW50LnNldFNlbGVjdGlvblJhbmdlKGlucHV0VmFsdWUubGVuZ3RoLCBvcHRpb24ubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBzeW5jSGlnaGxpZ2h0ZWRJbmRleCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBvcHVwT3Blbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZUl0ZW0gPSBtdWx0aXBsZSA/IHZhbHVlWzBdIDogdmFsdWU7IC8vIFRoZSBwb3B1cCBpcyBlbXB0eSwgcmVzZXRcblxuICAgIGlmIChmaWx0ZXJlZE9wdGlvbnMubGVuZ3RoID09PSAwIHx8IHZhbHVlSXRlbSA9PSBudWxsKSB7XG4gICAgICBjaGFuZ2VIaWdobGlnaHRlZEluZGV4KHtcbiAgICAgICAgZGlmZjogJ3Jlc2V0J1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFsaXN0Ym94UmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFN5bmNocm9uaXplIHRoZSB2YWx1ZSB3aXRoIHRoZSBoaWdobGlnaHRlZCBpbmRleFxuXG5cbiAgICBpZiAoIWZpbHRlclNlbGVjdGVkT3B0aW9ucyAmJiB2YWx1ZUl0ZW0gIT0gbnVsbCkge1xuICAgICAgdmFyIGN1cnJlbnRPcHRpb24gPSBmaWx0ZXJlZE9wdGlvbnNbaGlnaGxpZ2h0ZWRJbmRleFJlZi5jdXJyZW50XTsgLy8gS2VlcCB0aGUgY3VycmVudCBoaWdobGlnaHRlZCBpbmRleCBpZiBwb3NzaWJsZVxuXG4gICAgICBpZiAobXVsdGlwbGUgJiYgY3VycmVudE9wdGlvbiAmJiBmaW5kSW5kZXgodmFsdWUsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGdldE9wdGlvblNlbGVjdGVkKGN1cnJlbnRPcHRpb24sIHZhbCk7XG4gICAgICB9KSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlbUluZGV4ID0gZmluZEluZGV4KGZpbHRlcmVkT3B0aW9ucywgZnVuY3Rpb24gKG9wdGlvbkl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGdldE9wdGlvblNlbGVjdGVkKG9wdGlvbkl0ZW0sIHZhbHVlSXRlbSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGl0ZW1JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgY2hhbmdlSGlnaGxpZ2h0ZWRJbmRleCh7XG4gICAgICAgICAgZGlmZjogJ3Jlc2V0J1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEhpZ2hsaWdodGVkSW5kZXgoe1xuICAgICAgICAgIGluZGV4OiBpdGVtSW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFByZXZlbnQgdGhlIGhpZ2hsaWdodGVkIGluZGV4IHRvIGxlYWsgb3V0c2lkZSB0aGUgYm91bmRhcmllcy5cblxuXG4gICAgaWYgKGhpZ2hsaWdodGVkSW5kZXhSZWYuY3VycmVudCA+PSBmaWx0ZXJlZE9wdGlvbnMubGVuZ3RoIC0gMSkge1xuICAgICAgc2V0SGlnaGxpZ2h0ZWRJbmRleCh7XG4gICAgICAgIGluZGV4OiBmaWx0ZXJlZE9wdGlvbnMubGVuZ3RoIC0gMVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBSZXN0b3JlIHRoZSBmb2N1cyB0byB0aGUgcHJldmlvdXMgaW5kZXguXG5cblxuICAgIHNldEhpZ2hsaWdodGVkSW5kZXgoe1xuICAgICAgaW5kZXg6IGhpZ2hsaWdodGVkSW5kZXhSZWYuY3VycmVudFxuICAgIH0pOyAvLyBJZ25vcmUgZmlsdGVyZWRPcHRpb25zIChhbmQgb3B0aW9ucywgZ2V0T3B0aW9uU2VsZWN0ZWQsIGdldE9wdGlvbkxhYmVsKSBub3QgdG8gYnJlYWsgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgWy8vIE9ubHkgc3luYyB0aGUgaGlnaGxpZ2h0ZWQgaW5kZXggd2hlbiB0aGUgb3B0aW9uIHN3aXRjaCBiZXR3ZWVuIGVtcHR5IGFuZCBub3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBmaWx0ZXJlZE9wdGlvbnMubGVuZ3RoID09PSAwLCAvLyBEb24ndCBzeW5jIHRoZSBoaWdobGlnaHRlZCBpbmRleCB3aXRoIHRoZSB2YWx1ZSB3aGVuIG11bHRpcGxlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgbXVsdGlwbGUgPyBmYWxzZSA6IHZhbHVlLCBmaWx0ZXJTZWxlY3RlZE9wdGlvbnMsIGNoYW5nZUhpZ2hsaWdodGVkSW5kZXgsIHNldEhpZ2hsaWdodGVkSW5kZXgsIHBvcHVwT3BlbiwgaW5wdXRWYWx1ZSwgbXVsdGlwbGVdKTtcbiAgdmFyIGhhbmRsZUxpc3Rib3hSZWYgPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgc2V0UmVmKGxpc3Rib3hSZWYsIG5vZGUpO1xuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3luY0hpZ2hsaWdodGVkSW5kZXgoKTtcbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgc3luY0hpZ2hsaWdodGVkSW5kZXgoKTtcbiAgfSwgW3N5bmNIaWdobGlnaHRlZEluZGV4XSk7XG5cbiAgdmFyIGhhbmRsZU9wZW4gPSBmdW5jdGlvbiBoYW5kbGVPcGVuKGV2ZW50KSB7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRPcGVuU3RhdGUodHJ1ZSk7XG5cbiAgICBpZiAob25PcGVuKSB7XG4gICAgICBvbk9wZW4oZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlQ2xvc2UgPSBmdW5jdGlvbiBoYW5kbGVDbG9zZShldmVudCwgcmVhc29uKSB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0T3BlblN0YXRlKGZhbHNlKTtcblxuICAgIGlmIChvbkNsb3NlKSB7XG4gICAgICBvbkNsb3NlKGV2ZW50LCByZWFzb24pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlVmFsdWUgPSBmdW5jdGlvbiBoYW5kbGVWYWx1ZShldmVudCwgbmV3VmFsdWUsIHJlYXNvbiwgZGV0YWlscykge1xuICAgIGlmICh2YWx1ZSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgIG9uQ2hhbmdlKGV2ZW50LCBuZXdWYWx1ZSwgcmVhc29uLCBkZXRhaWxzKTtcbiAgICB9XG5cbiAgICBzZXRWYWx1ZShuZXdWYWx1ZSk7XG4gIH07XG5cbiAgdmFyIGlzVG91Y2ggPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuXG4gIHZhciBzZWxlY3ROZXdWYWx1ZSA9IGZ1bmN0aW9uIHNlbGVjdE5ld1ZhbHVlKGV2ZW50LCBvcHRpb24pIHtcbiAgICB2YXIgcmVhc29uUHJvcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ3NlbGVjdC1vcHRpb24nO1xuICAgIHZhciBvcmlnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6ICdvcHRpb25zJztcbiAgICB2YXIgcmVhc29uID0gcmVhc29uUHJvcDtcbiAgICB2YXIgbmV3VmFsdWUgPSBvcHRpb247XG5cbiAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgIG5ld1ZhbHVlID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5zbGljZSgpIDogW107XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gbmV3VmFsdWUuZmlsdGVyKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0T3B0aW9uU2VsZWN0ZWQob3B0aW9uLCB2YWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihbXCJNYXRlcmlhbC1VSTogVGhlIGBnZXRPcHRpb25TZWxlY3RlZGAgbWV0aG9kIG9mIFwiLmNvbmNhdChjb21wb25lbnROYW1lLCBcIiBkbyBub3QgaGFuZGxlIHRoZSBhcmd1bWVudHMgY29ycmVjdGx5LlwiKSwgXCJUaGUgY29tcG9uZW50IGV4cGVjdHMgYSBzaW5nbGUgdmFsdWUgdG8gbWF0Y2ggYSBnaXZlbiBvcHRpb24gYnV0IGZvdW5kIFwiLmNvbmNhdChtYXRjaGVzLmxlbmd0aCwgXCIgbWF0Y2hlcy5cIildLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlbUluZGV4ID0gZmluZEluZGV4KG5ld1ZhbHVlLCBmdW5jdGlvbiAodmFsdWVJdGVtKSB7XG4gICAgICAgIHJldHVybiBnZXRPcHRpb25TZWxlY3RlZChvcHRpb24sIHZhbHVlSXRlbSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGl0ZW1JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgbmV3VmFsdWUucHVzaChvcHRpb24pO1xuICAgICAgfSBlbHNlIGlmIChvcmlnaW4gIT09ICdmcmVlU29sbycpIHtcbiAgICAgICAgbmV3VmFsdWUuc3BsaWNlKGl0ZW1JbmRleCwgMSk7XG4gICAgICAgIHJlYXNvbiA9ICdyZW1vdmUtb3B0aW9uJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldElucHV0VmFsdWUoZXZlbnQsIG5ld1ZhbHVlKTtcbiAgICBoYW5kbGVWYWx1ZShldmVudCwgbmV3VmFsdWUsIHJlYXNvbiwge1xuICAgICAgb3B0aW9uOiBvcHRpb25cbiAgICB9KTtcblxuICAgIGlmICghZGlzYWJsZUNsb3NlT25TZWxlY3QpIHtcbiAgICAgIGhhbmRsZUNsb3NlKGV2ZW50LCByZWFzb24pO1xuICAgIH1cblxuICAgIGlmIChibHVyT25TZWxlY3QgPT09IHRydWUgfHwgYmx1ck9uU2VsZWN0ID09PSAndG91Y2gnICYmIGlzVG91Y2guY3VycmVudCB8fCBibHVyT25TZWxlY3QgPT09ICdtb3VzZScgJiYgIWlzVG91Y2guY3VycmVudCkge1xuICAgICAgaW5wdXRSZWYuY3VycmVudC5ibHVyKCk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbGlkVGFnSW5kZXgoaW5kZXgsIGRpcmVjdGlvbikge1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEZvY3VzID0gaW5kZXg7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gT3V0IG9mIHJhbmdlXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAnbmV4dCcgJiYgbmV4dEZvY3VzID09PSB2YWx1ZS5sZW5ndGggfHwgZGlyZWN0aW9uID09PSAncHJldmlvdXMnICYmIG5leHRGb2N1cyA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3B0aW9uID0gYW5jaG9yRWwucXVlcnlTZWxlY3RvcihcIltkYXRhLXRhZy1pbmRleD1cXFwiXCIuY29uY2F0KG5leHRGb2N1cywgXCJcXFwiXVwiKSk7IC8vIFNhbWUgbG9naWMgYXMgTWVudUxpc3QuanNcblxuICAgICAgaWYgKG9wdGlvbiAmJiAoIW9wdGlvbi5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykgfHwgb3B0aW9uLmRpc2FibGVkIHx8IG9wdGlvbi5nZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnKSA9PT0gJ3RydWUnKSkge1xuICAgICAgICBuZXh0Rm9jdXMgKz0gZGlyZWN0aW9uID09PSAnbmV4dCcgPyAxIDogLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV4dEZvY3VzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoYW5kbGVGb2N1c1RhZyA9IGZ1bmN0aW9uIGhhbmRsZUZvY3VzVGFnKGV2ZW50LCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFuZGxlQ2xvc2UoZXZlbnQsICd0b2dnbGVJbnB1dCcpO1xuICAgIHZhciBuZXh0VGFnID0gZm9jdXNlZFRhZztcblxuICAgIGlmIChmb2N1c2VkVGFnID09PSAtMSkge1xuICAgICAgaWYgKGlucHV0VmFsdWUgPT09ICcnICYmIGRpcmVjdGlvbiA9PT0gJ3ByZXZpb3VzJykge1xuICAgICAgICBuZXh0VGFnID0gdmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFRhZyArPSBkaXJlY3Rpb24gPT09ICduZXh0JyA/IDEgOiAtMTtcblxuICAgICAgaWYgKG5leHRUYWcgPCAwKSB7XG4gICAgICAgIG5leHRUYWcgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dFRhZyA9PT0gdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIG5leHRUYWcgPSAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXh0VGFnID0gdmFsaWRUYWdJbmRleChuZXh0VGFnLCBkaXJlY3Rpb24pO1xuICAgIHNldEZvY3VzZWRUYWcobmV4dFRhZyk7XG4gICAgZm9jdXNUYWcobmV4dFRhZyk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUNsZWFyID0gZnVuY3Rpb24gaGFuZGxlQ2xlYXIoZXZlbnQpIHtcbiAgICBpZ25vcmVGb2N1cy5jdXJyZW50ID0gdHJ1ZTtcbiAgICBzZXRJbnB1dFZhbHVlKCcnKTtcblxuICAgIGlmIChvbklucHV0Q2hhbmdlKSB7XG4gICAgICBvbklucHV0Q2hhbmdlKGV2ZW50LCAnJywgJ2NsZWFyJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlVmFsdWUoZXZlbnQsIG11bHRpcGxlID8gW10gOiBudWxsLCAnY2xlYXInKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIGhhbmRsZUtleURvd24ob3RoZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZm9jdXNlZFRhZyAhPT0gLTEgJiYgWydBcnJvd0xlZnQnLCAnQXJyb3dSaWdodCddLmluZGV4T2YoZXZlbnQua2V5KSA9PT0gLTEpIHtcbiAgICAgICAgc2V0Rm9jdXNlZFRhZygtMSk7XG4gICAgICAgIGZvY3VzVGFnKC0xKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgY2FzZSAnSG9tZSc6XG4gICAgICAgICAgaWYgKHBvcHVwT3BlbiAmJiBoYW5kbGVIb21lRW5kS2V5cykge1xuICAgICAgICAgICAgLy8gUHJldmVudCBzY3JvbGwgb2YgdGhlIHBhZ2VcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBjaGFuZ2VIaWdobGlnaHRlZEluZGV4KHtcbiAgICAgICAgICAgICAgZGlmZjogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnbmV4dCcsXG4gICAgICAgICAgICAgIHJlYXNvbjogJ2tleWJvYXJkJyxcbiAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdFbmQnOlxuICAgICAgICAgIGlmIChwb3B1cE9wZW4gJiYgaGFuZGxlSG9tZUVuZEtleXMpIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsIG9mIHRoZSBwYWdlXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY2hhbmdlSGlnaGxpZ2h0ZWRJbmRleCh7XG4gICAgICAgICAgICAgIGRpZmY6ICdlbmQnLFxuICAgICAgICAgICAgICBkaXJlY3Rpb246ICdwcmV2aW91cycsXG4gICAgICAgICAgICAgIHJlYXNvbjogJ2tleWJvYXJkJyxcbiAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdQYWdlVXAnOlxuICAgICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsIG9mIHRoZSBwYWdlXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBjaGFuZ2VIaWdobGlnaHRlZEluZGV4KHtcbiAgICAgICAgICAgIGRpZmY6IC1wYWdlU2l6ZSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ3ByZXZpb3VzJyxcbiAgICAgICAgICAgIHJlYXNvbjogJ2tleWJvYXJkJyxcbiAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGhhbmRsZU9wZW4oZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1BhZ2VEb3duJzpcbiAgICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbCBvZiB0aGUgcGFnZVxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgY2hhbmdlSGlnaGxpZ2h0ZWRJbmRleCh7XG4gICAgICAgICAgICBkaWZmOiBwYWdlU2l6ZSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ25leHQnLFxuICAgICAgICAgICAgcmVhc29uOiAna2V5Ym9hcmQnLFxuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaGFuZGxlT3BlbihldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAvLyBQcmV2ZW50IGN1cnNvciBtb3ZlXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBjaGFuZ2VIaWdobGlnaHRlZEluZGV4KHtcbiAgICAgICAgICAgIGRpZmY6IDEsXG4gICAgICAgICAgICBkaXJlY3Rpb246ICduZXh0JyxcbiAgICAgICAgICAgIHJlYXNvbjogJ2tleWJvYXJkJyxcbiAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGhhbmRsZU9wZW4oZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICAgIC8vIFByZXZlbnQgY3Vyc29yIG1vdmVcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNoYW5nZUhpZ2hsaWdodGVkSW5kZXgoe1xuICAgICAgICAgICAgZGlmZjogLTEsXG4gICAgICAgICAgICBkaXJlY3Rpb246ICdwcmV2aW91cycsXG4gICAgICAgICAgICByZWFzb246ICdrZXlib2FyZCcsXG4gICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBoYW5kbGVPcGVuKGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICAgIGhhbmRsZUZvY3VzVGFnKGV2ZW50LCAncHJldmlvdXMnKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgICAgICBoYW5kbGVGb2N1c1RhZyhldmVudCwgJ25leHQnKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgICAgLy8gV2FpdCB1bnRpbCBJTUUgaXMgc2V0dGxlZC5cbiAgICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IDIyOSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhpZ2hsaWdodGVkSW5kZXhSZWYuY3VycmVudCAhPT0gLTEgJiYgcG9wdXBPcGVuKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gZmlsdGVyZWRPcHRpb25zW2hpZ2hsaWdodGVkSW5kZXhSZWYuY3VycmVudF07XG4gICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBnZXRPcHRpb25EaXNhYmxlZCA/IGdldE9wdGlvbkRpc2FibGVkKG9wdGlvbikgOiBmYWxzZTsgLy8gV2UgZG9uJ3Qgd2FudCB0byB2YWxpZGF0ZSB0aGUgZm9ybS5cblxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZWN0TmV3VmFsdWUoZXZlbnQsIG9wdGlvbiwgJ3NlbGVjdC1vcHRpb24nKTsgLy8gTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBlbmQuXG5cbiAgICAgICAgICAgIGlmIChhdXRvQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgaW5wdXRSZWYuY3VycmVudC5zZXRTZWxlY3Rpb25SYW5nZShpbnB1dFJlZi5jdXJyZW50LnZhbHVlLmxlbmd0aCwgaW5wdXRSZWYuY3VycmVudC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZnJlZVNvbG8gJiYgaW5wdXRWYWx1ZSAhPT0gJycgJiYgaW5wdXRWYWx1ZUlzU2VsZWN0ZWRWYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAvLyBBbGxvdyBwZW9wbGUgdG8gYWRkIG5ldyB2YWx1ZXMgYmVmb3JlIHRoZXkgc3VibWl0IHRoZSBmb3JtLlxuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxlY3ROZXdWYWx1ZShldmVudCwgaW5wdXRWYWx1ZSwgJ2NyZWF0ZS1vcHRpb24nLCAnZnJlZVNvbG8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICAgIGlmIChwb3B1cE9wZW4pIHtcbiAgICAgICAgICAgIC8vIEF2b2lkIE9wZXJhIHRvIGV4aXQgZnVsbHNjcmVlbiBtb2RlLlxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gQXZvaWQgdGhlIE1vZGFsIHRvIGhhbmRsZSB0aGUgZXZlbnQuXG5cbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgaGFuZGxlQ2xvc2UoZXZlbnQsICdlc2NhcGUnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsZWFyT25Fc2NhcGUgJiYgKGlucHV0VmFsdWUgIT09ICcnIHx8IG11bHRpcGxlICYmIHZhbHVlLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAvLyBBdm9pZCBPcGVyYSB0byBleGl0IGZ1bGxzY3JlZW4gbW9kZS5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIEF2b2lkIHRoZSBNb2RhbCB0byBoYW5kbGUgdGhlIGV2ZW50LlxuXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGhhbmRsZUNsZWFyKGV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdCYWNrc3BhY2UnOlxuICAgICAgICAgIGlmIChtdWx0aXBsZSAmJiBpbnB1dFZhbHVlID09PSAnJyAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBmb2N1c2VkVGFnID09PSAtMSA/IHZhbHVlLmxlbmd0aCAtIDEgOiBmb2N1c2VkVGFnO1xuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgIG5ld1ZhbHVlLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBoYW5kbGVWYWx1ZShldmVudCwgbmV3VmFsdWUsICdyZW1vdmUtb3B0aW9uJywge1xuICAgICAgICAgICAgICBvcHRpb246IHZhbHVlW2luZGV4XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cblxuICAgICAgaWYgKG90aGVyLm9uS2V5RG93bikge1xuICAgICAgICBvdGhlci5vbktleURvd24oZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGhhbmRsZUZvY3VzID0gZnVuY3Rpb24gaGFuZGxlRm9jdXMoZXZlbnQpIHtcbiAgICBzZXRGb2N1c2VkKHRydWUpO1xuXG4gICAgaWYgKG9wZW5PbkZvY3VzICYmICFpZ25vcmVGb2N1cy5jdXJyZW50KSB7XG4gICAgICBoYW5kbGVPcGVuKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKGV2ZW50KSB7XG4gICAgLy8gSWdub3JlIHRoZSBldmVudCB3aGVuIHVzaW5nIHRoZSBzY3JvbGxiYXIgd2l0aCBJRSAxMVxuICAgIGlmIChsaXN0Ym94UmVmLmN1cnJlbnQgIT09IG51bGwgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gbGlzdGJveFJlZi5jdXJyZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGlucHV0UmVmLmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRGb2N1c2VkKGZhbHNlKTtcbiAgICBmaXJzdEZvY3VzLmN1cnJlbnQgPSB0cnVlO1xuICAgIGlnbm9yZUZvY3VzLmN1cnJlbnQgPSBmYWxzZTtcblxuICAgIGlmIChkZWJ1ZyAmJiBpbnB1dFZhbHVlICE9PSAnJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhdXRvU2VsZWN0ICYmIGhpZ2hsaWdodGVkSW5kZXhSZWYuY3VycmVudCAhPT0gLTEgJiYgcG9wdXBPcGVuKSB7XG4gICAgICBzZWxlY3ROZXdWYWx1ZShldmVudCwgZmlsdGVyZWRPcHRpb25zW2hpZ2hsaWdodGVkSW5kZXhSZWYuY3VycmVudF0sICdibHVyJyk7XG4gICAgfSBlbHNlIGlmIChhdXRvU2VsZWN0ICYmIGZyZWVTb2xvICYmIGlucHV0VmFsdWUgIT09ICcnKSB7XG4gICAgICBzZWxlY3ROZXdWYWx1ZShldmVudCwgaW5wdXRWYWx1ZSwgJ2JsdXInLCAnZnJlZVNvbG8nKTtcbiAgICB9IGVsc2UgaWYgKGNsZWFyT25CbHVyKSB7XG4gICAgICByZXNldElucHV0VmFsdWUoZXZlbnQsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVDbG9zZShldmVudCwgJ2JsdXInKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlSW5wdXRDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVJbnB1dENoYW5nZShldmVudCkge1xuICAgIHZhciBuZXdWYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcblxuICAgIGlmIChpbnB1dFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgc2V0SW5wdXRWYWx1ZShuZXdWYWx1ZSk7XG5cbiAgICAgIGlmIChvbklucHV0Q2hhbmdlKSB7XG4gICAgICAgIG9uSW5wdXRDaGFuZ2UoZXZlbnQsIG5ld1ZhbHVlLCAnaW5wdXQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmV3VmFsdWUgPT09ICcnKSB7XG4gICAgICBpZiAoIWRpc2FibGVDbGVhcmFibGUgJiYgIW11bHRpcGxlKSB7XG4gICAgICAgIGhhbmRsZVZhbHVlKGV2ZW50LCBudWxsLCAnY2xlYXInKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlT3BlbihldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVPcHRpb25Nb3VzZU92ZXIgPSBmdW5jdGlvbiBoYW5kbGVPcHRpb25Nb3VzZU92ZXIoZXZlbnQpIHtcbiAgICBzZXRIaWdobGlnaHRlZEluZGV4KHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGluZGV4OiBOdW1iZXIoZXZlbnQuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3B0aW9uLWluZGV4JykpLFxuICAgICAgcmVhc29uOiAnbW91c2UnXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZU9wdGlvblRvdWNoU3RhcnQgPSBmdW5jdGlvbiBoYW5kbGVPcHRpb25Ub3VjaFN0YXJ0KCkge1xuICAgIGlzVG91Y2guY3VycmVudCA9IHRydWU7XG4gIH07XG5cbiAgdmFyIGhhbmRsZU9wdGlvbkNsaWNrID0gZnVuY3Rpb24gaGFuZGxlT3B0aW9uQ2xpY2soZXZlbnQpIHtcbiAgICB2YXIgaW5kZXggPSBOdW1iZXIoZXZlbnQuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3B0aW9uLWluZGV4JykpO1xuICAgIHNlbGVjdE5ld1ZhbHVlKGV2ZW50LCBmaWx0ZXJlZE9wdGlvbnNbaW5kZXhdLCAnc2VsZWN0LW9wdGlvbicpO1xuICAgIGlzVG91Y2guY3VycmVudCA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBoYW5kbGVUYWdEZWxldGUgPSBmdW5jdGlvbiBoYW5kbGVUYWdEZWxldGUoaW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSB2YWx1ZS5zbGljZSgpO1xuICAgICAgbmV3VmFsdWUuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIGhhbmRsZVZhbHVlKGV2ZW50LCBuZXdWYWx1ZSwgJ3JlbW92ZS1vcHRpb24nLCB7XG4gICAgICAgIG9wdGlvbjogdmFsdWVbaW5kZXhdXG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBoYW5kbGVQb3B1cEluZGljYXRvciA9IGZ1bmN0aW9uIGhhbmRsZVBvcHVwSW5kaWNhdG9yKGV2ZW50KSB7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIGhhbmRsZUNsb3NlKGV2ZW50LCAndG9nZ2xlSW5wdXQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlT3BlbihldmVudCk7XG4gICAgfVxuICB9OyAvLyBQcmV2ZW50IGlucHV0IGJsdXIgd2hlbiBpbnRlcmFjdGluZyB3aXRoIHRoZSBjb21ib2JveFxuXG5cbiAgdmFyIGhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCdpZCcpICE9PSBpZCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07IC8vIEZvY3VzIHRoZSBpbnB1dCB3aGVuIGludGVyYWN0aW5nIHdpdGggdGhlIGNvbWJvYm94XG5cblxuICB2YXIgaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljaygpIHtcbiAgICBpbnB1dFJlZi5jdXJyZW50LmZvY3VzKCk7XG5cbiAgICBpZiAoc2VsZWN0T25Gb2N1cyAmJiBmaXJzdEZvY3VzLmN1cnJlbnQgJiYgaW5wdXRSZWYuY3VycmVudC5zZWxlY3Rpb25FbmQgLSBpbnB1dFJlZi5jdXJyZW50LnNlbGVjdGlvblN0YXJ0ID09PSAwKSB7XG4gICAgICBpbnB1dFJlZi5jdXJyZW50LnNlbGVjdCgpO1xuICAgIH1cblxuICAgIGZpcnN0Rm9jdXMuY3VycmVudCA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBoYW5kbGVJbnB1dE1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZUlucHV0TW91c2VEb3duKGV2ZW50KSB7XG4gICAgaWYgKGlucHV0VmFsdWUgPT09ICcnIHx8ICFvcGVuKSB7XG4gICAgICBoYW5kbGVQb3B1cEluZGljYXRvcihldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkaXJ0eSA9IGZyZWVTb2xvICYmIGlucHV0VmFsdWUubGVuZ3RoID4gMDtcbiAgZGlydHkgPSBkaXJ0eSB8fCAobXVsdGlwbGUgPyB2YWx1ZS5sZW5ndGggPiAwIDogdmFsdWUgIT09IG51bGwpO1xuICB2YXIgZ3JvdXBlZE9wdGlvbnMgPSBmaWx0ZXJlZE9wdGlvbnM7XG5cbiAgaWYgKGdyb3VwQnkpIHtcbiAgICAvLyB1c2VkIHRvIGtlZXAgdHJhY2sgb2Yga2V5IGFuZCBpbmRleGVzIGluIHRoZSByZXN1bHQgYXJyYXlcbiAgICB2YXIgaW5kZXhCeSA9IG5ldyBNYXAoKTtcbiAgICB2YXIgd2FybiA9IGZhbHNlO1xuICAgIGdyb3VwZWRPcHRpb25zID0gZmlsdGVyZWRPcHRpb25zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBvcHRpb24sIGluZGV4KSB7XG4gICAgICB2YXIgZ3JvdXAgPSBncm91cEJ5KG9wdGlvbik7XG5cbiAgICAgIGlmIChhY2MubGVuZ3RoID4gMCAmJiBhY2NbYWNjLmxlbmd0aCAtIDFdLmdyb3VwID09PSBncm91cCkge1xuICAgICAgICBhY2NbYWNjLmxlbmd0aCAtIDFdLm9wdGlvbnMucHVzaChvcHRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoaW5kZXhCeS5nZXQoZ3JvdXApICYmICF3YXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJNYXRlcmlhbC1VSTogVGhlIG9wdGlvbnMgcHJvdmlkZWQgY29tYmluZWQgd2l0aCB0aGUgYGdyb3VwQnlgIG1ldGhvZCBvZiBcIi5jb25jYXQoY29tcG9uZW50TmFtZSwgXCIgcmV0dXJucyBkdXBsaWNhdGVkIGhlYWRlcnMuXCIpLCAnWW91IGNhbiBzb2x2ZSB0aGUgaXNzdWUgYnkgc29ydGluZyB0aGUgb3B0aW9ucyB3aXRoIHRoZSBvdXRwdXQgb2YgYGdyb3VwQnlgLicpO1xuICAgICAgICAgICAgd2FybiA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5kZXhCeS5zZXQoZ3JvdXAsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWNjLnB1c2goe1xuICAgICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgIGdyb3VwOiBncm91cCxcbiAgICAgICAgICBvcHRpb25zOiBbb3B0aW9uXVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldFJvb3RQcm9wczogZnVuY3Rpb24gZ2V0Um9vdFByb3BzKCkge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgICdhcmlhLW93bnMnOiBwb3B1cE9wZW4gPyBcIlwiLmNvbmNhdChpZCwgXCItcG9wdXBcIikgOiBudWxsLFxuICAgICAgICByb2xlOiAnY29tYm9ib3gnLFxuICAgICAgICAnYXJpYS1leHBhbmRlZCc6IHBvcHVwT3BlblxuICAgICAgfSwgb3RoZXIsIHtcbiAgICAgICAgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duKG90aGVyKSxcbiAgICAgICAgb25Nb3VzZURvd246IGhhbmRsZU1vdXNlRG93bixcbiAgICAgICAgb25DbGljazogaGFuZGxlQ2xpY2tcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0SW5wdXRMYWJlbFByb3BzOiBmdW5jdGlvbiBnZXRJbnB1dExhYmVsUHJvcHMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogXCJcIi5jb25jYXQoaWQsIFwiLWxhYmVsXCIpLFxuICAgICAgICBodG1sRm9yOiBpZFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldElucHV0UHJvcHM6IGZ1bmN0aW9uIGdldElucHV0UHJvcHMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlLFxuICAgICAgICBvbkJsdXI6IGhhbmRsZUJsdXIsXG4gICAgICAgIG9uRm9jdXM6IGhhbmRsZUZvY3VzLFxuICAgICAgICBvbkNoYW5nZTogaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgICAgIG9uTW91c2VEb3duOiBoYW5kbGVJbnB1dE1vdXNlRG93bixcbiAgICAgICAgLy8gaWYgb3BlbiB0aGVuIHRoaXMgaXMgaGFuZGxlZCBpbXBlcmF0aXZlbGV5IHNvIGRvbid0IGxldCByZWFjdCBvdmVycmlkZVxuICAgICAgICAvLyBvbmx5IGhhdmUgYW4gb3BpbmlvbiBhYm91dCB0aGlzIHdoZW4gY2xvc2VkXG4gICAgICAgICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiBwb3B1cE9wZW4gPyAnJyA6IG51bGwsXG4gICAgICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6IGF1dG9Db21wbGV0ZSA/ICdib3RoJyA6ICdsaXN0JyxcbiAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBwb3B1cE9wZW4gPyBcIlwiLmNvbmNhdChpZCwgXCItcG9wdXBcIikgOiBudWxsLFxuICAgICAgICAvLyBEaXNhYmxlIGJyb3dzZXIncyBzdWdnZXN0aW9uIHRoYXQgbWlnaHQgb3ZlcmxhcCB3aXRoIHRoZSBwb3B1cC5cbiAgICAgICAgLy8gSGFuZGxlIGF1dG9jb21wbGV0ZSBidXQgbm90IGF1dG9maWxsLlxuICAgICAgICBhdXRvQ29tcGxldGU6ICdvZmYnLFxuICAgICAgICByZWY6IGlucHV0UmVmLFxuICAgICAgICBhdXRvQ2FwaXRhbGl6ZTogJ25vbmUnLFxuICAgICAgICBzcGVsbENoZWNrOiAnZmFsc2UnXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0Q2xlYXJQcm9wczogZnVuY3Rpb24gZ2V0Q2xlYXJQcm9wcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhYkluZGV4OiAtMSxcbiAgICAgICAgb25DbGljazogaGFuZGxlQ2xlYXJcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRQb3B1cEluZGljYXRvclByb3BzOiBmdW5jdGlvbiBnZXRQb3B1cEluZGljYXRvclByb3BzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFiSW5kZXg6IC0xLFxuICAgICAgICBvbkNsaWNrOiBoYW5kbGVQb3B1cEluZGljYXRvclxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFRhZ1Byb3BzOiBmdW5jdGlvbiBnZXRUYWdQcm9wcyhfcmVmNCkge1xuICAgICAgdmFyIGluZGV4ID0gX3JlZjQuaW5kZXg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IGluZGV4LFxuICAgICAgICAnZGF0YS10YWctaW5kZXgnOiBpbmRleCxcbiAgICAgICAgdGFiSW5kZXg6IC0xLFxuICAgICAgICBvbkRlbGV0ZTogaGFuZGxlVGFnRGVsZXRlKGluZGV4KVxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldExpc3Rib3hQcm9wczogZnVuY3Rpb24gZ2V0TGlzdGJveFByb3BzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ2xpc3Rib3gnLFxuICAgICAgICBpZDogXCJcIi5jb25jYXQoaWQsIFwiLXBvcHVwXCIpLFxuICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogXCJcIi5jb25jYXQoaWQsIFwiLWxhYmVsXCIpLFxuICAgICAgICByZWY6IGhhbmRsZUxpc3Rib3hSZWYsXG4gICAgICAgIG9uTW91c2VEb3duOiBmdW5jdGlvbiBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICAgIC8vIFByZXZlbnQgYmx1clxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRPcHRpb25Qcm9wczogZnVuY3Rpb24gZ2V0T3B0aW9uUHJvcHMoX3JlZjUpIHtcbiAgICAgIHZhciBpbmRleCA9IF9yZWY1LmluZGV4LFxuICAgICAgICAgIG9wdGlvbiA9IF9yZWY1Lm9wdGlvbjtcbiAgICAgIHZhciBzZWxlY3RlZCA9IChtdWx0aXBsZSA/IHZhbHVlIDogW3ZhbHVlXSkuc29tZShmdW5jdGlvbiAodmFsdWUyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTIgIT0gbnVsbCAmJiBnZXRPcHRpb25TZWxlY3RlZChvcHRpb24sIHZhbHVlMik7XG4gICAgICB9KTtcbiAgICAgIHZhciBkaXNhYmxlZCA9IGdldE9wdGlvbkRpc2FibGVkID8gZ2V0T3B0aW9uRGlzYWJsZWQob3B0aW9uKSA6IGZhbHNlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBpbmRleCxcbiAgICAgICAgdGFiSW5kZXg6IC0xLFxuICAgICAgICByb2xlOiAnb3B0aW9uJyxcbiAgICAgICAgaWQ6IFwiXCIuY29uY2F0KGlkLCBcIi1vcHRpb24tXCIpLmNvbmNhdChpbmRleCksXG4gICAgICAgIG9uTW91c2VPdmVyOiBoYW5kbGVPcHRpb25Nb3VzZU92ZXIsXG4gICAgICAgIG9uQ2xpY2s6IGhhbmRsZU9wdGlvbkNsaWNrLFxuICAgICAgICBvblRvdWNoU3RhcnQ6IGhhbmRsZU9wdGlvblRvdWNoU3RhcnQsXG4gICAgICAgICdkYXRhLW9wdGlvbi1pbmRleCc6IGluZGV4LFxuICAgICAgICAnYXJpYS1kaXNhYmxlZCc6IGRpc2FibGVkLFxuICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IHNlbGVjdGVkXG4gICAgICB9O1xuICAgIH0sXG4gICAgaWQ6IGlkLFxuICAgIGlucHV0VmFsdWU6IGlucHV0VmFsdWUsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRpcnR5OiBkaXJ0eSxcbiAgICBwb3B1cE9wZW46IHBvcHVwT3BlbixcbiAgICBmb2N1c2VkOiBmb2N1c2VkIHx8IGZvY3VzZWRUYWcgIT09IC0xLFxuICAgIGFuY2hvckVsOiBhbmNob3JFbCxcbiAgICBzZXRBbmNob3JFbDogc2V0QW5jaG9yRWwsXG4gICAgZm9jdXNlZFRhZzogZm9jdXNlZFRhZyxcbiAgICBncm91cGVkT3B0aW9uczogZ3JvdXBlZE9wdGlvbnNcbiAgfTtcbn0iLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHsgd2l0aFN0eWxlcyB9IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL3N0eWxlcyc7XG5pbXBvcnQgUG9wcGVyIGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL1BvcHBlcic7XG5pbXBvcnQgTGlzdFN1YmhlYWRlciBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS9MaXN0U3ViaGVhZGVyJztcbmltcG9ydCBQYXBlciBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS9QYXBlcic7XG5pbXBvcnQgSWNvbkJ1dHRvbiBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS9JY29uQnV0dG9uJztcbmltcG9ydCBDaGlwIGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL0NoaXAnO1xuaW1wb3J0IENsb3NlSWNvbiBmcm9tICcuLi9pbnRlcm5hbC9zdmctaWNvbnMvQ2xvc2UnO1xuaW1wb3J0IEFycm93RHJvcERvd25JY29uIGZyb20gJy4uL2ludGVybmFsL3N2Zy1pY29ucy9BcnJvd0Ryb3BEb3duJztcbmltcG9ydCB1c2VBdXRvY29tcGxldGUsIHsgY3JlYXRlRmlsdGVyT3B0aW9ucyB9IGZyb20gJy4uL3VzZUF1dG9jb21wbGV0ZSc7XG5leHBvcnQgeyBjcmVhdGVGaWx0ZXJPcHRpb25zIH07XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICB2YXIgX29wdGlvbjtcblxuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gICAgcm9vdDoge1xuICAgICAgJyYkZm9jdXNlZCAkY2xlYXJJbmRpY2F0b3JEaXJ0eSc6IHtcbiAgICAgICAgdmlzaWJpbGl0eTogJ3Zpc2libGUnXG4gICAgICB9LFxuXG4gICAgICAvKiBBdm9pZCBkb3VibGUgdGFwIGlzc3VlIG9uIGlPUyAqL1xuICAgICAgJ0BtZWRpYSAocG9pbnRlcjogZmluZSknOiB7XG4gICAgICAgICcmOmhvdmVyICRjbGVhckluZGljYXRvckRpcnR5Jzoge1xuICAgICAgICAgIHZpc2liaWxpdHk6ICd2aXNpYmxlJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGZ1bGxXaWR0aD17dHJ1ZX1gLiAqL1xuICAgIGZ1bGxXaWR0aDoge1xuICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgIH0sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGZvY3VzZWQuICovXG4gICAgZm9jdXNlZDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgdGFnIGVsZW1lbnRzLCBlLmcuIHRoZSBjaGlwcy4gKi9cbiAgICB0YWc6IHtcbiAgICAgIG1hcmdpbjogMyxcbiAgICAgIG1heFdpZHRoOiAnY2FsYygxMDAlIC0gNnB4KSdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHRhZyBlbGVtZW50cywgZS5nLiB0aGUgY2hpcHMgaWYgYHNpemU9XCJzbWFsbFwiYC4gKi9cbiAgICB0YWdTaXplU21hbGw6IHtcbiAgICAgIG1hcmdpbjogMixcbiAgICAgIG1heFdpZHRoOiAnY2FsYygxMDAlIC0gNHB4KSdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgd2hlbiB0aGUgcG9wdXAgaWNvbiBpcyByZW5kZXJlZC4gKi9cbiAgICBoYXNQb3B1cEljb246IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgd2hlbiB0aGUgY2xlYXIgaWNvbiBpcyByZW5kZXJlZC4gKi9cbiAgICBoYXNDbGVhckljb246IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIElucHV0IGVsZW1lbnQuICovXG4gICAgaW5wdXRSb290OiB7XG4gICAgICBmbGV4V3JhcDogJ3dyYXAnLFxuICAgICAgJyRoYXNQb3B1cEljb24gJiwgJGhhc0NsZWFySWNvbiAmJzoge1xuICAgICAgICBwYWRkaW5nUmlnaHQ6IDI2ICsgNFxuICAgICAgfSxcbiAgICAgICckaGFzUG9wdXBJY29uJGhhc0NsZWFySWNvbiAmJzoge1xuICAgICAgICBwYWRkaW5nUmlnaHQ6IDUyICsgNFxuICAgICAgfSxcbiAgICAgICcmICRpbnB1dCc6IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIG1pbldpZHRoOiAzMFxuICAgICAgfSxcbiAgICAgICcmW2NsYXNzKj1cIk11aUlucHV0LXJvb3RcIl0nOiB7XG4gICAgICAgIHBhZGRpbmdCb3R0b206IDEsXG4gICAgICAgICcmICRpbnB1dCc6IHtcbiAgICAgICAgICBwYWRkaW5nOiA0XG4gICAgICAgIH0sXG4gICAgICAgICcmICRpbnB1dDpmaXJzdC1jaGlsZCc6IHtcbiAgICAgICAgICBwYWRkaW5nOiAnNnB4IDAnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnJltjbGFzcyo9XCJNdWlJbnB1dC1yb290XCJdW2NsYXNzKj1cIk11aUlucHV0LW1hcmdpbkRlbnNlXCJdJzoge1xuICAgICAgICAnJiAkaW5wdXQnOiB7XG4gICAgICAgICAgcGFkZGluZzogJzRweCA0cHggNXB4J1xuICAgICAgICB9LFxuICAgICAgICAnJiAkaW5wdXQ6Zmlyc3QtY2hpbGQnOiB7XG4gICAgICAgICAgcGFkZGluZzogJzNweCAwIDZweCdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICcmW2NsYXNzKj1cIk11aU91dGxpbmVkSW5wdXQtcm9vdFwiXSc6IHtcbiAgICAgICAgcGFkZGluZzogOSxcbiAgICAgICAgJyRoYXNQb3B1cEljb24gJiwgJGhhc0NsZWFySWNvbiAmJzoge1xuICAgICAgICAgIHBhZGRpbmdSaWdodDogMjYgKyA0ICsgOVxuICAgICAgICB9LFxuICAgICAgICAnJGhhc1BvcHVwSWNvbiRoYXNDbGVhckljb24gJic6IHtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQ6IDUyICsgNCArIDlcbiAgICAgICAgfSxcbiAgICAgICAgJyYgJGlucHV0Jzoge1xuICAgICAgICAgIHBhZGRpbmc6ICc5LjVweCA0cHgnXG4gICAgICAgIH0sXG4gICAgICAgICcmICRpbnB1dDpmaXJzdC1jaGlsZCc6IHtcbiAgICAgICAgICBwYWRkaW5nTGVmdDogNlxuICAgICAgICB9LFxuICAgICAgICAnJiAkZW5kQWRvcm5tZW50Jzoge1xuICAgICAgICAgIHJpZ2h0OiA5XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnJltjbGFzcyo9XCJNdWlPdXRsaW5lZElucHV0LXJvb3RcIl1bY2xhc3MqPVwiTXVpT3V0bGluZWRJbnB1dC1tYXJnaW5EZW5zZVwiXSc6IHtcbiAgICAgICAgcGFkZGluZzogNixcbiAgICAgICAgJyYgJGlucHV0Jzoge1xuICAgICAgICAgIHBhZGRpbmc6ICc0LjVweCA0cHgnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnJltjbGFzcyo9XCJNdWlGaWxsZWRJbnB1dC1yb290XCJdJzoge1xuICAgICAgICBwYWRkaW5nVG9wOiAxOSxcbiAgICAgICAgcGFkZGluZ0xlZnQ6IDgsXG4gICAgICAgICckaGFzUG9wdXBJY29uICYsICRoYXNDbGVhckljb24gJic6IHtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQ6IDI2ICsgNCArIDlcbiAgICAgICAgfSxcbiAgICAgICAgJyRoYXNQb3B1cEljb24kaGFzQ2xlYXJJY29uICYnOiB7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0OiA1MiArIDQgKyA5XG4gICAgICAgIH0sXG4gICAgICAgICcmICRpbnB1dCc6IHtcbiAgICAgICAgICBwYWRkaW5nOiAnOXB4IDRweCdcbiAgICAgICAgfSxcbiAgICAgICAgJyYgJGVuZEFkb3JubWVudCc6IHtcbiAgICAgICAgICByaWdodDogOVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJyZbY2xhc3MqPVwiTXVpRmlsbGVkSW5wdXQtcm9vdFwiXVtjbGFzcyo9XCJNdWlGaWxsZWRJbnB1dC1tYXJnaW5EZW5zZVwiXSc6IHtcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogMSxcbiAgICAgICAgJyYgJGlucHV0Jzoge1xuICAgICAgICAgIHBhZGRpbmc6ICc0LjVweCA0cHgnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGlucHV0IGVsZW1lbnQuICovXG4gICAgaW5wdXQ6IHtcbiAgICAgIGZsZXhHcm93OiAxLFxuICAgICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgICAgb3BhY2l0eTogMFxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaW5wdXQgZWxlbWVudCBpZiB0YWcgZm9jdXNlZC4gKi9cbiAgICBpbnB1dEZvY3VzZWQ6IHtcbiAgICAgIG9wYWNpdHk6IDFcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGVuZEFkb3JubWVudCBlbGVtZW50LiAqL1xuICAgIGVuZEFkb3JubWVudDoge1xuICAgICAgLy8gV2UgdXNlIGEgcG9zaXRpb24gYWJzb2x1dGUgdG8gc3VwcG9ydCB3cmFwcGluZyB0YWdzLlxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogJ2NhbGMoNTAlIC0gMTRweCknIC8vIENlbnRlciB2ZXJ0aWNhbGx5XG5cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNsZWFyIGluZGljYXRvci4gKi9cbiAgICBjbGVhckluZGljYXRvcjoge1xuICAgICAgbWFyZ2luUmlnaHQ6IC0yLFxuICAgICAgcGFkZGluZzogNCxcbiAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjbGVhciBpbmRpY2F0b3IgaWYgdGhlIGlucHV0IGlzIGRpcnR5LiAqL1xuICAgIGNsZWFySW5kaWNhdG9yRGlydHk6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHBvcHVwIGluZGljYXRvci4gKi9cbiAgICBwb3B1cEluZGljYXRvcjoge1xuICAgICAgcGFkZGluZzogMixcbiAgICAgIG1hcmdpblJpZ2h0OiAtMlxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcG9wdXAgaW5kaWNhdG9yIGlmIHRoZSBwb3B1cCBpcyBvcGVuLiAqL1xuICAgIHBvcHVwSW5kaWNhdG9yT3Blbjoge1xuICAgICAgdHJhbnNmb3JtOiAncm90YXRlKDE4MGRlZyknXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgZWxlbWVudC4gKi9cbiAgICBwb3BwZXI6IHtcbiAgICAgIHpJbmRleDogdGhlbWUuekluZGV4Lm1vZGFsXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgZWxlbWVudCBpZiBgZGlzYWJsZVBvcnRhbD17dHJ1ZX1gLiAqL1xuICAgIHBvcHBlckRpc2FibGVQb3J0YWw6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgUGFwZXJgIGNvbXBvbmVudC4gKi9cbiAgICBwYXBlcjogX2V4dGVuZHMoe30sIHRoZW1lLnR5cG9ncmFwaHkuYm9keTEsIHtcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIG1hcmdpbjogJzRweCAwJ1xuICAgIH0pLFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBsaXN0Ym94YCBjb21wb25lbnQuICovXG4gICAgbGlzdGJveDoge1xuICAgICAgbGlzdFN0eWxlOiAnbm9uZScsXG4gICAgICBtYXJnaW46IDAsXG4gICAgICBwYWRkaW5nOiAnOHB4IDAnLFxuICAgICAgbWF4SGVpZ2h0OiAnNDB2aCcsXG4gICAgICBvdmVyZmxvdzogJ2F1dG8nXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBsb2FkaW5nIHdyYXBwZXIuICovXG4gICAgbG9hZGluZzoge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudGV4dC5zZWNvbmRhcnksXG4gICAgICBwYWRkaW5nOiAnMTRweCAxNnB4J1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgbm8gb3B0aW9uIHdyYXBwZXIuICovXG4gICAgbm9PcHRpb25zOiB7XG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS50ZXh0LnNlY29uZGFyeSxcbiAgICAgIHBhZGRpbmc6ICcxNHB4IDE2cHgnXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBvcHRpb24gZWxlbWVudHMuICovXG4gICAgb3B0aW9uOiAoX29wdGlvbiA9IHtcbiAgICAgIG1pbkhlaWdodDogNDgsXG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtc3RhcnQnLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgIHBhZGRpbmdUb3A6IDYsXG4gICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgIG91dGxpbmU6ICcwJyxcbiAgICAgIFdlYmtpdFRhcEhpZ2hsaWdodENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgcGFkZGluZ0JvdHRvbTogNixcbiAgICAgIHBhZGRpbmdMZWZ0OiAxNixcbiAgICAgIHBhZGRpbmdSaWdodDogMTZcbiAgICB9LCBfZGVmaW5lUHJvcGVydHkoX29wdGlvbiwgdGhlbWUuYnJlYWtwb2ludHMudXAoJ3NtJyksIHtcbiAgICAgIG1pbkhlaWdodDogJ2F1dG8nXG4gICAgfSksIF9kZWZpbmVQcm9wZXJ0eShfb3B0aW9uLCAnJlthcmlhLXNlbGVjdGVkPVwidHJ1ZVwiXScsIHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5hY3Rpb24uc2VsZWN0ZWRcbiAgICB9KSwgX2RlZmluZVByb3BlcnR5KF9vcHRpb24sICcmW2RhdGEtZm9jdXM9XCJ0cnVlXCJdJywge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLmFjdGlvbi5ob3ZlclxuICAgIH0pLCBfZGVmaW5lUHJvcGVydHkoX29wdGlvbiwgJyY6YWN0aXZlJywge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLmFjdGlvbi5zZWxlY3RlZFxuICAgIH0pLCBfZGVmaW5lUHJvcGVydHkoX29wdGlvbiwgJyZbYXJpYS1kaXNhYmxlZD1cInRydWVcIl0nLCB7XG4gICAgICBvcGFjaXR5OiB0aGVtZS5wYWxldHRlLmFjdGlvbi5kaXNhYmxlZE9wYWNpdHksXG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgICB9KSwgX29wdGlvbiksXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgZ3JvdXAncyBsYWJlbCBlbGVtZW50cy4gKi9cbiAgICBncm91cExhYmVsOiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUuYmFja2dyb3VuZC5wYXBlcixcbiAgICAgIHRvcDogLThcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGdyb3VwJ3MgdWwgZWxlbWVudHMuICovXG4gICAgZ3JvdXBVbDoge1xuICAgICAgcGFkZGluZzogMCxcbiAgICAgICcmICRvcHRpb24nOiB7XG4gICAgICAgIHBhZGRpbmdMZWZ0OiAyNFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIERpc2FibGVQb3J0YWwocHJvcHMpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3Byb3AtdHlwZXNcbiAgdmFyIGFuY2hvckVsID0gcHJvcHMuYW5jaG9yRWwsXG4gICAgICBvcGVuID0gcHJvcHMub3BlbixcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJhbmNob3JFbFwiLCBcIm9wZW5cIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBvdGhlcik7XG59XG5cbnZhciBfcmVmID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2xvc2VJY29uLCB7XG4gIGZvbnRTaXplOiBcInNtYWxsXCJcbn0pO1xuXG52YXIgX3JlZjIgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBcnJvd0Ryb3BEb3duSWNvbiwgbnVsbCk7XG5cbnZhciBBdXRvY29tcGxldGUgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBBdXRvY29tcGxldGUocHJvcHMsIHJlZikge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICB2YXIgX3Byb3BzJGF1dG9Db21wbGV0ZSA9IHByb3BzLmF1dG9Db21wbGV0ZSxcbiAgICAgIGF1dG9Db21wbGV0ZSA9IF9wcm9wcyRhdXRvQ29tcGxldGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGF1dG9Db21wbGV0ZSxcbiAgICAgIF9wcm9wcyRhdXRvSGlnaGxpZ2h0ID0gcHJvcHMuYXV0b0hpZ2hsaWdodCxcbiAgICAgIGF1dG9IaWdobGlnaHQgPSBfcHJvcHMkYXV0b0hpZ2hsaWdodCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkYXV0b0hpZ2hsaWdodCxcbiAgICAgIF9wcm9wcyRhdXRvU2VsZWN0ID0gcHJvcHMuYXV0b1NlbGVjdCxcbiAgICAgIGF1dG9TZWxlY3QgPSBfcHJvcHMkYXV0b1NlbGVjdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkYXV0b1NlbGVjdCxcbiAgICAgIF9wcm9wcyRibHVyT25TZWxlY3QgPSBwcm9wcy5ibHVyT25TZWxlY3QsXG4gICAgICBibHVyT25TZWxlY3QgPSBfcHJvcHMkYmx1ck9uU2VsZWN0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRibHVyT25TZWxlY3QsXG4gICAgICBDaGlwUHJvcHMgPSBwcm9wcy5DaGlwUHJvcHMsXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRjbGVhck9uQmx1ciA9IHByb3BzLmNsZWFyT25CbHVyLFxuICAgICAgY2xlYXJPbkJsdXIgPSBfcHJvcHMkY2xlYXJPbkJsdXIgPT09IHZvaWQgMCA/ICFwcm9wcy5mcmVlU29sbyA6IF9wcm9wcyRjbGVhck9uQmx1cixcbiAgICAgIF9wcm9wcyRjbGVhck9uRXNjYXBlID0gcHJvcHMuY2xlYXJPbkVzY2FwZSxcbiAgICAgIGNsZWFyT25Fc2NhcGUgPSBfcHJvcHMkY2xlYXJPbkVzY2FwZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkY2xlYXJPbkVzY2FwZSxcbiAgICAgIF9wcm9wcyRjbGVhclRleHQgPSBwcm9wcy5jbGVhclRleHQsXG4gICAgICBjbGVhclRleHQgPSBfcHJvcHMkY2xlYXJUZXh0ID09PSB2b2lkIDAgPyAnQ2xlYXInIDogX3Byb3BzJGNsZWFyVGV4dCxcbiAgICAgIF9wcm9wcyRjbG9zZUljb24gPSBwcm9wcy5jbG9zZUljb24sXG4gICAgICBjbG9zZUljb24gPSBfcHJvcHMkY2xvc2VJY29uID09PSB2b2lkIDAgPyBfcmVmIDogX3Byb3BzJGNsb3NlSWNvbixcbiAgICAgIF9wcm9wcyRjbG9zZVRleHQgPSBwcm9wcy5jbG9zZVRleHQsXG4gICAgICBjbG9zZVRleHQgPSBfcHJvcHMkY2xvc2VUZXh0ID09PSB2b2lkIDAgPyAnQ2xvc2UnIDogX3Byb3BzJGNsb3NlVGV4dCxcbiAgICAgIF9wcm9wcyRkZWJ1ZyA9IHByb3BzLmRlYnVnLFxuICAgICAgZGVidWcgPSBfcHJvcHMkZGVidWcgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRlYnVnLFxuICAgICAgX3Byb3BzJGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgIGRlZmF1bHRWYWx1ZSA9IF9wcm9wcyRkZWZhdWx0VmFsdWUgPT09IHZvaWQgMCA/IHByb3BzLm11bHRpcGxlID8gW10gOiBudWxsIDogX3Byb3BzJGRlZmF1bHRWYWx1ZSxcbiAgICAgIF9wcm9wcyRkaXNhYmxlQ2xlYXJhYiA9IHByb3BzLmRpc2FibGVDbGVhcmFibGUsXG4gICAgICBkaXNhYmxlQ2xlYXJhYmxlID0gX3Byb3BzJGRpc2FibGVDbGVhcmFiID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlQ2xlYXJhYixcbiAgICAgIF9wcm9wcyRkaXNhYmxlQ2xvc2VPbiA9IHByb3BzLmRpc2FibGVDbG9zZU9uU2VsZWN0LFxuICAgICAgZGlzYWJsZUNsb3NlT25TZWxlY3QgPSBfcHJvcHMkZGlzYWJsZUNsb3NlT24gPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVDbG9zZU9uLFxuICAgICAgX3Byb3BzJGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQsXG4gICAgICBkaXNhYmxlZCA9IF9wcm9wcyRkaXNhYmxlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZWQsXG4gICAgICBfcHJvcHMkZGlzYWJsZWRJdGVtc0YgPSBwcm9wcy5kaXNhYmxlZEl0ZW1zRm9jdXNhYmxlLFxuICAgICAgZGlzYWJsZWRJdGVtc0ZvY3VzYWJsZSA9IF9wcm9wcyRkaXNhYmxlZEl0ZW1zRiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZWRJdGVtc0YsXG4gICAgICBfcHJvcHMkZGlzYWJsZUxpc3RXcmEgPSBwcm9wcy5kaXNhYmxlTGlzdFdyYXAsXG4gICAgICBkaXNhYmxlTGlzdFdyYXAgPSBfcHJvcHMkZGlzYWJsZUxpc3RXcmEgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVMaXN0V3JhLFxuICAgICAgX3Byb3BzJGRpc2FibGVQb3J0YWwgPSBwcm9wcy5kaXNhYmxlUG9ydGFsLFxuICAgICAgZGlzYWJsZVBvcnRhbCA9IF9wcm9wcyRkaXNhYmxlUG9ydGFsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlUG9ydGFsLFxuICAgICAgZmlsdGVyT3B0aW9ucyA9IHByb3BzLmZpbHRlck9wdGlvbnMsXG4gICAgICBfcHJvcHMkZmlsdGVyU2VsZWN0ZWQgPSBwcm9wcy5maWx0ZXJTZWxlY3RlZE9wdGlvbnMsXG4gICAgICBmaWx0ZXJTZWxlY3RlZE9wdGlvbnMgPSBfcHJvcHMkZmlsdGVyU2VsZWN0ZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGZpbHRlclNlbGVjdGVkLFxuICAgICAgX3Byb3BzJGZvcmNlUG9wdXBJY29uID0gcHJvcHMuZm9yY2VQb3B1cEljb24sXG4gICAgICBmb3JjZVBvcHVwSWNvbiA9IF9wcm9wcyRmb3JjZVBvcHVwSWNvbiA9PT0gdm9pZCAwID8gJ2F1dG8nIDogX3Byb3BzJGZvcmNlUG9wdXBJY29uLFxuICAgICAgX3Byb3BzJGZyZWVTb2xvID0gcHJvcHMuZnJlZVNvbG8sXG4gICAgICBmcmVlU29sbyA9IF9wcm9wcyRmcmVlU29sbyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZnJlZVNvbG8sXG4gICAgICBfcHJvcHMkZnVsbFdpZHRoID0gcHJvcHMuZnVsbFdpZHRoLFxuICAgICAgZnVsbFdpZHRoID0gX3Byb3BzJGZ1bGxXaWR0aCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZnVsbFdpZHRoLFxuICAgICAgX3Byb3BzJGdldExpbWl0VGFnc1RlID0gcHJvcHMuZ2V0TGltaXRUYWdzVGV4dCxcbiAgICAgIGdldExpbWl0VGFnc1RleHQgPSBfcHJvcHMkZ2V0TGltaXRUYWdzVGUgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChtb3JlKSB7XG4gICAgcmV0dXJuIFwiK1wiLmNvbmNhdChtb3JlKTtcbiAgfSA6IF9wcm9wcyRnZXRMaW1pdFRhZ3NUZSxcbiAgICAgIGdldE9wdGlvbkRpc2FibGVkID0gcHJvcHMuZ2V0T3B0aW9uRGlzYWJsZWQsXG4gICAgICBfcHJvcHMkZ2V0T3B0aW9uTGFiZWwgPSBwcm9wcy5nZXRPcHRpb25MYWJlbCxcbiAgICAgIGdldE9wdGlvbkxhYmVsID0gX3Byb3BzJGdldE9wdGlvbkxhYmVsID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4O1xuICB9IDogX3Byb3BzJGdldE9wdGlvbkxhYmVsLFxuICAgICAgZ2V0T3B0aW9uU2VsZWN0ZWQgPSBwcm9wcy5nZXRPcHRpb25TZWxlY3RlZCxcbiAgICAgIGdyb3VwQnkgPSBwcm9wcy5ncm91cEJ5LFxuICAgICAgX3Byb3BzJGhhbmRsZUhvbWVFbmRLID0gcHJvcHMuaGFuZGxlSG9tZUVuZEtleXMsXG4gICAgICBoYW5kbGVIb21lRW5kS2V5cyA9IF9wcm9wcyRoYW5kbGVIb21lRW5kSyA9PT0gdm9pZCAwID8gIXByb3BzLmZyZWVTb2xvIDogX3Byb3BzJGhhbmRsZUhvbWVFbmRLLFxuICAgICAgaWRQcm9wID0gcHJvcHMuaWQsXG4gICAgICBfcHJvcHMkaW5jbHVkZUlucHV0SW4gPSBwcm9wcy5pbmNsdWRlSW5wdXRJbkxpc3QsXG4gICAgICBpbmNsdWRlSW5wdXRJbkxpc3QgPSBfcHJvcHMkaW5jbHVkZUlucHV0SW4gPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGluY2x1ZGVJbnB1dEluLFxuICAgICAgaW5wdXRWYWx1ZVByb3AgPSBwcm9wcy5pbnB1dFZhbHVlLFxuICAgICAgX3Byb3BzJGxpbWl0VGFncyA9IHByb3BzLmxpbWl0VGFncyxcbiAgICAgIGxpbWl0VGFncyA9IF9wcm9wcyRsaW1pdFRhZ3MgPT09IHZvaWQgMCA/IC0xIDogX3Byb3BzJGxpbWl0VGFncyxcbiAgICAgIF9wcm9wcyRMaXN0Ym94Q29tcG9uZSA9IHByb3BzLkxpc3Rib3hDb21wb25lbnQsXG4gICAgICBMaXN0Ym94Q29tcG9uZW50ID0gX3Byb3BzJExpc3Rib3hDb21wb25lID09PSB2b2lkIDAgPyAndWwnIDogX3Byb3BzJExpc3Rib3hDb21wb25lLFxuICAgICAgTGlzdGJveFByb3BzID0gcHJvcHMuTGlzdGJveFByb3BzLFxuICAgICAgX3Byb3BzJGxvYWRpbmcgPSBwcm9wcy5sb2FkaW5nLFxuICAgICAgbG9hZGluZyA9IF9wcm9wcyRsb2FkaW5nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRsb2FkaW5nLFxuICAgICAgX3Byb3BzJGxvYWRpbmdUZXh0ID0gcHJvcHMubG9hZGluZ1RleHQsXG4gICAgICBsb2FkaW5nVGV4dCA9IF9wcm9wcyRsb2FkaW5nVGV4dCA9PT0gdm9pZCAwID8gJ0xvYWRpbmfigKYnIDogX3Byb3BzJGxvYWRpbmdUZXh0LFxuICAgICAgX3Byb3BzJG11bHRpcGxlID0gcHJvcHMubXVsdGlwbGUsXG4gICAgICBtdWx0aXBsZSA9IF9wcm9wcyRtdWx0aXBsZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkbXVsdGlwbGUsXG4gICAgICBfcHJvcHMkbm9PcHRpb25zVGV4dCA9IHByb3BzLm5vT3B0aW9uc1RleHQsXG4gICAgICBub09wdGlvbnNUZXh0ID0gX3Byb3BzJG5vT3B0aW9uc1RleHQgPT09IHZvaWQgMCA/ICdObyBvcHRpb25zJyA6IF9wcm9wcyRub09wdGlvbnNUZXh0LFxuICAgICAgb25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZSxcbiAgICAgIG9uQ2xvc2UgPSBwcm9wcy5vbkNsb3NlLFxuICAgICAgb25IaWdobGlnaHRDaGFuZ2UgPSBwcm9wcy5vbkhpZ2hsaWdodENoYW5nZSxcbiAgICAgIG9uSW5wdXRDaGFuZ2UgPSBwcm9wcy5vbklucHV0Q2hhbmdlLFxuICAgICAgb25PcGVuID0gcHJvcHMub25PcGVuLFxuICAgICAgb3BlbiA9IHByb3BzLm9wZW4sXG4gICAgICBfcHJvcHMkb3Blbk9uRm9jdXMgPSBwcm9wcy5vcGVuT25Gb2N1cyxcbiAgICAgIG9wZW5PbkZvY3VzID0gX3Byb3BzJG9wZW5PbkZvY3VzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRvcGVuT25Gb2N1cyxcbiAgICAgIF9wcm9wcyRvcGVuVGV4dCA9IHByb3BzLm9wZW5UZXh0LFxuICAgICAgb3BlblRleHQgPSBfcHJvcHMkb3BlblRleHQgPT09IHZvaWQgMCA/ICdPcGVuJyA6IF9wcm9wcyRvcGVuVGV4dCxcbiAgICAgIG9wdGlvbnMgPSBwcm9wcy5vcHRpb25zLFxuICAgICAgX3Byb3BzJFBhcGVyQ29tcG9uZW50ID0gcHJvcHMuUGFwZXJDb21wb25lbnQsXG4gICAgICBQYXBlckNvbXBvbmVudCA9IF9wcm9wcyRQYXBlckNvbXBvbmVudCA9PT0gdm9pZCAwID8gUGFwZXIgOiBfcHJvcHMkUGFwZXJDb21wb25lbnQsXG4gICAgICBfcHJvcHMkUG9wcGVyQ29tcG9uZW4gPSBwcm9wcy5Qb3BwZXJDb21wb25lbnQsXG4gICAgICBQb3BwZXJDb21wb25lbnRQcm9wID0gX3Byb3BzJFBvcHBlckNvbXBvbmVuID09PSB2b2lkIDAgPyBQb3BwZXIgOiBfcHJvcHMkUG9wcGVyQ29tcG9uZW4sXG4gICAgICBfcHJvcHMkcG9wdXBJY29uID0gcHJvcHMucG9wdXBJY29uLFxuICAgICAgcG9wdXBJY29uID0gX3Byb3BzJHBvcHVwSWNvbiA9PT0gdm9pZCAwID8gX3JlZjIgOiBfcHJvcHMkcG9wdXBJY29uLFxuICAgICAgcmVuZGVyR3JvdXBQcm9wID0gcHJvcHMucmVuZGVyR3JvdXAsXG4gICAgICByZW5kZXJJbnB1dCA9IHByb3BzLnJlbmRlcklucHV0LFxuICAgICAgcmVuZGVyT3B0aW9uUHJvcCA9IHByb3BzLnJlbmRlck9wdGlvbixcbiAgICAgIHJlbmRlclRhZ3MgPSBwcm9wcy5yZW5kZXJUYWdzLFxuICAgICAgX3Byb3BzJHNlbGVjdE9uRm9jdXMgPSBwcm9wcy5zZWxlY3RPbkZvY3VzLFxuICAgICAgc2VsZWN0T25Gb2N1cyA9IF9wcm9wcyRzZWxlY3RPbkZvY3VzID09PSB2b2lkIDAgPyAhcHJvcHMuZnJlZVNvbG8gOiBfcHJvcHMkc2VsZWN0T25Gb2N1cyxcbiAgICAgIF9wcm9wcyRzaXplID0gcHJvcHMuc2l6ZSxcbiAgICAgIHNpemUgPSBfcHJvcHMkc2l6ZSA9PT0gdm9pZCAwID8gJ21lZGl1bScgOiBfcHJvcHMkc2l6ZSxcbiAgICAgIHZhbHVlUHJvcCA9IHByb3BzLnZhbHVlLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImF1dG9Db21wbGV0ZVwiLCBcImF1dG9IaWdobGlnaHRcIiwgXCJhdXRvU2VsZWN0XCIsIFwiYmx1ck9uU2VsZWN0XCIsIFwiQ2hpcFByb3BzXCIsIFwiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcImNsZWFyT25CbHVyXCIsIFwiY2xlYXJPbkVzY2FwZVwiLCBcImNsZWFyVGV4dFwiLCBcImNsb3NlSWNvblwiLCBcImNsb3NlVGV4dFwiLCBcImRlYnVnXCIsIFwiZGVmYXVsdFZhbHVlXCIsIFwiZGlzYWJsZUNsZWFyYWJsZVwiLCBcImRpc2FibGVDbG9zZU9uU2VsZWN0XCIsIFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZEl0ZW1zRm9jdXNhYmxlXCIsIFwiZGlzYWJsZUxpc3RXcmFwXCIsIFwiZGlzYWJsZVBvcnRhbFwiLCBcImZpbHRlck9wdGlvbnNcIiwgXCJmaWx0ZXJTZWxlY3RlZE9wdGlvbnNcIiwgXCJmb3JjZVBvcHVwSWNvblwiLCBcImZyZWVTb2xvXCIsIFwiZnVsbFdpZHRoXCIsIFwiZ2V0TGltaXRUYWdzVGV4dFwiLCBcImdldE9wdGlvbkRpc2FibGVkXCIsIFwiZ2V0T3B0aW9uTGFiZWxcIiwgXCJnZXRPcHRpb25TZWxlY3RlZFwiLCBcImdyb3VwQnlcIiwgXCJoYW5kbGVIb21lRW5kS2V5c1wiLCBcImlkXCIsIFwiaW5jbHVkZUlucHV0SW5MaXN0XCIsIFwiaW5wdXRWYWx1ZVwiLCBcImxpbWl0VGFnc1wiLCBcIkxpc3Rib3hDb21wb25lbnRcIiwgXCJMaXN0Ym94UHJvcHNcIiwgXCJsb2FkaW5nXCIsIFwibG9hZGluZ1RleHRcIiwgXCJtdWx0aXBsZVwiLCBcIm5vT3B0aW9uc1RleHRcIiwgXCJvbkNoYW5nZVwiLCBcIm9uQ2xvc2VcIiwgXCJvbkhpZ2hsaWdodENoYW5nZVwiLCBcIm9uSW5wdXRDaGFuZ2VcIiwgXCJvbk9wZW5cIiwgXCJvcGVuXCIsIFwib3Blbk9uRm9jdXNcIiwgXCJvcGVuVGV4dFwiLCBcIm9wdGlvbnNcIiwgXCJQYXBlckNvbXBvbmVudFwiLCBcIlBvcHBlckNvbXBvbmVudFwiLCBcInBvcHVwSWNvblwiLCBcInJlbmRlckdyb3VwXCIsIFwicmVuZGVySW5wdXRcIiwgXCJyZW5kZXJPcHRpb25cIiwgXCJyZW5kZXJUYWdzXCIsIFwic2VsZWN0T25Gb2N1c1wiLCBcInNpemVcIiwgXCJ2YWx1ZVwiXSk7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuXG4gIHZhciBQb3BwZXJDb21wb25lbnQgPSBkaXNhYmxlUG9ydGFsID8gRGlzYWJsZVBvcnRhbCA6IFBvcHBlckNvbXBvbmVudFByb3A7XG5cbiAgdmFyIF91c2VBdXRvY29tcGxldGUgPSB1c2VBdXRvY29tcGxldGUoX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgY29tcG9uZW50TmFtZTogJ0F1dG9jb21wbGV0ZSdcbiAgfSkpLFxuICAgICAgZ2V0Um9vdFByb3BzID0gX3VzZUF1dG9jb21wbGV0ZS5nZXRSb290UHJvcHMsXG4gICAgICBnZXRJbnB1dFByb3BzID0gX3VzZUF1dG9jb21wbGV0ZS5nZXRJbnB1dFByb3BzLFxuICAgICAgZ2V0SW5wdXRMYWJlbFByb3BzID0gX3VzZUF1dG9jb21wbGV0ZS5nZXRJbnB1dExhYmVsUHJvcHMsXG4gICAgICBnZXRQb3B1cEluZGljYXRvclByb3BzID0gX3VzZUF1dG9jb21wbGV0ZS5nZXRQb3B1cEluZGljYXRvclByb3BzLFxuICAgICAgZ2V0Q2xlYXJQcm9wcyA9IF91c2VBdXRvY29tcGxldGUuZ2V0Q2xlYXJQcm9wcyxcbiAgICAgIGdldFRhZ1Byb3BzID0gX3VzZUF1dG9jb21wbGV0ZS5nZXRUYWdQcm9wcyxcbiAgICAgIGdldExpc3Rib3hQcm9wcyA9IF91c2VBdXRvY29tcGxldGUuZ2V0TGlzdGJveFByb3BzLFxuICAgICAgZ2V0T3B0aW9uUHJvcHMgPSBfdXNlQXV0b2NvbXBsZXRlLmdldE9wdGlvblByb3BzLFxuICAgICAgdmFsdWUgPSBfdXNlQXV0b2NvbXBsZXRlLnZhbHVlLFxuICAgICAgZGlydHkgPSBfdXNlQXV0b2NvbXBsZXRlLmRpcnR5LFxuICAgICAgaWQgPSBfdXNlQXV0b2NvbXBsZXRlLmlkLFxuICAgICAgcG9wdXBPcGVuID0gX3VzZUF1dG9jb21wbGV0ZS5wb3B1cE9wZW4sXG4gICAgICBmb2N1c2VkID0gX3VzZUF1dG9jb21wbGV0ZS5mb2N1c2VkLFxuICAgICAgZm9jdXNlZFRhZyA9IF91c2VBdXRvY29tcGxldGUuZm9jdXNlZFRhZyxcbiAgICAgIGFuY2hvckVsID0gX3VzZUF1dG9jb21wbGV0ZS5hbmNob3JFbCxcbiAgICAgIHNldEFuY2hvckVsID0gX3VzZUF1dG9jb21wbGV0ZS5zZXRBbmNob3JFbCxcbiAgICAgIGlucHV0VmFsdWUgPSBfdXNlQXV0b2NvbXBsZXRlLmlucHV0VmFsdWUsXG4gICAgICBncm91cGVkT3B0aW9ucyA9IF91c2VBdXRvY29tcGxldGUuZ3JvdXBlZE9wdGlvbnM7XG5cbiAgdmFyIHN0YXJ0QWRvcm5tZW50O1xuXG4gIGlmIChtdWx0aXBsZSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGdldEN1c3RvbWl6ZWRUYWdQcm9wcyA9IGZ1bmN0aW9uIGdldEN1c3RvbWl6ZWRUYWdQcm9wcyhwYXJhbXMpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnRhZywgc2l6ZSA9PT0gJ3NtYWxsJyAmJiBjbGFzc2VzLnRhZ1NpemVTbWFsbCksXG4gICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZFxuICAgICAgfSwgZ2V0VGFnUHJvcHMocGFyYW1zKSk7XG4gICAgfTtcblxuICAgIGlmIChyZW5kZXJUYWdzKSB7XG4gICAgICBzdGFydEFkb3JubWVudCA9IHJlbmRlclRhZ3ModmFsdWUsIGdldEN1c3RvbWl6ZWRUYWdQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0QWRvcm5tZW50ID0gdmFsdWUubWFwKGZ1bmN0aW9uIChvcHRpb24sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDaGlwLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgbGFiZWw6IGdldE9wdGlvbkxhYmVsKG9wdGlvbiksXG4gICAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgICB9LCBnZXRDdXN0b21pemVkVGFnUHJvcHMoe1xuICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9KSwgQ2hpcFByb3BzKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAobGltaXRUYWdzID4gLTEgJiYgQXJyYXkuaXNBcnJheShzdGFydEFkb3JubWVudCkpIHtcbiAgICB2YXIgbW9yZSA9IHN0YXJ0QWRvcm5tZW50Lmxlbmd0aCAtIGxpbWl0VGFncztcblxuICAgIGlmICghZm9jdXNlZCAmJiBtb3JlID4gMCkge1xuICAgICAgc3RhcnRBZG9ybm1lbnQgPSBzdGFydEFkb3JubWVudC5zcGxpY2UoMCwgbGltaXRUYWdzKTtcbiAgICAgIHN0YXJ0QWRvcm5tZW50LnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3Nlcy50YWcsXG4gICAgICAgIGtleTogc3RhcnRBZG9ybm1lbnQubGVuZ3RoXG4gICAgICB9LCBnZXRMaW1pdFRhZ3NUZXh0KG1vcmUpKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRSZW5kZXJHcm91cCA9IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJHcm91cChwYXJhbXMpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7XG4gICAgICBrZXk6IHBhcmFtcy5rZXlcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaXN0U3ViaGVhZGVyLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzZXMuZ3JvdXBMYWJlbCxcbiAgICAgIGNvbXBvbmVudDogXCJkaXZcIlxuICAgIH0sIHBhcmFtcy5ncm91cCksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzLmdyb3VwVWxcbiAgICB9LCBwYXJhbXMuY2hpbGRyZW4pKTtcbiAgfTtcblxuICB2YXIgcmVuZGVyR3JvdXAgPSByZW5kZXJHcm91cFByb3AgfHwgZGVmYXVsdFJlbmRlckdyb3VwO1xuICB2YXIgcmVuZGVyT3B0aW9uID0gcmVuZGVyT3B0aW9uUHJvcCB8fCBnZXRPcHRpb25MYWJlbDtcblxuICB2YXIgcmVuZGVyTGlzdE9wdGlvbiA9IGZ1bmN0aW9uIHJlbmRlckxpc3RPcHRpb24ob3B0aW9uLCBpbmRleCkge1xuICAgIHZhciBvcHRpb25Qcm9wcyA9IGdldE9wdGlvblByb3BzKHtcbiAgICAgIG9wdGlvbjogb3B0aW9uLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGlcIiwgX2V4dGVuZHMoe30sIG9wdGlvblByb3BzLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzZXMub3B0aW9uXG4gICAgfSksIHJlbmRlck9wdGlvbihvcHRpb24sIHtcbiAgICAgIHNlbGVjdGVkOiBvcHRpb25Qcm9wc1snYXJpYS1zZWxlY3RlZCddLFxuICAgICAgaW5wdXRWYWx1ZTogaW5wdXRWYWx1ZVxuICAgIH0pKTtcbiAgfTtcblxuICB2YXIgaGFzQ2xlYXJJY29uID0gIWRpc2FibGVDbGVhcmFibGUgJiYgIWRpc2FibGVkO1xuICB2YXIgaGFzUG9wdXBJY29uID0gKCFmcmVlU29sbyB8fCBmb3JjZVBvcHVwSWNvbiA9PT0gdHJ1ZSkgJiYgZm9yY2VQb3B1cEljb24gIT09IGZhbHNlO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZixcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUsIGZvY3VzZWQgJiYgY2xhc3Nlcy5mb2N1c2VkLCBmdWxsV2lkdGggJiYgY2xhc3Nlcy5mdWxsV2lkdGgsIGhhc0NsZWFySWNvbiAmJiBjbGFzc2VzLmhhc0NsZWFySWNvbiwgaGFzUG9wdXBJY29uICYmIGNsYXNzZXMuaGFzUG9wdXBJY29uKVxuICB9LCBnZXRSb290UHJvcHMob3RoZXIpKSwgcmVuZGVySW5wdXQoe1xuICAgIGlkOiBpZCxcbiAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgZnVsbFdpZHRoOiB0cnVlLFxuICAgIHNpemU6IHNpemUgPT09ICdzbWFsbCcgPyAnc21hbGwnIDogdW5kZWZpbmVkLFxuICAgIElucHV0TGFiZWxQcm9wczogZ2V0SW5wdXRMYWJlbFByb3BzKCksXG4gICAgSW5wdXRQcm9wczoge1xuICAgICAgcmVmOiBzZXRBbmNob3JFbCxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5pbnB1dFJvb3QsXG4gICAgICBzdGFydEFkb3JubWVudDogc3RhcnRBZG9ybm1lbnQsXG4gICAgICBlbmRBZG9ybm1lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzLmVuZEFkb3JubWVudFxuICAgICAgfSwgaGFzQ2xlYXJJY29uID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwgX2V4dGVuZHMoe30sIGdldENsZWFyUHJvcHMoKSwge1xuICAgICAgICBcImFyaWEtbGFiZWxcIjogY2xlYXJUZXh0LFxuICAgICAgICB0aXRsZTogY2xlYXJUZXh0LFxuICAgICAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5jbGVhckluZGljYXRvciwgZGlydHkgJiYgY2xhc3Nlcy5jbGVhckluZGljYXRvckRpcnR5KVxuICAgICAgfSksIGNsb3NlSWNvbikgOiBudWxsLCBoYXNQb3B1cEljb24gPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJY29uQnV0dG9uLCBfZXh0ZW5kcyh7fSwgZ2V0UG9wdXBJbmRpY2F0b3JQcm9wcygpLCB7XG4gICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBvcHVwT3BlbiA/IGNsb3NlVGV4dCA6IG9wZW5UZXh0LFxuICAgICAgICB0aXRsZTogcG9wdXBPcGVuID8gY2xvc2VUZXh0IDogb3BlblRleHQsXG4gICAgICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnBvcHVwSW5kaWNhdG9yLCBwb3B1cE9wZW4gJiYgY2xhc3Nlcy5wb3B1cEluZGljYXRvck9wZW4pXG4gICAgICB9KSwgcG9wdXBJY29uKSA6IG51bGwpXG4gICAgfSxcbiAgICBpbnB1dFByb3BzOiBfZXh0ZW5kcyh7XG4gICAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5pbnB1dCwgZm9jdXNlZFRhZyA9PT0gLTEgJiYgY2xhc3Nlcy5pbnB1dEZvY3VzZWQpLFxuICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkXG4gICAgfSwgZ2V0SW5wdXRQcm9wcygpKVxuICB9KSksIHBvcHVwT3BlbiAmJiBhbmNob3JFbCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvcHBlckNvbXBvbmVudCwge1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnBvcHBlciwgZGlzYWJsZVBvcnRhbCAmJiBjbGFzc2VzLnBvcHBlckRpc2FibGVQb3J0YWwpLFxuICAgIHN0eWxlOiB7XG4gICAgICB3aWR0aDogYW5jaG9yRWwgPyBhbmNob3JFbC5jbGllbnRXaWR0aCA6IG51bGxcbiAgICB9LFxuICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsXG4gICAgYW5jaG9yRWw6IGFuY2hvckVsLFxuICAgIG9wZW46IHRydWVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUGFwZXJDb21wb25lbnQsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMucGFwZXJcbiAgfSwgbG9hZGluZyAmJiBncm91cGVkT3B0aW9ucy5sZW5ndGggPT09IDAgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzLmxvYWRpbmdcbiAgfSwgbG9hZGluZ1RleHQpIDogbnVsbCwgZ3JvdXBlZE9wdGlvbnMubGVuZ3RoID09PSAwICYmICFmcmVlU29sbyAmJiAhbG9hZGluZyA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMubm9PcHRpb25zXG4gIH0sIG5vT3B0aW9uc1RleHQpIDogbnVsbCwgZ3JvdXBlZE9wdGlvbnMubGVuZ3RoID4gMCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExpc3Rib3hDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMubGlzdGJveFxuICB9LCBnZXRMaXN0Ym94UHJvcHMoKSwgTGlzdGJveFByb3BzKSwgZ3JvdXBlZE9wdGlvbnMubWFwKGZ1bmN0aW9uIChvcHRpb24sIGluZGV4KSB7XG4gICAgaWYgKGdyb3VwQnkpIHtcbiAgICAgIHJldHVybiByZW5kZXJHcm91cCh7XG4gICAgICAgIGtleTogb3B0aW9uLmtleSxcbiAgICAgICAgZ3JvdXA6IG9wdGlvbi5ncm91cCxcbiAgICAgICAgY2hpbGRyZW46IG9wdGlvbi5vcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uMiwgaW5kZXgyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlckxpc3RPcHRpb24ob3B0aW9uMiwgb3B0aW9uLmluZGV4ICsgaW5kZXgyKTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJMaXN0T3B0aW9uKG9wdGlvbiwgaW5kZXgpO1xuICB9KSkgOiBudWxsKSkgOiBudWxsKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gQXV0b2NvbXBsZXRlLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXHJcbiAgICogSWYgYHRydWVgLCB0aGUgcG9ydGlvbiBvZiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbiB0aGF0IGhhcyBub3QgYmVlbiB0eXBlZCBieSB0aGUgdXNlcixcclxuICAgKiBrbm93biBhcyB0aGUgY29tcGxldGlvbiBzdHJpbmcsIGFwcGVhcnMgaW5saW5lIGFmdGVyIHRoZSBpbnB1dCBjdXJzb3IgaW4gdGhlIHRleHRib3guXHJcbiAgICogVGhlIGlubGluZSBjb21wbGV0aW9uIHN0cmluZyBpcyB2aXN1YWxseSBoaWdobGlnaHRlZCBhbmQgaGFzIGEgc2VsZWN0ZWQgc3RhdGUuXHJcbiAgICovXG4gIGF1dG9Db21wbGV0ZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXHJcbiAgICogSWYgYHRydWVgLCB0aGUgZmlyc3Qgb3B0aW9uIGlzIGF1dG9tYXRpY2FsbHkgaGlnaGxpZ2h0ZWQuXHJcbiAgICovXG4gIGF1dG9IaWdobGlnaHQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxyXG4gICAqIElmIGB0cnVlYCwgdGhlIHNlbGVjdGVkIG9wdGlvbiBiZWNvbWVzIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXRcclxuICAgKiB3aGVuIHRoZSBBdXRvY29tcGxldGUgbG9zZXMgZm9jdXMgdW5sZXNzIHRoZSB1c2VyIGNob29zZXNcclxuICAgKiBhIGRpZmZlcmVudCBvcHRpb24gb3IgY2hhbmdlcyB0aGUgY2hhcmFjdGVyIHN0cmluZyBpbiB0aGUgaW5wdXQuXHJcbiAgICovXG4gIGF1dG9TZWxlY3Q6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxyXG4gICAqIENvbnRyb2wgaWYgdGhlIGlucHV0IHNob3VsZCBiZSBibHVycmVkIHdoZW4gYW4gb3B0aW9uIGlzIHNlbGVjdGVkOlxyXG4gICAqXHJcbiAgICogLSBgZmFsc2VgIHRoZSBpbnB1dCBpcyBub3QgYmx1cnJlZC5cclxuICAgKiAtIGB0cnVlYCB0aGUgaW5wdXQgaXMgYWx3YXlzIGJsdXJyZWQuXHJcbiAgICogLSBgdG91Y2hgIHRoZSBpbnB1dCBpcyBibHVycmVkIGFmdGVyIGEgdG91Y2ggZXZlbnQuXHJcbiAgICogLSBgbW91c2VgIHRoZSBpbnB1dCBpcyBibHVycmVkIGFmdGVyIGEgbW91c2UgZXZlbnQuXHJcbiAgICovXG4gIGJsdXJPblNlbGVjdDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9uZU9mKFsnbW91c2UnLCAndG91Y2gnXSksIFByb3BUeXBlcy5ib29sXSksXG5cbiAgLyoqXHJcbiAgICogUHJvcHMgYXBwbGllZCB0byB0aGUgW2BDaGlwYF0oL2FwaS9jaGlwLykgZWxlbWVudC5cclxuICAgKi9cbiAgQ2hpcFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxyXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cclxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXHJcbiAgICogSWYgYHRydWVgLCB0aGUgaW5wdXQncyB0ZXh0IHdpbGwgYmUgY2xlYXJlZCBvbiBibHVyIGlmIG5vIHZhbHVlIGlzIHNlbGVjdGVkLlxyXG4gICAqXHJcbiAgICogU2V0IHRvIGB0cnVlYCBpZiB5b3Ugd2FudCB0byBoZWxwIHRoZSB1c2VyIGVudGVyIGEgbmV3IHZhbHVlLlxyXG4gICAqIFNldCB0byBgZmFsc2VgIGlmIHlvdSB3YW50IHRvIGhlbHAgdGhlIHVzZXIgcmVzdW1lIGhpcyBzZWFyY2guXHJcbiAgICovXG4gIGNsZWFyT25CbHVyOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcclxuICAgKiBJZiBgdHJ1ZWAsIGNsZWFyIGFsbCB2YWx1ZXMgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGVzY2FwZSBhbmQgdGhlIHBvcHVwIGlzIGNsb3NlZC5cclxuICAgKi9cbiAgY2xlYXJPbkVzY2FwZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXHJcbiAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgdGV4dCBmb3IgdGhlICpjbGVhciogaWNvbiBidXR0b24uXHJcbiAgICpcclxuICAgKiBGb3IgbG9jYWxpemF0aW9uIHB1cnBvc2VzLCB5b3UgY2FuIHVzZSB0aGUgcHJvdmlkZWQgW3RyYW5zbGF0aW9uc10oL2d1aWRlcy9sb2NhbGl6YXRpb24vKS5cclxuICAgKi9cbiAgY2xlYXJUZXh0OiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxyXG4gICAqIFRoZSBpY29uIHRvIGRpc3BsYXkgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgY2xvc2UgaWNvbi5cclxuICAgKi9cbiAgY2xvc2VJY29uOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcclxuICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCB0ZXh0IGZvciB0aGUgKmNsb3NlIHBvcHVwKiBpY29uIGJ1dHRvbi5cclxuICAgKlxyXG4gICAqIEZvciBsb2NhbGl6YXRpb24gcHVycG9zZXMsIHlvdSBjYW4gdXNlIHRoZSBwcm92aWRlZCBbdHJhbnNsYXRpb25zXSgvZ3VpZGVzL2xvY2FsaXphdGlvbi8pLlxyXG4gICAqL1xuICBjbG9zZVRleHQ6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXHJcbiAgICogSWYgYHRydWVgLCB0aGUgcG9wdXAgd2lsbCBpZ25vcmUgdGhlIGJsdXIgZXZlbnQgaWYgdGhlIGlucHV0IGlzIGZpbGxlZC5cclxuICAgKiBZb3UgY2FuIGluc3BlY3QgdGhlIHBvcHVwIG1hcmt1cCB3aXRoIHlvdXIgYnJvd3NlciB0b29scy5cclxuICAgKiBDb25zaWRlciB0aGlzIG9wdGlvbiB3aGVuIHlvdSBuZWVkIHRvIGN1c3RvbWl6ZSB0aGUgY29tcG9uZW50LlxyXG4gICAqL1xuICBkZWJ1ZzogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXHJcbiAgICogVGhlIGRlZmF1bHQgaW5wdXQgdmFsdWUuIFVzZSB3aGVuIHRoZSBjb21wb25lbnQgaXMgbm90IGNvbnRyb2xsZWQuXHJcbiAgICovXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLmFueSxcblxuICAvKipcclxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBpbnB1dCBjYW4ndCBiZSBjbGVhcmVkLlxyXG4gICAqL1xuICBkaXNhYmxlQ2xlYXJhYmxlOiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAuYm9vbCxcblxuICAvKipcclxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBwb3B1cCB3b24ndCBjbG9zZSB3aGVuIGEgdmFsdWUgaXMgc2VsZWN0ZWQuXHJcbiAgICovXG4gIGRpc2FibGVDbG9zZU9uU2VsZWN0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcclxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBpbnB1dCB3aWxsIGJlIGRpc2FibGVkLlxyXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXHJcbiAgICogSWYgYHRydWVgLCB3aWxsIGFsbG93IGZvY3VzIG9uIGRpc2FibGVkIGl0ZW1zLlxyXG4gICAqL1xuICBkaXNhYmxlZEl0ZW1zRm9jdXNhYmxlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcclxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBsaXN0IGJveCBpbiB0aGUgcG9wdXAgd2lsbCBub3Qgd3JhcCBmb2N1cy5cclxuICAgKi9cbiAgZGlzYWJsZUxpc3RXcmFwOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcclxuICAgKiBEaXNhYmxlIHRoZSBwb3J0YWwgYmVoYXZpb3IuXHJcbiAgICogVGhlIGNoaWxkcmVuIHN0YXkgd2l0aGluIGl0J3MgcGFyZW50IERPTSBoaWVyYXJjaHkuXHJcbiAgICovXG4gIGRpc2FibGVQb3J0YWw6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxyXG4gICAqIEEgZmlsdGVyIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB0aGUgb3B0aW9ucyB0aGF0IGFyZSBlbGlnaWJsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VFtdfSBvcHRpb25zIFRoZSBvcHRpb25zIHRvIHJlbmRlci5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgVGhlIHN0YXRlIG9mIHRoZSBjb21wb25lbnQuXHJcbiAgICogQHJldHVybnMge1RbXX1cclxuICAgKi9cbiAgZmlsdGVyT3B0aW9uczogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXHJcbiAgICogSWYgYHRydWVgLCBoaWRlIHRoZSBzZWxlY3RlZCBvcHRpb25zIGZyb20gdGhlIGxpc3QgYm94LlxyXG4gICAqL1xuICBmaWx0ZXJTZWxlY3RlZE9wdGlvbnM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxyXG4gICAqIEZvcmNlIHRoZSB2aXNpYmlsaXR5IGRpc3BsYXkgb2YgdGhlIHBvcHVwIGljb24uXHJcbiAgICovXG4gIGZvcmNlUG9wdXBJY29uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub25lT2YoWydhdXRvJ10pLCBQcm9wVHlwZXMuYm9vbF0pLFxuXG4gIC8qKlxyXG4gICAqIElmIGB0cnVlYCwgdGhlIEF1dG9jb21wbGV0ZSBpcyBmcmVlIHNvbG8sIG1lYW5pbmcgdGhhdCB0aGUgdXNlciBpbnB1dCBpcyBub3QgYm91bmQgdG8gcHJvdmlkZWQgb3B0aW9ucy5cclxuICAgKi9cbiAgZnJlZVNvbG86IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5ib29sLFxuXG4gIC8qKlxyXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IHdpbGwgdGFrZSB1cCB0aGUgZnVsbCB3aWR0aCBvZiBpdHMgY29udGFpbmVyLlxyXG4gICAqL1xuICBmdWxsV2lkdGg6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxyXG4gICAqIFRoZSBsYWJlbCB0byBkaXNwbGF5IHdoZW4gdGhlIHRhZ3MgYXJlIHRydW5jYXRlZCAoYGxpbWl0VGFnc2ApLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1vcmUgVGhlIG51bWJlciBvZiB0cnVuY2F0ZWQgdGFncy5cclxuICAgKiBAcmV0dXJucyB7UmVhY3ROb2RlfVxyXG4gICAqL1xuICBnZXRMaW1pdFRhZ3NUZXh0OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcclxuICAgKiBVc2VkIHRvIGRldGVybWluZSB0aGUgZGlzYWJsZWQgc3RhdGUgZm9yIGEgZ2l2ZW4gb3B0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUfSBvcHRpb24gVGhlIG9wdGlvbiB0byB0ZXN0LlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xuICBnZXRPcHRpb25EaXNhYmxlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXHJcbiAgICogVXNlZCB0byBkZXRlcm1pbmUgdGhlIHN0cmluZyB2YWx1ZSBmb3IgYSBnaXZlbiBvcHRpb24uXHJcbiAgICogSXQncyB1c2VkIHRvIGZpbGwgdGhlIGlucHV0IChhbmQgdGhlIGxpc3QgYm94IG9wdGlvbnMgaWYgYHJlbmRlck9wdGlvbmAgaXMgbm90IHByb3ZpZGVkKS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VH0gb3B0aW9uXHJcbiAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgKi9cbiAgZ2V0T3B0aW9uTGFiZWw6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxyXG4gICAqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIGFuIG9wdGlvbiBpcyBzZWxlY3RlZCwgY29uc2lkZXJpbmcgdGhlIGN1cnJlbnQgdmFsdWUuXHJcbiAgICogVXNlcyBzdHJpY3QgZXF1YWxpdHkgYnkgZGVmYXVsdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VH0gb3B0aW9uIFRoZSBvcHRpb24gdG8gdGVzdC5cclxuICAgKiBAcGFyYW0ge1R9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0IGFnYWluc3QuXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXG4gIGdldE9wdGlvblNlbGVjdGVkOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcclxuICAgKiBJZiBwcm92aWRlZCwgdGhlIG9wdGlvbnMgd2lsbCBiZSBncm91cGVkIHVuZGVyIHRoZSByZXR1cm5lZCBzdHJpbmcuXHJcbiAgICogVGhlIGdyb3VwQnkgdmFsdWUgaXMgYWxzbyB1c2VkIGFzIHRoZSB0ZXh0IGZvciBncm91cCBoZWFkaW5ncyB3aGVuIGByZW5kZXJHcm91cGAgaXMgbm90IHByb3ZpZGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUfSBvcHRpb25zIFRoZSBvcHRpb25zIHRvIGdyb3VwLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICovXG4gIGdyb3VwQnk6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxyXG4gICAqIElmIGB0cnVlYCwgdGhlIGNvbXBvbmVudCBoYW5kbGVzIHRoZSBcIkhvbWVcIiBhbmQgXCJFbmRcIiBrZXlzIHdoZW4gdGhlIHBvcHVwIGlzIG9wZW4uXHJcbiAgICogSXQgc2hvdWxkIG1vdmUgZm9jdXMgdG8gdGhlIGZpcnN0IG9wdGlvbiBhbmQgbGFzdCBvcHRpb24sIHJlc3BlY3RpdmVseS5cclxuICAgKi9cbiAgaGFuZGxlSG9tZUVuZEtleXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxyXG4gICAqIFRoaXMgcHJvcCBpcyB1c2VkIHRvIGhlbHAgaW1wbGVtZW50IHRoZSBhY2Nlc3NpYmlsaXR5IGxvZ2ljLlxyXG4gICAqIElmIHlvdSBkb24ndCBwcm92aWRlIHRoaXMgcHJvcC4gSXQgZmFsbHMgYmFjayB0byBhIHJhbmRvbWx5IGdlbmVyYXRlZCBpZC5cclxuICAgKi9cbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXHJcbiAgICogSWYgYHRydWVgLCB0aGUgaGlnaGxpZ2h0IGNhbiBtb3ZlIHRvIHRoZSBpbnB1dC5cclxuICAgKi9cbiAgaW5jbHVkZUlucHV0SW5MaXN0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcclxuICAgKiBUaGUgaW5wdXQgdmFsdWUuXHJcbiAgICovXG4gIGlucHV0VmFsdWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXHJcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHRhZ3MgdGhhdCB3aWxsIGJlIHZpc2libGUgd2hlbiBub3QgZm9jdXNlZC5cclxuICAgKiBTZXQgYC0xYCB0byBkaXNhYmxlIHRoZSBsaW1pdC5cclxuICAgKi9cbiAgbGltaXRUYWdzOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxyXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCB0byByZW5kZXIgdGhlIGxpc3Rib3guXHJcbiAgICovXG4gIExpc3Rib3hDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50VHlwZSxcblxuICAvKipcclxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBMaXN0Ym94IGVsZW1lbnQuXHJcbiAgICovXG4gIExpc3Rib3hQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcclxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBjb21wb25lbnQgaXMgaW4gYSBsb2FkaW5nIHN0YXRlLlxyXG4gICAqL1xuICBsb2FkaW5nOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcclxuICAgKiBUZXh0IHRvIGRpc3BsYXkgd2hlbiBpbiBhIGxvYWRpbmcgc3RhdGUuXHJcbiAgICpcclxuICAgKiBGb3IgbG9jYWxpemF0aW9uIHB1cnBvc2VzLCB5b3UgY2FuIHVzZSB0aGUgcHJvdmlkZWQgW3RyYW5zbGF0aW9uc10oL2d1aWRlcy9sb2NhbGl6YXRpb24vKS5cclxuICAgKi9cbiAgbG9hZGluZ1RleHQ6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxyXG4gICAqIElmIGB0cnVlYCwgYHZhbHVlYCBtdXN0IGJlIGFuIGFycmF5IGFuZCB0aGUgbWVudSB3aWxsIHN1cHBvcnQgbXVsdGlwbGUgc2VsZWN0aW9ucy5cclxuICAgKi9cbiAgbXVsdGlwbGU6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5ib29sLFxuXG4gIC8qKlxyXG4gICAqIFRleHQgdG8gZGlzcGxheSB3aGVuIHRoZXJlIGFyZSBubyBvcHRpb25zLlxyXG4gICAqXHJcbiAgICogRm9yIGxvY2FsaXphdGlvbiBwdXJwb3NlcywgeW91IGNhbiB1c2UgdGhlIHByb3ZpZGVkIFt0cmFuc2xhdGlvbnNdKC9ndWlkZXMvbG9jYWxpemF0aW9uLykuXHJcbiAgICovXG4gIG5vT3B0aW9uc1RleHQ6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXHJcbiAgICogQHBhcmFtIHtUfFRbXX0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gT25lIG9mIFwiY3JlYXRlLW9wdGlvblwiLCBcInNlbGVjdC1vcHRpb25cIiwgXCJyZW1vdmUtb3B0aW9uXCIsIFwiYmx1clwiIG9yIFwiY2xlYXJcIi5cclxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIHBvcHVwIHJlcXVlc3RzIHRvIGJlIGNsb3NlZC5cclxuICAgKiBVc2UgaW4gY29udHJvbGxlZCBtb2RlIChzZWUgb3BlbikuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiBDYW4gYmU6IGBcInRvZ2dsZUlucHV0XCJgLCBgXCJlc2NhcGVcImAsIGBcInNlbGVjdC1vcHRpb25cImAsIGBcImJsdXJcImAuXHJcbiAgICovXG4gIG9uQ2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGhpZ2hsaWdodCBvcHRpb24gY2hhbmdlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cclxuICAgKiBAcGFyYW0ge1R9IG9wdGlvbiBUaGUgaGlnaGxpZ2h0ZWQgb3B0aW9uLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gQ2FuIGJlOiBgXCJrZXlib2FyZFwiYCwgYFwiYXV0b1wiYCwgYFwibW91c2VcImAuXHJcbiAgICovXG4gIG9uSGlnaGxpZ2h0Q2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcclxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBpbnB1dCB2YWx1ZSBjaGFuZ2VzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSB0ZXh0IGlucHV0LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gQ2FuIGJlOiBgXCJpbnB1dFwiYCAodXNlciBpbnB1dCksIGBcInJlc2V0XCJgIChwcm9ncmFtbWF0aWMgY2hhbmdlKSwgYFwiY2xlYXJcImAuXHJcbiAgICovXG4gIG9uSW5wdXRDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIHBvcHVwIHJlcXVlc3RzIHRvIGJlIG9wZW5lZC5cclxuICAgKiBVc2UgaW4gY29udHJvbGxlZCBtb2RlIChzZWUgb3BlbikuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXHJcbiAgICovXG4gIG9uT3BlbjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXHJcbiAgICogQ29udHJvbCB0aGUgcG9wdXBgIG9wZW4gc3RhdGUuXHJcbiAgICovXG4gIG9wZW46IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxyXG4gICAqIElmIGB0cnVlYCwgdGhlIHBvcHVwIHdpbGwgb3BlbiBvbiBpbnB1dCBmb2N1cy5cclxuICAgKi9cbiAgb3Blbk9uRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxyXG4gICAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHRleHQgZm9yIHRoZSAqb3BlbiBwb3B1cCogaWNvbiBidXR0b24uXHJcbiAgICpcclxuICAgKiBGb3IgbG9jYWxpemF0aW9uIHB1cnBvc2VzLCB5b3UgY2FuIHVzZSB0aGUgcHJvdmlkZWQgW3RyYW5zbGF0aW9uc10oL2d1aWRlcy9sb2NhbGl6YXRpb24vKS5cclxuICAgKi9cbiAgb3BlblRleHQ6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXHJcbiAgICogQXJyYXkgb2Ygb3B0aW9ucy5cclxuICAgKi9cbiAgb3B0aW9uczogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG5cbiAgLyoqXHJcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIHRvIHJlbmRlciB0aGUgYm9keSBvZiB0aGUgcG9wdXAuXHJcbiAgICovXG4gIFBhcGVyQ29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG5cbiAgLyoqXHJcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3B1cC5cclxuICAgKi9cbiAgUG9wcGVyQ29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG5cbiAgLyoqXHJcbiAgICogVGhlIGljb24gdG8gZGlzcGxheSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBwb3B1cCBpY29uLlxyXG4gICAqL1xuICBwb3B1cEljb246IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxyXG4gICAqIFJlbmRlciB0aGUgZ3JvdXAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2FueX0gb3B0aW9uIFRoZSBncm91cCB0byByZW5kZXIuXHJcbiAgICogQHJldHVybnMge1JlYWN0Tm9kZX1cclxuICAgKi9cbiAgcmVuZGVyR3JvdXA6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxyXG4gICAqIFJlbmRlciB0aGUgaW5wdXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXHJcbiAgICogQHJldHVybnMge1JlYWN0Tm9kZX1cclxuICAgKi9cbiAgcmVuZGVySW5wdXQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgLyoqXHJcbiAgICogUmVuZGVyIHRoZSBvcHRpb24sIHVzZSBgZ2V0T3B0aW9uTGFiZWxgIGJ5IGRlZmF1bHQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1R9IG9wdGlvbiBUaGUgb3B0aW9uIHRvIHJlbmRlci5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgVGhlIHN0YXRlIG9mIHRoZSBjb21wb25lbnQuXHJcbiAgICogQHJldHVybnMge1JlYWN0Tm9kZX1cclxuICAgKi9cbiAgcmVuZGVyT3B0aW9uOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcclxuICAgKiBSZW5kZXIgdGhlIHNlbGVjdGVkIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUW119IHZhbHVlIFRoZSBgdmFsdWVgIHByb3ZpZGVkIHRvIHRoZSBjb21wb25lbnQuXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZ2V0VGFnUHJvcHMgQSB0YWcgcHJvcHMgZ2V0dGVyLlxyXG4gICAqIEByZXR1cm5zIHtSZWFjdE5vZGV9XHJcbiAgICovXG4gIHJlbmRlclRhZ3M6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxyXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0J3MgdGV4dCB3aWxsIGJlIHNlbGVjdGVkIG9uIGZvY3VzLlxyXG4gICAqIEl0IGhlbHBzIHRoZSB1c2VyIGNsZWFyIHRoZSBzZWxlY3RlZCB2YWx1ZS5cclxuICAgKi9cbiAgc2VsZWN0T25Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXHJcbiAgICogVGhlIHNpemUgb2YgdGhlIGF1dG9jb21wbGV0ZS5cclxuICAgKi9cbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnbWVkaXVtJywgJ3NtYWxsJ10pLFxuXG4gIC8qKlxyXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgYXV0b2NvbXBsZXRlLlxyXG4gICAqXHJcbiAgICogVGhlIHZhbHVlIG11c3QgaGF2ZSByZWZlcmVuY2UgZXF1YWxpdHkgd2l0aCB0aGUgb3B0aW9uIGluIG9yZGVyIHRvIGJlIHNlbGVjdGVkLlxyXG4gICAqIFlvdSBjYW4gY3VzdG9taXplIHRoZSBlcXVhbGl0eSBiZWhhdmlvciB3aXRoIHRoZSBgZ2V0T3B0aW9uU2VsZWN0ZWRgIHByb3AuXHJcbiAgICovXG4gIHZhbHVlOiBQcm9wVHlwZXMuYW55XG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUF1dG9jb21wbGV0ZSdcbn0pKEF1dG9jb21wbGV0ZSk7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybUNvbnRyb2xTdGF0ZShfcmVmKSB7XG4gIHZhciBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICBzdGF0ZXMgPSBfcmVmLnN0YXRlcyxcbiAgICAgIG11aUZvcm1Db250cm9sID0gX3JlZi5tdWlGb3JtQ29udHJvbDtcbiAgcmV0dXJuIHN0YXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc3RhdGUpIHtcbiAgICBhY2Nbc3RhdGVdID0gcHJvcHNbc3RhdGVdO1xuXG4gICAgaWYgKG11aUZvcm1Db250cm9sKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzW3N0YXRlXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYWNjW3N0YXRlXSA9IG11aUZvcm1Db250cm9sW3N0YXRlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuLyoqXG4gKiBAaWdub3JlIC0gaW50ZXJuYWwgY29tcG9uZW50LlxuICovXG5cbnZhciBGb3JtQ29udHJvbENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIEZvcm1Db250cm9sQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdGb3JtQ29udHJvbENvbnRleHQnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9ybUNvbnRyb2woKSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KEZvcm1Db250cm9sQ29udGV4dCk7XG59XG5leHBvcnQgZGVmYXVsdCBGb3JtQ29udHJvbENvbnRleHQ7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBkZWJvdW5jZSBmcm9tICcuLi91dGlscy9kZWJvdW5jZSc7XG5pbXBvcnQgdXNlRm9ya1JlZiBmcm9tICcuLi91dGlscy91c2VGb3JrUmVmJztcbmltcG9ydCBkZXByZWNhdGVkUHJvcFR5cGUgZnJvbSAnLi4vdXRpbHMvZGVwcmVjYXRlZFByb3BUeXBlJztcblxuZnVuY3Rpb24gZ2V0U3R5bGVWYWx1ZShjb21wdXRlZFN0eWxlLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVtwcm9wZXJ0eV0sIDEwKSB8fCAwO1xufVxuXG52YXIgdXNlRW5oYW5jZWRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbnZhciBzdHlsZXMgPSB7XG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBzaGFkb3cgdGV4dGFyZWEgZWxlbWVudC4gKi9cbiAgc2hhZG93OiB7XG4gICAgLy8gVmlzaWJpbGl0eSBuZWVkZWQgdG8gaGlkZSB0aGUgZXh0cmEgdGV4dCBhcmVhIG9uIGlQYWRzXG4gICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgLy8gUmVtb3ZlIGZyb20gdGhlIGNvbnRlbnQgZmxvd1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIC8vIElnbm9yZSB0aGUgc2Nyb2xsYmFyIHdpZHRoXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIGhlaWdodDogMCxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICAvLyBDcmVhdGUgYSBuZXcgbGF5ZXIsIGluY3JlYXNlIHRoZSBpc29sYXRpb24gb2YgdGhlIGNvbXB1dGVkIHZhbHVlc1xuICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVooMCknXG4gIH1cbn07XG52YXIgVGV4dGFyZWFBdXRvc2l6ZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFRleHRhcmVhQXV0b3NpemUocHJvcHMsIHJlZikge1xuICB2YXIgb25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZSxcbiAgICAgIHJvd3MgPSBwcm9wcy5yb3dzLFxuICAgICAgcm93c01heCA9IHByb3BzLnJvd3NNYXgsXG4gICAgICByb3dzTWluUHJvcCA9IHByb3BzLnJvd3NNaW4sXG4gICAgICBtYXhSb3dzUHJvcCA9IHByb3BzLm1heFJvd3MsXG4gICAgICBfcHJvcHMkbWluUm93cyA9IHByb3BzLm1pblJvd3MsXG4gICAgICBtaW5Sb3dzUHJvcCA9IF9wcm9wcyRtaW5Sb3dzID09PSB2b2lkIDAgPyAxIDogX3Byb3BzJG1pblJvd3MsXG4gICAgICBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgdmFsdWUgPSBwcm9wcy52YWx1ZSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJvbkNoYW5nZVwiLCBcInJvd3NcIiwgXCJyb3dzTWF4XCIsIFwicm93c01pblwiLCBcIm1heFJvd3NcIiwgXCJtaW5Sb3dzXCIsIFwic3R5bGVcIiwgXCJ2YWx1ZVwiXSk7XG5cbiAgdmFyIG1heFJvd3MgPSBtYXhSb3dzUHJvcCB8fCByb3dzTWF4O1xuICB2YXIgbWluUm93cyA9IHJvd3MgfHwgcm93c01pblByb3AgfHwgbWluUm93c1Byb3A7XG5cbiAgdmFyIF9SZWFjdCR1c2VSZWYgPSBSZWFjdC51c2VSZWYodmFsdWUgIT0gbnVsbCksXG4gICAgICBpc0NvbnRyb2xsZWQgPSBfUmVhY3QkdXNlUmVmLmN1cnJlbnQ7XG5cbiAgdmFyIGlucHV0UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgaGFuZGxlUmVmID0gdXNlRm9ya1JlZihyZWYsIGlucHV0UmVmKTtcbiAgdmFyIHNoYWRvd1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIHJlbmRlcnMgPSBSZWFjdC51c2VSZWYoMCk7XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKHt9KSxcbiAgICAgIHN0YXRlID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgc2V0U3RhdGUgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIHN5bmNIZWlnaHQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlucHV0ID0gaW5wdXRSZWYuY3VycmVudDtcbiAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGlucHV0KTtcbiAgICB2YXIgaW5wdXRTaGFsbG93ID0gc2hhZG93UmVmLmN1cnJlbnQ7XG4gICAgaW5wdXRTaGFsbG93LnN0eWxlLndpZHRoID0gY29tcHV0ZWRTdHlsZS53aWR0aDtcbiAgICBpbnB1dFNoYWxsb3cudmFsdWUgPSBpbnB1dC52YWx1ZSB8fCBwcm9wcy5wbGFjZWhvbGRlciB8fCAneCc7XG5cbiAgICBpZiAoaW5wdXRTaGFsbG93LnZhbHVlLnNsaWNlKC0xKSA9PT0gJ1xcbicpIHtcbiAgICAgIC8vIENlcnRhaW4gZm9udHMgd2hpY2ggb3ZlcmZsb3cgdGhlIGxpbmUgaGVpZ2h0IHdpbGwgY2F1c2UgdGhlIHRleHRhcmVhXG4gICAgICAvLyB0byByZXBvcnQgYSBkaWZmZXJlbnQgc2Nyb2xsSGVpZ2h0IGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBsYXN0IGxpbmVcbiAgICAgIC8vIGlzIGVtcHR5LiBNYWtlIGl0IG5vbi1lbXB0eSB0byBhdm9pZCB0aGlzIGlzc3VlLlxuICAgICAgaW5wdXRTaGFsbG93LnZhbHVlICs9ICcgJztcbiAgICB9XG5cbiAgICB2YXIgYm94U2l6aW5nID0gY29tcHV0ZWRTdHlsZVsnYm94LXNpemluZyddO1xuICAgIHZhciBwYWRkaW5nID0gZ2V0U3R5bGVWYWx1ZShjb21wdXRlZFN0eWxlLCAncGFkZGluZy1ib3R0b20nKSArIGdldFN0eWxlVmFsdWUoY29tcHV0ZWRTdHlsZSwgJ3BhZGRpbmctdG9wJyk7XG4gICAgdmFyIGJvcmRlciA9IGdldFN0eWxlVmFsdWUoY29tcHV0ZWRTdHlsZSwgJ2JvcmRlci1ib3R0b20td2lkdGgnKSArIGdldFN0eWxlVmFsdWUoY29tcHV0ZWRTdHlsZSwgJ2JvcmRlci10b3Atd2lkdGgnKTsgLy8gVGhlIGhlaWdodCBvZiB0aGUgaW5uZXIgY29udGVudFxuXG4gICAgdmFyIGlubmVySGVpZ2h0ID0gaW5wdXRTaGFsbG93LnNjcm9sbEhlaWdodCAtIHBhZGRpbmc7IC8vIE1lYXN1cmUgaGVpZ2h0IG9mIGEgdGV4dGFyZWEgd2l0aCBhIHNpbmdsZSByb3dcblxuICAgIGlucHV0U2hhbGxvdy52YWx1ZSA9ICd4JztcbiAgICB2YXIgc2luZ2xlUm93SGVpZ2h0ID0gaW5wdXRTaGFsbG93LnNjcm9sbEhlaWdodCAtIHBhZGRpbmc7IC8vIFRoZSBoZWlnaHQgb2YgdGhlIG91dGVyIGNvbnRlbnRcblxuICAgIHZhciBvdXRlckhlaWdodCA9IGlubmVySGVpZ2h0O1xuXG4gICAgaWYgKG1pblJvd3MpIHtcbiAgICAgIG91dGVySGVpZ2h0ID0gTWF0aC5tYXgoTnVtYmVyKG1pblJvd3MpICogc2luZ2xlUm93SGVpZ2h0LCBvdXRlckhlaWdodCk7XG4gICAgfVxuXG4gICAgaWYgKG1heFJvd3MpIHtcbiAgICAgIG91dGVySGVpZ2h0ID0gTWF0aC5taW4oTnVtYmVyKG1heFJvd3MpICogc2luZ2xlUm93SGVpZ2h0LCBvdXRlckhlaWdodCk7XG4gICAgfVxuXG4gICAgb3V0ZXJIZWlnaHQgPSBNYXRoLm1heChvdXRlckhlaWdodCwgc2luZ2xlUm93SGVpZ2h0KTsgLy8gVGFrZSB0aGUgYm94IHNpemluZyBpbnRvIGFjY291bnQgZm9yIGFwcGx5aW5nIHRoaXMgdmFsdWUgYXMgYSBzdHlsZS5cblxuICAgIHZhciBvdXRlckhlaWdodFN0eWxlID0gb3V0ZXJIZWlnaHQgKyAoYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCcgPyBwYWRkaW5nICsgYm9yZGVyIDogMCk7XG4gICAgdmFyIG92ZXJmbG93ID0gTWF0aC5hYnMob3V0ZXJIZWlnaHQgLSBpbm5lckhlaWdodCkgPD0gMTtcbiAgICBzZXRTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICAvLyBOZWVkIGEgbGFyZ2UgZW5vdWdoIGRpZmZlcmVuY2UgdG8gdXBkYXRlIHRoZSBoZWlnaHQuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIGluZmluaXRlIHJlbmRlcmluZyBsb29wLlxuICAgICAgaWYgKHJlbmRlcnMuY3VycmVudCA8IDIwICYmIChvdXRlckhlaWdodFN0eWxlID4gMCAmJiBNYXRoLmFicygocHJldlN0YXRlLm91dGVySGVpZ2h0U3R5bGUgfHwgMCkgLSBvdXRlckhlaWdodFN0eWxlKSA+IDEgfHwgcHJldlN0YXRlLm92ZXJmbG93ICE9PSBvdmVyZmxvdykpIHtcbiAgICAgICAgcmVuZGVycy5jdXJyZW50ICs9IDE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3ZlcmZsb3c6IG92ZXJmbG93LFxuICAgICAgICAgIG91dGVySGVpZ2h0U3R5bGU6IG91dGVySGVpZ2h0U3R5bGVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHJlbmRlcnMuY3VycmVudCA9PT0gMjApIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFsnTWF0ZXJpYWwtVUk6IFRvbyBtYW55IHJlLXJlbmRlcnMuIFRoZSBsYXlvdXQgaXMgdW5zdGFibGUuJywgJ1RleHRhcmVhQXV0b3NpemUgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AuJ10uam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgfSk7XG4gIH0sIFttYXhSb3dzLCBtaW5Sb3dzLCBwcm9wcy5wbGFjZWhvbGRlcl0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVSZXNpemUgPSBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICByZW5kZXJzLmN1cnJlbnQgPSAwO1xuICAgICAgc3luY0hlaWdodCgpO1xuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBoYW5kbGVSZXNpemUuY2xlYXIoKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgIH07XG4gIH0sIFtzeW5jSGVpZ2h0XSk7XG4gIHVzZUVuaGFuY2VkRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBzeW5jSGVpZ2h0KCk7XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlbmRlcnMuY3VycmVudCA9IDA7XG4gIH0sIFt2YWx1ZV0pO1xuXG4gIHZhciBoYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgICByZW5kZXJzLmN1cnJlbnQgPSAwO1xuXG4gICAgaWYgKCFpc0NvbnRyb2xsZWQpIHtcbiAgICAgIHN5bmNIZWlnaHQoKTtcbiAgICB9XG5cbiAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgIG9uQ2hhbmdlKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIsIF9leHRlbmRzKHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgb25DaGFuZ2U6IGhhbmRsZUNoYW5nZSxcbiAgICByZWY6IGhhbmRsZVJlZiAvLyBBcHBseSB0aGUgcm93cyBwcm9wIHRvIGdldCBhIFwiY29ycmVjdFwiIGZpcnN0IFNTUiBwYWludFxuICAgICxcbiAgICByb3dzOiBtaW5Sb3dzLFxuICAgIHN0eWxlOiBfZXh0ZW5kcyh7XG4gICAgICBoZWlnaHQ6IHN0YXRlLm91dGVySGVpZ2h0U3R5bGUsXG4gICAgICAvLyBOZWVkIGEgbGFyZ2UgZW5vdWdoIGRpZmZlcmVuY2UgdG8gYWxsb3cgc2Nyb2xsaW5nLlxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyBpbmZpbml0ZSByZW5kZXJpbmcgbG9vcC5cbiAgICAgIG92ZXJmbG93OiBzdGF0ZS5vdmVyZmxvdyA/ICdoaWRkZW4nIDogbnVsbFxuICAgIH0sIHN0eWxlKVxuICB9LCBvdGhlcikpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIsIHtcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgY2xhc3NOYW1lOiBwcm9wcy5jbGFzc05hbWUsXG4gICAgcmVhZE9ubHk6IHRydWUsXG4gICAgcmVmOiBzaGFkb3dSZWYsXG4gICAgdGFiSW5kZXg6IC0xLFxuICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgc3R5bGVzLnNoYWRvdywgc3R5bGUpXG4gIH0pKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVGV4dGFyZWFBdXRvc2l6ZS5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheS5cbiAgICovXG4gIG1heFJvd3M6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5LlxuICAgKi9cbiAgbWluUm93czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBNaW5pbXVtIG51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgbWluUm93c2AgaW5zdGVhZC5cbiAgICovXG4gIHJvd3M6IGRlcHJlY2F0ZWRQcm9wVHlwZShQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksICdVc2UgYG1pblJvd3NgIGluc3RlYWQuJyksXG5cbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBtYXhSb3dzYCBpbnN0ZWFkLlxuICAgKi9cbiAgcm93c01heDogZGVwcmVjYXRlZFByb3BUeXBlKFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSwgJ1VzZSBgbWF4Um93c2AgaW5zdGVhZC4nKSxcblxuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5LlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYG1pblJvd3NgIGluc3RlYWQuXG4gICAqL1xuICByb3dzTWluOiBkZXByZWNhdGVkUHJvcFR5cGUoUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLCAnVXNlIGBtaW5Sb3dzYCBpbnN0ZWFkLicpLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLCBQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCBUZXh0YXJlYUF1dG9zaXplOyIsIi8vIFN1cHBvcnRzIGRldGVybWluYXRpb24gb2YgaXNDb250cm9sbGVkKCkuXG4vLyBDb250cm9sbGVkIGlucHV0IGFjY2VwdHMgaXRzIGN1cnJlbnQgdmFsdWUgYXMgYSBwcm9wLlxuLy9cbi8vIEBzZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9mb3Jtcy5odG1sI2NvbnRyb2xsZWQtY29tcG9uZW50c1xuLy8gQHBhcmFtIHZhbHVlXG4vLyBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBzdHJpbmcgKGluY2x1ZGluZyAnJykgb3IgbnVtYmVyIChpbmNsdWRpbmcgemVybylcbmV4cG9ydCBmdW5jdGlvbiBoYXNWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAhKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCk7XG59IC8vIERldGVybWluZSBpZiBmaWVsZCBpcyBlbXB0eSBvciBmaWxsZWQuXG4vLyBSZXNwb25zZSBkZXRlcm1pbmVzIGlmIGxhYmVsIGlzIHByZXNlbnRlZCBhYm92ZSBmaWVsZCBvciBhcyBwbGFjZWhvbGRlci5cbi8vXG4vLyBAcGFyYW0gb2JqXG4vLyBAcGFyYW0gU1NSXG4vLyBAcmV0dXJucyB7Ym9vbGVhbn0gRmFsc2Ugd2hlbiBub3QgcHJlc2VudCBvciBlbXB0eSBzdHJpbmcuXG4vLyAgICAgICAgICAgICAgICAgICAgVHJ1ZSB3aGVuIGFueSBudW1iZXIgb3Igc3RyaW5nIHdpdGggbGVuZ3RoLlxuXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxsZWQob2JqKSB7XG4gIHZhciBTU1IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICByZXR1cm4gb2JqICYmIChoYXNWYWx1ZShvYmoudmFsdWUpICYmIG9iai52YWx1ZSAhPT0gJycgfHwgU1NSICYmIGhhc1ZhbHVlKG9iai5kZWZhdWx0VmFsdWUpICYmIG9iai5kZWZhdWx0VmFsdWUgIT09ICcnKTtcbn0gLy8gRGV0ZXJtaW5lIGlmIGFuIElucHV0IGlzIGFkb3JuZWQgb24gc3RhcnQuXG4vLyBJdCdzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGxlZnQgd2l0aCBMVFIuXG4vL1xuLy8gQHBhcmFtIG9ialxuLy8gQHJldHVybnMge2Jvb2xlYW59IEZhbHNlIHdoZW4gbm8gYWRvcm5tZW50cy5cbi8vICAgICAgICAgICAgICAgICAgICBUcnVlIHdoZW4gYWRvcm5lZCBhdCB0aGUgc3RhcnQuXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Fkb3JuZWRTdGFydChvYmopIHtcbiAgcmV0dXJuIG9iai5zdGFydEFkb3JubWVudDtcbn0iLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgeyBmb3JtYXRNdWlFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdE11aUVycm9yTWVzc2FnZSB9IGZyb20gXCJAbWF0ZXJpYWwtdWkvdXRpbHNcIjtcblxuLyogZXNsaW50LWRpc2FibGUganN4LWExMXkvY2xpY2stZXZlbnRzLWhhdmUta2V5LWV2ZW50cywganN4LWExMXkvbm8tc3RhdGljLWVsZW1lbnQtaW50ZXJhY3Rpb25zICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyByZWZUeXBlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCBmb3JtQ29udHJvbFN0YXRlIGZyb20gJy4uL0Zvcm1Db250cm9sL2Zvcm1Db250cm9sU3RhdGUnO1xuaW1wb3J0IEZvcm1Db250cm9sQ29udGV4dCwgeyB1c2VGb3JtQ29udHJvbCB9IGZyb20gJy4uL0Zvcm1Db250cm9sL0Zvcm1Db250cm9sQ29udGV4dCc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5pbXBvcnQgY2FwaXRhbGl6ZSBmcm9tICcuLi91dGlscy9jYXBpdGFsaXplJztcbmltcG9ydCB1c2VGb3JrUmVmIGZyb20gJy4uL3V0aWxzL3VzZUZvcmtSZWYnO1xuaW1wb3J0IFRleHRhcmVhQXV0b3NpemUgZnJvbSAnLi4vVGV4dGFyZWFBdXRvc2l6ZSc7XG5pbXBvcnQgeyBpc0ZpbGxlZCB9IGZyb20gJy4vdXRpbHMnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgdmFyIGxpZ2h0ID0gdGhlbWUucGFsZXR0ZS50eXBlID09PSAnbGlnaHQnO1xuICB2YXIgcGxhY2Vob2xkZXIgPSB7XG4gICAgY29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgIG9wYWNpdHk6IGxpZ2h0ID8gMC40MiA6IDAuNSxcbiAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ29wYWNpdHknLCB7XG4gICAgICBkdXJhdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlclxuICAgIH0pXG4gIH07XG4gIHZhciBwbGFjZWhvbGRlckhpZGRlbiA9IHtcbiAgICBvcGFjaXR5OiAnMCAhaW1wb3J0YW50J1xuICB9O1xuICB2YXIgcGxhY2Vob2xkZXJWaXNpYmxlID0ge1xuICAgIG9wYWNpdHk6IGxpZ2h0ID8gMC40MiA6IDAuNVxuICB9O1xuICByZXR1cm4ge1xuICAgICdAZ2xvYmFsJzoge1xuICAgICAgJ0BrZXlmcmFtZXMgbXVpLWF1dG8tZmlsbCc6IHt9LFxuICAgICAgJ0BrZXlmcmFtZXMgbXVpLWF1dG8tZmlsbC1jYW5jZWwnOiB7fVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IF9leHRlbmRzKHt9LCB0aGVtZS50eXBvZ3JhcGh5LmJvZHkxLCB7XG4gICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS50ZXh0LnByaW1hcnksXG4gICAgICBsaW5lSGVpZ2h0OiAnMS4xODc2ZW0nLFxuICAgICAgLy8gUmVzZXQgKDE5cHgpLCBtYXRjaCB0aGUgbmF0aXZlIGlucHV0IGxpbmUtaGVpZ2h0XG4gICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgIC8vIFByZXZlbnQgcGFkZGluZyBpc3N1ZSB3aXRoIGZ1bGxXaWR0aC5cbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgY3Vyc29yOiAndGV4dCcsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWZsZXgnLFxuICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAnJiRkaXNhYmxlZCc6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudGV4dC5kaXNhYmxlZCxcbiAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCdcbiAgICAgIH1cbiAgICB9KSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgdGhlIGNvbXBvbmVudCBpcyBhIGRlc2NlbmRhbnQgb2YgYEZvcm1Db250cm9sYC4gKi9cbiAgICBmb3JtQ29udHJvbDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIHRoZSBjb21wb25lbnQgaXMgZm9jdXNlZC4gKi9cbiAgICBmb2N1c2VkOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVkPXt0cnVlfWAuICovXG4gICAgZGlzYWJsZWQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgc3RhcnRBZG9ybm1lbnRgIGlzIHByb3ZpZGVkLiAqL1xuICAgIGFkb3JuZWRTdGFydDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBlbmRBZG9ybm1lbnRgIGlzIHByb3ZpZGVkLiAqL1xuICAgIGFkb3JuZWRFbmQ6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZXJyb3I9e3RydWV9YC4gKi9cbiAgICBlcnJvcjoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBtYXJnaW49XCJkZW5zZVwiYC4gKi9cbiAgICBtYXJnaW5EZW5zZToge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBtdWx0aWxpbmU9e3RydWV9YC4gKi9cbiAgICBtdWx0aWxpbmU6IHtcbiAgICAgIHBhZGRpbmc6IFwiXCIuY29uY2F0KDggLSAyLCBcInB4IDAgXCIpLmNvbmNhdCg4IC0gMSwgXCJweFwiKSxcbiAgICAgICcmJG1hcmdpbkRlbnNlJzoge1xuICAgICAgICBwYWRkaW5nVG9wOiA0IC0gMVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIHRoZSBjb2xvciBpcyBzZWNvbmRhcnkuICovXG4gICAgY29sb3JTZWNvbmRhcnk6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZnVsbFdpZHRoPXt0cnVlfWAuICovXG4gICAgZnVsbFdpZHRoOiB7XG4gICAgICB3aWR0aDogJzEwMCUnXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuICovXG4gICAgaW5wdXQ6IHtcbiAgICAgIGZvbnQ6ICdpbmhlcml0JyxcbiAgICAgIGxldHRlclNwYWNpbmc6ICdpbmhlcml0JyxcbiAgICAgIGNvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHBhZGRpbmc6IFwiXCIuY29uY2F0KDggLSAyLCBcInB4IDAgXCIpLmNvbmNhdCg4IC0gMSwgXCJweFwiKSxcbiAgICAgIGJvcmRlcjogMCxcbiAgICAgIGJveFNpemluZzogJ2NvbnRlbnQtYm94JyxcbiAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICAgIGhlaWdodDogJzEuMTg3NmVtJyxcbiAgICAgIC8vIFJlc2V0ICgxOXB4KSwgbWF0Y2ggdGhlIG5hdGl2ZSBpbnB1dCBsaW5lLWhlaWdodFxuICAgICAgbWFyZ2luOiAwLFxuICAgICAgLy8gUmVzZXQgZm9yIFNhZmFyaVxuICAgICAgV2Via2l0VGFwSGlnaGxpZ2h0Q29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgLy8gTWFrZSB0aGUgZmxleCBpdGVtIHNocmluayB3aXRoIEZpcmVmb3hcbiAgICAgIG1pbldpZHRoOiAwLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIC8vIEZpeCBJRSAxMSB3aWR0aCBpc3N1ZVxuICAgICAgYW5pbWF0aW9uTmFtZTogJ211aS1hdXRvLWZpbGwtY2FuY2VsJyxcbiAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAnMTBtcycsXG4gICAgICAnJjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcic6IHBsYWNlaG9sZGVyLFxuICAgICAgJyY6Oi1tb3otcGxhY2Vob2xkZXInOiBwbGFjZWhvbGRlcixcbiAgICAgIC8vIEZpcmVmb3ggMTkrXG4gICAgICAnJjotbXMtaW5wdXQtcGxhY2Vob2xkZXInOiBwbGFjZWhvbGRlcixcbiAgICAgIC8vIElFIDExXG4gICAgICAnJjo6LW1zLWlucHV0LXBsYWNlaG9sZGVyJzogcGxhY2Vob2xkZXIsXG4gICAgICAvLyBFZGdlXG4gICAgICAnJjpmb2N1cyc6IHtcbiAgICAgICAgb3V0bGluZTogMFxuICAgICAgfSxcbiAgICAgIC8vIFJlc2V0IEZpcmVmb3ggaW52YWxpZCByZXF1aXJlZCBpbnB1dCBzdHlsZVxuICAgICAgJyY6aW52YWxpZCc6IHtcbiAgICAgICAgYm94U2hhZG93OiAnbm9uZSdcbiAgICAgIH0sXG4gICAgICAnJjo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbic6IHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBwYWRkaW5nIHdoZW4gdHlwZT1zZWFyY2guXG4gICAgICAgICctd2Via2l0LWFwcGVhcmFuY2UnOiAnbm9uZSdcbiAgICAgIH0sXG4gICAgICAvLyBTaG93IGFuZCBoaWRlIHRoZSBwbGFjZWhvbGRlciBsb2dpY1xuICAgICAgJ2xhYmVsW2RhdGEtc2hyaW5rPWZhbHNlXSArICRmb3JtQ29udHJvbCAmJzoge1xuICAgICAgICAnJjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcic6IHBsYWNlaG9sZGVySGlkZGVuLFxuICAgICAgICAnJjo6LW1vei1wbGFjZWhvbGRlcic6IHBsYWNlaG9sZGVySGlkZGVuLFxuICAgICAgICAvLyBGaXJlZm94IDE5K1xuICAgICAgICAnJjotbXMtaW5wdXQtcGxhY2Vob2xkZXInOiBwbGFjZWhvbGRlckhpZGRlbixcbiAgICAgICAgLy8gSUUgMTFcbiAgICAgICAgJyY6Oi1tcy1pbnB1dC1wbGFjZWhvbGRlcic6IHBsYWNlaG9sZGVySGlkZGVuLFxuICAgICAgICAvLyBFZGdlXG4gICAgICAgICcmOmZvY3VzOjotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVyJzogcGxhY2Vob2xkZXJWaXNpYmxlLFxuICAgICAgICAnJjpmb2N1czo6LW1vei1wbGFjZWhvbGRlcic6IHBsYWNlaG9sZGVyVmlzaWJsZSxcbiAgICAgICAgLy8gRmlyZWZveCAxOStcbiAgICAgICAgJyY6Zm9jdXM6LW1zLWlucHV0LXBsYWNlaG9sZGVyJzogcGxhY2Vob2xkZXJWaXNpYmxlLFxuICAgICAgICAvLyBJRSAxMVxuICAgICAgICAnJjpmb2N1czo6LW1zLWlucHV0LXBsYWNlaG9sZGVyJzogcGxhY2Vob2xkZXJWaXNpYmxlIC8vIEVkZ2VcblxuICAgICAgfSxcbiAgICAgICcmJGRpc2FibGVkJzoge1xuICAgICAgICBvcGFjaXR5OiAxIC8vIFJlc2V0IGlPUyBvcGFjaXR5XG5cbiAgICAgIH0sXG4gICAgICAnJjotd2Via2l0LWF1dG9maWxsJzoge1xuICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogJzUwMDBzJyxcbiAgICAgICAgYW5pbWF0aW9uTmFtZTogJ211aS1hdXRvLWZpbGwnXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYG1hcmdpbj1cImRlbnNlXCJgLiAqL1xuICAgIGlucHV0TWFyZ2luRGVuc2U6IHtcbiAgICAgIHBhZGRpbmdUb3A6IDQgLSAxXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYG11bHRpbGluZT17dHJ1ZX1gLiAqL1xuICAgIGlucHV0TXVsdGlsaW5lOiB7XG4gICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgIHJlc2l6ZTogJ25vbmUnLFxuICAgICAgcGFkZGluZzogMFxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGB0eXBlPVwic2VhcmNoXCJgLiAqL1xuICAgIGlucHV0VHlwZVNlYXJjaDoge1xuICAgICAgLy8gSW1wcm92ZSB0eXBlIHNlYXJjaCBzdHlsZS5cbiAgICAgICctbW96LWFwcGVhcmFuY2UnOiAndGV4dGZpZWxkJyxcbiAgICAgICctd2Via2l0LWFwcGVhcmFuY2UnOiAndGV4dGZpZWxkJ1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBzdGFydEFkb3JubWVudGAgaXMgcHJvdmlkZWQuICovXG4gICAgaW5wdXRBZG9ybmVkU3RhcnQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgZW5kQWRvcm5tZW50YCBpcyBwcm92aWRlZC4gKi9cbiAgICBpbnB1dEFkb3JuZWRFbmQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgaGlkZGVuTGFiZWw9e3RydWV9YC4gKi9cbiAgICBpbnB1dEhpZGRlbkxhYmVsOiB7fVxuICB9O1xufTtcbnZhciB1c2VFbmhhbmNlZEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gUmVhY3QudXNlRWZmZWN0IDogUmVhY3QudXNlTGF5b3V0RWZmZWN0O1xuLyoqXG4gKiBgSW5wdXRCYXNlYCBjb250YWlucyBhcyBmZXcgc3R5bGVzIGFzIHBvc3NpYmxlLlxuICogSXQgYWltcyB0byBiZSBhIHNpbXBsZSBidWlsZGluZyBibG9jayBmb3IgY3JlYXRpbmcgYW4gaW5wdXQuXG4gKiBJdCBjb250YWlucyBhIGxvYWQgb2Ygc3R5bGUgcmVzZXQgYW5kIHNvbWUgc3RhdGUgbG9naWMuXG4gKi9cblxudmFyIElucHV0QmFzZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIElucHV0QmFzZShwcm9wcywgcmVmKSB7XG4gIHZhciBhcmlhRGVzY3JpYmVkYnkgPSBwcm9wc1snYXJpYS1kZXNjcmliZWRieSddLFxuICAgICAgYXV0b0NvbXBsZXRlID0gcHJvcHMuYXV0b0NvbXBsZXRlLFxuICAgICAgYXV0b0ZvY3VzID0gcHJvcHMuYXV0b0ZvY3VzLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjb2xvciA9IHByb3BzLmNvbG9yLFxuICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGVuZEFkb3JubWVudCA9IHByb3BzLmVuZEFkb3JubWVudCxcbiAgICAgIGVycm9yID0gcHJvcHMuZXJyb3IsXG4gICAgICBfcHJvcHMkZnVsbFdpZHRoID0gcHJvcHMuZnVsbFdpZHRoLFxuICAgICAgZnVsbFdpZHRoID0gX3Byb3BzJGZ1bGxXaWR0aCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZnVsbFdpZHRoLFxuICAgICAgaWQgPSBwcm9wcy5pZCxcbiAgICAgIF9wcm9wcyRpbnB1dENvbXBvbmVudCA9IHByb3BzLmlucHV0Q29tcG9uZW50LFxuICAgICAgaW5wdXRDb21wb25lbnQgPSBfcHJvcHMkaW5wdXRDb21wb25lbnQgPT09IHZvaWQgMCA/ICdpbnB1dCcgOiBfcHJvcHMkaW5wdXRDb21wb25lbnQsXG4gICAgICBfcHJvcHMkaW5wdXRQcm9wcyA9IHByb3BzLmlucHV0UHJvcHMsXG4gICAgICBpbnB1dFByb3BzUHJvcCA9IF9wcm9wcyRpbnB1dFByb3BzID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRpbnB1dFByb3BzLFxuICAgICAgaW5wdXRSZWZQcm9wID0gcHJvcHMuaW5wdXRSZWYsXG4gICAgICBtYXJnaW4gPSBwcm9wcy5tYXJnaW4sXG4gICAgICBfcHJvcHMkbXVsdGlsaW5lID0gcHJvcHMubXVsdGlsaW5lLFxuICAgICAgbXVsdGlsaW5lID0gX3Byb3BzJG11bHRpbGluZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkbXVsdGlsaW5lLFxuICAgICAgbmFtZSA9IHByb3BzLm5hbWUsXG4gICAgICBvbkJsdXIgPSBwcm9wcy5vbkJsdXIsXG4gICAgICBvbkNoYW5nZSA9IHByb3BzLm9uQ2hhbmdlLFxuICAgICAgb25DbGljayA9IHByb3BzLm9uQ2xpY2ssXG4gICAgICBvbkZvY3VzID0gcHJvcHMub25Gb2N1cyxcbiAgICAgIG9uS2V5RG93biA9IHByb3BzLm9uS2V5RG93bixcbiAgICAgIG9uS2V5VXAgPSBwcm9wcy5vbktleVVwLFxuICAgICAgcGxhY2Vob2xkZXIgPSBwcm9wcy5wbGFjZWhvbGRlcixcbiAgICAgIHJlYWRPbmx5ID0gcHJvcHMucmVhZE9ubHksXG4gICAgICByZW5kZXJTdWZmaXggPSBwcm9wcy5yZW5kZXJTdWZmaXgsXG4gICAgICByb3dzID0gcHJvcHMucm93cyxcbiAgICAgIHJvd3NNYXggPSBwcm9wcy5yb3dzTWF4LFxuICAgICAgcm93c01pbiA9IHByb3BzLnJvd3NNaW4sXG4gICAgICBtYXhSb3dzID0gcHJvcHMubWF4Um93cyxcbiAgICAgIG1pblJvd3MgPSBwcm9wcy5taW5Sb3dzLFxuICAgICAgc3RhcnRBZG9ybm1lbnQgPSBwcm9wcy5zdGFydEFkb3JubWVudCxcbiAgICAgIF9wcm9wcyR0eXBlID0gcHJvcHMudHlwZSxcbiAgICAgIHR5cGUgPSBfcHJvcHMkdHlwZSA9PT0gdm9pZCAwID8gJ3RleHQnIDogX3Byb3BzJHR5cGUsXG4gICAgICB2YWx1ZVByb3AgPSBwcm9wcy52YWx1ZSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIFwiYXV0b0NvbXBsZXRlXCIsIFwiYXV0b0ZvY3VzXCIsIFwiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcImNvbG9yXCIsIFwiZGVmYXVsdFZhbHVlXCIsIFwiZGlzYWJsZWRcIiwgXCJlbmRBZG9ybm1lbnRcIiwgXCJlcnJvclwiLCBcImZ1bGxXaWR0aFwiLCBcImlkXCIsIFwiaW5wdXRDb21wb25lbnRcIiwgXCJpbnB1dFByb3BzXCIsIFwiaW5wdXRSZWZcIiwgXCJtYXJnaW5cIiwgXCJtdWx0aWxpbmVcIiwgXCJuYW1lXCIsIFwib25CbHVyXCIsIFwib25DaGFuZ2VcIiwgXCJvbkNsaWNrXCIsIFwib25Gb2N1c1wiLCBcIm9uS2V5RG93blwiLCBcIm9uS2V5VXBcIiwgXCJwbGFjZWhvbGRlclwiLCBcInJlYWRPbmx5XCIsIFwicmVuZGVyU3VmZml4XCIsIFwicm93c1wiLCBcInJvd3NNYXhcIiwgXCJyb3dzTWluXCIsIFwibWF4Um93c1wiLCBcIm1pblJvd3NcIiwgXCJzdGFydEFkb3JubWVudFwiLCBcInR5cGVcIiwgXCJ2YWx1ZVwiXSk7XG5cbiAgdmFyIHZhbHVlID0gaW5wdXRQcm9wc1Byb3AudmFsdWUgIT0gbnVsbCA/IGlucHV0UHJvcHNQcm9wLnZhbHVlIDogdmFsdWVQcm9wO1xuXG4gIHZhciBfUmVhY3QkdXNlUmVmID0gUmVhY3QudXNlUmVmKHZhbHVlICE9IG51bGwpLFxuICAgICAgaXNDb250cm9sbGVkID0gX1JlYWN0JHVzZVJlZi5jdXJyZW50O1xuXG4gIHZhciBpbnB1dFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICB2YXIgaGFuZGxlSW5wdXRSZWZXYXJuaW5nID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5ub2RlTmFtZSAhPT0gJ0lOUFVUJyAmJiAhaW5zdGFuY2UuZm9jdXMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihbJ01hdGVyaWFsLVVJOiBZb3UgaGF2ZSBwcm92aWRlZCBhIGBpbnB1dENvbXBvbmVudGAgdG8gdGhlIGlucHV0IGNvbXBvbmVudCcsICd0aGF0IGRvZXMgbm90IGNvcnJlY3RseSBoYW5kbGUgdGhlIGBpbnB1dFJlZmAgcHJvcC4nLCAnTWFrZSBzdXJlIHRoZSBgaW5wdXRSZWZgIHByb3AgaXMgY2FsbGVkIHdpdGggYSBIVE1MSW5wdXRFbGVtZW50LiddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcbiAgdmFyIGhhbmRsZUlucHV0UHJvcHNSZWZQcm9wID0gdXNlRm9ya1JlZihpbnB1dFByb3BzUHJvcC5yZWYsIGhhbmRsZUlucHV0UmVmV2FybmluZyk7XG4gIHZhciBoYW5kbGVJbnB1dFJlZlByb3AgPSB1c2VGb3JrUmVmKGlucHV0UmVmUHJvcCwgaGFuZGxlSW5wdXRQcm9wc1JlZlByb3ApO1xuICB2YXIgaGFuZGxlSW5wdXRSZWYgPSB1c2VGb3JrUmVmKGlucHV0UmVmLCBoYW5kbGVJbnB1dFJlZlByb3ApO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgICBmb2N1c2VkID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgc2V0Rm9jdXNlZCA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICB2YXIgbXVpRm9ybUNvbnRyb2wgPSB1c2VGb3JtQ29udHJvbCgpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChtdWlGb3JtQ29udHJvbCkge1xuICAgICAgICByZXR1cm4gbXVpRm9ybUNvbnRyb2wucmVnaXN0ZXJFZmZlY3QoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LCBbbXVpRm9ybUNvbnRyb2xdKTtcbiAgfVxuXG4gIHZhciBmY3MgPSBmb3JtQ29udHJvbFN0YXRlKHtcbiAgICBwcm9wczogcHJvcHMsXG4gICAgbXVpRm9ybUNvbnRyb2w6IG11aUZvcm1Db250cm9sLFxuICAgIHN0YXRlczogWydjb2xvcicsICdkaXNhYmxlZCcsICdlcnJvcicsICdoaWRkZW5MYWJlbCcsICdtYXJnaW4nLCAncmVxdWlyZWQnLCAnZmlsbGVkJ11cbiAgfSk7XG4gIGZjcy5mb2N1c2VkID0gbXVpRm9ybUNvbnRyb2wgPyBtdWlGb3JtQ29udHJvbC5mb2N1c2VkIDogZm9jdXNlZDsgLy8gVGhlIGJsdXIgd29uJ3QgZmlyZSB3aGVuIHRoZSBkaXNhYmxlZCBzdGF0ZSBpcyBzZXQgb24gYSBmb2N1c2VkIGlucHV0LlxuICAvLyBXZSBuZWVkIHRvIGJvb2sga2VlcCB0aGUgZm9jdXNlZCBzdGF0ZSBtYW51YWxseS5cblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghbXVpRm9ybUNvbnRyb2wgJiYgZGlzYWJsZWQgJiYgZm9jdXNlZCkge1xuICAgICAgc2V0Rm9jdXNlZChmYWxzZSk7XG5cbiAgICAgIGlmIChvbkJsdXIpIHtcbiAgICAgICAgb25CbHVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbbXVpRm9ybUNvbnRyb2wsIGRpc2FibGVkLCBmb2N1c2VkLCBvbkJsdXJdKTtcbiAgdmFyIG9uRmlsbGVkID0gbXVpRm9ybUNvbnRyb2wgJiYgbXVpRm9ybUNvbnRyb2wub25GaWxsZWQ7XG4gIHZhciBvbkVtcHR5ID0gbXVpRm9ybUNvbnRyb2wgJiYgbXVpRm9ybUNvbnRyb2wub25FbXB0eTtcbiAgdmFyIGNoZWNrRGlydHkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKGlzRmlsbGVkKG9iaikpIHtcbiAgICAgIGlmIChvbkZpbGxlZCkge1xuICAgICAgICBvbkZpbGxlZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob25FbXB0eSkge1xuICAgICAgb25FbXB0eSgpO1xuICAgIH1cbiAgfSwgW29uRmlsbGVkLCBvbkVtcHR5XSk7XG4gIHVzZUVuaGFuY2VkRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNDb250cm9sbGVkKSB7XG4gICAgICBjaGVja0RpcnR5KHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFt2YWx1ZSwgY2hlY2tEaXJ0eSwgaXNDb250cm9sbGVkXSk7XG5cbiAgdmFyIGhhbmRsZUZvY3VzID0gZnVuY3Rpb24gaGFuZGxlRm9jdXMoZXZlbnQpIHtcbiAgICAvLyBGaXggYSBidWcgd2l0aCBJRSAxMSB3aGVyZSB0aGUgZm9jdXMvYmx1ciBldmVudHMgYXJlIHRyaWdnZXJlZFxuICAgIC8vIHdoaWxlIHRoZSBpbnB1dCBpcyBkaXNhYmxlZC5cbiAgICBpZiAoZmNzLmRpc2FibGVkKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob25Gb2N1cykge1xuICAgICAgb25Gb2N1cyhldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0UHJvcHNQcm9wLm9uRm9jdXMpIHtcbiAgICAgIGlucHV0UHJvcHNQcm9wLm9uRm9jdXMoZXZlbnQpO1xuICAgIH1cblxuICAgIGlmIChtdWlGb3JtQ29udHJvbCAmJiBtdWlGb3JtQ29udHJvbC5vbkZvY3VzKSB7XG4gICAgICBtdWlGb3JtQ29udHJvbC5vbkZvY3VzKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0Rm9jdXNlZCh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKGV2ZW50KSB7XG4gICAgaWYgKG9uQmx1cikge1xuICAgICAgb25CbHVyKGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXRQcm9wc1Byb3Aub25CbHVyKSB7XG4gICAgICBpbnB1dFByb3BzUHJvcC5vbkJsdXIoZXZlbnQpO1xuICAgIH1cblxuICAgIGlmIChtdWlGb3JtQ29udHJvbCAmJiBtdWlGb3JtQ29udHJvbC5vbkJsdXIpIHtcbiAgICAgIG11aUZvcm1Db250cm9sLm9uQmx1cihldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEZvY3VzZWQoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKCFpc0NvbnRyb2xsZWQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gZXZlbnQudGFyZ2V0IHx8IGlucHV0UmVmLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiTWF0ZXJpYWwtVUk6IEV4cGVjdGVkIHZhbGlkIGlucHV0IHRhcmdldC4gRGlkIHlvdSB1c2UgYSBjdXN0b20gYGlucHV0Q29tcG9uZW50YCBhbmQgZm9yZ2V0IHRvIGZvcndhcmQgcmVmcz8gU2VlIGh0dHBzOi8vbWF0ZXJpYWwtdWkuY29tL3IvaW5wdXQtY29tcG9uZW50LXJlZi1pbnRlcmZhY2UgZm9yIG1vcmUgaW5mby5cIiA6IF9mb3JtYXRNdWlFcnJvck1lc3NhZ2UoMSkpO1xuICAgICAgfVxuXG4gICAgICBjaGVja0RpcnR5KHtcbiAgICAgICAgdmFsdWU6IGVsZW1lbnQudmFsdWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChpbnB1dFByb3BzUHJvcC5vbkNoYW5nZSkge1xuICAgICAgaW5wdXRQcm9wc1Byb3Aub25DaGFuZ2UuYXBwbHkoaW5wdXRQcm9wc1Byb3AsIFtldmVudF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9IC8vIFBlcmZvcm0gaW4gdGhlIHdpbGxVcGRhdGVcblxuXG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICBvbkNoYW5nZS5hcHBseSh2b2lkIDAsIFtldmVudF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07IC8vIENoZWNrIHRoZSBpbnB1dCBzdGF0ZSBvbiBtb3VudCwgaW4gY2FzZSBpdCB3YXMgZmlsbGVkIGJ5IHRoZSB1c2VyXG4gIC8vIG9yIGF1dG8gZmlsbGVkIGJ5IHRoZSBicm93c2VyIGJlZm9yZSB0aGUgaHlkcmF0aW9uIChmb3IgU1NSKS5cblxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgY2hlY2tEaXJ0eShpbnB1dFJlZi5jdXJyZW50KTtcbiAgfSwgW10pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuXG4gIHZhciBoYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKGlucHV0UmVmLmN1cnJlbnQgJiYgZXZlbnQuY3VycmVudFRhcmdldCA9PT0gZXZlbnQudGFyZ2V0KSB7XG4gICAgICBpbnB1dFJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgIG9uQ2xpY2soZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgSW5wdXRDb21wb25lbnQgPSBpbnB1dENvbXBvbmVudDtcblxuICB2YXIgaW5wdXRQcm9wcyA9IF9leHRlbmRzKHt9LCBpbnB1dFByb3BzUHJvcCwge1xuICAgIHJlZjogaGFuZGxlSW5wdXRSZWZcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBJbnB1dENvbXBvbmVudCAhPT0gJ3N0cmluZycpIHtcbiAgICBpbnB1dFByb3BzID0gX2V4dGVuZHMoe1xuICAgICAgLy8gUmVuYW1lIHJlZiB0byBpbnB1dFJlZiBhcyB3ZSBkb24ndCBrbm93IHRoZVxuICAgICAgLy8gcHJvdmlkZWQgYGlucHV0Q29tcG9uZW50YCBzdHJ1Y3R1cmUuXG4gICAgICBpbnB1dFJlZjogaGFuZGxlSW5wdXRSZWYsXG4gICAgICB0eXBlOiB0eXBlXG4gICAgfSwgaW5wdXRQcm9wcywge1xuICAgICAgcmVmOiBudWxsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAobXVsdGlsaW5lKSB7XG4gICAgaWYgKHJvd3MgJiYgIW1heFJvd3MgJiYgIW1pblJvd3MgJiYgIXJvd3NNYXggJiYgIXJvd3NNaW4pIHtcbiAgICAgIElucHV0Q29tcG9uZW50ID0gJ3RleHRhcmVhJztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXRQcm9wcyA9IF9leHRlbmRzKHtcbiAgICAgICAgbWluUm93czogcm93cyB8fCBtaW5Sb3dzLFxuICAgICAgICByb3dzTWF4OiByb3dzTWF4LFxuICAgICAgICBtYXhSb3dzOiBtYXhSb3dzXG4gICAgICB9LCBpbnB1dFByb3BzKTtcbiAgICAgIElucHV0Q29tcG9uZW50ID0gVGV4dGFyZWFBdXRvc2l6ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaW5wdXRQcm9wcyA9IF9leHRlbmRzKHtcbiAgICAgIHR5cGU6IHR5cGVcbiAgICB9LCBpbnB1dFByb3BzKTtcbiAgfVxuXG4gIHZhciBoYW5kbGVBdXRvRmlsbCA9IGZ1bmN0aW9uIGhhbmRsZUF1dG9GaWxsKGV2ZW50KSB7XG4gICAgLy8gUHJvdmlkZSBhIGZha2UgdmFsdWUgYXMgQ2hyb21lIG1pZ2h0IG5vdCBsZXQgeW91IGFjY2VzcyBpdCBmb3Igc2VjdXJpdHkgcmVhc29ucy5cbiAgICBjaGVja0RpcnR5KGV2ZW50LmFuaW1hdGlvbk5hbWUgPT09ICdtdWktYXV0by1maWxsLWNhbmNlbCcgPyBpbnB1dFJlZi5jdXJyZW50IDoge1xuICAgICAgdmFsdWU6ICd4J1xuICAgIH0pO1xuICB9O1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG11aUZvcm1Db250cm9sKSB7XG4gICAgICBtdWlGb3JtQ29udHJvbC5zZXRBZG9ybmVkU3RhcnQoQm9vbGVhbihzdGFydEFkb3JubWVudCkpO1xuICAgIH1cbiAgfSwgW211aUZvcm1Db250cm9sLCBzdGFydEFkb3JubWVudF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzZXNbXCJjb2xvclwiLmNvbmNhdChjYXBpdGFsaXplKGZjcy5jb2xvciB8fCAncHJpbWFyeScpKV0sIGNsYXNzTmFtZSwgZmNzLmRpc2FibGVkICYmIGNsYXNzZXMuZGlzYWJsZWQsIGZjcy5lcnJvciAmJiBjbGFzc2VzLmVycm9yLCBmdWxsV2lkdGggJiYgY2xhc3Nlcy5mdWxsV2lkdGgsIGZjcy5mb2N1c2VkICYmIGNsYXNzZXMuZm9jdXNlZCwgbXVpRm9ybUNvbnRyb2wgJiYgY2xhc3Nlcy5mb3JtQ29udHJvbCwgbXVsdGlsaW5lICYmIGNsYXNzZXMubXVsdGlsaW5lLCBzdGFydEFkb3JubWVudCAmJiBjbGFzc2VzLmFkb3JuZWRTdGFydCwgZW5kQWRvcm5tZW50ICYmIGNsYXNzZXMuYWRvcm5lZEVuZCwgZmNzLm1hcmdpbiA9PT0gJ2RlbnNlJyAmJiBjbGFzc2VzLm1hcmdpbkRlbnNlKSxcbiAgICBvbkNsaWNrOiBoYW5kbGVDbGljayxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlciksIHN0YXJ0QWRvcm5tZW50LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtQ29udHJvbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbnVsbFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJbnB1dENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIFwiYXJpYS1pbnZhbGlkXCI6IGZjcy5lcnJvcixcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogYXJpYURlc2NyaWJlZGJ5LFxuICAgIGF1dG9Db21wbGV0ZTogYXV0b0NvbXBsZXRlLFxuICAgIGF1dG9Gb2N1czogYXV0b0ZvY3VzLFxuICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIGRpc2FibGVkOiBmY3MuZGlzYWJsZWQsXG4gICAgaWQ6IGlkLFxuICAgIG9uQW5pbWF0aW9uU3RhcnQ6IGhhbmRsZUF1dG9GaWxsLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgIHJlYWRPbmx5OiByZWFkT25seSxcbiAgICByZXF1aXJlZDogZmNzLnJlcXVpcmVkLFxuICAgIHJvd3M6IHJvd3MsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIG9uS2V5RG93bjogb25LZXlEb3duLFxuICAgIG9uS2V5VXA6IG9uS2V5VXBcbiAgfSwgaW5wdXRQcm9wcywge1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLmlucHV0LCBpbnB1dFByb3BzUHJvcC5jbGFzc05hbWUsIGZjcy5kaXNhYmxlZCAmJiBjbGFzc2VzLmRpc2FibGVkLCBtdWx0aWxpbmUgJiYgY2xhc3Nlcy5pbnB1dE11bHRpbGluZSwgZmNzLmhpZGRlbkxhYmVsICYmIGNsYXNzZXMuaW5wdXRIaWRkZW5MYWJlbCwgc3RhcnRBZG9ybm1lbnQgJiYgY2xhc3Nlcy5pbnB1dEFkb3JuZWRTdGFydCwgZW5kQWRvcm5tZW50ICYmIGNsYXNzZXMuaW5wdXRBZG9ybmVkRW5kLCB0eXBlID09PSAnc2VhcmNoJyAmJiBjbGFzc2VzLmlucHV0VHlwZVNlYXJjaCwgZmNzLm1hcmdpbiA9PT0gJ2RlbnNlJyAmJiBjbGFzc2VzLmlucHV0TWFyZ2luRGVuc2UpLFxuICAgIG9uQmx1cjogaGFuZGxlQmx1cixcbiAgICBvbkNoYW5nZTogaGFuZGxlQ2hhbmdlLFxuICAgIG9uRm9jdXM6IGhhbmRsZUZvY3VzXG4gIH0pKSksIGVuZEFkb3JubWVudCwgcmVuZGVyU3VmZml4ID8gcmVuZGVyU3VmZml4KF9leHRlbmRzKHt9LCBmY3MsIHtcbiAgICBzdGFydEFkb3JubWVudDogc3RhcnRBZG9ybm1lbnRcbiAgfSkpIDogbnVsbCk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IElucHV0QmFzZS5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICAnYXJpYS1kZXNjcmliZWRieSc6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoaXMgcHJvcCBoZWxwcyB1c2VycyB0byBmaWxsIGZvcm1zIGZhc3RlciwgZXNwZWNpYWxseSBvbiBtb2JpbGUgZGV2aWNlcy5cbiAgICogVGhlIG5hbWUgY2FuIGJlIGNvbmZ1c2luZywgYXMgaXQncyBtb3JlIGxpa2UgYW4gYXV0b2ZpbGwuXG4gICAqIFlvdSBjYW4gbGVhcm4gbW9yZSBhYm91dCBpdCBbZm9sbG93aW5nIHRoZSBzcGVjaWZpY2F0aW9uXShodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNhdXRvZmlsbCkuXG4gICAqL1xuICBhdXRvQ29tcGxldGU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIGZvY3VzZWQgZHVyaW5nIHRoZSBmaXJzdCBtb3VudC5cbiAgICovXG4gIGF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2YgdGhlIGNvbXBvbmVudC4gSXQgc3VwcG9ydHMgdGhvc2UgdGhlbWUgY29sb3JzIHRoYXQgbWFrZSBzZW5zZSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsncHJpbWFyeScsICdzZWNvbmRhcnknXSksXG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGBpbnB1dGAgZWxlbWVudCB2YWx1ZS4gVXNlIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBub3QgY29udHJvbGxlZC5cbiAgICovXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLmFueSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYGlucHV0YCBlbGVtZW50IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEVuZCBgSW5wdXRBZG9ybm1lbnRgIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIGVuZEFkb3JubWVudDogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IHdpbGwgaW5kaWNhdGUgYW4gZXJyb3IuIFRoaXMgaXMgbm9ybWFsbHkgb2J0YWluZWQgdmlhIGNvbnRleHQgZnJvbVxuICAgKiBGb3JtQ29udHJvbC5cbiAgICovXG4gIGVycm9yOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgaW5wdXQgd2lsbCB0YWtlIHVwIHRoZSBmdWxsIHdpZHRoIG9mIGl0cyBjb250YWluZXIuXG4gICAqL1xuICBmdWxsV2lkdGg6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgaWQgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBpbnB1dENvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBbQXR0cmlidXRlc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0I0F0dHJpYnV0ZXMpIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGlucHV0UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFBhc3MgYSByZWYgdG8gdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGlucHV0UmVmOiByZWZUeXBlLFxuXG4gIC8qKlxuICAgKiBJZiBgZGVuc2VgLCB3aWxsIGFkanVzdCB2ZXJ0aWNhbCBzcGFjaW5nLiBUaGlzIGlzIG5vcm1hbGx5IG9idGFpbmVkIHZpYSBjb250ZXh0IGZyb21cbiAgICogRm9ybUNvbnRyb2wuXG4gICAqL1xuICBtYXJnaW46IFByb3BUeXBlcy5vbmVPZihbJ2RlbnNlJywgJ25vbmUnXSksXG5cbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheSB3aGVuIG11bHRpbGluZSBvcHRpb24gaXMgc2V0IHRvIHRydWUuXG4gICAqL1xuICBtYXhSb3dzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheSB3aGVuIG11bHRpbGluZSBvcHRpb24gaXMgc2V0IHRvIHRydWUuXG4gICAqL1xuICBtaW5Sb3dzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgYSB0ZXh0YXJlYSBlbGVtZW50IHdpbGwgYmUgcmVuZGVyZWQuXG4gICAqL1xuICBtdWx0aWxpbmU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBOYW1lIGF0dHJpYnV0ZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgaW5wdXQgaXMgYmx1cnJlZC5cbiAgICpcbiAgICogTm90aWNlIHRoYXQgdGhlIGZpcnN0IGFyZ3VtZW50IChldmVudCkgbWlnaHQgYmUgdW5kZWZpbmVkLlxuICAgKi9cbiAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgdmFsdWUgaXMgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBZb3UgY2FuIHB1bGwgb3V0IHRoZSBuZXcgdmFsdWUgYnkgYWNjZXNzaW5nIGBldmVudC50YXJnZXQudmFsdWVgIChzdHJpbmcpLlxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uS2V5RG93bjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uS2V5VXA6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBUaGUgc2hvcnQgaGludCBkaXNwbGF5ZWQgaW4gdGhlIGlucHV0IGJlZm9yZSB0aGUgdXNlciBlbnRlcnMgYSB2YWx1ZS5cbiAgICovXG4gIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBJdCBwcmV2ZW50cyB0aGUgdXNlciBmcm9tIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiB0aGUgZmllbGRcbiAgICogKG5vdCBmcm9tIGludGVyYWN0aW5nIHdpdGggdGhlIGZpZWxkKS5cbiAgICovXG4gIHJlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgcmVuZGVyU3VmZml4OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYGlucHV0YCBlbGVtZW50IHdpbGwgYmUgcmVxdWlyZWQuXG4gICAqL1xuICByZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgd2hlbiBtdWx0aWxpbmUgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgKi9cbiAgcm93czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgbWF4Um93c2AgaW5zdGVhZC5cbiAgICovXG4gIHJvd3NNYXg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5LlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYG1pblJvd3NgIGluc3RlYWQuXG4gICAqL1xuICByb3dzTWluOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIFN0YXJ0IGBJbnB1dEFkb3JubWVudGAgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgc3RhcnRBZG9ybm1lbnQ6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBUeXBlIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuIEl0IHNob3VsZCBiZSBbYSB2YWxpZCBIVE1MNSBpbnB1dCB0eXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQjRm9ybV8lM0NpbnB1dCUzRV90eXBlcykuXG4gICAqL1xuICB0eXBlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudCwgcmVxdWlyZWQgZm9yIGEgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAqL1xuICB2YWx1ZTogUHJvcFR5cGVzLmFueVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlJbnB1dEJhc2UnXG59KShJbnB1dEJhc2UpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IHJlZlR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IElucHV0QmFzZSBmcm9tICcuLi9JbnB1dEJhc2UnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgdmFyIGxpZ2h0ID0gdGhlbWUucGFsZXR0ZS50eXBlID09PSAnbGlnaHQnO1xuICB2YXIgYm90dG9tTGluZUNvbG9yID0gbGlnaHQgPyAncmdiYSgwLCAwLCAwLCAwLjQyKScgOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpJztcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgdGhlIGNvbXBvbmVudCBpcyBhIGRlc2NlbmRhbnQgb2YgYEZvcm1Db250cm9sYC4gKi9cbiAgICBmb3JtQ29udHJvbDoge1xuICAgICAgJ2xhYmVsICsgJic6IHtcbiAgICAgICAgbWFyZ2luVG9wOiAxNlxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIHRoZSBjb21wb25lbnQgaXMgZm9jdXNlZC4gKi9cbiAgICBmb2N1c2VkOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVkPXt0cnVlfWAuICovXG4gICAgZGlzYWJsZWQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBjb2xvciBzZWNvbmRhcnkuICovXG4gICAgY29sb3JTZWNvbmRhcnk6IHtcbiAgICAgICcmJHVuZGVybGluZTphZnRlcic6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW5cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZGlzYWJsZVVuZGVybGluZT17ZmFsc2V9YC4gKi9cbiAgICB1bmRlcmxpbmU6IHtcbiAgICAgICcmOmFmdGVyJzoge1xuICAgICAgICBib3JkZXJCb3R0b206IFwiMnB4IHNvbGlkIFwiLmNvbmNhdCh0aGVtZS5wYWxldHRlLnByaW1hcnkubWFpbiksXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgLy8gRG9pbmcgdGhlIG90aGVyIHdheSBhcm91bmQgY3Jhc2ggb24gSUUgMTEgXCInJ1wiIGh0dHBzOi8vZ2l0aHViLmNvbS9jc3NpbmpzL2pzcy9pc3N1ZXMvMjQyXG4gICAgICAgIGNvbnRlbnQ6ICdcIlwiJyxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZVgoMCknLFxuICAgICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ3RyYW5zZm9ybScsIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlcixcbiAgICAgICAgICBlYXNpbmc6IHRoZW1lLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlT3V0XG4gICAgICAgIH0pLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScgLy8gVHJhbnNwYXJlbnQgdG8gdGhlIGhvdmVyIHN0eWxlLlxuXG4gICAgICB9LFxuICAgICAgJyYkZm9jdXNlZDphZnRlcic6IHtcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGVYKDEpJ1xuICAgICAgfSxcbiAgICAgICcmJGVycm9yOmFmdGVyJzoge1xuICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogdGhlbWUucGFsZXR0ZS5lcnJvci5tYWluLFxuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZVgoMSknIC8vIGVycm9yIGlzIGFsd2F5cyB1bmRlcmxpbmVkIGluIHJlZFxuXG4gICAgICB9LFxuICAgICAgJyY6YmVmb3JlJzoge1xuICAgICAgICBib3JkZXJCb3R0b206IFwiMXB4IHNvbGlkIFwiLmNvbmNhdChib3R0b21MaW5lQ29sb3IpLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIC8vIERvaW5nIHRoZSBvdGhlciB3YXkgYXJvdW5kIGNyYXNoIG9uIElFIDExIFwiJydcIiBodHRwczovL2dpdGh1Yi5jb20vY3NzaW5qcy9qc3MvaXNzdWVzLzI0MlxuICAgICAgICBjb250ZW50OiAnXCJcXFxcMDBhMFwiJyxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ2JvcmRlci1ib3R0b20tY29sb3InLCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXJcbiAgICAgICAgfSksXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyAvLyBUcmFuc3BhcmVudCB0byB0aGUgaG92ZXIgc3R5bGUuXG5cbiAgICAgIH0sXG4gICAgICAnJjpob3Zlcjpub3QoJGRpc2FibGVkKTpiZWZvcmUnOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbTogXCIycHggc29saWQgXCIuY29uY2F0KHRoZW1lLnBhbGV0dGUudGV4dC5wcmltYXJ5KSxcbiAgICAgICAgLy8gUmVzZXQgb24gdG91Y2ggZGV2aWNlcywgaXQgZG9lc24ndCBhZGQgc3BlY2lmaWNpdHlcbiAgICAgICAgJ0BtZWRpYSAoaG92ZXI6IG5vbmUpJzoge1xuICAgICAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgXCIuY29uY2F0KGJvdHRvbUxpbmVDb2xvcilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICcmJGRpc2FibGVkOmJlZm9yZSc6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tU3R5bGU6ICdkb3R0ZWQnXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGVycm9yPXt0cnVlfWAuICovXG4gICAgZXJyb3I6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgbWFyZ2luPVwiZGVuc2VcImAuICovXG4gICAgbWFyZ2luRGVuc2U6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgbXVsdGlsaW5lPXt0cnVlfWAuICovXG4gICAgbXVsdGlsaW5lOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGZ1bGxXaWR0aD17dHJ1ZX1gLiAqL1xuICAgIGZ1bGxXaWR0aDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50LiAqL1xuICAgIGlucHV0OiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYG1hcmdpbj1cImRlbnNlXCJgLiAqL1xuICAgIGlucHV0TWFyZ2luRGVuc2U6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgbXVsdGlsaW5lPXt0cnVlfWAuICovXG4gICAgaW5wdXRNdWx0aWxpbmU6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgdHlwZT1cInNlYXJjaFwiYC4gKi9cbiAgICBpbnB1dFR5cGVTZWFyY2g6IHt9XG4gIH07XG59O1xudmFyIElucHV0ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gSW5wdXQocHJvcHMsIHJlZikge1xuICB2YXIgZGlzYWJsZVVuZGVybGluZSA9IHByb3BzLmRpc2FibGVVbmRlcmxpbmUsXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIF9wcm9wcyRmdWxsV2lkdGggPSBwcm9wcy5mdWxsV2lkdGgsXG4gICAgICBmdWxsV2lkdGggPSBfcHJvcHMkZnVsbFdpZHRoID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRmdWxsV2lkdGgsXG4gICAgICBfcHJvcHMkaW5wdXRDb21wb25lbnQgPSBwcm9wcy5pbnB1dENvbXBvbmVudCxcbiAgICAgIGlucHV0Q29tcG9uZW50ID0gX3Byb3BzJGlucHV0Q29tcG9uZW50ID09PSB2b2lkIDAgPyAnaW5wdXQnIDogX3Byb3BzJGlucHV0Q29tcG9uZW50LFxuICAgICAgX3Byb3BzJG11bHRpbGluZSA9IHByb3BzLm11bHRpbGluZSxcbiAgICAgIG11bHRpbGluZSA9IF9wcm9wcyRtdWx0aWxpbmUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJG11bHRpbGluZSxcbiAgICAgIF9wcm9wcyR0eXBlID0gcHJvcHMudHlwZSxcbiAgICAgIHR5cGUgPSBfcHJvcHMkdHlwZSA9PT0gdm9pZCAwID8gJ3RleHQnIDogX3Byb3BzJHR5cGUsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiZGlzYWJsZVVuZGVybGluZVwiLCBcImNsYXNzZXNcIiwgXCJmdWxsV2lkdGhcIiwgXCJpbnB1dENvbXBvbmVudFwiLCBcIm11bHRpbGluZVwiLCBcInR5cGVcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJbnB1dEJhc2UsIF9leHRlbmRzKHtcbiAgICBjbGFzc2VzOiBfZXh0ZW5kcyh7fSwgY2xhc3Nlcywge1xuICAgICAgcm9vdDogY2xzeChjbGFzc2VzLnJvb3QsICFkaXNhYmxlVW5kZXJsaW5lICYmIGNsYXNzZXMudW5kZXJsaW5lKSxcbiAgICAgIHVuZGVybGluZTogbnVsbFxuICAgIH0pLFxuICAgIGZ1bGxXaWR0aDogZnVsbFdpZHRoLFxuICAgIGlucHV0Q29tcG9uZW50OiBpbnB1dENvbXBvbmVudCxcbiAgICBtdWx0aWxpbmU6IG11bHRpbGluZSxcbiAgICByZWY6IHJlZixcbiAgICB0eXBlOiB0eXBlXG4gIH0sIG90aGVyKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IElucHV0LnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoaXMgcHJvcCBoZWxwcyB1c2VycyB0byBmaWxsIGZvcm1zIGZhc3RlciwgZXNwZWNpYWxseSBvbiBtb2JpbGUgZGV2aWNlcy5cbiAgICogVGhlIG5hbWUgY2FuIGJlIGNvbmZ1c2luZywgYXMgaXQncyBtb3JlIGxpa2UgYW4gYXV0b2ZpbGwuXG4gICAqIFlvdSBjYW4gbGVhcm4gbW9yZSBhYm91dCBpdCBbZm9sbG93aW5nIHRoZSBzcGVjaWZpY2F0aW9uXShodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNhdXRvZmlsbCkuXG4gICAqL1xuICBhdXRvQ29tcGxldGU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIGZvY3VzZWQgZHVyaW5nIHRoZSBmaXJzdCBtb3VudC5cbiAgICovXG4gIGF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIHRob3NlIHRoZW1lIGNvbG9ycyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBgaW5wdXRgIGVsZW1lbnQgdmFsdWUuIFVzZSB3aGVuIHRoZSBjb21wb25lbnQgaXMgbm90IGNvbnRyb2xsZWQuXG4gICAqL1xuICBkZWZhdWx0VmFsdWU6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBpbnB1dCB3aWxsIG5vdCBoYXZlIGFuIHVuZGVybGluZS5cbiAgICovXG4gIGRpc2FibGVVbmRlcmxpbmU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBFbmQgYElucHV0QWRvcm5tZW50YCBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBlbmRBZG9ybm1lbnQ6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBpbnB1dCB3aWxsIGluZGljYXRlIGFuIGVycm9yLiBUaGlzIGlzIG5vcm1hbGx5IG9idGFpbmVkIHZpYSBjb250ZXh0IGZyb21cbiAgICogRm9ybUNvbnRyb2wuXG4gICAqL1xuICBlcnJvcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IHdpbGwgdGFrZSB1cCB0aGUgZnVsbCB3aWR0aCBvZiBpdHMgY29udGFpbmVyLlxuICAgKi9cbiAgZnVsbFdpZHRoOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGlkIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgaW5wdXRDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogW0F0dHJpYnV0ZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNBdHRyaWJ1dGVzKSBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBQYXNzIGEgcmVmIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFJlZjogcmVmVHlwZSxcblxuICAvKipcbiAgICogSWYgYGRlbnNlYCwgd2lsbCBhZGp1c3QgdmVydGljYWwgc3BhY2luZy4gVGhpcyBpcyBub3JtYWxseSBvYnRhaW5lZCB2aWEgY29udGV4dCBmcm9tXG4gICAqIEZvcm1Db250cm9sLlxuICAgKi9cbiAgbWFyZ2luOiBQcm9wVHlwZXMub25lT2YoWydkZW5zZScsICdub25lJ10pLFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgd2hlbiBtdWx0aWxpbmUgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgKi9cbiAgbWF4Um93czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGEgdGV4dGFyZWEgZWxlbWVudCB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgbXVsdGlsaW5lOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTmFtZSBhdHRyaWJ1dGUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cbiAgICogWW91IGNhbiBwdWxsIG91dCB0aGUgbmV3IHZhbHVlIGJ5IGFjY2Vzc2luZyBgZXZlbnQudGFyZ2V0LnZhbHVlYCAoc3RyaW5nKS5cbiAgICovXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogVGhlIHNob3J0IGhpbnQgZGlzcGxheWVkIGluIHRoZSBpbnB1dCBiZWZvcmUgdGhlIHVzZXIgZW50ZXJzIGEgdmFsdWUuXG4gICAqL1xuICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSXQgcHJldmVudHMgdGhlIHVzZXIgZnJvbSBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkXG4gICAqIChub3QgZnJvbSBpbnRlcmFjdGluZyB3aXRoIHRoZSBmaWVsZCkuXG4gICAqL1xuICByZWFkT25seTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIHJlcXVpcmVkLlxuICAgKi9cbiAgcmVxdWlyZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IHdoZW4gbXVsdGlsaW5lIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICovXG4gIHJvd3M6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogU3RhcnQgYElucHV0QWRvcm5tZW50YCBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBzdGFydEFkb3JubWVudDogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIFR5cGUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC4gSXQgc2hvdWxkIGJlIFthIHZhbGlkIEhUTUw1IGlucHV0IHR5cGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNGb3JtXyUzQ2lucHV0JTNFX3R5cGVzKS5cbiAgICovXG4gIHR5cGU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LCByZXF1aXJlZCBmb3IgYSBjb250cm9sbGVkIGNvbXBvbmVudC5cbiAgICovXG4gIHZhbHVlOiBQcm9wVHlwZXMuYW55XG59IDogdm9pZCAwO1xuSW5wdXQubXVpTmFtZSA9ICdJbnB1dCc7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpSW5wdXQnXG59KShJbnB1dCk7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHsgcmVmVHlwZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgSW5wdXRCYXNlIGZyb20gJy4uL0lucHV0QmFzZSc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICB2YXIgbGlnaHQgPSB0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCc7XG4gIHZhciBib3R0b21MaW5lQ29sb3IgPSBsaWdodCA/ICdyZ2JhKDAsIDAsIDAsIDAuNDIpJyA6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyknO1xuICB2YXIgYmFja2dyb3VuZENvbG9yID0gbGlnaHQgPyAncmdiYSgwLCAwLCAwLCAwLjA5KScgOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjA5KSc7XG4gIHJldHVybiB7XG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgICByb290OiB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yLFxuICAgICAgYm9yZGVyVG9wTGVmdFJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzLFxuICAgICAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6IHRoZW1lLnNoYXBlLmJvcmRlclJhZGl1cyxcbiAgICAgIHRyYW5zaXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgnYmFja2dyb3VuZC1jb2xvcicsIHtcbiAgICAgICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXIsXG4gICAgICAgIGVhc2luZzogdGhlbWUudHJhbnNpdGlvbnMuZWFzaW5nLmVhc2VPdXRcbiAgICAgIH0pLFxuICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogbGlnaHQgPyAncmdiYSgwLCAwLCAwLCAwLjEzKScgOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEzKScsXG4gICAgICAgIC8vIFJlc2V0IG9uIHRvdWNoIGRldmljZXMsIGl0IGRvZXNuJ3QgYWRkIHNwZWNpZmljaXR5XG4gICAgICAgICdAbWVkaWEgKGhvdmVyOiBub25lKSc6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJyYkZm9jdXNlZCc6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBsaWdodCA/ICdyZ2JhKDAsIDAsIDAsIDAuMDkpJyA6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDkpJ1xuICAgICAgfSxcbiAgICAgICcmJGRpc2FibGVkJzoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0ID8gJ3JnYmEoMCwgMCwgMCwgMC4xMiknIDogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4xMiknXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgY29sb3Igc2Vjb25kYXJ5LiAqL1xuICAgIGNvbG9yU2Vjb25kYXJ5OiB7XG4gICAgICAnJiR1bmRlcmxpbmU6YWZ0ZXInOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0aGVtZS5wYWxldHRlLnNlY29uZGFyeS5tYWluXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVVbmRlcmxpbmU9e2ZhbHNlfWAuICovXG4gICAgdW5kZXJsaW5lOiB7XG4gICAgICAnJjphZnRlcic6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tOiBcIjJweCBzb2xpZCBcIi5jb25jYXQodGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW4pLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIC8vIERvaW5nIHRoZSBvdGhlciB3YXkgYXJvdW5kIGNyYXNoIG9uIElFIDExIFwiJydcIiBodHRwczovL2dpdGh1Yi5jb20vY3NzaW5qcy9qc3MvaXNzdWVzLzI0MlxuICAgICAgICBjb250ZW50OiAnXCJcIicsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGVYKDApJyxcbiAgICAgICAgdHJhbnNpdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKCd0cmFuc2Zvcm0nLCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXIsXG4gICAgICAgICAgZWFzaW5nOiB0aGVtZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZU91dFxuICAgICAgICB9KSxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnIC8vIFRyYW5zcGFyZW50IHRvIHRoZSBob3ZlciBzdHlsZS5cblxuICAgICAgfSxcbiAgICAgICcmJGZvY3VzZWQ6YWZ0ZXInOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlWCgxKSdcbiAgICAgIH0sXG4gICAgICAnJiRlcnJvcjphZnRlcic6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IHRoZW1lLnBhbGV0dGUuZXJyb3IubWFpbixcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGVYKDEpJyAvLyBlcnJvciBpcyBhbHdheXMgdW5kZXJsaW5lZCBpbiByZWRcblxuICAgICAgfSxcbiAgICAgICcmOmJlZm9yZSc6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCBcIi5jb25jYXQoYm90dG9tTGluZUNvbG9yKSxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAvLyBEb2luZyB0aGUgb3RoZXIgd2F5IGFyb3VuZCBjcmFzaCBvbiBJRSAxMSBcIicnXCIgaHR0cHM6Ly9naXRodWIuY29tL2Nzc2luanMvanNzL2lzc3Vlcy8yNDJcbiAgICAgICAgY29udGVudDogJ1wiXFxcXDAwYTBcIicsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgdHJhbnNpdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKCdib3JkZXItYm90dG9tLWNvbG9yJywge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVyXG4gICAgICAgIH0pLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScgLy8gVHJhbnNwYXJlbnQgdG8gdGhlIGhvdmVyIHN0eWxlLlxuXG4gICAgICB9LFxuICAgICAgJyY6aG92ZXI6YmVmb3JlJzoge1xuICAgICAgICBib3JkZXJCb3R0b206IFwiMXB4IHNvbGlkIFwiLmNvbmNhdCh0aGVtZS5wYWxldHRlLnRleHQucHJpbWFyeSlcbiAgICAgIH0sXG4gICAgICAnJiRkaXNhYmxlZDpiZWZvcmUnOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbVN0eWxlOiAnZG90dGVkJ1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIHRoZSBjb21wb25lbnQgaXMgZm9jdXNlZC4gKi9cbiAgICBmb2N1c2VkOiB7fSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVkPXt0cnVlfWAuICovXG4gICAgZGlzYWJsZWQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgc3RhcnRBZG9ybm1lbnRgIGlzIHByb3ZpZGVkLiAqL1xuICAgIGFkb3JuZWRTdGFydDoge1xuICAgICAgcGFkZGluZ0xlZnQ6IDEyXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGVuZEFkb3JubWVudGAgaXMgcHJvdmlkZWQuICovXG4gICAgYWRvcm5lZEVuZDoge1xuICAgICAgcGFkZGluZ1JpZ2h0OiAxMlxuICAgIH0sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBlcnJvcj17dHJ1ZX1gLiAqL1xuICAgIGVycm9yOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYG1hcmdpbj1cImRlbnNlXCJgLiAqL1xuICAgIG1hcmdpbkRlbnNlOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYG11bHRpbGluZT17dHJ1ZX1gLiAqL1xuICAgIG11bHRpbGluZToge1xuICAgICAgcGFkZGluZzogJzI3cHggMTJweCAxMHB4JyxcbiAgICAgICcmJG1hcmdpbkRlbnNlJzoge1xuICAgICAgICBwYWRkaW5nVG9wOiAyMyxcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogNlxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50LiAqL1xuICAgIGlucHV0OiB7XG4gICAgICBwYWRkaW5nOiAnMjdweCAxMnB4IDEwcHgnLFxuICAgICAgJyY6LXdlYmtpdC1hdXRvZmlsbCc6IHtcbiAgICAgICAgV2Via2l0Qm94U2hhZG93OiB0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCcgPyBudWxsIDogJzAgMCAwIDEwMHB4ICMyNjY3OTggaW5zZXQnLFxuICAgICAgICBXZWJraXRUZXh0RmlsbENvbG9yOiB0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCcgPyBudWxsIDogJyNmZmYnLFxuICAgICAgICBjYXJldENvbG9yOiB0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCcgPyBudWxsIDogJyNmZmYnLFxuICAgICAgICBib3JkZXJUb3BMZWZ0UmFkaXVzOiAnaW5oZXJpdCcsXG4gICAgICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiAnaW5oZXJpdCdcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgbWFyZ2luPVwiZGVuc2VcImAuICovXG4gICAgaW5wdXRNYXJnaW5EZW5zZToge1xuICAgICAgcGFkZGluZ1RvcDogMjMsXG4gICAgICBwYWRkaW5nQm90dG9tOiA2XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGlmIGluIGA8Rm9ybUNvbnRyb2wgaGlkZGVuTGFiZWwgLz5gLiAqL1xuICAgIGlucHV0SGlkZGVuTGFiZWw6IHtcbiAgICAgIHBhZGRpbmdUb3A6IDE4LFxuICAgICAgcGFkZGluZ0JvdHRvbTogMTksXG4gICAgICAnJiRpbnB1dE1hcmdpbkRlbnNlJzoge1xuICAgICAgICBwYWRkaW5nVG9wOiAxMCxcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogMTFcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgbXVsdGlsaW5lPXt0cnVlfWAuICovXG4gICAgaW5wdXRNdWx0aWxpbmU6IHtcbiAgICAgIHBhZGRpbmc6IDBcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgc3RhcnRBZG9ybm1lbnRgIGlzIHByb3ZpZGVkLiAqL1xuICAgIGlucHV0QWRvcm5lZFN0YXJ0OiB7XG4gICAgICBwYWRkaW5nTGVmdDogMFxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBlbmRBZG9ybm1lbnRgIGlzIHByb3ZpZGVkLiAqL1xuICAgIGlucHV0QWRvcm5lZEVuZDoge1xuICAgICAgcGFkZGluZ1JpZ2h0OiAwXG4gICAgfVxuICB9O1xufTtcbnZhciBGaWxsZWRJbnB1dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZpbGxlZElucHV0KHByb3BzLCByZWYpIHtcbiAgdmFyIGRpc2FibGVVbmRlcmxpbmUgPSBwcm9wcy5kaXNhYmxlVW5kZXJsaW5lLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBfcHJvcHMkZnVsbFdpZHRoID0gcHJvcHMuZnVsbFdpZHRoLFxuICAgICAgZnVsbFdpZHRoID0gX3Byb3BzJGZ1bGxXaWR0aCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZnVsbFdpZHRoLFxuICAgICAgX3Byb3BzJGlucHV0Q29tcG9uZW50ID0gcHJvcHMuaW5wdXRDb21wb25lbnQsXG4gICAgICBpbnB1dENvbXBvbmVudCA9IF9wcm9wcyRpbnB1dENvbXBvbmVudCA9PT0gdm9pZCAwID8gJ2lucHV0JyA6IF9wcm9wcyRpbnB1dENvbXBvbmVudCxcbiAgICAgIF9wcm9wcyRtdWx0aWxpbmUgPSBwcm9wcy5tdWx0aWxpbmUsXG4gICAgICBtdWx0aWxpbmUgPSBfcHJvcHMkbXVsdGlsaW5lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRtdWx0aWxpbmUsXG4gICAgICBfcHJvcHMkdHlwZSA9IHByb3BzLnR5cGUsXG4gICAgICB0eXBlID0gX3Byb3BzJHR5cGUgPT09IHZvaWQgMCA/ICd0ZXh0JyA6IF9wcm9wcyR0eXBlLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImRpc2FibGVVbmRlcmxpbmVcIiwgXCJjbGFzc2VzXCIsIFwiZnVsbFdpZHRoXCIsIFwiaW5wdXRDb21wb25lbnRcIiwgXCJtdWx0aWxpbmVcIiwgXCJ0eXBlXCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXRCYXNlLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NlczogX2V4dGVuZHMoe30sIGNsYXNzZXMsIHtcbiAgICAgIHJvb3Q6IGNsc3goY2xhc3Nlcy5yb290LCAhZGlzYWJsZVVuZGVybGluZSAmJiBjbGFzc2VzLnVuZGVybGluZSksXG4gICAgICB1bmRlcmxpbmU6IG51bGxcbiAgICB9KSxcbiAgICBmdWxsV2lkdGg6IGZ1bGxXaWR0aCxcbiAgICBpbnB1dENvbXBvbmVudDogaW5wdXRDb21wb25lbnQsXG4gICAgbXVsdGlsaW5lOiBtdWx0aWxpbmUsXG4gICAgcmVmOiByZWYsXG4gICAgdHlwZTogdHlwZVxuICB9LCBvdGhlcikpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBGaWxsZWRJbnB1dC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBUaGlzIHByb3AgaGVscHMgdXNlcnMgdG8gZmlsbCBmb3JtcyBmYXN0ZXIsIGVzcGVjaWFsbHkgb24gbW9iaWxlIGRldmljZXMuXG4gICAqIFRoZSBuYW1lIGNhbiBiZSBjb25mdXNpbmcsIGFzIGl0J3MgbW9yZSBsaWtlIGFuIGF1dG9maWxsLlxuICAgKiBZb3UgY2FuIGxlYXJuIG1vcmUgYWJvdXQgaXQgW2ZvbGxvd2luZyB0aGUgc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjYXV0b2ZpbGwpLlxuICAgKi9cbiAgYXV0b0NvbXBsZXRlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBgaW5wdXRgIGVsZW1lbnQgd2lsbCBiZSBmb2N1c2VkIGR1cmluZyB0aGUgZmlyc3QgbW91bnQuXG4gICAqL1xuICBhdXRvRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29tcG9uZW50LiBJdCBzdXBwb3J0cyB0aG9zZSB0aGVtZSBjb2xvcnMgdGhhdCBtYWtlIHNlbnNlIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoWydwcmltYXJ5JywgJ3NlY29uZGFyeSddKSxcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgYGlucHV0YCBlbGVtZW50IHZhbHVlLiBVc2Ugd2hlbiB0aGUgY29tcG9uZW50IGlzIG5vdCBjb250cm9sbGVkLlxuICAgKi9cbiAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMuYW55LFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBgaW5wdXRgIGVsZW1lbnQgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgaW5wdXQgd2lsbCBub3QgaGF2ZSBhbiB1bmRlcmxpbmUuXG4gICAqL1xuICBkaXNhYmxlVW5kZXJsaW5lOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogRW5kIGBJbnB1dEFkb3JubWVudGAgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgZW5kQWRvcm5tZW50OiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgaW5wdXQgd2lsbCBpbmRpY2F0ZSBhbiBlcnJvci4gVGhpcyBpcyBub3JtYWxseSBvYnRhaW5lZCB2aWEgY29udGV4dCBmcm9tXG4gICAqIEZvcm1Db250cm9sLlxuICAgKi9cbiAgZXJyb3I6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBpbnB1dCB3aWxsIHRha2UgdXAgdGhlIGZ1bGwgd2lkdGggb2YgaXRzIGNvbnRhaW5lci5cbiAgICovXG4gIGZ1bGxXaWR0aDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBpZCBvZiB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGlucHV0Q29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG5cbiAgLyoqXG4gICAqIFtBdHRyaWJ1dGVzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQjQXR0cmlidXRlcykgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgaW5wdXRQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogUGFzcyBhIHJlZiB0byB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgaW5wdXRSZWY6IHJlZlR5cGUsXG5cbiAgLyoqXG4gICAqIElmIGBkZW5zZWAsIHdpbGwgYWRqdXN0IHZlcnRpY2FsIHNwYWNpbmcuIFRoaXMgaXMgbm9ybWFsbHkgb2J0YWluZWQgdmlhIGNvbnRleHQgZnJvbVxuICAgKiBGb3JtQ29udHJvbC5cbiAgICovXG4gIG1hcmdpbjogUHJvcFR5cGVzLm9uZU9mKFsnZGVuc2UnLCAnbm9uZSddKSxcblxuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IHdoZW4gbXVsdGlsaW5lIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICovXG4gIG1heFJvd3M6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBhIHRleHRhcmVhIGVsZW1lbnQgd2lsbCBiZSByZW5kZXJlZC5cbiAgICovXG4gIG11bHRpbGluZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE5hbWUgYXR0cmlidXRlIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqIFlvdSBjYW4gcHVsbCBvdXQgdGhlIG5ldyB2YWx1ZSBieSBhY2Nlc3NpbmcgYGV2ZW50LnRhcmdldC52YWx1ZWAgKHN0cmluZykuXG4gICAqL1xuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIFRoZSBzaG9ydCBoaW50IGRpc3BsYXllZCBpbiB0aGUgaW5wdXQgYmVmb3JlIHRoZSB1c2VyIGVudGVycyBhIHZhbHVlLlxuICAgKi9cbiAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIEl0IHByZXZlbnRzIHRoZSB1c2VyIGZyb20gY2hhbmdpbmcgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZFxuICAgKiAobm90IGZyb20gaW50ZXJhY3Rpbmcgd2l0aCB0aGUgZmllbGQpLlxuICAgKi9cbiAgcmVhZE9ubHk6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBgaW5wdXRgIGVsZW1lbnQgd2lsbCBiZSByZXF1aXJlZC5cbiAgICovXG4gIHJlcXVpcmVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheSB3aGVuIG11bHRpbGluZSBvcHRpb24gaXMgc2V0IHRvIHRydWUuXG4gICAqL1xuICByb3dzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIFN0YXJ0IGBJbnB1dEFkb3JubWVudGAgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgc3RhcnRBZG9ybm1lbnQ6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBUeXBlIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuIEl0IHNob3VsZCBiZSBbYSB2YWxpZCBIVE1MNSBpbnB1dCB0eXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQjRm9ybV8lM0NpbnB1dCUzRV90eXBlcykuXG4gICAqL1xuICB0eXBlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudCwgcmVxdWlyZWQgZm9yIGEgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAqL1xuICB2YWx1ZTogUHJvcFR5cGVzLmFueVxufSA6IHZvaWQgMDtcbkZpbGxlZElucHV0Lm11aU5hbWUgPSAnSW5wdXQnO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aUZpbGxlZElucHV0J1xufSkoRmlsbGVkSW5wdXQpOyIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5pbXBvcnQgdXNlVGhlbWUgZnJvbSAnLi4vc3R5bGVzL3VzZVRoZW1lJztcbmltcG9ydCBjYXBpdGFsaXplIGZyb20gJy4uL3V0aWxzL2NhcGl0YWxpemUnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICAgIHJvb3Q6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IC01LFxuICAgICAgbGVmdDogMCxcbiAgICAgIG1hcmdpbjogMCxcbiAgICAgIHBhZGRpbmc6ICcwIDhweCcsXG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICBib3JkZXJSYWRpdXM6ICdpbmhlcml0JyxcbiAgICAgIGJvcmRlclN0eWxlOiAnc29saWQnLFxuICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGxlZ2VuZCBlbGVtZW50IHdoZW4gYGxhYmVsV2lkdGhgIGlzIHByb3ZpZGVkLiAqL1xuICAgIGxlZ2VuZDoge1xuICAgICAgdGV4dEFsaWduOiAnbGVmdCcsXG4gICAgICBwYWRkaW5nOiAwLFxuICAgICAgbGluZUhlaWdodDogJzExcHgnLFxuICAgICAgLy8gc3luYyB3aXRoIGBoZWlnaHRgIGluIGBsZWdlbmRgIHN0eWxlc1xuICAgICAgdHJhbnNpdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKCd3aWR0aCcsIHtcbiAgICAgICAgZHVyYXRpb246IDE1MCxcbiAgICAgICAgZWFzaW5nOiB0aGVtZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZU91dFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGxlZ2VuZCBlbGVtZW50LiAqL1xuICAgIGxlZ2VuZExhYmVsbGVkOiB7XG4gICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgd2lkdGg6ICdhdXRvJyxcbiAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIGhlaWdodDogMTEsXG4gICAgICAvLyBzeW5jIHdpdGggYGxpbmVIZWlnaHRgIGluIGBsZWdlbmRgIHN0eWxlc1xuICAgICAgZm9udFNpemU6ICcwLjc1ZW0nLFxuICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgICBtYXhXaWR0aDogMC4wMSxcbiAgICAgIHRyYW5zaXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgnbWF4LXdpZHRoJywge1xuICAgICAgICBkdXJhdGlvbjogNTAsXG4gICAgICAgIGVhc2luZzogdGhlbWUudHJhbnNpdGlvbnMuZWFzaW5nLmVhc2VPdXRcbiAgICAgIH0pLFxuICAgICAgJyYgPiBzcGFuJzoge1xuICAgICAgICBwYWRkaW5nTGVmdDogNSxcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiA1LFxuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJ1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgbGVnZW5kIGVsZW1lbnQgaXMgbm90Y2hlZC4gKi9cbiAgICBsZWdlbmROb3RjaGVkOiB7XG4gICAgICBtYXhXaWR0aDogMTAwMCxcbiAgICAgIHRyYW5zaXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgnbWF4LXdpZHRoJywge1xuICAgICAgICBkdXJhdGlvbjogMTAwLFxuICAgICAgICBlYXNpbmc6IHRoZW1lLnRyYW5zaXRpb25zLmVhc2luZy5lYXNlT3V0LFxuICAgICAgICBkZWxheTogNTBcbiAgICAgIH0pXG4gICAgfVxuICB9O1xufTtcbi8qKlxuICogQGlnbm9yZSAtIGludGVybmFsIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgTm90Y2hlZE91dGxpbmUgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBOb3RjaGVkT3V0bGluZShwcm9wcywgcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBsYWJlbCA9IHByb3BzLmxhYmVsLFxuICAgICAgbGFiZWxXaWR0aFByb3AgPSBwcm9wcy5sYWJlbFdpZHRoLFxuICAgICAgbm90Y2hlZCA9IHByb3BzLm5vdGNoZWQsXG4gICAgICBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcImxhYmVsXCIsIFwibGFiZWxXaWR0aFwiLCBcIm5vdGNoZWRcIiwgXCJzdHlsZVwiXSk7XG5cbiAgdmFyIHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgdmFyIGFsaWduID0gdGhlbWUuZGlyZWN0aW9uID09PSAncnRsJyA/ICdyaWdodCcgOiAnbGVmdCc7XG5cbiAgaWYgKGxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiLCBfZXh0ZW5kcyh7XG4gICAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUpLFxuICAgICAgcmVmOiByZWYsXG4gICAgICBzdHlsZTogc3R5bGVcbiAgICB9LCBvdGhlciksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibGVnZW5kXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLmxlZ2VuZExhYmVsbGVkLCBub3RjaGVkICYmIGNsYXNzZXMubGVnZW5kTm90Y2hlZClcbiAgICB9LCBsYWJlbCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBsYWJlbCkgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgX19odG1sOiAnJiM4MjAzOydcbiAgICAgIH1cbiAgICB9KSkpO1xuICB9XG5cbiAgdmFyIGxhYmVsV2lkdGggPSBsYWJlbFdpZHRoUHJvcCA+IDAgPyBsYWJlbFdpZHRoUHJvcCAqIDAuNzUgKyA4IDogMC4wMTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIiwgX2V4dGVuZHMoe1xuICAgIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSxcbiAgICBzdHlsZTogX2V4dGVuZHMoX2RlZmluZVByb3BlcnR5KHt9LCBcInBhZGRpbmdcIi5jb25jYXQoY2FwaXRhbGl6ZShhbGlnbikpLCA4KSwgc3R5bGUpLFxuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSksXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxlZ2VuZFwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzLmxlZ2VuZCxcbiAgICBzdHlsZToge1xuICAgICAgLy8gSUUgMTE6IGZpZWxkc2V0IHdpdGggbGVnZW5kIGRvZXMgbm90IHJlbmRlclxuICAgICAgLy8gYSBib3JkZXIgcmFkaXVzLiBUaGlzIG1haW50YWlucyBjb25zaXN0ZW5jeVxuICAgICAgLy8gYnkgYWx3YXlzIGhhdmluZyBhIGxlZ2VuZCByZW5kZXJlZFxuICAgICAgd2lkdGg6IG5vdGNoZWQgPyBsYWJlbFdpZHRoIDogMC4wMVxuICAgIH1cbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgX19odG1sOiAnJiM4MjAzOydcbiAgICB9XG4gIH0pKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IE5vdGNoZWRPdXRsaW5lLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgbGFiZWwuXG4gICAqL1xuICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBvZiB0aGUgbGFiZWwuXG4gICAqL1xuICBsYWJlbFdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIG91dGxpbmUgaXMgbm90Y2hlZCB0byBhY2NvbW1vZGF0ZSB0aGUgbGFiZWwuXG4gICAqL1xuICBub3RjaGVkOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdFxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdQcml2YXRlTm90Y2hlZE91dGxpbmUnXG59KShOb3RjaGVkT3V0bGluZSk7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHsgcmVmVHlwZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgSW5wdXRCYXNlIGZyb20gJy4uL0lucHV0QmFzZSc7XG5pbXBvcnQgTm90Y2hlZE91dGxpbmUgZnJvbSAnLi9Ob3RjaGVkT3V0bGluZSc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICB2YXIgYm9yZGVyQ29sb3IgPSB0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCcgPyAncmdiYSgwLCAwLCAwLCAwLjIzKScgOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIzKSc7XG4gIHJldHVybiB7XG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgICByb290OiB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIGJvcmRlclJhZGl1czogdGhlbWUuc2hhcGUuYm9yZGVyUmFkaXVzLFxuICAgICAgJyY6aG92ZXIgJG5vdGNoZWRPdXRsaW5lJzoge1xuICAgICAgICBib3JkZXJDb2xvcjogdGhlbWUucGFsZXR0ZS50ZXh0LnByaW1hcnlcbiAgICAgIH0sXG4gICAgICAvLyBSZXNldCBvbiB0b3VjaCBkZXZpY2VzLCBpdCBkb2Vzbid0IGFkZCBzcGVjaWZpY2l0eVxuICAgICAgJ0BtZWRpYSAoaG92ZXI6IG5vbmUpJzoge1xuICAgICAgICAnJjpob3ZlciAkbm90Y2hlZE91dGxpbmUnOiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IGJvcmRlckNvbG9yXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnJiRmb2N1c2VkICRub3RjaGVkT3V0bGluZSc6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6IHRoZW1lLnBhbGV0dGUucHJpbWFyeS5tYWluLFxuICAgICAgICBib3JkZXJXaWR0aDogMlxuICAgICAgfSxcbiAgICAgICcmJGVycm9yICRub3RjaGVkT3V0bGluZSc6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6IHRoZW1lLnBhbGV0dGUuZXJyb3IubWFpblxuICAgICAgfSxcbiAgICAgICcmJGRpc2FibGVkICRub3RjaGVkT3V0bGluZSc6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6IHRoZW1lLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgdGhlIGNvbG9yIGlzIHNlY29uZGFyeS4gKi9cbiAgICBjb2xvclNlY29uZGFyeToge1xuICAgICAgJyYkZm9jdXNlZCAkbm90Y2hlZE91dGxpbmUnOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiB0aGVtZS5wYWxldHRlLnNlY29uZGFyeS5tYWluXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgdGhlIGNvbXBvbmVudCBpcyBmb2N1c2VkLiAqL1xuICAgIGZvY3VzZWQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZGlzYWJsZWQ9e3RydWV9YC4gKi9cbiAgICBkaXNhYmxlZDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBzdGFydEFkb3JubWVudGAgaXMgcHJvdmlkZWQuICovXG4gICAgYWRvcm5lZFN0YXJ0OiB7XG4gICAgICBwYWRkaW5nTGVmdDogMTRcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZW5kQWRvcm5tZW50YCBpcyBwcm92aWRlZC4gKi9cbiAgICBhZG9ybmVkRW5kOiB7XG4gICAgICBwYWRkaW5nUmlnaHQ6IDE0XG4gICAgfSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGVycm9yPXt0cnVlfWAuICovXG4gICAgZXJyb3I6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgbWFyZ2luPVwiZGVuc2VcImAuICovXG4gICAgbWFyZ2luRGVuc2U6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgbXVsdGlsaW5lPXt0cnVlfWAuICovXG4gICAgbXVsdGlsaW5lOiB7XG4gICAgICBwYWRkaW5nOiAnMTguNXB4IDE0cHgnLFxuICAgICAgJyYkbWFyZ2luRGVuc2UnOiB7XG4gICAgICAgIHBhZGRpbmdUb3A6IDEwLjUsXG4gICAgICAgIHBhZGRpbmdCb3R0b206IDEwLjVcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBOb3RjaGVkT3V0bGluZWAgZWxlbWVudC4gKi9cbiAgICBub3RjaGVkT3V0bGluZToge1xuICAgICAgYm9yZGVyQ29sb3I6IGJvcmRlckNvbG9yXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuICovXG4gICAgaW5wdXQ6IHtcbiAgICAgIHBhZGRpbmc6ICcxOC41cHggMTRweCcsXG4gICAgICAnJjotd2Via2l0LWF1dG9maWxsJzoge1xuICAgICAgICBXZWJraXRCb3hTaGFkb3c6IHRoZW1lLnBhbGV0dGUudHlwZSA9PT0gJ2xpZ2h0JyA/IG51bGwgOiAnMCAwIDAgMTAwcHggIzI2Njc5OCBpbnNldCcsXG4gICAgICAgIFdlYmtpdFRleHRGaWxsQ29sb3I6IHRoZW1lLnBhbGV0dGUudHlwZSA9PT0gJ2xpZ2h0JyA/IG51bGwgOiAnI2ZmZicsXG4gICAgICAgIGNhcmV0Q29sb3I6IHRoZW1lLnBhbGV0dGUudHlwZSA9PT0gJ2xpZ2h0JyA/IG51bGwgOiAnI2ZmZicsXG4gICAgICAgIGJvcmRlclJhZGl1czogJ2luaGVyaXQnXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYG1hcmdpbj1cImRlbnNlXCJgLiAqL1xuICAgIGlucHV0TWFyZ2luRGVuc2U6IHtcbiAgICAgIHBhZGRpbmdUb3A6IDEwLjUsXG4gICAgICBwYWRkaW5nQm90dG9tOiAxMC41XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYG11bHRpbGluZT17dHJ1ZX1gLiAqL1xuICAgIGlucHV0TXVsdGlsaW5lOiB7XG4gICAgICBwYWRkaW5nOiAwXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgaWYgYHN0YXJ0QWRvcm5tZW50YCBpcyBwcm92aWRlZC4gKi9cbiAgICBpbnB1dEFkb3JuZWRTdGFydDoge1xuICAgICAgcGFkZGluZ0xlZnQ6IDBcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgZW5kQWRvcm5tZW50YCBpcyBwcm92aWRlZC4gKi9cbiAgICBpbnB1dEFkb3JuZWRFbmQ6IHtcbiAgICAgIHBhZGRpbmdSaWdodDogMFxuICAgIH1cbiAgfTtcbn07XG52YXIgT3V0bGluZWRJbnB1dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIE91dGxpbmVkSW5wdXQocHJvcHMsIHJlZikge1xuICB2YXIgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBfcHJvcHMkZnVsbFdpZHRoID0gcHJvcHMuZnVsbFdpZHRoLFxuICAgICAgZnVsbFdpZHRoID0gX3Byb3BzJGZ1bGxXaWR0aCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZnVsbFdpZHRoLFxuICAgICAgX3Byb3BzJGlucHV0Q29tcG9uZW50ID0gcHJvcHMuaW5wdXRDb21wb25lbnQsXG4gICAgICBpbnB1dENvbXBvbmVudCA9IF9wcm9wcyRpbnB1dENvbXBvbmVudCA9PT0gdm9pZCAwID8gJ2lucHV0JyA6IF9wcm9wcyRpbnB1dENvbXBvbmVudCxcbiAgICAgIGxhYmVsID0gcHJvcHMubGFiZWwsXG4gICAgICBfcHJvcHMkbGFiZWxXaWR0aCA9IHByb3BzLmxhYmVsV2lkdGgsXG4gICAgICBsYWJlbFdpZHRoID0gX3Byb3BzJGxhYmVsV2lkdGggPT09IHZvaWQgMCA/IDAgOiBfcHJvcHMkbGFiZWxXaWR0aCxcbiAgICAgIF9wcm9wcyRtdWx0aWxpbmUgPSBwcm9wcy5tdWx0aWxpbmUsXG4gICAgICBtdWx0aWxpbmUgPSBfcHJvcHMkbXVsdGlsaW5lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRtdWx0aWxpbmUsXG4gICAgICBub3RjaGVkID0gcHJvcHMubm90Y2hlZCxcbiAgICAgIF9wcm9wcyR0eXBlID0gcHJvcHMudHlwZSxcbiAgICAgIHR5cGUgPSBfcHJvcHMkdHlwZSA9PT0gdm9pZCAwID8gJ3RleHQnIDogX3Byb3BzJHR5cGUsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2xhc3Nlc1wiLCBcImZ1bGxXaWR0aFwiLCBcImlucHV0Q29tcG9uZW50XCIsIFwibGFiZWxcIiwgXCJsYWJlbFdpZHRoXCIsIFwibXVsdGlsaW5lXCIsIFwibm90Y2hlZFwiLCBcInR5cGVcIl0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJbnB1dEJhc2UsIF9leHRlbmRzKHtcbiAgICByZW5kZXJTdWZmaXg6IGZ1bmN0aW9uIHJlbmRlclN1ZmZpeChzdGF0ZSkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE5vdGNoZWRPdXRsaW5lLCB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5ub3RjaGVkT3V0bGluZSxcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBsYWJlbFdpZHRoOiBsYWJlbFdpZHRoLFxuICAgICAgICBub3RjaGVkOiB0eXBlb2Ygbm90Y2hlZCAhPT0gJ3VuZGVmaW5lZCcgPyBub3RjaGVkIDogQm9vbGVhbihzdGF0ZS5zdGFydEFkb3JubWVudCB8fCBzdGF0ZS5maWxsZWQgfHwgc3RhdGUuZm9jdXNlZClcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY2xhc3NlczogX2V4dGVuZHMoe30sIGNsYXNzZXMsIHtcbiAgICAgIHJvb3Q6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc2VzLnVuZGVybGluZSksXG4gICAgICBub3RjaGVkT3V0bGluZTogbnVsbFxuICAgIH0pLFxuICAgIGZ1bGxXaWR0aDogZnVsbFdpZHRoLFxuICAgIGlucHV0Q29tcG9uZW50OiBpbnB1dENvbXBvbmVudCxcbiAgICBtdWx0aWxpbmU6IG11bHRpbGluZSxcbiAgICByZWY6IHJlZixcbiAgICB0eXBlOiB0eXBlXG4gIH0sIG90aGVyKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IE91dGxpbmVkSW5wdXQucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogVGhpcyBwcm9wIGhlbHBzIHVzZXJzIHRvIGZpbGwgZm9ybXMgZmFzdGVyLCBlc3BlY2lhbGx5IG9uIG1vYmlsZSBkZXZpY2VzLlxuICAgKiBUaGUgbmFtZSBjYW4gYmUgY29uZnVzaW5nLCBhcyBpdCdzIG1vcmUgbGlrZSBhbiBhdXRvZmlsbC5cbiAgICogWW91IGNhbiBsZWFybiBtb3JlIGFib3V0IGl0IFtmb2xsb3dpbmcgdGhlIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI2F1dG9maWxsKS5cbiAgICovXG4gIGF1dG9Db21wbGV0ZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYGlucHV0YCBlbGVtZW50IHdpbGwgYmUgZm9jdXNlZCBkdXJpbmcgdGhlIGZpcnN0IG1vdW50LlxuICAgKi9cbiAgYXV0b0ZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2YgdGhlIGNvbXBvbmVudC4gSXQgc3VwcG9ydHMgdGhvc2UgdGhlbWUgY29sb3JzIHRoYXQgbWFrZSBzZW5zZSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsncHJpbWFyeScsICdzZWNvbmRhcnknXSksXG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGBpbnB1dGAgZWxlbWVudCB2YWx1ZS4gVXNlIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBub3QgY29udHJvbGxlZC5cbiAgICovXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLmFueSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYGlucHV0YCBlbGVtZW50IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEVuZCBgSW5wdXRBZG9ybm1lbnRgIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICovXG4gIGVuZEFkb3JubWVudDogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGlucHV0IHdpbGwgaW5kaWNhdGUgYW4gZXJyb3IuIFRoaXMgaXMgbm9ybWFsbHkgb2J0YWluZWQgdmlhIGNvbnRleHQgZnJvbVxuICAgKiBGb3JtQ29udHJvbC5cbiAgICovXG4gIGVycm9yOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgaW5wdXQgd2lsbCB0YWtlIHVwIHRoZSBmdWxsIHdpZHRoIG9mIGl0cyBjb250YWluZXIuXG4gICAqL1xuICBmdWxsV2lkdGg6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgaWQgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBpbnB1dENvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBbQXR0cmlidXRlc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0I0F0dHJpYnV0ZXMpIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGlucHV0UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFBhc3MgYSByZWYgdG8gdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGlucHV0UmVmOiByZWZUeXBlLFxuXG4gIC8qKlxuICAgKiBUaGUgbGFiZWwgb2YgdGhlIGlucHV0LiBJdCBpcyBvbmx5IHVzZWQgZm9yIGxheW91dC4gVGhlIGFjdHVhbCBsYWJlbGxpbmdcbiAgICogaXMgaGFuZGxlZCBieSBgSW5wdXRMYWJlbGAuIElmIHNwZWNpZmllZCBgbGFiZWxXaWR0aGAgaXMgaWdub3JlZC5cbiAgICovXG4gIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBsYWJlbC4gSXMgaWdub3JlZCBpZiBgbGFiZWxgIGlzIHByb3ZpZGVkLiBQcmVmZXIgYGxhYmVsYFxuICAgKiBpZiB0aGUgaW5wdXQgbGFiZWwgYXBwZWFycyB3aXRoIGEgc3RyaWtlIHRocm91Z2guXG4gICAqL1xuICBsYWJlbFdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBJZiBgZGVuc2VgLCB3aWxsIGFkanVzdCB2ZXJ0aWNhbCBzcGFjaW5nLiBUaGlzIGlzIG5vcm1hbGx5IG9idGFpbmVkIHZpYSBjb250ZXh0IGZyb21cbiAgICogRm9ybUNvbnRyb2wuXG4gICAqL1xuICBtYXJnaW46IFByb3BUeXBlcy5vbmVPZihbJ2RlbnNlJywgJ25vbmUnXSksXG5cbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheSB3aGVuIG11bHRpbGluZSBvcHRpb24gaXMgc2V0IHRvIHRydWUuXG4gICAqL1xuICBtYXhSb3dzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgYSB0ZXh0YXJlYSBlbGVtZW50IHdpbGwgYmUgcmVuZGVyZWQuXG4gICAqL1xuICBtdWx0aWxpbmU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBOYW1lIGF0dHJpYnV0ZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgb3V0bGluZSBpcyBub3RjaGVkIHRvIGFjY29tbW9kYXRlIHRoZSBsYWJlbC5cbiAgICovXG4gIG5vdGNoZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqIFlvdSBjYW4gcHVsbCBvdXQgdGhlIG5ldyB2YWx1ZSBieSBhY2Nlc3NpbmcgYGV2ZW50LnRhcmdldC52YWx1ZWAgKHN0cmluZykuXG4gICAqL1xuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIFRoZSBzaG9ydCBoaW50IGRpc3BsYXllZCBpbiB0aGUgaW5wdXQgYmVmb3JlIHRoZSB1c2VyIGVudGVycyBhIHZhbHVlLlxuICAgKi9cbiAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIEl0IHByZXZlbnRzIHRoZSB1c2VyIGZyb20gY2hhbmdpbmcgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZFxuICAgKiAobm90IGZyb20gaW50ZXJhY3Rpbmcgd2l0aCB0aGUgZmllbGQpLlxuICAgKi9cbiAgcmVhZE9ubHk6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBgaW5wdXRgIGVsZW1lbnQgd2lsbCBiZSByZXF1aXJlZC5cbiAgICovXG4gIHJlcXVpcmVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheSB3aGVuIG11bHRpbGluZSBvcHRpb24gaXMgc2V0IHRvIHRydWUuXG4gICAqL1xuICByb3dzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIFN0YXJ0IGBJbnB1dEFkb3JubWVudGAgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgc3RhcnRBZG9ybm1lbnQ6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBUeXBlIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuIEl0IHNob3VsZCBiZSBbYSB2YWxpZCBIVE1MNSBpbnB1dCB0eXBlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQjRm9ybV8lM0NpbnB1dCUzRV90eXBlcykuXG4gICAqL1xuICB0eXBlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudCwgcmVxdWlyZWQgZm9yIGEgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAqL1xuICB2YWx1ZTogUHJvcFR5cGVzLmFueVxufSA6IHZvaWQgMDtcbk91dGxpbmVkSW5wdXQubXVpTmFtZSA9ICdJbnB1dCc7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpT3V0bGluZWRJbnB1dCdcbn0pKE91dGxpbmVkSW5wdXQpOyIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBGb3JtQ29udHJvbENvbnRleHQgZnJvbSAnLi9Gb3JtQ29udHJvbENvbnRleHQnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlRm9ybUNvbnRyb2woKSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KEZvcm1Db250cm9sQ29udGV4dCk7XG59IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IGZvcm1Db250cm9sU3RhdGUgZnJvbSAnLi4vRm9ybUNvbnRyb2wvZm9ybUNvbnRyb2xTdGF0ZSc7XG5pbXBvcnQgdXNlRm9ybUNvbnRyb2wgZnJvbSAnLi4vRm9ybUNvbnRyb2wvdXNlRm9ybUNvbnRyb2wnO1xuaW1wb3J0IGNhcGl0YWxpemUgZnJvbSAnLi4vdXRpbHMvY2FwaXRhbGl6ZSc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gICAgcm9vdDogX2V4dGVuZHMoe1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudGV4dC5zZWNvbmRhcnlcbiAgICB9LCB0aGVtZS50eXBvZ3JhcGh5LmJvZHkxLCB7XG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgICcmJGZvY3VzZWQnOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnByaW1hcnkubWFpblxuICAgICAgfSxcbiAgICAgICcmJGRpc2FibGVkJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS50ZXh0LmRpc2FibGVkXG4gICAgICB9LFxuICAgICAgJyYkZXJyb3InOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmVycm9yLm1haW5cbiAgICAgIH1cbiAgICB9KSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgdGhlIGNvbG9yIGlzIHNlY29uZGFyeS4gKi9cbiAgICBjb2xvclNlY29uZGFyeToge1xuICAgICAgJyYkZm9jdXNlZCc6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuc2Vjb25kYXJ5Lm1haW5cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZm9jdXNlZD17dHJ1ZX1gLiAqL1xuICAgIGZvY3VzZWQ6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZGlzYWJsZWQ9e3RydWV9YC4gKi9cbiAgICBkaXNhYmxlZDoge30sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBlcnJvcj17dHJ1ZX1gLiAqL1xuICAgIGVycm9yOiB7fSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGZpbGxlZD17dHJ1ZX1gLiAqL1xuICAgIGZpbGxlZDoge30sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGByZXF1aXJlZD17dHJ1ZX1gLiAqL1xuICAgIHJlcXVpcmVkOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBhc3RlcmlzayBlbGVtZW50LiAqL1xuICAgIGFzdGVyaXNrOiB7XG4gICAgICAnJiRlcnJvcic6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuZXJyb3IubWFpblxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG52YXIgRm9ybUxhYmVsID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gRm9ybUxhYmVsKHByb3BzLCByZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNvbG9yID0gcHJvcHMuY29sb3IsXG4gICAgICBfcHJvcHMkY29tcG9uZW50ID0gcHJvcHMuY29tcG9uZW50LFxuICAgICAgQ29tcG9uZW50ID0gX3Byb3BzJGNvbXBvbmVudCA9PT0gdm9pZCAwID8gJ2xhYmVsJyA6IF9wcm9wcyRjb21wb25lbnQsXG4gICAgICBkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkLFxuICAgICAgZXJyb3IgPSBwcm9wcy5lcnJvcixcbiAgICAgIGZpbGxlZCA9IHByb3BzLmZpbGxlZCxcbiAgICAgIGZvY3VzZWQgPSBwcm9wcy5mb2N1c2VkLFxuICAgICAgcmVxdWlyZWQgPSBwcm9wcy5yZXF1aXJlZCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjb2xvclwiLCBcImNvbXBvbmVudFwiLCBcImRpc2FibGVkXCIsIFwiZXJyb3JcIiwgXCJmaWxsZWRcIiwgXCJmb2N1c2VkXCIsIFwicmVxdWlyZWRcIl0pO1xuXG4gIHZhciBtdWlGb3JtQ29udHJvbCA9IHVzZUZvcm1Db250cm9sKCk7XG4gIHZhciBmY3MgPSBmb3JtQ29udHJvbFN0YXRlKHtcbiAgICBwcm9wczogcHJvcHMsXG4gICAgbXVpRm9ybUNvbnRyb2w6IG11aUZvcm1Db250cm9sLFxuICAgIHN0YXRlczogWydjb2xvcicsICdyZXF1aXJlZCcsICdmb2N1c2VkJywgJ2Rpc2FibGVkJywgJ2Vycm9yJywgJ2ZpbGxlZCddXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3Nlc1tcImNvbG9yXCIuY29uY2F0KGNhcGl0YWxpemUoZmNzLmNvbG9yIHx8ICdwcmltYXJ5JykpXSwgY2xhc3NOYW1lLCBmY3MuZGlzYWJsZWQgJiYgY2xhc3Nlcy5kaXNhYmxlZCwgZmNzLmVycm9yICYmIGNsYXNzZXMuZXJyb3IsIGZjcy5maWxsZWQgJiYgY2xhc3Nlcy5maWxsZWQsIGZjcy5mb2N1c2VkICYmIGNsYXNzZXMuZm9jdXNlZCwgZmNzLnJlcXVpcmVkICYmIGNsYXNzZXMucmVxdWlyZWQpLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSwgY2hpbGRyZW4sIGZjcy5yZXF1aXJlZCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSxcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5hc3RlcmlzaywgZmNzLmVycm9yICYmIGNsYXNzZXMuZXJyb3IpXG4gIH0sIFwiXFx1MjAwOVwiLCAnKicpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gRm9ybUxhYmVsLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2YgdGhlIGNvbXBvbmVudC4gSXQgc3VwcG9ydHMgdGhvc2UgdGhlbWUgY29sb3JzIHRoYXQgbWFrZSBzZW5zZSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsncHJpbWFyeScsICdzZWNvbmRhcnknXSksXG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBsYWJlbCBzaG91bGQgYmUgZGlzcGxheWVkIGluIGEgZGlzYWJsZWQgc3RhdGUuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxhYmVsIHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gYW4gZXJyb3Igc3RhdGUuXG4gICAqL1xuICBlcnJvcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxhYmVsIHNob3VsZCB1c2UgZmlsbGVkIGNsYXNzZXMga2V5LlxuICAgKi9cbiAgZmlsbGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgaW5wdXQgb2YgdGhpcyBsYWJlbCBpcyBmb2N1c2VkICh1c2VkIGJ5IGBGb3JtR3JvdXBgIGNvbXBvbmVudHMpLlxuICAgKi9cbiAgZm9jdXNlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxhYmVsIHdpbGwgaW5kaWNhdGUgdGhhdCB0aGUgaW5wdXQgaXMgcmVxdWlyZWQuXG4gICAqL1xuICByZXF1aXJlZDogUHJvcFR5cGVzLmJvb2xcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpRm9ybUxhYmVsJ1xufSkoRm9ybUxhYmVsKTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgZm9ybUNvbnRyb2xTdGF0ZSBmcm9tICcuLi9Gb3JtQ29udHJvbC9mb3JtQ29udHJvbFN0YXRlJztcbmltcG9ydCB1c2VGb3JtQ29udHJvbCBmcm9tICcuLi9Gb3JtQ29udHJvbC91c2VGb3JtQ29udHJvbCc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5pbXBvcnQgRm9ybUxhYmVsIGZyb20gJy4uL0Zvcm1MYWJlbCc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gICAgcm9vdDoge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjogJ3RvcCBsZWZ0J1xuICAgIH0sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBmb2N1c2VkPXt0cnVlfWAuICovXG4gICAgZm9jdXNlZDoge30sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBkaXNhYmxlZD17dHJ1ZX1gLiAqL1xuICAgIGRpc2FibGVkOiB7fSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGVycm9yPXt0cnVlfWAuICovXG4gICAgZXJyb3I6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgcmVxdWlyZWQ9e3RydWV9YC4gKi9cbiAgICByZXF1aXJlZDoge30sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgYXN0ZXJpc2sgZWxlbWVudC4gKi9cbiAgICBhc3Rlcmlzazoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIHRoZSBjb21wb25lbnQgaXMgYSBkZXNjZW5kYW50IG9mIGBGb3JtQ29udHJvbGAuICovXG4gICAgZm9ybUNvbnRyb2w6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIC8vIHNsaWdodCBhbHRlcmF0aW9uIHRvIHNwZWMgc3BhY2luZyB0byBtYXRjaCB2aXN1YWwgc3BlYyByZXN1bHRcbiAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgwLCAyNHB4KSBzY2FsZSgxKSdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgbWFyZ2luPVwiZGVuc2VcImAuICovXG4gICAgbWFyZ2luRGVuc2U6IHtcbiAgICAgIC8vIENvbXBlbnNhdGlvbiBmb3IgdGhlIGBJbnB1dC5pbnB1dERlbnNlYCBzdHlsZS5cbiAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgwLCAyMXB4KSBzY2FsZSgxKSdcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudCBpZiBgc2hyaW5rPXt0cnVlfWAuICovXG4gICAgc2hyaW5rOiB7XG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwgMS41cHgpIHNjYWxlKDAuNzUpJyxcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjogJ3RvcCBsZWZ0J1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYGlucHV0YCBlbGVtZW50IGlmIGBkaXNhYmxlQW5pbWF0aW9uPXtmYWxzZX1gLiAqL1xuICAgIGFuaW1hdGVkOiB7XG4gICAgICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoWydjb2xvcicsICd0cmFuc2Zvcm0nXSwge1xuICAgICAgICBkdXJhdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlcixcbiAgICAgICAgZWFzaW5nOiB0aGVtZS50cmFuc2l0aW9ucy5lYXNpbmcuZWFzZU91dFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cImZpbGxlZFwiYC4gKi9cbiAgICBmaWxsZWQ6IHtcbiAgICAgIC8vIENocm9tZSdzIGF1dG9maWxsIGZlYXR1cmUgZ2l2ZXMgdGhlIGlucHV0IGZpZWxkIGEgeWVsbG93IGJhY2tncm91bmQuXG4gICAgICAvLyBTaW5jZSB0aGUgaW5wdXQgZmllbGQgaXMgYmVoaW5kIHRoZSBsYWJlbCBpbiB0aGUgSFRNTCB0cmVlLFxuICAgICAgLy8gdGhlIGlucHV0IGZpZWxkIGlzIGRyYXduIGxhc3QgYW5kIGhpZGVzIHRoZSBsYWJlbCB3aXRoIGFuIG9wYXF1ZSBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgICAgLy8gekluZGV4OiAxIHdpbGwgcmFpc2UgdGhlIGxhYmVsIGFib3ZlIG9wYXF1ZSBiYWNrZ3JvdW5kLWNvbG9ycyBvZiBpbnB1dC5cbiAgICAgIHpJbmRleDogMSxcbiAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgxMnB4LCAyMHB4KSBzY2FsZSgxKScsXG4gICAgICAnJiRtYXJnaW5EZW5zZSc6IHtcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDEycHgsIDE3cHgpIHNjYWxlKDEpJ1xuICAgICAgfSxcbiAgICAgICcmJHNocmluayc6IHtcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDEycHgsIDEwcHgpIHNjYWxlKDAuNzUpJyxcbiAgICAgICAgJyYkbWFyZ2luRGVuc2UnOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDEycHgsIDdweCkgc2NhbGUoMC43NSknXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cIm91dGxpbmVkXCJgLiAqL1xuICAgIG91dGxpbmVkOiB7XG4gICAgICAvLyBzZWUgY29tbWVudCBhYm92ZSBvbiBmaWxsZWQuekluZGV4XG4gICAgICB6SW5kZXg6IDEsXG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMTRweCwgMjBweCkgc2NhbGUoMSknLFxuICAgICAgJyYkbWFyZ2luRGVuc2UnOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgxNHB4LCAxMnB4KSBzY2FsZSgxKSdcbiAgICAgIH0sXG4gICAgICAnJiRzaHJpbmsnOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgxNHB4LCAtNnB4KSBzY2FsZSgwLjc1KSdcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xudmFyIElucHV0TGFiZWwgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBJbnB1dExhYmVsKHByb3BzLCByZWYpIHtcbiAgdmFyIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgX3Byb3BzJGRpc2FibGVBbmltYXRpID0gcHJvcHMuZGlzYWJsZUFuaW1hdGlvbixcbiAgICAgIGRpc2FibGVBbmltYXRpb24gPSBfcHJvcHMkZGlzYWJsZUFuaW1hdGkgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVBbmltYXRpLFxuICAgICAgbWFyZ2luID0gcHJvcHMubWFyZ2luLFxuICAgICAgc2hyaW5rUHJvcCA9IHByb3BzLnNocmluayxcbiAgICAgIHZhcmlhbnQgPSBwcm9wcy52YXJpYW50LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJkaXNhYmxlQW5pbWF0aW9uXCIsIFwibWFyZ2luXCIsIFwic2hyaW5rXCIsIFwidmFyaWFudFwiXSk7XG5cbiAgdmFyIG11aUZvcm1Db250cm9sID0gdXNlRm9ybUNvbnRyb2woKTtcbiAgdmFyIHNocmluayA9IHNocmlua1Byb3A7XG5cbiAgaWYgKHR5cGVvZiBzaHJpbmsgPT09ICd1bmRlZmluZWQnICYmIG11aUZvcm1Db250cm9sKSB7XG4gICAgc2hyaW5rID0gbXVpRm9ybUNvbnRyb2wuZmlsbGVkIHx8IG11aUZvcm1Db250cm9sLmZvY3VzZWQgfHwgbXVpRm9ybUNvbnRyb2wuYWRvcm5lZFN0YXJ0O1xuICB9XG5cbiAgdmFyIGZjcyA9IGZvcm1Db250cm9sU3RhdGUoe1xuICAgIHByb3BzOiBwcm9wcyxcbiAgICBtdWlGb3JtQ29udHJvbDogbXVpRm9ybUNvbnRyb2wsXG4gICAgc3RhdGVzOiBbJ21hcmdpbicsICd2YXJpYW50J11cbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtTGFiZWwsIF9leHRlbmRzKHtcbiAgICBcImRhdGEtc2hyaW5rXCI6IHNocmluayxcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUsIG11aUZvcm1Db250cm9sICYmIGNsYXNzZXMuZm9ybUNvbnRyb2wsICFkaXNhYmxlQW5pbWF0aW9uICYmIGNsYXNzZXMuYW5pbWF0ZWQsIHNocmluayAmJiBjbGFzc2VzLnNocmluaywgZmNzLm1hcmdpbiA9PT0gJ2RlbnNlJyAmJiBjbGFzc2VzLm1hcmdpbkRlbnNlLCB7XG4gICAgICAnZmlsbGVkJzogY2xhc3Nlcy5maWxsZWQsXG4gICAgICAnb3V0bGluZWQnOiBjbGFzc2VzLm91dGxpbmVkXG4gICAgfVtmY3MudmFyaWFudF0pLFxuICAgIGNsYXNzZXM6IHtcbiAgICAgIGZvY3VzZWQ6IGNsYXNzZXMuZm9jdXNlZCxcbiAgICAgIGRpc2FibGVkOiBjbGFzc2VzLmRpc2FibGVkLFxuICAgICAgZXJyb3I6IGNsYXNzZXMuZXJyb3IsXG4gICAgICByZXF1aXJlZDogY2xhc3Nlcy5yZXF1aXJlZCxcbiAgICAgIGFzdGVyaXNrOiBjbGFzc2VzLmFzdGVyaXNrXG4gICAgfSxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlcikpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBJbnB1dExhYmVsLnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgYElucHV0TGFiZWxgLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIHRob3NlIHRoZW1lIGNvbG9ycyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSB0cmFuc2l0aW9uIGFuaW1hdGlvbiBpcyBkaXNhYmxlZC5cbiAgICovXG4gIGRpc2FibGVBbmltYXRpb246IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGFwcGx5IGRpc2FibGVkIGNsYXNzLlxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBsYWJlbCB3aWxsIGJlIGRpc3BsYXllZCBpbiBhbiBlcnJvciBzdGF0ZS5cbiAgICovXG4gIGVycm9yOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgaW5wdXQgb2YgdGhpcyBsYWJlbCBpcyBmb2N1c2VkLlxuICAgKi9cbiAgZm9jdXNlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGBkZW5zZWAsIHdpbGwgYWRqdXN0IHZlcnRpY2FsIHNwYWNpbmcuIFRoaXMgaXMgbm9ybWFsbHkgb2J0YWluZWQgdmlhIGNvbnRleHQgZnJvbVxuICAgKiBGb3JtQ29udHJvbC5cbiAgICovXG4gIG1hcmdpbjogUHJvcFR5cGVzLm9uZU9mKFsnZGVuc2UnXSksXG5cbiAgLyoqXG4gICAqIGlmIGB0cnVlYCwgdGhlIGxhYmVsIHdpbGwgaW5kaWNhdGUgdGhhdCB0aGUgaW5wdXQgaXMgcmVxdWlyZWQuXG4gICAqL1xuICByZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGxhYmVsIGlzIHNocnVuay5cbiAgICovXG4gIHNocmluazogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSB2YXJpYW50IHRvIHVzZS5cbiAgICovXG4gIHZhcmlhbnQ6IFByb3BUeXBlcy5vbmVPZihbJ2ZpbGxlZCcsICdvdXRsaW5lZCcsICdzdGFuZGFyZCddKVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlJbnB1dExhYmVsJ1xufSkoSW5wdXRMYWJlbCk7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHsgaXNGaWxsZWQsIGlzQWRvcm5lZFN0YXJ0IH0gZnJvbSAnLi4vSW5wdXRCYXNlL3V0aWxzJztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCBjYXBpdGFsaXplIGZyb20gJy4uL3V0aWxzL2NhcGl0YWxpemUnO1xuaW1wb3J0IGlzTXVpRWxlbWVudCBmcm9tICcuLi91dGlscy9pc011aUVsZW1lbnQnO1xuaW1wb3J0IEZvcm1Db250cm9sQ29udGV4dCBmcm9tICcuL0Zvcm1Db250cm9sQ29udGV4dCc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IHtcbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgcm9vdDoge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtZmxleCcsXG4gICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgLy8gUmVzZXQgZmllbGRzZXQgZGVmYXVsdCBzdHlsZS5cbiAgICBtaW5XaWR0aDogMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIG1hcmdpbjogMCxcbiAgICBib3JkZXI6IDAsXG4gICAgdmVydGljYWxBbGlnbjogJ3RvcCcgLy8gRml4IGFsaWdubWVudCBpc3N1ZSBvbiBTYWZhcmkuXG5cbiAgfSxcblxuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBtYXJnaW49XCJub3JtYWxcImAuICovXG4gIG1hcmdpbk5vcm1hbDoge1xuICAgIG1hcmdpblRvcDogMTYsXG4gICAgbWFyZ2luQm90dG9tOiA4XG4gIH0sXG5cbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgbWFyZ2luPVwiZGVuc2VcImAuICovXG4gIG1hcmdpbkRlbnNlOiB7XG4gICAgbWFyZ2luVG9wOiA4LFxuICAgIG1hcmdpbkJvdHRvbTogNFxuICB9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGZ1bGxXaWR0aD17dHJ1ZX1gLiAqL1xuICBmdWxsV2lkdGg6IHtcbiAgICB3aWR0aDogJzEwMCUnXG4gIH1cbn07XG4vKipcbiAqIFByb3ZpZGVzIGNvbnRleHQgc3VjaCBhcyBmaWxsZWQvZm9jdXNlZC9lcnJvci9yZXF1aXJlZCBmb3IgZm9ybSBpbnB1dHMuXG4gKiBSZWx5aW5nIG9uIHRoZSBjb250ZXh0IHByb3ZpZGVzIGhpZ2ggZmxleGliaWxpdHkgYW5kIGVuc3VyZXMgdGhhdCB0aGUgc3RhdGUgYWx3YXlzIHN0YXlzXG4gKiBjb25zaXN0ZW50IGFjcm9zcyB0aGUgY2hpbGRyZW4gb2YgdGhlIGBGb3JtQ29udHJvbGAuXG4gKiBUaGlzIGNvbnRleHQgaXMgdXNlZCBieSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6XG4gKlxuICogIC0gRm9ybUxhYmVsXG4gKiAgLSBGb3JtSGVscGVyVGV4dFxuICogIC0gSW5wdXRcbiAqICAtIElucHV0TGFiZWxcbiAqXG4gKiBZb3UgY2FuIGZpbmQgb25lIGNvbXBvc2l0aW9uIGV4YW1wbGUgYmVsb3cgYW5kIG1vcmUgZ29pbmcgdG8gW3RoZSBkZW1vc10oL2NvbXBvbmVudHMvdGV4dC1maWVsZHMvI2NvbXBvbmVudHMpLlxuICpcbiAqIGBgYGpzeFxuICogPEZvcm1Db250cm9sPlxuICogICA8SW5wdXRMYWJlbCBodG1sRm9yPVwibXktaW5wdXRcIj5FbWFpbCBhZGRyZXNzPC9JbnB1dExhYmVsPlxuICogICA8SW5wdXQgaWQ9XCJteS1pbnB1dFwiIGFyaWEtZGVzY3JpYmVkYnk9XCJteS1oZWxwZXItdGV4dFwiIC8+XG4gKiAgIDxGb3JtSGVscGVyVGV4dCBpZD1cIm15LWhlbHBlci10ZXh0XCI+V2UnbGwgbmV2ZXIgc2hhcmUgeW91ciBlbWFpbC48L0Zvcm1IZWxwZXJUZXh0PlxuICogPC9Gb3JtQ29udHJvbD5cbiAqIGBgYFxuICpcbiAqIOKaoO+4j09ubHkgb25lIGlucHV0IGNhbiBiZSB1c2VkIHdpdGhpbiBhIEZvcm1Db250cm9sLlxuICovXG5cbnZhciBGb3JtQ29udHJvbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZvcm1Db250cm9sKHByb3BzLCByZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRjb2xvciA9IHByb3BzLmNvbG9yLFxuICAgICAgY29sb3IgPSBfcHJvcHMkY29sb3IgPT09IHZvaWQgMCA/ICdwcmltYXJ5JyA6IF9wcm9wcyRjb2xvcixcbiAgICAgIF9wcm9wcyRjb21wb25lbnQgPSBwcm9wcy5jb21wb25lbnQsXG4gICAgICBDb21wb25lbnQgPSBfcHJvcHMkY29tcG9uZW50ID09PSB2b2lkIDAgPyAnZGl2JyA6IF9wcm9wcyRjb21wb25lbnQsXG4gICAgICBfcHJvcHMkZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGRpc2FibGVkID0gX3Byb3BzJGRpc2FibGVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlZCxcbiAgICAgIF9wcm9wcyRlcnJvciA9IHByb3BzLmVycm9yLFxuICAgICAgZXJyb3IgPSBfcHJvcHMkZXJyb3IgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGVycm9yLFxuICAgICAgX3Byb3BzJGZ1bGxXaWR0aCA9IHByb3BzLmZ1bGxXaWR0aCxcbiAgICAgIGZ1bGxXaWR0aCA9IF9wcm9wcyRmdWxsV2lkdGggPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGZ1bGxXaWR0aCxcbiAgICAgIHZpc3VhbGx5Rm9jdXNlZCA9IHByb3BzLmZvY3VzZWQsXG4gICAgICBfcHJvcHMkaGlkZGVuTGFiZWwgPSBwcm9wcy5oaWRkZW5MYWJlbCxcbiAgICAgIGhpZGRlbkxhYmVsID0gX3Byb3BzJGhpZGRlbkxhYmVsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRoaWRkZW5MYWJlbCxcbiAgICAgIF9wcm9wcyRtYXJnaW4gPSBwcm9wcy5tYXJnaW4sXG4gICAgICBtYXJnaW4gPSBfcHJvcHMkbWFyZ2luID09PSB2b2lkIDAgPyAnbm9uZScgOiBfcHJvcHMkbWFyZ2luLFxuICAgICAgX3Byb3BzJHJlcXVpcmVkID0gcHJvcHMucmVxdWlyZWQsXG4gICAgICByZXF1aXJlZCA9IF9wcm9wcyRyZXF1aXJlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkcmVxdWlyZWQsXG4gICAgICBzaXplID0gcHJvcHMuc2l6ZSxcbiAgICAgIF9wcm9wcyR2YXJpYW50ID0gcHJvcHMudmFyaWFudCxcbiAgICAgIHZhcmlhbnQgPSBfcHJvcHMkdmFyaWFudCA9PT0gdm9pZCAwID8gJ3N0YW5kYXJkJyA6IF9wcm9wcyR2YXJpYW50LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcImNvbG9yXCIsIFwiY29tcG9uZW50XCIsIFwiZGlzYWJsZWRcIiwgXCJlcnJvclwiLCBcImZ1bGxXaWR0aFwiLCBcImZvY3VzZWRcIiwgXCJoaWRkZW5MYWJlbFwiLCBcIm1hcmdpblwiLCBcInJlcXVpcmVkXCIsIFwic2l6ZVwiLCBcInZhcmlhbnRcIl0pO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgLy8gV2UgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggdGhlIGNoaWxkcmVuIGFuZCBmaW5kIHRoZSBJbnB1dCBpbiBvcmRlclxuICAgIC8vIHRvIGZ1bGx5IHN1cHBvcnQgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICAgIHZhciBpbml0aWFsQWRvcm5lZFN0YXJ0ID0gZmFsc2U7XG5cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoIWlzTXVpRWxlbWVudChjaGlsZCwgWydJbnB1dCcsICdTZWxlY3QnXSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5wdXQgPSBpc011aUVsZW1lbnQoY2hpbGQsIFsnU2VsZWN0J10pID8gY2hpbGQucHJvcHMuaW5wdXQgOiBjaGlsZDtcblxuICAgICAgICBpZiAoaW5wdXQgJiYgaXNBZG9ybmVkU3RhcnQoaW5wdXQucHJvcHMpKSB7XG4gICAgICAgICAgaW5pdGlhbEFkb3JuZWRTdGFydCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBpbml0aWFsQWRvcm5lZFN0YXJ0O1xuICB9KSxcbiAgICAgIGFkb3JuZWRTdGFydCA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldEFkb3JuZWRTdGFydCA9IF9SZWFjdCR1c2VTdGF0ZVsxXTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlMiA9IFJlYWN0LnVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGl0ZXJhdGUgdGhyb3VnaCB0aGUgY2hpbGRyZW4gYW5kIGZpbmQgdGhlIElucHV0IGluIG9yZGVyXG4gICAgLy8gdG8gZnVsbHkgc3VwcG9ydCBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gICAgdmFyIGluaXRpYWxGaWxsZWQgPSBmYWxzZTtcblxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmICghaXNNdWlFbGVtZW50KGNoaWxkLCBbJ0lucHV0JywgJ1NlbGVjdCddKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZpbGxlZChjaGlsZC5wcm9wcywgdHJ1ZSkpIHtcbiAgICAgICAgICBpbml0aWFsRmlsbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluaXRpYWxGaWxsZWQ7XG4gIH0pLFxuICAgICAgZmlsbGVkID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldEZpbGxlZCA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTMgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgICBfZm9jdXNlZCA9IF9SZWFjdCR1c2VTdGF0ZTNbMF0sXG4gICAgICBzZXRGb2N1c2VkID0gX1JlYWN0JHVzZVN0YXRlM1sxXTtcblxuICB2YXIgZm9jdXNlZCA9IHZpc3VhbGx5Rm9jdXNlZCAhPT0gdW5kZWZpbmVkID8gdmlzdWFsbHlGb2N1c2VkIDogX2ZvY3VzZWQ7XG5cbiAgaWYgKGRpc2FibGVkICYmIGZvY3VzZWQpIHtcbiAgICBzZXRGb2N1c2VkKGZhbHNlKTtcbiAgfVxuXG4gIHZhciByZWdpc3RlckVmZmVjdDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHZhciByZWdpc3RlcmVkSW5wdXQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuXG4gICAgcmVnaXN0ZXJFZmZlY3QgPSBmdW5jdGlvbiByZWdpc3RlckVmZmVjdCgpIHtcbiAgICAgIGlmIChyZWdpc3RlcmVkSW5wdXQuY3VycmVudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFsnTWF0ZXJpYWwtVUk6IFRoZXJlIGFyZSBtdWx0aXBsZSBJbnB1dEJhc2UgY29tcG9uZW50cyBpbnNpZGUgYSBGb3JtQ29udHJvbC4nLCAnVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBJdCBtaWdodCBjYXVzZSBpbmZpbml0ZSByZW5kZXJpbmcgbG9vcHMuJywgJ09ubHkgdXNlIG9uZSBJbnB1dEJhc2UuJ10uam9pbignXFxuJykpO1xuICAgICAgfVxuXG4gICAgICByZWdpc3RlcmVkSW5wdXQuY3VycmVudCA9IHRydWU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZWdpc3RlcmVkSW5wdXQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIG9uRmlsbGVkID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHNldEZpbGxlZCh0cnVlKTtcbiAgfSwgW10pO1xuICB2YXIgb25FbXB0eSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzZXRGaWxsZWQoZmFsc2UpO1xuICB9LCBbXSk7XG4gIHZhciBjaGlsZENvbnRleHQgPSB7XG4gICAgYWRvcm5lZFN0YXJ0OiBhZG9ybmVkU3RhcnQsXG4gICAgc2V0QWRvcm5lZFN0YXJ0OiBzZXRBZG9ybmVkU3RhcnQsXG4gICAgY29sb3I6IGNvbG9yLFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICBlcnJvcjogZXJyb3IsXG4gICAgZmlsbGVkOiBmaWxsZWQsXG4gICAgZm9jdXNlZDogZm9jdXNlZCxcbiAgICBmdWxsV2lkdGg6IGZ1bGxXaWR0aCxcbiAgICBoaWRkZW5MYWJlbDogaGlkZGVuTGFiZWwsXG4gICAgbWFyZ2luOiAoc2l6ZSA9PT0gJ3NtYWxsJyA/ICdkZW5zZScgOiB1bmRlZmluZWQpIHx8IG1hcmdpbixcbiAgICBvbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIHNldEZvY3VzZWQoZmFsc2UpO1xuICAgIH0sXG4gICAgb25FbXB0eTogb25FbXB0eSxcbiAgICBvbkZpbGxlZDogb25GaWxsZWQsXG4gICAgb25Gb2N1czogZnVuY3Rpb24gb25Gb2N1cygpIHtcbiAgICAgIHNldEZvY3VzZWQodHJ1ZSk7XG4gICAgfSxcbiAgICByZWdpc3RlckVmZmVjdDogcmVnaXN0ZXJFZmZlY3QsXG4gICAgcmVxdWlyZWQ6IHJlcXVpcmVkLFxuICAgIHZhcmlhbnQ6IHZhcmlhbnRcbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1Db250cm9sQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjaGlsZENvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lLCBtYXJnaW4gIT09ICdub25lJyAmJiBjbGFzc2VzW1wibWFyZ2luXCIuY29uY2F0KGNhcGl0YWxpemUobWFyZ2luKSldLCBmdWxsV2lkdGggJiYgY2xhc3Nlcy5mdWxsV2lkdGgpLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSwgY2hpbGRyZW4pKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gRm9ybUNvbnRyb2wucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSBmb3JtIGNvbnRyb2wuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29sb3Igb2YgdGhlIGNvbXBvbmVudC4gSXQgc3VwcG9ydHMgdGhvc2UgdGhlbWUgY29sb3JzIHRoYXQgbWFrZSBzZW5zZSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsncHJpbWFyeScsICdzZWNvbmRhcnknXSksXG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzXG4gIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi9cbiAgLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBsYWJlbCwgaW5wdXQgYW5kIGhlbHBlciB0ZXh0IHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gYSBkaXNhYmxlZCBzdGF0ZS5cbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbGFiZWwgc2hvdWxkIGJlIGRpc3BsYXllZCBpbiBhbiBlcnJvciBzdGF0ZS5cbiAgICovXG4gIGVycm9yOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY29tcG9uZW50IHdpbGwgYmUgZGlzcGxheWVkIGluIGZvY3VzZWQgc3RhdGUuXG4gICAqL1xuICBmb2N1c2VkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY29tcG9uZW50IHdpbGwgdGFrZSB1cCB0aGUgZnVsbCB3aWR0aCBvZiBpdHMgY29udGFpbmVyLlxuICAgKi9cbiAgZnVsbFdpZHRoOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbGFiZWwgd2lsbCBiZSBoaWRkZW4uXG4gICAqIFRoaXMgaXMgdXNlZCB0byBpbmNyZWFzZSBkZW5zaXR5IGZvciBhIGBGaWxsZWRJbnB1dGAuXG4gICAqIEJlIHN1cmUgdG8gYWRkIGBhcmlhLWxhYmVsYCB0byB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgaGlkZGVuTGFiZWw6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgZGVuc2VgIG9yIGBub3JtYWxgLCB3aWxsIGFkanVzdCB2ZXJ0aWNhbCBzcGFjaW5nIG9mIHRoaXMgYW5kIGNvbnRhaW5lZCBjb21wb25lbnRzLlxuICAgKi9cbiAgbWFyZ2luOiBQcm9wVHlwZXMub25lT2YoWydkZW5zZScsICdub25lJywgJ25vcm1hbCddKSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbGFiZWwgd2lsbCBpbmRpY2F0ZSB0aGF0IHRoZSBpbnB1dCBpcyByZXF1aXJlZC5cbiAgICovXG4gIHJlcXVpcmVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIHRleHQgZmllbGQuXG4gICAqL1xuICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydtZWRpdW0nLCAnc21hbGwnXSksXG5cbiAgLyoqXG4gICAqIFRoZSB2YXJpYW50IHRvIHVzZS5cbiAgICovXG4gIHZhcmlhbnQ6IFByb3BUeXBlcy5vbmVPZihbJ2ZpbGxlZCcsICdvdXRsaW5lZCcsICdzdGFuZGFyZCddKVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlGb3JtQ29udHJvbCdcbn0pKEZvcm1Db250cm9sKTsiLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgZm9ybUNvbnRyb2xTdGF0ZSBmcm9tICcuLi9Gb3JtQ29udHJvbC9mb3JtQ29udHJvbFN0YXRlJztcbmltcG9ydCB1c2VGb3JtQ29udHJvbCBmcm9tICcuLi9Gb3JtQ29udHJvbC91c2VGb3JtQ29udHJvbCc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gICAgcm9vdDogX2V4dGVuZHMoe1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudGV4dC5zZWNvbmRhcnlcbiAgICB9LCB0aGVtZS50eXBvZ3JhcGh5LmNhcHRpb24sIHtcbiAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxuICAgICAgbWFyZ2luVG9wOiAzLFxuICAgICAgbWFyZ2luOiAwLFxuICAgICAgJyYkZGlzYWJsZWQnOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnRleHQuZGlzYWJsZWRcbiAgICAgIH0sXG4gICAgICAnJiRlcnJvcic6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuZXJyb3IubWFpblxuICAgICAgfVxuICAgIH0pLFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZXJyb3I9e3RydWV9YC4gKi9cbiAgICBlcnJvcjoge30sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBkaXNhYmxlZD17dHJ1ZX1gLiAqL1xuICAgIGRpc2FibGVkOiB7fSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYG1hcmdpbj1cImRlbnNlXCJgLiAqL1xuICAgIG1hcmdpbkRlbnNlOiB7XG4gICAgICBtYXJnaW5Ub3A6IDRcbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgdmFyaWFudD1cImZpbGxlZFwiYCBvciBgdmFyaWFudD1cIm91dGxpbmVkXCJgLiAqL1xuICAgIGNvbnRhaW5lZDoge1xuICAgICAgbWFyZ2luTGVmdDogMTQsXG4gICAgICBtYXJnaW5SaWdodDogMTRcbiAgICB9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZm9jdXNlZD17dHJ1ZX1gLiAqL1xuICAgIGZvY3VzZWQ6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZmlsbGVkPXt0cnVlfWAuICovXG4gICAgZmlsbGVkOiB7fSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYHJlcXVpcmVkPXt0cnVlfWAuICovXG4gICAgcmVxdWlyZWQ6IHt9XG4gIH07XG59O1xudmFyIEZvcm1IZWxwZXJUZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gRm9ybUhlbHBlclRleHQocHJvcHMsIHJlZikge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgX3Byb3BzJGNvbXBvbmVudCA9IHByb3BzLmNvbXBvbmVudCxcbiAgICAgIENvbXBvbmVudCA9IF9wcm9wcyRjb21wb25lbnQgPT09IHZvaWQgMCA/ICdwJyA6IF9wcm9wcyRjb21wb25lbnQsXG4gICAgICBkaXNhYmxlZCA9IHByb3BzLmRpc2FibGVkLFxuICAgICAgZXJyb3IgPSBwcm9wcy5lcnJvcixcbiAgICAgIGZpbGxlZCA9IHByb3BzLmZpbGxlZCxcbiAgICAgIGZvY3VzZWQgPSBwcm9wcy5mb2N1c2VkLFxuICAgICAgbWFyZ2luID0gcHJvcHMubWFyZ2luLFxuICAgICAgcmVxdWlyZWQgPSBwcm9wcy5yZXF1aXJlZCxcbiAgICAgIHZhcmlhbnQgPSBwcm9wcy52YXJpYW50LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3Nlc1wiLCBcImNsYXNzTmFtZVwiLCBcImNvbXBvbmVudFwiLCBcImRpc2FibGVkXCIsIFwiZXJyb3JcIiwgXCJmaWxsZWRcIiwgXCJmb2N1c2VkXCIsIFwibWFyZ2luXCIsIFwicmVxdWlyZWRcIiwgXCJ2YXJpYW50XCJdKTtcblxuICB2YXIgbXVpRm9ybUNvbnRyb2wgPSB1c2VGb3JtQ29udHJvbCgpO1xuICB2YXIgZmNzID0gZm9ybUNvbnRyb2xTdGF0ZSh7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIG11aUZvcm1Db250cm9sOiBtdWlGb3JtQ29udHJvbCxcbiAgICBzdGF0ZXM6IFsndmFyaWFudCcsICdtYXJnaW4nLCAnZGlzYWJsZWQnLCAnZXJyb3InLCAnZmlsbGVkJywgJ2ZvY3VzZWQnLCAncmVxdWlyZWQnXVxuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIChmY3MudmFyaWFudCA9PT0gJ2ZpbGxlZCcgfHwgZmNzLnZhcmlhbnQgPT09ICdvdXRsaW5lZCcpICYmIGNsYXNzZXMuY29udGFpbmVkLCBjbGFzc05hbWUsIGZjcy5kaXNhYmxlZCAmJiBjbGFzc2VzLmRpc2FibGVkLCBmY3MuZXJyb3IgJiYgY2xhc3Nlcy5lcnJvciwgZmNzLmZpbGxlZCAmJiBjbGFzc2VzLmZpbGxlZCwgZmNzLmZvY3VzZWQgJiYgY2xhc3Nlcy5mb2N1c2VkLCBmY3MucmVxdWlyZWQgJiYgY2xhc3Nlcy5yZXF1aXJlZCwgZmNzLm1hcmdpbiA9PT0gJ2RlbnNlJyAmJiBjbGFzc2VzLm1hcmdpbkRlbnNlKSxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlciksIGNoaWxkcmVuID09PSAnICcgP1xuICAvKiNfX1BVUkVfXyovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1kYW5nZXJcbiAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICBfX2h0bWw6ICcmIzgyMDM7J1xuICAgIH1cbiAgfSkgOiBjaGlsZHJlbik7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IEZvcm1IZWxwZXJUZXh0LnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIElmIGAnICdgIGlzIHByb3ZpZGVkLCB0aGUgY29tcG9uZW50IHJlc2VydmVzIG9uZSBsaW5lIGhlaWdodCBmb3IgZGlzcGxheWluZyBhIGZ1dHVyZSBtZXNzYWdlLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCB1c2VkIGZvciB0aGUgcm9vdCBub2RlLlxuICAgKiBFaXRoZXIgYSBzdHJpbmcgdG8gdXNlIGEgSFRNTCBlbGVtZW50IG9yIGEgY29tcG9uZW50LlxuICAgKi9cbiAgY29tcG9uZW50OiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAuZWxlbWVudFR5cGUsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGhlbHBlciB0ZXh0IHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gYSBkaXNhYmxlZCBzdGF0ZS5cbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBoZWxwZXIgdGV4dCBzaG91bGQgYmUgZGlzcGxheWVkIGluIGFuIGVycm9yIHN0YXRlLlxuICAgKi9cbiAgZXJyb3I6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBoZWxwZXIgdGV4dCBzaG91bGQgdXNlIGZpbGxlZCBjbGFzc2VzIGtleS5cbiAgICovXG4gIGZpbGxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGhlbHBlciB0ZXh0IHNob3VsZCB1c2UgZm9jdXNlZCBjbGFzc2VzIGtleS5cbiAgICovXG4gIGZvY3VzZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgZGVuc2VgLCB3aWxsIGFkanVzdCB2ZXJ0aWNhbCBzcGFjaW5nLiBUaGlzIGlzIG5vcm1hbGx5IG9idGFpbmVkIHZpYSBjb250ZXh0IGZyb21cbiAgICogRm9ybUNvbnRyb2wuXG4gICAqL1xuICBtYXJnaW46IFByb3BUeXBlcy5vbmVPZihbJ2RlbnNlJ10pLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBoZWxwZXIgdGV4dCBzaG91bGQgdXNlIHJlcXVpcmVkIGNsYXNzZXMga2V5LlxuICAgKi9cbiAgcmVxdWlyZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgdmFyaWFudCB0byB1c2UuXG4gICAqL1xuICB2YXJpYW50OiBQcm9wVHlwZXMub25lT2YoWydmaWxsZWQnLCAnb3V0bGluZWQnLCAnc3RhbmRhcmQnXSlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpRm9ybUhlbHBlclRleHQnXG59KShGb3JtSGVscGVyVGV4dCk7IiwiLy8gQSBjaGFuZ2Ugb2YgdGhlIGJyb3dzZXIgem9vbSBjaGFuZ2UgdGhlIHNjcm9sbGJhciBzaXplLlxuLy8gQ3JlZGl0IGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iLzNmZmUzYTVkODJmNmY1NjFiODJmZjc4ZDgyYjMyYTdkMTRhZWQ1NTgvanMvc3JjL21vZGFsLmpzI0w1MTItTDUxOVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyU2l6ZSgpIHtcbiAgdmFyIHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBzY3JvbGxEaXYuc3R5bGUud2lkdGggPSAnOTlweCc7XG4gIHNjcm9sbERpdi5zdHlsZS5oZWlnaHQgPSAnOTlweCc7XG4gIHNjcm9sbERpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIHNjcm9sbERpdi5zdHlsZS50b3AgPSAnLTk5OTlweCc7XG4gIHNjcm9sbERpdi5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcm9sbERpdik7XG4gIHZhciBzY3JvbGxiYXJTaXplID0gc2Nyb2xsRGl2Lm9mZnNldFdpZHRoIC0gc2Nyb2xsRGl2LmNsaWVudFdpZHRoO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNjcm9sbERpdik7XG4gIHJldHVybiBzY3JvbGxiYXJTaXplO1xufSIsImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXlcIjtcbmltcG9ydCBnZXRTY3JvbGxiYXJTaXplIGZyb20gJy4uL3V0aWxzL2dldFNjcm9sbGJhclNpemUnO1xuaW1wb3J0IG93bmVyRG9jdW1lbnQgZnJvbSAnLi4vdXRpbHMvb3duZXJEb2N1bWVudCc7XG5pbXBvcnQgb3duZXJXaW5kb3cgZnJvbSAnLi4vdXRpbHMvb3duZXJXaW5kb3cnOyAvLyBJcyBhIHZlcnRpY2FsIHNjcm9sbGJhciBkaXNwbGF5ZWQ/XG5cbmZ1bmN0aW9uIGlzT3ZlcmZsb3dpbmcoY29udGFpbmVyKSB7XG4gIHZhciBkb2MgPSBvd25lckRvY3VtZW50KGNvbnRhaW5lcik7XG5cbiAgaWYgKGRvYy5ib2R5ID09PSBjb250YWluZXIpIHtcbiAgICByZXR1cm4gb3duZXJXaW5kb3coZG9jKS5pbm5lcldpZHRoID4gZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgfVxuXG4gIHJldHVybiBjb250YWluZXIuc2Nyb2xsSGVpZ2h0ID4gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFyaWFIaWRkZW4obm9kZSwgc2hvdykge1xuICBpZiAoc2hvdykge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UGFkZGluZ1JpZ2h0KG5vZGUpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpWydwYWRkaW5nLXJpZ2h0J10sIDEwKSB8fCAwO1xufVxuXG5mdW5jdGlvbiBhcmlhSGlkZGVuU2libGluZ3MoY29udGFpbmVyLCBtb3VudE5vZGUsIGN1cnJlbnROb2RlKSB7XG4gIHZhciBub2Rlc1RvRXhjbHVkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogW107XG4gIHZhciBzaG93ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gIHZhciBibGFja2xpc3QgPSBbbW91bnROb2RlLCBjdXJyZW50Tm9kZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShub2Rlc1RvRXhjbHVkZSkpO1xuICB2YXIgYmxhY2tsaXN0VGFnTmFtZXMgPSBbJ1RFTVBMQVRFJywgJ1NDUklQVCcsICdTVFlMRSddO1xuICBbXS5mb3JFYWNoLmNhbGwoY29udGFpbmVyLmNoaWxkcmVuLCBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxICYmIGJsYWNrbGlzdC5pbmRleE9mKG5vZGUpID09PSAtMSAmJiBibGFja2xpc3RUYWdOYW1lcy5pbmRleE9mKG5vZGUudGFnTmFtZSkgPT09IC0xKSB7XG4gICAgICBhcmlhSGlkZGVuKG5vZGUsIHNob3cpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRJbmRleE9mKGNvbnRhaW5lckluZm8sIGNhbGxiYWNrKSB7XG4gIHZhciBpZHggPSAtMTtcbiAgY29udGFpbmVySW5mby5zb21lKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIGlmIChjYWxsYmFjayhpdGVtKSkge1xuICAgICAgaWR4ID0gaW5kZXg7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuICByZXR1cm4gaWR4O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVDb250YWluZXIoY29udGFpbmVySW5mbywgcHJvcHMpIHtcbiAgdmFyIHJlc3RvcmVTdHlsZSA9IFtdO1xuICB2YXIgcmVzdG9yZVBhZGRpbmdzID0gW107XG4gIHZhciBjb250YWluZXIgPSBjb250YWluZXJJbmZvLmNvbnRhaW5lcjtcbiAgdmFyIGZpeGVkTm9kZXM7XG5cbiAgaWYgKCFwcm9wcy5kaXNhYmxlU2Nyb2xsTG9jaykge1xuICAgIGlmIChpc092ZXJmbG93aW5nKGNvbnRhaW5lcikpIHtcbiAgICAgIC8vIENvbXB1dGUgdGhlIHNpemUgYmVmb3JlIGFwcGx5aW5nIG92ZXJmbG93IGhpZGRlbiB0byBhdm9pZCBhbnkgc2Nyb2xsIGp1bXBzLlxuICAgICAgdmFyIHNjcm9sbGJhclNpemUgPSBnZXRTY3JvbGxiYXJTaXplKCk7XG4gICAgICByZXN0b3JlU3R5bGUucHVzaCh7XG4gICAgICAgIHZhbHVlOiBjb250YWluZXIuc3R5bGUucGFkZGluZ1JpZ2h0LFxuICAgICAgICBrZXk6ICdwYWRkaW5nLXJpZ2h0JyxcbiAgICAgICAgZWw6IGNvbnRhaW5lclxuICAgICAgfSk7IC8vIFVzZSBjb21wdXRlZCBzdHlsZSwgaGVyZSB0byBnZXQgdGhlIHJlYWwgcGFkZGluZyB0byBhZGQgb3VyIHNjcm9sbGJhciB3aWR0aC5cblxuICAgICAgY29udGFpbmVyLnN0eWxlWydwYWRkaW5nLXJpZ2h0J10gPSBcIlwiLmNvbmNhdChnZXRQYWRkaW5nUmlnaHQoY29udGFpbmVyKSArIHNjcm9sbGJhclNpemUsIFwicHhcIik7IC8vIC5tdWktZml4ZWQgaXMgYSBnbG9iYWwgaGVscGVyLlxuXG4gICAgICBmaXhlZE5vZGVzID0gb3duZXJEb2N1bWVudChjb250YWluZXIpLnF1ZXJ5U2VsZWN0b3JBbGwoJy5tdWktZml4ZWQnKTtcbiAgICAgIFtdLmZvckVhY2guY2FsbChmaXhlZE5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXN0b3JlUGFkZGluZ3MucHVzaChub2RlLnN0eWxlLnBhZGRpbmdSaWdodCk7XG4gICAgICAgIG5vZGUuc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCJcIi5jb25jYXQoZ2V0UGFkZGluZ1JpZ2h0KG5vZGUpICsgc2Nyb2xsYmFyU2l6ZSwgXCJweFwiKTtcbiAgICAgIH0pO1xuICAgIH0gLy8gSW1wcm92ZSBHYXRzYnkgc3VwcG9ydFxuICAgIC8vIGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vc25pcHBldHMvY3NzL2ZvcmNlLXZlcnRpY2FsLXNjcm9sbGJhci9cblxuXG4gICAgdmFyIHBhcmVudCA9IGNvbnRhaW5lci5wYXJlbnRFbGVtZW50O1xuICAgIHZhciBzY3JvbGxDb250YWluZXIgPSBwYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJyAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpWydvdmVyZmxvdy15J10gPT09ICdzY3JvbGwnID8gcGFyZW50IDogY29udGFpbmVyOyAvLyBCbG9jayB0aGUgc2Nyb2xsIGV2ZW4gaWYgbm8gc2Nyb2xsYmFyIGlzIHZpc2libGUgdG8gYWNjb3VudCBmb3IgbW9iaWxlIGtleWJvYXJkXG4gICAgLy8gc2NyZWVuc2l6ZSBzaHJpbmsuXG5cbiAgICByZXN0b3JlU3R5bGUucHVzaCh7XG4gICAgICB2YWx1ZTogc2Nyb2xsQ29udGFpbmVyLnN0eWxlLm92ZXJmbG93LFxuICAgICAga2V5OiAnb3ZlcmZsb3cnLFxuICAgICAgZWw6IHNjcm9sbENvbnRhaW5lclxuICAgIH0pO1xuICAgIHNjcm9sbENvbnRhaW5lci5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICB9XG5cbiAgdmFyIHJlc3RvcmUgPSBmdW5jdGlvbiByZXN0b3JlKCkge1xuICAgIGlmIChmaXhlZE5vZGVzKSB7XG4gICAgICBbXS5mb3JFYWNoLmNhbGwoZml4ZWROb2RlcywgZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgICAgaWYgKHJlc3RvcmVQYWRkaW5nc1tpXSkge1xuICAgICAgICAgIG5vZGUuc3R5bGUucGFkZGluZ1JpZ2h0ID0gcmVzdG9yZVBhZGRpbmdzW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3BhZGRpbmctcmlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzdG9yZVN0eWxlLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICAgICAgZWwgPSBfcmVmLmVsLFxuICAgICAgICAgIGtleSA9IF9yZWYua2V5O1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiByZXN0b3JlO1xufVxuXG5mdW5jdGlvbiBnZXRIaWRkZW5TaWJsaW5ncyhjb250YWluZXIpIHtcbiAgdmFyIGhpZGRlblNpYmxpbmdzID0gW107XG4gIFtdLmZvckVhY2guY2FsbChjb250YWluZXIuY2hpbGRyZW4sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpID09PSAndHJ1ZScpIHtcbiAgICAgIGhpZGRlblNpYmxpbmdzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGhpZGRlblNpYmxpbmdzO1xufVxuLyoqXG4gKiBAaWdub3JlIC0gZG8gbm90IGRvY3VtZW50LlxuICpcbiAqIFByb3BlciBzdGF0ZSBtYW5hZ2VtZW50IGZvciBjb250YWluZXJzIGFuZCB0aGUgbW9kYWxzIGluIHRob3NlIGNvbnRhaW5lcnMuXG4gKiBTaW1wbGlmaWVkLCBidXQgaW5zcGlyZWQgYnkgcmVhY3Qtb3ZlcmxheSdzIE1vZGFsTWFuYWdlciBjbGFzcy5cbiAqIFVzZWQgYnkgdGhlIE1vZGFsIHRvIGVuc3VyZSBwcm9wZXIgc3R5bGluZyBvZiBjb250YWluZXJzLlxuICovXG5cblxudmFyIE1vZGFsTWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1vZGFsTWFuYWdlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9kYWxNYW5hZ2VyKTtcblxuICAgIC8vIHRoaXMubW9kYWxzW21vZGFsSW5kZXhdID0gbW9kYWxcbiAgICB0aGlzLm1vZGFscyA9IFtdOyAvLyB0aGlzLmNvbnRhaW5lcnNbY29udGFpbmVySW5kZXhdID0ge1xuICAgIC8vICAgbW9kYWxzOiBbXSxcbiAgICAvLyAgIGNvbnRhaW5lcixcbiAgICAvLyAgIHJlc3RvcmU6IG51bGwsXG4gICAgLy8gfVxuXG4gICAgdGhpcy5jb250YWluZXJzID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTW9kYWxNYW5hZ2VyLCBbe1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKG1vZGFsLCBjb250YWluZXIpIHtcbiAgICAgIHZhciBtb2RhbEluZGV4ID0gdGhpcy5tb2RhbHMuaW5kZXhPZihtb2RhbCk7XG5cbiAgICAgIGlmIChtb2RhbEluZGV4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gbW9kYWxJbmRleDtcbiAgICAgIH1cblxuICAgICAgbW9kYWxJbmRleCA9IHRoaXMubW9kYWxzLmxlbmd0aDtcbiAgICAgIHRoaXMubW9kYWxzLnB1c2gobW9kYWwpOyAvLyBJZiB0aGUgbW9kYWwgd2UgYXJlIGFkZGluZyBpcyBhbHJlYWR5IGluIHRoZSBET00uXG5cbiAgICAgIGlmIChtb2RhbC5tb2RhbFJlZikge1xuICAgICAgICBhcmlhSGlkZGVuKG1vZGFsLm1vZGFsUmVmLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBoaWRkZW5TaWJsaW5nTm9kZXMgPSBnZXRIaWRkZW5TaWJsaW5ncyhjb250YWluZXIpO1xuICAgICAgYXJpYUhpZGRlblNpYmxpbmdzKGNvbnRhaW5lciwgbW9kYWwubW91bnROb2RlLCBtb2RhbC5tb2RhbFJlZiwgaGlkZGVuU2libGluZ05vZGVzLCB0cnVlKTtcbiAgICAgIHZhciBjb250YWluZXJJbmRleCA9IGZpbmRJbmRleE9mKHRoaXMuY29udGFpbmVycywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uY29udGFpbmVyID09PSBjb250YWluZXI7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGNvbnRhaW5lckluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lcnNbY29udGFpbmVySW5kZXhdLm1vZGFscy5wdXNoKG1vZGFsKTtcbiAgICAgICAgcmV0dXJuIG1vZGFsSW5kZXg7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGFpbmVycy5wdXNoKHtcbiAgICAgICAgbW9kYWxzOiBbbW9kYWxdLFxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgcmVzdG9yZTogbnVsbCxcbiAgICAgICAgaGlkZGVuU2libGluZ05vZGVzOiBoaWRkZW5TaWJsaW5nTm9kZXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1vZGFsSW5kZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdW50KG1vZGFsLCBwcm9wcykge1xuICAgICAgdmFyIGNvbnRhaW5lckluZGV4ID0gZmluZEluZGV4T2YodGhpcy5jb250YWluZXJzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5tb2RhbHMuaW5kZXhPZihtb2RhbCkgIT09IC0xO1xuICAgICAgfSk7XG4gICAgICB2YXIgY29udGFpbmVySW5mbyA9IHRoaXMuY29udGFpbmVyc1tjb250YWluZXJJbmRleF07XG5cbiAgICAgIGlmICghY29udGFpbmVySW5mby5yZXN0b3JlKSB7XG4gICAgICAgIGNvbnRhaW5lckluZm8ucmVzdG9yZSA9IGhhbmRsZUNvbnRhaW5lcihjb250YWluZXJJbmZvLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUobW9kYWwpIHtcbiAgICAgIHZhciBtb2RhbEluZGV4ID0gdGhpcy5tb2RhbHMuaW5kZXhPZihtb2RhbCk7XG5cbiAgICAgIGlmIChtb2RhbEluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gbW9kYWxJbmRleDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRhaW5lckluZGV4ID0gZmluZEluZGV4T2YodGhpcy5jb250YWluZXJzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5tb2RhbHMuaW5kZXhPZihtb2RhbCkgIT09IC0xO1xuICAgICAgfSk7XG4gICAgICB2YXIgY29udGFpbmVySW5mbyA9IHRoaXMuY29udGFpbmVyc1tjb250YWluZXJJbmRleF07XG4gICAgICBjb250YWluZXJJbmZvLm1vZGFscy5zcGxpY2UoY29udGFpbmVySW5mby5tb2RhbHMuaW5kZXhPZihtb2RhbCksIDEpO1xuICAgICAgdGhpcy5tb2RhbHMuc3BsaWNlKG1vZGFsSW5kZXgsIDEpOyAvLyBJZiB0aGF0IHdhcyB0aGUgbGFzdCBtb2RhbCBpbiBhIGNvbnRhaW5lciwgY2xlYW4gdXAgdGhlIGNvbnRhaW5lci5cblxuICAgICAgaWYgKGNvbnRhaW5lckluZm8ubW9kYWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBUaGUgbW9kYWwgbWlnaHQgYmUgY2xvc2VkIGJlZm9yZSBpdCBoYWQgdGhlIGNoYW5jZSB0byBiZSBtb3VudGVkIGluIHRoZSBET00uXG4gICAgICAgIGlmIChjb250YWluZXJJbmZvLnJlc3RvcmUpIHtcbiAgICAgICAgICBjb250YWluZXJJbmZvLnJlc3RvcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RhbC5tb2RhbFJlZikge1xuICAgICAgICAgIC8vIEluIGNhc2UgdGhlIG1vZGFsIHdhc24ndCBpbiB0aGUgRE9NIHlldC5cbiAgICAgICAgICBhcmlhSGlkZGVuKG1vZGFsLm1vZGFsUmVmLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyaWFIaWRkZW5TaWJsaW5ncyhjb250YWluZXJJbmZvLmNvbnRhaW5lciwgbW9kYWwubW91bnROb2RlLCBtb2RhbC5tb2RhbFJlZiwgY29udGFpbmVySW5mby5oaWRkZW5TaWJsaW5nTm9kZXMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJzLnNwbGljZShjb250YWluZXJJbmRleCwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UgbWFrZSBzdXJlIHRoZSBuZXh0IHRvcCBtb2RhbCBpcyB2aXNpYmxlIHRvIGEgc2NyZWVuIHJlYWRlci5cbiAgICAgICAgdmFyIG5leHRUb3AgPSBjb250YWluZXJJbmZvLm1vZGFsc1tjb250YWluZXJJbmZvLm1vZGFscy5sZW5ndGggLSAxXTsgLy8gYXMgc29vbiBhcyBhIG1vZGFsIGlzIGFkZGluZyBpdHMgbW9kYWxSZWYgaXMgdW5kZWZpbmVkLiBpdCBjYW4ndCBzZXRcbiAgICAgICAgLy8gYXJpYS1oaWRkZW4gYmVjYXVzZSB0aGUgZG9tIGVsZW1lbnQgZG9lc24ndCBleGlzdCBlaXRoZXJcbiAgICAgICAgLy8gd2hlbiBtb2RhbCB3YXMgdW5tb3VudGVkIGJlZm9yZSBtb2RhbFJlZiBnZXRzIG51bGxcblxuICAgICAgICBpZiAobmV4dFRvcC5tb2RhbFJlZikge1xuICAgICAgICAgIGFyaWFIaWRkZW4obmV4dFRvcC5tb2RhbFJlZiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb2RhbEluZGV4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1RvcE1vZGFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVG9wTW9kYWwobW9kYWwpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGFscy5sZW5ndGggPiAwICYmIHRoaXMubW9kYWxzW3RoaXMubW9kYWxzLmxlbmd0aCAtIDFdID09PSBtb2RhbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTW9kYWxNYW5hZ2VyO1xufSgpO1xuXG5leHBvcnQgeyBNb2RhbE1hbmFnZXIgYXMgZGVmYXVsdCB9OyIsIi8qIGVzbGludC1kaXNhYmxlIGNvbnNpc3RlbnQtcmV0dXJuLCBqc3gtYTExeS9uby1ub25pbnRlcmFjdGl2ZS10YWJpbmRleCwgY2FtZWxjYXNlICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBvd25lckRvY3VtZW50IGZyb20gJy4uL3V0aWxzL293bmVyRG9jdW1lbnQnO1xuaW1wb3J0IHVzZUZvcmtSZWYgZnJvbSAnLi4vdXRpbHMvdXNlRm9ya1JlZic7XG5pbXBvcnQgeyBleGFjdFByb3AgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuLyoqXG4gKiBVdGlsaXR5IGNvbXBvbmVudCB0aGF0IGxvY2tzIGZvY3VzIGluc2lkZSB0aGUgY29tcG9uZW50LlxuICovXG5cbmZ1bmN0aW9uIFVuc3RhYmxlX1RyYXBGb2N1cyhwcm9wcykge1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIF9wcm9wcyRkaXNhYmxlQXV0b0ZvYyA9IHByb3BzLmRpc2FibGVBdXRvRm9jdXMsXG4gICAgICBkaXNhYmxlQXV0b0ZvY3VzID0gX3Byb3BzJGRpc2FibGVBdXRvRm9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlQXV0b0ZvYyxcbiAgICAgIF9wcm9wcyRkaXNhYmxlRW5mb3JjZSA9IHByb3BzLmRpc2FibGVFbmZvcmNlRm9jdXMsXG4gICAgICBkaXNhYmxlRW5mb3JjZUZvY3VzID0gX3Byb3BzJGRpc2FibGVFbmZvcmNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlRW5mb3JjZSxcbiAgICAgIF9wcm9wcyRkaXNhYmxlUmVzdG9yZSA9IHByb3BzLmRpc2FibGVSZXN0b3JlRm9jdXMsXG4gICAgICBkaXNhYmxlUmVzdG9yZUZvY3VzID0gX3Byb3BzJGRpc2FibGVSZXN0b3JlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlUmVzdG9yZSxcbiAgICAgIGdldERvYyA9IHByb3BzLmdldERvYyxcbiAgICAgIGlzRW5hYmxlZCA9IHByb3BzLmlzRW5hYmxlZCxcbiAgICAgIG9wZW4gPSBwcm9wcy5vcGVuO1xuICB2YXIgaWdub3JlTmV4dEVuZm9yY2VGb2N1cyA9IFJlYWN0LnVzZVJlZigpO1xuICB2YXIgc2VudGluZWxTdGFydCA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIHNlbnRpbmVsRW5kID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgbm9kZVRvUmVzdG9yZSA9IFJlYWN0LnVzZVJlZigpO1xuICB2YXIgcm9vdFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTsgLy8gY2FuIGJlIHJlbW92ZWQgb25jZSB3ZSBkcm9wIHN1cHBvcnQgZm9yIG5vbiByZWYgZm9yd2FyZGluZyBjbGFzcyBjb21wb25lbnRzXG5cbiAgdmFyIGhhbmRsZU93blJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIC8vICNTdHJpY3RNb2RlIHJlYWR5XG4gICAgcm9vdFJlZi5jdXJyZW50ID0gUmVhY3RET00uZmluZERPTU5vZGUoaW5zdGFuY2UpO1xuICB9LCBbXSk7XG4gIHZhciBoYW5kbGVSZWYgPSB1c2VGb3JrUmVmKGNoaWxkcmVuLnJlZiwgaGFuZGxlT3duUmVmKTtcbiAgdmFyIHByZXZPcGVuUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcHJldk9wZW5SZWYuY3VycmVudCA9IG9wZW47XG4gIH0sIFtvcGVuXSk7XG5cbiAgaWYgKCFwcmV2T3BlblJlZi5jdXJyZW50ICYmIG9wZW4gJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBXQVJOSU5HOiBQb3RlbnRpYWxseSB1bnNhZmUgaW4gY29uY3VycmVudCBtb2RlLlxuICAgIC8vIFRoZSB3YXkgdGhlIHJlYWQgb24gYG5vZGVUb1Jlc3RvcmVgIGlzIHNldHVwIGNvdWxkIG1ha2UgdGhpcyBhY3R1YWxseSBzYWZlLlxuICAgIC8vIFNheSB3ZSByZW5kZXIgYG9wZW49e2ZhbHNlfWAgLT4gYG9wZW49e3RydWV9YCBidXQgbmV2ZXIgY29tbWl0LlxuICAgIC8vIFdlIGhhdmUgbm93IHdyaXR0ZW4gYSBzdGF0ZSB0aGF0IHdhc24ndCBjb21taXR0ZWQuIEJ1dCBubyBjb21taXR0ZWQgZWZmZWN0XG4gICAgLy8gd2lsbCByZWFkIHRoaXMgd3JvbmcgdmFsdWUuIFdlIG9ubHkgcmVhZCBmcm9tIGBub2RlVG9SZXN0b3JlYCBpbiBlZmZlY3RzXG4gICAgLy8gdGhhdCB3ZXJlIGNvbW1pdHRlZCBvbiBgb3Blbj17dHJ1ZX1gXG4gICAgLy8gV0FSTklORzogUHJldmVudHMgdGhlIGluc3RhbmNlIGZyb20gYmVpbmcgZ2FyYmFnZSBjb2xsZWN0ZWQuIFNob3VsZCBvbmx5XG4gICAgLy8gaG9sZCBhIHdlYWsgcmVmLlxuICAgIG5vZGVUb1Jlc3RvcmUuY3VycmVudCA9IGdldERvYygpLmFjdGl2ZUVsZW1lbnQ7XG4gIH1cblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghb3Blbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkb2MgPSBvd25lckRvY3VtZW50KHJvb3RSZWYuY3VycmVudCk7IC8vIFdlIG1pZ2h0IHJlbmRlciBhbiBlbXB0eSBjaGlsZC5cblxuICAgIGlmICghZGlzYWJsZUF1dG9Gb2N1cyAmJiByb290UmVmLmN1cnJlbnQgJiYgIXJvb3RSZWYuY3VycmVudC5jb250YWlucyhkb2MuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIGlmICghcm9vdFJlZi5jdXJyZW50Lmhhc0F0dHJpYnV0ZSgndGFiSW5kZXgnKSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoWydNYXRlcmlhbC1VSTogVGhlIG1vZGFsIGNvbnRlbnQgbm9kZSBkb2VzIG5vdCBhY2NlcHQgZm9jdXMuJywgJ0ZvciB0aGUgYmVuZWZpdCBvZiBhc3Npc3RpdmUgdGVjaG5vbG9naWVzLCAnICsgJ3RoZSB0YWJJbmRleCBvZiB0aGUgbm9kZSBpcyBiZWluZyBzZXQgdG8gXCItMVwiLiddLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3RSZWYuY3VycmVudC5zZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JywgLTEpO1xuICAgICAgfVxuXG4gICAgICByb290UmVmLmN1cnJlbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbiA9IGZ1bmN0aW9uIGNvbnRhaW4oKSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSByb290UmVmLmN1cnJlbnQ7IC8vIENsZWFudXAgZnVuY3Rpb25zIGFyZSBleGVjdXRlZCBsYXppbHkgaW4gUmVhY3QgMTcuXG4gICAgICAvLyBDb250YWluIGNhbiBiZSBjYWxsZWQgYmV0d2VlbiB0aGUgY29tcG9uZW50IGJlaW5nIHVubW91bnRlZCBhbmQgaXRzIGNsZWFudXAgZnVuY3Rpb24gYmVpbmcgcnVuLlxuXG4gICAgICBpZiAocm9vdEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRvYy5oYXNGb2N1cygpIHx8IGRpc2FibGVFbmZvcmNlRm9jdXMgfHwgIWlzRW5hYmxlZCgpIHx8IGlnbm9yZU5leHRFbmZvcmNlRm9jdXMuY3VycmVudCkge1xuICAgICAgICBpZ25vcmVOZXh0RW5mb3JjZUZvY3VzLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocm9vdFJlZi5jdXJyZW50ICYmICFyb290UmVmLmN1cnJlbnQuY29udGFpbnMoZG9jLmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIHJvb3RSZWYuY3VycmVudC5mb2N1cygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbG9vcEZvY3VzID0gZnVuY3Rpb24gbG9vcEZvY3VzKGV2ZW50KSB7XG4gICAgICAvLyA5ID0gVGFiXG4gICAgICBpZiAoZGlzYWJsZUVuZm9yY2VGb2N1cyB8fCAhaXNFbmFibGVkKCkgfHwgZXZlbnQua2V5Q29kZSAhPT0gOSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIE1ha2Ugc3VyZSB0aGUgbmV4dCB0YWIgc3RhcnRzIGZyb20gdGhlIHJpZ2h0IHBsYWNlLlxuXG5cbiAgICAgIGlmIChkb2MuYWN0aXZlRWxlbWVudCA9PT0gcm9vdFJlZi5jdXJyZW50KSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gaWdub3JlIHRoZSBuZXh0IGNvbnRhaW4gYXNcbiAgICAgICAgLy8gaXQgd2lsbCB0cnkgdG8gbW92ZSB0aGUgZm9jdXMgYmFjayB0byB0aGUgcm9vdFJlZiBlbGVtZW50LlxuICAgICAgICBpZ25vcmVOZXh0RW5mb3JjZUZvY3VzLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgIHNlbnRpbmVsRW5kLmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZW50aW5lbFN0YXJ0LmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBjb250YWluLCB0cnVlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGxvb3BGb2N1cywgdHJ1ZSk7IC8vIFdpdGggRWRnZSwgU2FmYXJpIGFuZCBGaXJlZm94LCBubyBmb2N1cyByZWxhdGVkIGV2ZW50cyBhcmUgZmlyZWQgd2hlbiB0aGUgZm9jdXNlZCBhcmVhIHN0b3BzIGJlaW5nIGEgZm9jdXNlZCBhcmVhXG4gICAgLy8gZS5nLiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NTk1NjEuXG4gICAgLy9cbiAgICAvLyBUaGUgd2hhdHdnIHNwZWMgZGVmaW5lcyBob3cgdGhlIGJyb3dzZXIgc2hvdWxkIGJlaGF2ZSBidXQgZG9lcyBub3QgZXhwbGljaXRseSBtZW50aW9uIGFueSBldmVudHM6XG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNmb2N1cy1maXh1cC1ydWxlLlxuXG4gICAgdmFyIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgY29udGFpbigpO1xuICAgIH0sIDUwKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBjb250YWluLCB0cnVlKTtcbiAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgbG9vcEZvY3VzLCB0cnVlKTsgLy8gcmVzdG9yZUxhc3RGb2N1cygpXG5cbiAgICAgIGlmICghZGlzYWJsZVJlc3RvcmVGb2N1cykge1xuICAgICAgICAvLyBJbiBJRSAxMSBpdCBpcyBwb3NzaWJsZSBmb3IgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB0byBiZSBudWxsIHJlc3VsdGluZ1xuICAgICAgICAvLyBpbiBub2RlVG9SZXN0b3JlLmN1cnJlbnQgYmVpbmcgbnVsbC5cbiAgICAgICAgLy8gTm90IGFsbCBlbGVtZW50cyBpbiBJRSAxMSBoYXZlIGEgZm9jdXMgbWV0aG9kLlxuICAgICAgICAvLyBPbmNlIElFIDExIHN1cHBvcnQgaXMgZHJvcHBlZCB0aGUgZm9jdXMoKSBjYWxsIGNhbiBiZSB1bmNvbmRpdGlvbmFsLlxuICAgICAgICBpZiAobm9kZVRvUmVzdG9yZS5jdXJyZW50ICYmIG5vZGVUb1Jlc3RvcmUuY3VycmVudC5mb2N1cykge1xuICAgICAgICAgIG5vZGVUb1Jlc3RvcmUuY3VycmVudC5mb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZVRvUmVzdG9yZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZGlzYWJsZUF1dG9Gb2N1cywgZGlzYWJsZUVuZm9yY2VGb2N1cywgZGlzYWJsZVJlc3RvcmVGb2N1cywgaXNFbmFibGVkLCBvcGVuXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHRhYkluZGV4OiAwLFxuICAgIHJlZjogc2VudGluZWxTdGFydCxcbiAgICBcImRhdGEtdGVzdFwiOiBcInNlbnRpbmVsU3RhcnRcIlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChjaGlsZHJlbiwge1xuICAgIHJlZjogaGFuZGxlUmVmXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgdGFiSW5kZXg6IDAsXG4gICAgcmVmOiBzZW50aW5lbEVuZCxcbiAgICBcImRhdGEtdGVzdFwiOiBcInNlbnRpbmVsRW5kXCJcbiAgfSkpO1xufVxuXG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVbnN0YWJsZV9UcmFwRm9jdXMucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQSBzaW5nbGUgY2hpbGQgY29udGVudCBlbGVtZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSB0cmFwIGZvY3VzIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgc2hpZnQgZm9jdXMgdG8gaXRzZWxmIHdoZW4gaXQgb3BlbnMsIGFuZFxuICAgKiByZXBsYWNlIGl0IHRvIHRoZSBsYXN0IGZvY3VzZWQgZWxlbWVudCB3aGVuIGl0IGNsb3Nlcy5cbiAgICogVGhpcyBhbHNvIHdvcmtzIGNvcnJlY3RseSB3aXRoIGFueSB0cmFwIGZvY3VzIGNoaWxkcmVuIHRoYXQgaGF2ZSB0aGUgYGRpc2FibGVBdXRvRm9jdXNgIHByb3AuXG4gICAqXG4gICAqIEdlbmVyYWxseSB0aGlzIHNob3VsZCBuZXZlciBiZSBzZXQgdG8gYHRydWVgIGFzIGl0IG1ha2VzIHRoZSB0cmFwIGZvY3VzIGxlc3NcbiAgICogYWNjZXNzaWJsZSB0byBhc3Npc3RpdmUgdGVjaG5vbG9naWVzLCBsaWtlIHNjcmVlbiByZWFkZXJzLlxuICAgKi9cbiAgZGlzYWJsZUF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHRyYXAgZm9jdXMgd2lsbCBub3QgcHJldmVudCBmb2N1cyBmcm9tIGxlYXZpbmcgdGhlIHRyYXAgZm9jdXMgd2hpbGUgb3Blbi5cbiAgICpcbiAgICogR2VuZXJhbGx5IHRoaXMgc2hvdWxkIG5ldmVyIGJlIHNldCB0byBgdHJ1ZWAgYXMgaXQgbWFrZXMgdGhlIHRyYXAgZm9jdXMgbGVzc1xuICAgKiBhY2Nlc3NpYmxlIHRvIGFzc2lzdGl2ZSB0ZWNobm9sb2dpZXMsIGxpa2Ugc2NyZWVuIHJlYWRlcnMuXG4gICAqL1xuICBkaXNhYmxlRW5mb3JjZUZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgdHJhcCBmb2N1cyB3aWxsIG5vdCByZXN0b3JlIGZvY3VzIHRvIHByZXZpb3VzbHkgZm9jdXNlZCBlbGVtZW50IG9uY2VcbiAgICogdHJhcCBmb2N1cyBpcyBoaWRkZW4uXG4gICAqL1xuICBkaXNhYmxlUmVzdG9yZUZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkb2N1bWVudCB0byBjb25zaWRlci5cbiAgICogV2UgdXNlIGl0IHRvIGltcGxlbWVudCB0aGUgcmVzdG9yZSBmb2N1cyBiZXR3ZWVuIGRpZmZlcmVudCBicm93c2VyIGRvY3VtZW50cy5cbiAgICovXG4gIGdldERvYzogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogRG8gd2Ugc3RpbGwgd2FudCB0byBlbmZvcmNlIHRoZSBmb2N1cz9cbiAgICogVGhpcyBwcm9wIGhlbHBzIG5lc3RpbmcgVHJhcEZvY3VzIGVsZW1lbnRzLlxuICAgKi9cbiAgaXNFbmFibGVkOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGZvY3VzIHdpbGwgYmUgbG9ja2VkLlxuICAgKi9cbiAgb3BlbjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZFxufSA6IHZvaWQgMDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIFVuc3RhYmxlX1RyYXBGb2N1c1sncHJvcFR5cGVzJyArICcnXSA9IGV4YWN0UHJvcChVbnN0YWJsZV9UcmFwRm9jdXMucHJvcFR5cGVzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVW5zdGFibGVfVHJhcEZvY3VzOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IHtcbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgcm9vdDoge1xuICAgIHpJbmRleDogLTEsXG4gICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gICAgV2Via2l0VGFwSGlnaGxpZ2h0Q29sb3I6ICd0cmFuc3BhcmVudCdcbiAgfSxcblxuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBpbnZpc2libGU9e3RydWV9YC4gKi9cbiAgaW52aXNpYmxlOiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnXG4gIH1cbn07XG4vKipcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXG4gKi9cblxudmFyIFNpbXBsZUJhY2tkcm9wID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gU2ltcGxlQmFja2Ryb3AocHJvcHMsIHJlZikge1xuICB2YXIgX3Byb3BzJGludmlzaWJsZSA9IHByb3BzLmludmlzaWJsZSxcbiAgICAgIGludmlzaWJsZSA9IF9wcm9wcyRpbnZpc2libGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGludmlzaWJsZSxcbiAgICAgIG9wZW4gPSBwcm9wcy5vcGVuLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImludmlzaWJsZVwiLCBcIm9wZW5cIl0pO1xuXG4gIHJldHVybiBvcGVuID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlciwge1xuICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgc3R5bGVzLnJvb3QsIGludmlzaWJsZSA/IHN0eWxlcy5pbnZpc2libGUgOiB7fSwgb3RoZXIuc3R5bGUpXG4gIH0pKSA6IG51bGw7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFNpbXBsZUJhY2tkcm9wLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGJhY2tkcm9wIGlzIGludmlzaWJsZS5cbiAgICogSXQgY2FuIGJlIHVzZWQgd2hlbiByZW5kZXJpbmcgYSBwb3BvdmVyIG9yIGEgY3VzdG9tIHNlbGVjdCBjb21wb25lbnQuXG4gICAqL1xuICBpbnZpc2libGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBiYWNrZHJvcCBpcyBvcGVuLlxuICAgKi9cbiAgb3BlbjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZFxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IFNpbXBsZUJhY2tkcm9wOyIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgZ2V0VGhlbWVQcm9wcywgdXNlVGhlbWUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvc3R5bGVzJztcbmltcG9ydCB7IGVsZW1lbnRBY2NlcHRpbmdSZWYsIEhUTUxFbGVtZW50VHlwZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgZGVwcmVjYXRlZFByb3BUeXBlIGZyb20gJy4uL3V0aWxzL2RlcHJlY2F0ZWRQcm9wVHlwZSc7XG5pbXBvcnQgb3duZXJEb2N1bWVudCBmcm9tICcuLi91dGlscy9vd25lckRvY3VtZW50JztcbmltcG9ydCBQb3J0YWwgZnJvbSAnLi4vUG9ydGFsJztcbmltcG9ydCBjcmVhdGVDaGFpbmVkRnVuY3Rpb24gZnJvbSAnLi4vdXRpbHMvY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uJztcbmltcG9ydCB1c2VGb3JrUmVmIGZyb20gJy4uL3V0aWxzL3VzZUZvcmtSZWYnO1xuaW1wb3J0IHVzZUV2ZW50Q2FsbGJhY2sgZnJvbSAnLi4vdXRpbHMvdXNlRXZlbnRDYWxsYmFjayc7XG5pbXBvcnQgekluZGV4IGZyb20gJy4uL3N0eWxlcy96SW5kZXgnO1xuaW1wb3J0IE1vZGFsTWFuYWdlciwgeyBhcmlhSGlkZGVuIH0gZnJvbSAnLi9Nb2RhbE1hbmFnZXInO1xuaW1wb3J0IFRyYXBGb2N1cyBmcm9tICcuLi9VbnN0YWJsZV9UcmFwRm9jdXMnO1xuaW1wb3J0IFNpbXBsZUJhY2tkcm9wIGZyb20gJy4vU2ltcGxlQmFja2Ryb3AnO1xuXG5mdW5jdGlvbiBnZXRDb250YWluZXIoY29udGFpbmVyKSB7XG4gIGNvbnRhaW5lciA9IHR5cGVvZiBjb250YWluZXIgPT09ICdmdW5jdGlvbicgPyBjb250YWluZXIoKSA6IGNvbnRhaW5lcjtcbiAgcmV0dXJuIFJlYWN0RE9NLmZpbmRET01Ob2RlKGNvbnRhaW5lcik7XG59XG5cbmZ1bmN0aW9uIGdldEhhc1RyYW5zaXRpb24ocHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzLmNoaWxkcmVuID8gcHJvcHMuY2hpbGRyZW4ucHJvcHMuaGFzT3duUHJvcGVydHkoJ2luJykgOiBmYWxzZTtcbn0gLy8gQSBtb2RhbCBtYW5hZ2VyIHVzZWQgdG8gdHJhY2sgYW5kIG1hbmFnZSB0aGUgc3RhdGUgb2Ygb3BlbiBNb2RhbHMuXG4vLyBNb2RhbHMgZG9uJ3Qgb3BlbiBvbiB0aGUgc2VydmVyIHNvIHRoaXMgd29uJ3QgY29uZmxpY3Qgd2l0aCBjb25jdXJyZW50IHJlcXVlc3RzLlxuXG5cbnZhciBkZWZhdWx0TWFuYWdlciA9IG5ldyBNb2RhbE1hbmFnZXIoKTtcbmV4cG9ydCB2YXIgc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKHRoZW1lKSB7XG4gIHJldHVybiB7XG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgICByb290OiB7XG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIHpJbmRleDogdGhlbWUuekluZGV4Lm1vZGFsLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgdGhlIGBNb2RhbGAgaGFzIGV4aXRlZC4gKi9cbiAgICBoaWRkZW46IHtcbiAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nXG4gICAgfVxuICB9O1xufTtcbi8qKlxuICogTW9kYWwgaXMgYSBsb3dlci1sZXZlbCBjb25zdHJ1Y3QgdGhhdCBpcyBsZXZlcmFnZWQgYnkgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOlxuICpcbiAqIC0gW0RpYWxvZ10oL2FwaS9kaWFsb2cvKVxuICogLSBbRHJhd2VyXSgvYXBpL2RyYXdlci8pXG4gKiAtIFtNZW51XSgvYXBpL21lbnUvKVxuICogLSBbUG9wb3Zlcl0oL2FwaS9wb3BvdmVyLylcbiAqXG4gKiBJZiB5b3UgYXJlIGNyZWF0aW5nIGEgbW9kYWwgZGlhbG9nLCB5b3UgcHJvYmFibHkgd2FudCB0byB1c2UgdGhlIFtEaWFsb2ddKC9hcGkvZGlhbG9nLykgY29tcG9uZW50XG4gKiByYXRoZXIgdGhhbiBkaXJlY3RseSB1c2luZyBNb2RhbC5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBzaGFyZXMgbWFueSBjb25jZXB0cyB3aXRoIFtyZWFjdC1vdmVybGF5c10oaHR0cHM6Ly9yZWFjdC1ib290c3RyYXAuZ2l0aHViLmlvL3JlYWN0LW92ZXJsYXlzLyNtb2RhbHMpLlxuICovXG5cbnZhciBNb2RhbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIE1vZGFsKGluUHJvcHMsIHJlZikge1xuICB2YXIgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICB2YXIgcHJvcHMgPSBnZXRUaGVtZVByb3BzKHtcbiAgICBuYW1lOiAnTXVpTW9kYWwnLFxuICAgIHByb3BzOiBfZXh0ZW5kcyh7fSwgaW5Qcm9wcyksXG4gICAgdGhlbWU6IHRoZW1lXG4gIH0pO1xuXG4gIHZhciBfcHJvcHMkQmFja2Ryb3BDb21wb24gPSBwcm9wcy5CYWNrZHJvcENvbXBvbmVudCxcbiAgICAgIEJhY2tkcm9wQ29tcG9uZW50ID0gX3Byb3BzJEJhY2tkcm9wQ29tcG9uID09PSB2b2lkIDAgPyBTaW1wbGVCYWNrZHJvcCA6IF9wcm9wcyRCYWNrZHJvcENvbXBvbixcbiAgICAgIEJhY2tkcm9wUHJvcHMgPSBwcm9wcy5CYWNrZHJvcFByb3BzLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIF9wcm9wcyRjbG9zZUFmdGVyVHJhbiA9IHByb3BzLmNsb3NlQWZ0ZXJUcmFuc2l0aW9uLFxuICAgICAgY2xvc2VBZnRlclRyYW5zaXRpb24gPSBfcHJvcHMkY2xvc2VBZnRlclRyYW4gPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGNsb3NlQWZ0ZXJUcmFuLFxuICAgICAgY29udGFpbmVyID0gcHJvcHMuY29udGFpbmVyLFxuICAgICAgX3Byb3BzJGRpc2FibGVBdXRvRm9jID0gcHJvcHMuZGlzYWJsZUF1dG9Gb2N1cyxcbiAgICAgIGRpc2FibGVBdXRvRm9jdXMgPSBfcHJvcHMkZGlzYWJsZUF1dG9Gb2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVBdXRvRm9jLFxuICAgICAgX3Byb3BzJGRpc2FibGVCYWNrZHJvID0gcHJvcHMuZGlzYWJsZUJhY2tkcm9wQ2xpY2ssXG4gICAgICBkaXNhYmxlQmFja2Ryb3BDbGljayA9IF9wcm9wcyRkaXNhYmxlQmFja2RybyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZUJhY2tkcm8sXG4gICAgICBfcHJvcHMkZGlzYWJsZUVuZm9yY2UgPSBwcm9wcy5kaXNhYmxlRW5mb3JjZUZvY3VzLFxuICAgICAgZGlzYWJsZUVuZm9yY2VGb2N1cyA9IF9wcm9wcyRkaXNhYmxlRW5mb3JjZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZUVuZm9yY2UsXG4gICAgICBfcHJvcHMkZGlzYWJsZUVzY2FwZUsgPSBwcm9wcy5kaXNhYmxlRXNjYXBlS2V5RG93bixcbiAgICAgIGRpc2FibGVFc2NhcGVLZXlEb3duID0gX3Byb3BzJGRpc2FibGVFc2NhcGVLID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlRXNjYXBlSyxcbiAgICAgIF9wcm9wcyRkaXNhYmxlUG9ydGFsID0gcHJvcHMuZGlzYWJsZVBvcnRhbCxcbiAgICAgIGRpc2FibGVQb3J0YWwgPSBfcHJvcHMkZGlzYWJsZVBvcnRhbCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZVBvcnRhbCxcbiAgICAgIF9wcm9wcyRkaXNhYmxlUmVzdG9yZSA9IHByb3BzLmRpc2FibGVSZXN0b3JlRm9jdXMsXG4gICAgICBkaXNhYmxlUmVzdG9yZUZvY3VzID0gX3Byb3BzJGRpc2FibGVSZXN0b3JlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlUmVzdG9yZSxcbiAgICAgIF9wcm9wcyRkaXNhYmxlU2Nyb2xsTCA9IHByb3BzLmRpc2FibGVTY3JvbGxMb2NrLFxuICAgICAgZGlzYWJsZVNjcm9sbExvY2sgPSBfcHJvcHMkZGlzYWJsZVNjcm9sbEwgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRpc2FibGVTY3JvbGxMLFxuICAgICAgX3Byb3BzJGhpZGVCYWNrZHJvcCA9IHByb3BzLmhpZGVCYWNrZHJvcCxcbiAgICAgIGhpZGVCYWNrZHJvcCA9IF9wcm9wcyRoaWRlQmFja2Ryb3AgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGhpZGVCYWNrZHJvcCxcbiAgICAgIF9wcm9wcyRrZWVwTW91bnRlZCA9IHByb3BzLmtlZXBNb3VudGVkLFxuICAgICAga2VlcE1vdW50ZWQgPSBfcHJvcHMka2VlcE1vdW50ZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGtlZXBNb3VudGVkLFxuICAgICAgX3Byb3BzJG1hbmFnZXIgPSBwcm9wcy5tYW5hZ2VyLFxuICAgICAgbWFuYWdlciA9IF9wcm9wcyRtYW5hZ2VyID09PSB2b2lkIDAgPyBkZWZhdWx0TWFuYWdlciA6IF9wcm9wcyRtYW5hZ2VyLFxuICAgICAgb25CYWNrZHJvcENsaWNrID0gcHJvcHMub25CYWNrZHJvcENsaWNrLFxuICAgICAgb25DbG9zZSA9IHByb3BzLm9uQ2xvc2UsXG4gICAgICBvbkVzY2FwZUtleURvd24gPSBwcm9wcy5vbkVzY2FwZUtleURvd24sXG4gICAgICBvblJlbmRlcmVkID0gcHJvcHMub25SZW5kZXJlZCxcbiAgICAgIG9wZW4gPSBwcm9wcy5vcGVuLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcIkJhY2tkcm9wQ29tcG9uZW50XCIsIFwiQmFja2Ryb3BQcm9wc1wiLCBcImNoaWxkcmVuXCIsIFwiY2xvc2VBZnRlclRyYW5zaXRpb25cIiwgXCJjb250YWluZXJcIiwgXCJkaXNhYmxlQXV0b0ZvY3VzXCIsIFwiZGlzYWJsZUJhY2tkcm9wQ2xpY2tcIiwgXCJkaXNhYmxlRW5mb3JjZUZvY3VzXCIsIFwiZGlzYWJsZUVzY2FwZUtleURvd25cIiwgXCJkaXNhYmxlUG9ydGFsXCIsIFwiZGlzYWJsZVJlc3RvcmVGb2N1c1wiLCBcImRpc2FibGVTY3JvbGxMb2NrXCIsIFwiaGlkZUJhY2tkcm9wXCIsIFwia2VlcE1vdW50ZWRcIiwgXCJtYW5hZ2VyXCIsIFwib25CYWNrZHJvcENsaWNrXCIsIFwib25DbG9zZVwiLCBcIm9uRXNjYXBlS2V5RG93blwiLCBcIm9uUmVuZGVyZWRcIiwgXCJvcGVuXCJdKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUodHJ1ZSksXG4gICAgICBleGl0ZWQgPSBfUmVhY3QkdXNlU3RhdGVbMF0sXG4gICAgICBzZXRFeGl0ZWQgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIG1vZGFsID0gUmVhY3QudXNlUmVmKHt9KTtcbiAgdmFyIG1vdW50Tm9kZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIG1vZGFsUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgaGFuZGxlUmVmID0gdXNlRm9ya1JlZihtb2RhbFJlZiwgcmVmKTtcbiAgdmFyIGhhc1RyYW5zaXRpb24gPSBnZXRIYXNUcmFuc2l0aW9uKHByb3BzKTtcblxuICB2YXIgZ2V0RG9jID0gZnVuY3Rpb24gZ2V0RG9jKCkge1xuICAgIHJldHVybiBvd25lckRvY3VtZW50KG1vdW50Tm9kZVJlZi5jdXJyZW50KTtcbiAgfTtcblxuICB2YXIgZ2V0TW9kYWwgPSBmdW5jdGlvbiBnZXRNb2RhbCgpIHtcbiAgICBtb2RhbC5jdXJyZW50Lm1vZGFsUmVmID0gbW9kYWxSZWYuY3VycmVudDtcbiAgICBtb2RhbC5jdXJyZW50Lm1vdW50Tm9kZSA9IG1vdW50Tm9kZVJlZi5jdXJyZW50O1xuICAgIHJldHVybiBtb2RhbC5jdXJyZW50O1xuICB9O1xuXG4gIHZhciBoYW5kbGVNb3VudGVkID0gZnVuY3Rpb24gaGFuZGxlTW91bnRlZCgpIHtcbiAgICBtYW5hZ2VyLm1vdW50KGdldE1vZGFsKCksIHtcbiAgICAgIGRpc2FibGVTY3JvbGxMb2NrOiBkaXNhYmxlU2Nyb2xsTG9ja1xuICAgIH0pOyAvLyBGaXggYSBidWcgb24gQ2hyb21lIHdoZXJlIHRoZSBzY3JvbGwgaXNuJ3QgaW5pdGlhbGx5IDAuXG5cbiAgICBtb2RhbFJlZi5jdXJyZW50LnNjcm9sbFRvcCA9IDA7XG4gIH07XG5cbiAgdmFyIGhhbmRsZU9wZW4gPSB1c2VFdmVudENhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzb2x2ZWRDb250YWluZXIgPSBnZXRDb250YWluZXIoY29udGFpbmVyKSB8fCBnZXREb2MoKS5ib2R5O1xuICAgIG1hbmFnZXIuYWRkKGdldE1vZGFsKCksIHJlc29sdmVkQ29udGFpbmVyKTsgLy8gVGhlIGVsZW1lbnQgd2FzIGFscmVhZHkgbW91bnRlZC5cblxuICAgIGlmIChtb2RhbFJlZi5jdXJyZW50KSB7XG4gICAgICBoYW5kbGVNb3VudGVkKCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIGlzVG9wTW9kYWwgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1hbmFnZXIuaXNUb3BNb2RhbChnZXRNb2RhbCgpKTtcbiAgfSwgW21hbmFnZXJdKTtcbiAgdmFyIGhhbmRsZVBvcnRhbFJlZiA9IHVzZUV2ZW50Q2FsbGJhY2soZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBtb3VudE5vZGVSZWYuY3VycmVudCA9IG5vZGU7XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob25SZW5kZXJlZCkge1xuICAgICAgb25SZW5kZXJlZCgpO1xuICAgIH1cblxuICAgIGlmIChvcGVuICYmIGlzVG9wTW9kYWwoKSkge1xuICAgICAgaGFuZGxlTW91bnRlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmlhSGlkZGVuKG1vZGFsUmVmLmN1cnJlbnQsIHRydWUpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBoYW5kbGVDbG9zZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBtYW5hZ2VyLnJlbW92ZShnZXRNb2RhbCgpKTtcbiAgfSwgW21hbmFnZXJdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaGFuZGxlQ2xvc2UoKTtcbiAgICB9O1xuICB9LCBbaGFuZGxlQ2xvc2VdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAob3Blbikge1xuICAgICAgaGFuZGxlT3BlbigpO1xuICAgIH0gZWxzZSBpZiAoIWhhc1RyYW5zaXRpb24gfHwgIWNsb3NlQWZ0ZXJUcmFuc2l0aW9uKSB7XG4gICAgICBoYW5kbGVDbG9zZSgpO1xuICAgIH1cbiAgfSwgW29wZW4sIGhhbmRsZUNsb3NlLCBoYXNUcmFuc2l0aW9uLCBjbG9zZUFmdGVyVHJhbnNpdGlvbiwgaGFuZGxlT3Blbl0pO1xuXG4gIGlmICgha2VlcE1vdW50ZWQgJiYgIW9wZW4gJiYgKCFoYXNUcmFuc2l0aW9uIHx8IGV4aXRlZCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBoYW5kbGVFbnRlciA9IGZ1bmN0aW9uIGhhbmRsZUVudGVyKCkge1xuICAgIHNldEV4aXRlZChmYWxzZSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUV4aXRlZCA9IGZ1bmN0aW9uIGhhbmRsZUV4aXRlZCgpIHtcbiAgICBzZXRFeGl0ZWQodHJ1ZSk7XG5cbiAgICBpZiAoY2xvc2VBZnRlclRyYW5zaXRpb24pIHtcbiAgICAgIGhhbmRsZUNsb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVCYWNrZHJvcENsaWNrID0gZnVuY3Rpb24gaGFuZGxlQmFja2Ryb3BDbGljayhldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgIT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob25CYWNrZHJvcENsaWNrKSB7XG4gICAgICBvbkJhY2tkcm9wQ2xpY2soZXZlbnQpO1xuICAgIH1cblxuICAgIGlmICghZGlzYWJsZUJhY2tkcm9wQ2xpY2sgJiYgb25DbG9zZSkge1xuICAgICAgb25DbG9zZShldmVudCwgJ2JhY2tkcm9wQ2xpY2snKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZUtleURvd24gPSBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgLy8gVGhlIGhhbmRsZXIgZG9lc24ndCB0YWtlIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgaW50byBhY2NvdW50OlxuICAgIC8vXG4gICAgLy8gZXZlbnQucHJldmVudERlZmF1bHQoKSBpcyBtZWFudCB0byBzdG9wIGRlZmF1bHQgYmVoYXZpb3VycyBsaWtlXG4gICAgLy8gY2xpY2tpbmcgYSBjaGVja2JveCB0byBjaGVjayBpdCwgaGl0dGluZyBhIGJ1dHRvbiB0byBzdWJtaXQgYSBmb3JtLFxuICAgIC8vIGFuZCBoaXR0aW5nIGxlZnQgYXJyb3cgdG8gbW92ZSB0aGUgY3Vyc29yIGluIGEgdGV4dCBpbnB1dCBldGMuXG4gICAgLy8gT25seSBzcGVjaWFsIEhUTUwgZWxlbWVudHMgaGF2ZSB0aGVzZSBkZWZhdWx0IGJlaGF2aW9ycy5cbiAgICBpZiAoZXZlbnQua2V5ICE9PSAnRXNjYXBlJyB8fCAhaXNUb3BNb2RhbCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9uRXNjYXBlS2V5RG93bikge1xuICAgICAgb25Fc2NhcGVLZXlEb3duKGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoIWRpc2FibGVFc2NhcGVLZXlEb3duKSB7XG4gICAgICAvLyBTd2FsbG93IHRoZSBldmVudCwgaW4gY2FzZSBzb21lb25lIGlzIGxpc3RlbmluZyBmb3IgdGhlIGVzY2FwZSBrZXkgb24gdGhlIGJvZHkuXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgaWYgKG9uQ2xvc2UpIHtcbiAgICAgICAgb25DbG9zZShldmVudCwgJ2VzY2FwZUtleURvd24nKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGlubGluZVN0eWxlID0gc3R5bGVzKHRoZW1lIHx8IHtcbiAgICB6SW5kZXg6IHpJbmRleFxuICB9KTtcbiAgdmFyIGNoaWxkUHJvcHMgPSB7fTtcblxuICBpZiAoY2hpbGRyZW4ucHJvcHMudGFiSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgIGNoaWxkUHJvcHMudGFiSW5kZXggPSBjaGlsZHJlbi5wcm9wcy50YWJJbmRleCB8fCAnLTEnO1xuICB9IC8vIEl0J3MgYSBUcmFuc2l0aW9uIGxpa2UgY29tcG9uZW50XG5cblxuICBpZiAoaGFzVHJhbnNpdGlvbikge1xuICAgIGNoaWxkUHJvcHMub25FbnRlciA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihoYW5kbGVFbnRlciwgY2hpbGRyZW4ucHJvcHMub25FbnRlcik7XG4gICAgY2hpbGRQcm9wcy5vbkV4aXRlZCA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihoYW5kbGVFeGl0ZWQsIGNoaWxkcmVuLnByb3BzLm9uRXhpdGVkKTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQb3J0YWwsIHtcbiAgICByZWY6IGhhbmRsZVBvcnRhbFJlZixcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBkaXNhYmxlUG9ydGFsOiBkaXNhYmxlUG9ydGFsXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICByZWY6IGhhbmRsZVJlZixcbiAgICBvbktleURvd246IGhhbmRsZUtleURvd24sXG4gICAgcm9sZTogXCJwcmVzZW50YXRpb25cIlxuICB9LCBvdGhlciwge1xuICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgaW5saW5lU3R5bGUucm9vdCwgIW9wZW4gJiYgZXhpdGVkID8gaW5saW5lU3R5bGUuaGlkZGVuIDoge30sIG90aGVyLnN0eWxlKVxuICB9KSwgaGlkZUJhY2tkcm9wID8gbnVsbCA6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEJhY2tkcm9wQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgb3Blbjogb3BlbixcbiAgICBvbkNsaWNrOiBoYW5kbGVCYWNrZHJvcENsaWNrXG4gIH0sIEJhY2tkcm9wUHJvcHMpKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhcEZvY3VzLCB7XG4gICAgZGlzYWJsZUVuZm9yY2VGb2N1czogZGlzYWJsZUVuZm9yY2VGb2N1cyxcbiAgICBkaXNhYmxlQXV0b0ZvY3VzOiBkaXNhYmxlQXV0b0ZvY3VzLFxuICAgIGRpc2FibGVSZXN0b3JlRm9jdXM6IGRpc2FibGVSZXN0b3JlRm9jdXMsXG4gICAgZ2V0RG9jOiBnZXREb2MsXG4gICAgaXNFbmFibGVkOiBpc1RvcE1vZGFsLFxuICAgIG9wZW46IG9wZW5cbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChjaGlsZHJlbiwgY2hpbGRQcm9wcykpKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IE1vZGFsLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIEEgYmFja2Ryb3AgY29tcG9uZW50LiBUaGlzIHByb3AgZW5hYmxlcyBjdXN0b20gYmFja2Ryb3AgcmVuZGVyaW5nLlxuICAgKi9cbiAgQmFja2Ryb3BDb21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogUHJvcHMgYXBwbGllZCB0byB0aGUgW2BCYWNrZHJvcGBdKC9hcGkvYmFja2Ryb3AvKSBlbGVtZW50LlxuICAgKi9cbiAgQmFja2Ryb3BQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQSBzaW5nbGUgY2hpbGQgY29udGVudCBlbGVtZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IGVsZW1lbnRBY2NlcHRpbmdSZWYuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogV2hlbiBzZXQgdG8gdHJ1ZSB0aGUgTW9kYWwgd2FpdHMgdW50aWwgYSBuZXN0ZWQgVHJhbnNpdGlvbiBpcyBjb21wbGV0ZWQgYmVmb3JlIGNsb3NpbmcuXG4gICAqL1xuICBjbG9zZUFmdGVyVHJhbnNpdGlvbjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEEgSFRNTCBlbGVtZW50LCBjb21wb25lbnQgaW5zdGFuY2UsIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBlaXRoZXIuXG4gICAqIFRoZSBgY29udGFpbmVyYCB3aWxsIGhhdmUgdGhlIHBvcnRhbCBjaGlsZHJlbiBhcHBlbmRlZCB0byBpdC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgaXQgdXNlcyB0aGUgYm9keSBvZiB0aGUgdG9wLWxldmVsIGRvY3VtZW50IG9iamVjdCxcbiAgICogc28gaXQncyBzaW1wbHkgYGRvY3VtZW50LmJvZHlgIG1vc3Qgb2YgdGhlIHRpbWUuXG4gICAqL1xuICBjb250YWluZXI6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5vbmVPZlR5cGUoW0hUTUxFbGVtZW50VHlwZSwgUHJvcFR5cGVzLmluc3RhbmNlT2YoUmVhY3QuQ29tcG9uZW50KSwgUHJvcFR5cGVzLmZ1bmNdKSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbW9kYWwgd2lsbCBub3QgYXV0b21hdGljYWxseSBzaGlmdCBmb2N1cyB0byBpdHNlbGYgd2hlbiBpdCBvcGVucywgYW5kXG4gICAqIHJlcGxhY2UgaXQgdG8gdGhlIGxhc3QgZm9jdXNlZCBlbGVtZW50IHdoZW4gaXQgY2xvc2VzLlxuICAgKiBUaGlzIGFsc28gd29ya3MgY29ycmVjdGx5IHdpdGggYW55IG1vZGFsIGNoaWxkcmVuIHRoYXQgaGF2ZSB0aGUgYGRpc2FibGVBdXRvRm9jdXNgIHByb3AuXG4gICAqXG4gICAqIEdlbmVyYWxseSB0aGlzIHNob3VsZCBuZXZlciBiZSBzZXQgdG8gYHRydWVgIGFzIGl0IG1ha2VzIHRoZSBtb2RhbCBsZXNzXG4gICAqIGFjY2Vzc2libGUgdG8gYXNzaXN0aXZlIHRlY2hub2xvZ2llcywgbGlrZSBzY3JlZW4gcmVhZGVycy5cbiAgICovXG4gIGRpc2FibGVBdXRvRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGNsaWNraW5nIHRoZSBiYWNrZHJvcCB3aWxsIG5vdCBmaXJlIGBvbkNsb3NlYC5cbiAgICovXG4gIGRpc2FibGVCYWNrZHJvcENsaWNrOiBkZXByZWNhdGVkUHJvcFR5cGUoUHJvcFR5cGVzLmJvb2wsICdVc2UgdGhlIG9uQ2xvc2UgcHJvcCB3aXRoIHRoZSBgcmVhc29uYCBhcmd1bWVudCB0byBmaWx0ZXIgdGhlIGBiYWNrZHJvcENsaWNrYCBldmVudHMuJyksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIG1vZGFsIHdpbGwgbm90IHByZXZlbnQgZm9jdXMgZnJvbSBsZWF2aW5nIHRoZSBtb2RhbCB3aGlsZSBvcGVuLlxuICAgKlxuICAgKiBHZW5lcmFsbHkgdGhpcyBzaG91bGQgbmV2ZXIgYmUgc2V0IHRvIGB0cnVlYCBhcyBpdCBtYWtlcyB0aGUgbW9kYWwgbGVzc1xuICAgKiBhY2Nlc3NpYmxlIHRvIGFzc2lzdGl2ZSB0ZWNobm9sb2dpZXMsIGxpa2Ugc2NyZWVuIHJlYWRlcnMuXG4gICAqL1xuICBkaXNhYmxlRW5mb3JjZUZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBoaXR0aW5nIGVzY2FwZSB3aWxsIG5vdCBmaXJlIGBvbkNsb3NlYC5cbiAgICovXG4gIGRpc2FibGVFc2NhcGVLZXlEb3duOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogRGlzYWJsZSB0aGUgcG9ydGFsIGJlaGF2aW9yLlxuICAgKiBUaGUgY2hpbGRyZW4gc3RheSB3aXRoaW4gaXQncyBwYXJlbnQgRE9NIGhpZXJhcmNoeS5cbiAgICovXG4gIGRpc2FibGVQb3J0YWw6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBtb2RhbCB3aWxsIG5vdCByZXN0b3JlIGZvY3VzIHRvIHByZXZpb3VzbHkgZm9jdXNlZCBlbGVtZW50IG9uY2VcbiAgICogbW9kYWwgaXMgaGlkZGVuLlxuICAgKi9cbiAgZGlzYWJsZVJlc3RvcmVGb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIERpc2FibGUgdGhlIHNjcm9sbCBsb2NrIGJlaGF2aW9yLlxuICAgKi9cbiAgZGlzYWJsZVNjcm9sbExvY2s6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBiYWNrZHJvcCBpcyBub3QgcmVuZGVyZWQuXG4gICAqL1xuICBoaWRlQmFja2Ryb3A6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBBbHdheXMga2VlcCB0aGUgY2hpbGRyZW4gaW4gdGhlIERPTS5cbiAgICogVGhpcyBwcm9wIGNhbiBiZSB1c2VmdWwgaW4gU0VPIHNpdHVhdGlvbiBvclxuICAgKiB3aGVuIHlvdSB3YW50IHRvIG1heGltaXplIHRoZSByZXNwb25zaXZlbmVzcyBvZiB0aGUgTW9kYWwuXG4gICAqL1xuICBrZWVwTW91bnRlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG1hbmFnZXI6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGJhY2tkcm9wIGlzIGNsaWNrZWQuXG4gICAqL1xuICBvbkJhY2tkcm9wQ2xpY2s6IGRlcHJlY2F0ZWRQcm9wVHlwZShQcm9wVHlwZXMuZnVuYywgJ1VzZSB0aGUgb25DbG9zZSBwcm9wIHdpdGggdGhlIGByZWFzb25gIGFyZ3VtZW50IHRvIGhhbmRsZSB0aGUgYGJhY2tkcm9wQ2xpY2tgIGV2ZW50cy4nKSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IHJlcXVlc3RzIHRvIGJlIGNsb3NlZC5cbiAgICogVGhlIGByZWFzb25gIHBhcmFtZXRlciBjYW4gb3B0aW9uYWxseSBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIHJlc3BvbnNlIHRvIGBvbkNsb3NlYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIENhbiBiZTogYFwiZXNjYXBlS2V5RG93blwiYCwgYFwiYmFja2Ryb3BDbGlja1wiYC5cbiAgICovXG4gIG9uQ2xvc2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBlc2NhcGUga2V5IGlzIHByZXNzZWQsXG4gICAqIGBkaXNhYmxlRXNjYXBlS2V5RG93bmAgaXMgZmFsc2UgYW5kIHRoZSBtb2RhbCBpcyBpbiBmb2N1cy5cbiAgICovXG4gIG9uRXNjYXBlS2V5RG93bjogZGVwcmVjYXRlZFByb3BUeXBlKFByb3BUeXBlcy5mdW5jLCAnVXNlIHRoZSBvbkNsb3NlIHByb3Agd2l0aCB0aGUgYHJlYXNvbmAgYXJndW1lbnQgdG8gaGFuZGxlIHRoZSBgZXNjYXBlS2V5RG93bmAgZXZlbnRzLicpLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBvbmNlIHRoZSBjaGlsZHJlbiBoYXMgYmVlbiBtb3VudGVkIGludG8gdGhlIGBjb250YWluZXJgLlxuICAgKiBJdCBzaWduYWxzIHRoYXQgdGhlIGBvcGVuPXt0cnVlfWAgcHJvcCB0b29rIGVmZmVjdC5cbiAgICpcbiAgICogVGhpcyBwcm9wIHdpbGwgYmUgcmVtb3ZlZCBpbiB2NSwgdGhlIHJlZiBjYW4gYmUgdXNlZCBpbnN0ZWFkLlxuICAgKi9cbiAgb25SZW5kZXJlZDogZGVwcmVjYXRlZFByb3BUeXBlKFByb3BUeXBlcy5mdW5jLCAnVXNlIHRoZSByZWYgaW5zdGVhZC4nKSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbW9kYWwgaXMgb3Blbi5cbiAgICovXG4gIG9wZW46IFByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWRcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCBNb2RhbDsiLCJleHBvcnQgdmFyIHJlZmxvdyA9IGZ1bmN0aW9uIHJlZmxvdyhub2RlKSB7XG4gIHJldHVybiBub2RlLnNjcm9sbFRvcDtcbn07XG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblByb3BzKHByb3BzLCBvcHRpb25zKSB7XG4gIHZhciB0aW1lb3V0ID0gcHJvcHMudGltZW91dCxcbiAgICAgIF9wcm9wcyRzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgc3R5bGUgPSBfcHJvcHMkc3R5bGUgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJHN0eWxlO1xuICByZXR1cm4ge1xuICAgIGR1cmF0aW9uOiBzdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gfHwgdHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInID8gdGltZW91dCA6IHRpbWVvdXRbb3B0aW9ucy5tb2RlXSB8fCAwLFxuICAgIGRlbGF5OiBzdHlsZS50cmFuc2l0aW9uRGVsYXlcbiAgfTtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBUcmFuc2l0aW9uIH0gZnJvbSAncmVhY3QtdHJhbnNpdGlvbi1ncm91cCc7XG5pbXBvcnQgdXNlVGhlbWUgZnJvbSAnLi4vc3R5bGVzL3VzZVRoZW1lJztcbmltcG9ydCB7IHJlZmxvdywgZ2V0VHJhbnNpdGlvblByb3BzIH0gZnJvbSAnLi4vdHJhbnNpdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHVzZUZvcmtSZWYgZnJvbSAnLi4vdXRpbHMvdXNlRm9ya1JlZic7XG5cbmZ1bmN0aW9uIGdldFNjYWxlKHZhbHVlKSB7XG4gIHJldHVybiBcInNjYWxlKFwiLmNvbmNhdCh2YWx1ZSwgXCIsIFwiKS5jb25jYXQoTWF0aC5wb3codmFsdWUsIDIpLCBcIilcIik7XG59XG5cbnZhciBzdHlsZXMgPSB7XG4gIGVudGVyaW5nOiB7XG4gICAgb3BhY2l0eTogMSxcbiAgICB0cmFuc2Zvcm06IGdldFNjYWxlKDEpXG4gIH0sXG4gIGVudGVyZWQ6IHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIHRyYW5zZm9ybTogJ25vbmUnXG4gIH1cbn07XG4vKipcbiAqIFRoZSBHcm93IHRyYW5zaXRpb24gaXMgdXNlZCBieSB0aGUgW1Rvb2x0aXBdKC9jb21wb25lbnRzL3Rvb2x0aXBzLykgYW5kXG4gKiBbUG9wb3Zlcl0oL2NvbXBvbmVudHMvcG9wb3Zlci8pIGNvbXBvbmVudHMuXG4gKiBJdCB1c2VzIFtyZWFjdC10cmFuc2l0aW9uLWdyb3VwXShodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwKSBpbnRlcm5hbGx5LlxuICovXG5cbnZhciBHcm93ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gR3Jvdyhwcm9wcywgcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgX3Byb3BzJGRpc2FibGVTdHJpY3RNID0gcHJvcHMuZGlzYWJsZVN0cmljdE1vZGVDb21wYXQsXG4gICAgICBkaXNhYmxlU3RyaWN0TW9kZUNvbXBhdCA9IF9wcm9wcyRkaXNhYmxlU3RyaWN0TSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZVN0cmljdE0sXG4gICAgICBpblByb3AgPSBwcm9wcy5pbixcbiAgICAgIG9uRW50ZXIgPSBwcm9wcy5vbkVudGVyLFxuICAgICAgb25FbnRlcmVkID0gcHJvcHMub25FbnRlcmVkLFxuICAgICAgb25FbnRlcmluZyA9IHByb3BzLm9uRW50ZXJpbmcsXG4gICAgICBvbkV4aXQgPSBwcm9wcy5vbkV4aXQsXG4gICAgICBvbkV4aXRlZCA9IHByb3BzLm9uRXhpdGVkLFxuICAgICAgb25FeGl0aW5nID0gcHJvcHMub25FeGl0aW5nLFxuICAgICAgc3R5bGUgPSBwcm9wcy5zdHlsZSxcbiAgICAgIF9wcm9wcyR0aW1lb3V0ID0gcHJvcHMudGltZW91dCxcbiAgICAgIHRpbWVvdXQgPSBfcHJvcHMkdGltZW91dCA9PT0gdm9pZCAwID8gJ2F1dG8nIDogX3Byb3BzJHRpbWVvdXQsXG4gICAgICBfcHJvcHMkVHJhbnNpdGlvbkNvbXAgPSBwcm9wcy5UcmFuc2l0aW9uQ29tcG9uZW50LFxuICAgICAgVHJhbnNpdGlvbkNvbXBvbmVudCA9IF9wcm9wcyRUcmFuc2l0aW9uQ29tcCA9PT0gdm9pZCAwID8gVHJhbnNpdGlvbiA6IF9wcm9wcyRUcmFuc2l0aW9uQ29tcCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImRpc2FibGVTdHJpY3RNb2RlQ29tcGF0XCIsIFwiaW5cIiwgXCJvbkVudGVyXCIsIFwib25FbnRlcmVkXCIsIFwib25FbnRlcmluZ1wiLCBcIm9uRXhpdFwiLCBcIm9uRXhpdGVkXCIsIFwib25FeGl0aW5nXCIsIFwic3R5bGVcIiwgXCJ0aW1lb3V0XCIsIFwiVHJhbnNpdGlvbkNvbXBvbmVudFwiXSk7XG5cbiAgdmFyIHRpbWVyID0gUmVhY3QudXNlUmVmKCk7XG4gIHZhciBhdXRvVGltZW91dCA9IFJlYWN0LnVzZVJlZigpO1xuICB2YXIgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICB2YXIgZW5hYmxlU3RyaWN0TW9kZUNvbXBhdCA9IHRoZW1lLnVuc3RhYmxlX3N0cmljdE1vZGUgJiYgIWRpc2FibGVTdHJpY3RNb2RlQ29tcGF0O1xuICB2YXIgbm9kZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIGZvcmVpZ25SZWYgPSB1c2VGb3JrUmVmKGNoaWxkcmVuLnJlZiwgcmVmKTtcbiAgdmFyIGhhbmRsZVJlZiA9IHVzZUZvcmtSZWYoZW5hYmxlU3RyaWN0TW9kZUNvbXBhdCA/IG5vZGVSZWYgOiB1bmRlZmluZWQsIGZvcmVpZ25SZWYpO1xuXG4gIHZhciBub3JtYWxpemVkVHJhbnNpdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24gbm9ybWFsaXplZFRyYW5zaXRpb25DYWxsYmFjayhjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZU9yQXBwZWFyaW5nLCBtYXliZUFwcGVhcmluZykge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfcmVmID0gZW5hYmxlU3RyaWN0TW9kZUNvbXBhdCA/IFtub2RlUmVmLmN1cnJlbnQsIG5vZGVPckFwcGVhcmluZ10gOiBbbm9kZU9yQXBwZWFyaW5nLCBtYXliZUFwcGVhcmluZ10sXG4gICAgICAgICAgICBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgbm9kZSA9IF9yZWYyWzBdLFxuICAgICAgICAgICAgaXNBcHBlYXJpbmcgPSBfcmVmMlsxXTsgLy8gb25FbnRlclh4eCBhbmQgb25FeGl0WHh4IGNhbGxiYWNrcyBoYXZlIGEgZGlmZmVyZW50IGFyZ3VtZW50cy5sZW5ndGggdmFsdWUuXG5cblxuICAgICAgICBpZiAoaXNBcHBlYXJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNhbGxiYWNrKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKG5vZGUsIGlzQXBwZWFyaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGhhbmRsZUVudGVyaW5nID0gbm9ybWFsaXplZFRyYW5zaXRpb25DYWxsYmFjayhvbkVudGVyaW5nKTtcbiAgdmFyIGhhbmRsZUVudGVyID0gbm9ybWFsaXplZFRyYW5zaXRpb25DYWxsYmFjayhmdW5jdGlvbiAobm9kZSwgaXNBcHBlYXJpbmcpIHtcbiAgICByZWZsb3cobm9kZSk7IC8vIFNvIHRoZSBhbmltYXRpb24gYWx3YXlzIHN0YXJ0IGZyb20gdGhlIHN0YXJ0LlxuXG4gICAgdmFyIF9nZXRUcmFuc2l0aW9uUHJvcHMgPSBnZXRUcmFuc2l0aW9uUHJvcHMoe1xuICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgdGltZW91dDogdGltZW91dFxuICAgIH0sIHtcbiAgICAgIG1vZGU6ICdlbnRlcidcbiAgICB9KSxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gX2dldFRyYW5zaXRpb25Qcm9wcy5kdXJhdGlvbixcbiAgICAgICAgZGVsYXkgPSBfZ2V0VHJhbnNpdGlvblByb3BzLmRlbGF5O1xuXG4gICAgdmFyIGR1cmF0aW9uO1xuXG4gICAgaWYgKHRpbWVvdXQgPT09ICdhdXRvJykge1xuICAgICAgZHVyYXRpb24gPSB0aGVtZS50cmFuc2l0aW9ucy5nZXRBdXRvSGVpZ2h0RHVyYXRpb24obm9kZS5jbGllbnRIZWlnaHQpO1xuICAgICAgYXV0b1RpbWVvdXQuY3VycmVudCA9IGR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdXJhdGlvbiA9IHRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICB9XG5cbiAgICBub2RlLnN0eWxlLnRyYW5zaXRpb24gPSBbdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKCdvcGFjaXR5Jywge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgZGVsYXk6IGRlbGF5XG4gICAgfSksIHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZSgndHJhbnNmb3JtJywge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uICogMC42NjYsXG4gICAgICBkZWxheTogZGVsYXlcbiAgICB9KV0uam9pbignLCcpO1xuXG4gICAgaWYgKG9uRW50ZXIpIHtcbiAgICAgIG9uRW50ZXIobm9kZSwgaXNBcHBlYXJpbmcpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBoYW5kbGVFbnRlcmVkID0gbm9ybWFsaXplZFRyYW5zaXRpb25DYWxsYmFjayhvbkVudGVyZWQpO1xuICB2YXIgaGFuZGxlRXhpdGluZyA9IG5vcm1hbGl6ZWRUcmFuc2l0aW9uQ2FsbGJhY2sob25FeGl0aW5nKTtcbiAgdmFyIGhhbmRsZUV4aXQgPSBub3JtYWxpemVkVHJhbnNpdGlvbkNhbGxiYWNrKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIF9nZXRUcmFuc2l0aW9uUHJvcHMyID0gZ2V0VHJhbnNpdGlvblByb3BzKHtcbiAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgIHRpbWVvdXQ6IHRpbWVvdXRcbiAgICB9LCB7XG4gICAgICBtb2RlOiAnZXhpdCdcbiAgICB9KSxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gX2dldFRyYW5zaXRpb25Qcm9wczIuZHVyYXRpb24sXG4gICAgICAgIGRlbGF5ID0gX2dldFRyYW5zaXRpb25Qcm9wczIuZGVsYXk7XG5cbiAgICB2YXIgZHVyYXRpb247XG5cbiAgICBpZiAodGltZW91dCA9PT0gJ2F1dG8nKSB7XG4gICAgICBkdXJhdGlvbiA9IHRoZW1lLnRyYW5zaXRpb25zLmdldEF1dG9IZWlnaHREdXJhdGlvbihub2RlLmNsaWVudEhlaWdodCk7XG4gICAgICBhdXRvVGltZW91dC5jdXJyZW50ID0gZHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1cmF0aW9uID0gdHJhbnNpdGlvbkR1cmF0aW9uO1xuICAgIH1cblxuICAgIG5vZGUuc3R5bGUudHJhbnNpdGlvbiA9IFt0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoJ29wYWNpdHknLCB7XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICBkZWxheTogZGVsYXlcbiAgICB9KSwgdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKCd0cmFuc2Zvcm0nLCB7XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24gKiAwLjY2NixcbiAgICAgIGRlbGF5OiBkZWxheSB8fCBkdXJhdGlvbiAqIDAuMzMzXG4gICAgfSldLmpvaW4oJywnKTtcbiAgICBub2RlLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBnZXRTY2FsZSgwLjc1KTtcblxuICAgIGlmIChvbkV4aXQpIHtcbiAgICAgIG9uRXhpdChub2RlKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgaGFuZGxlRXhpdGVkID0gbm9ybWFsaXplZFRyYW5zaXRpb25DYWxsYmFjayhvbkV4aXRlZCk7XG5cbiAgdmFyIGFkZEVuZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkRW5kTGlzdGVuZXIobm9kZU9yTmV4dCwgbWF5YmVOZXh0KSB7XG4gICAgdmFyIG5leHQgPSBlbmFibGVTdHJpY3RNb2RlQ29tcGF0ID8gbm9kZU9yTmV4dCA6IG1heWJlTmV4dDtcblxuICAgIGlmICh0aW1lb3V0ID09PSAnYXV0bycpIHtcbiAgICAgIHRpbWVyLmN1cnJlbnQgPSBzZXRUaW1lb3V0KG5leHQsIGF1dG9UaW1lb3V0LmN1cnJlbnQgfHwgMCk7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lci5jdXJyZW50KTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUcmFuc2l0aW9uQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgYXBwZWFyOiB0cnVlLFxuICAgIGluOiBpblByb3AsXG4gICAgbm9kZVJlZjogZW5hYmxlU3RyaWN0TW9kZUNvbXBhdCA/IG5vZGVSZWYgOiB1bmRlZmluZWQsXG4gICAgb25FbnRlcjogaGFuZGxlRW50ZXIsXG4gICAgb25FbnRlcmVkOiBoYW5kbGVFbnRlcmVkLFxuICAgIG9uRW50ZXJpbmc6IGhhbmRsZUVudGVyaW5nLFxuICAgIG9uRXhpdDogaGFuZGxlRXhpdCxcbiAgICBvbkV4aXRlZDogaGFuZGxlRXhpdGVkLFxuICAgIG9uRXhpdGluZzogaGFuZGxlRXhpdGluZyxcbiAgICBhZGRFbmRMaXN0ZW5lcjogYWRkRW5kTGlzdGVuZXIsXG4gICAgdGltZW91dDogdGltZW91dCA9PT0gJ2F1dG8nID8gbnVsbCA6IHRpbWVvdXRcbiAgfSwgb3RoZXIpLCBmdW5jdGlvbiAoc3RhdGUsIGNoaWxkUHJvcHMpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChjaGlsZHJlbiwgX2V4dGVuZHMoe1xuICAgICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgdHJhbnNmb3JtOiBnZXRTY2FsZSgwLjc1KSxcbiAgICAgICAgdmlzaWJpbGl0eTogc3RhdGUgPT09ICdleGl0ZWQnICYmICFpblByb3AgPyAnaGlkZGVuJyA6IHVuZGVmaW5lZFxuICAgICAgfSwgc3R5bGVzW3N0YXRlXSwgc3R5bGUsIGNoaWxkcmVuLnByb3BzLnN0eWxlKSxcbiAgICAgIHJlZjogaGFuZGxlUmVmXG4gICAgfSwgY2hpbGRQcm9wcykpO1xuICB9KTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gR3Jvdy5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBBIHNpbmdsZSBjaGlsZCBjb250ZW50IGVsZW1lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLmVsZW1lbnQsXG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGlzIHByb3AgaWYgeW91IGVuY291bnRlciAnRnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcycsXG4gICAqIHVzZSBgdW5zdGFibGVfY3JlYXRlU3RyaWN0TW9kZVRoZW1lYCxcbiAgICogYW5kIGNhbid0IGZvcndhcmQgdGhlIHJlZiBpbiB0aGUgY2hpbGQgY29tcG9uZW50LlxuICAgKi9cbiAgZGlzYWJsZVN0cmljdE1vZGVDb21wYXQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHNob3cgdGhlIGNvbXBvbmVudDsgdHJpZ2dlcnMgdGhlIGVudGVyIG9yIGV4aXQgYW5pbWF0aW9uLlxuICAgKi9cbiAgaW46IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkVudGVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25FbnRlcmVkOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25FbnRlcmluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRXhpdDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRXhpdGVkOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25FeGl0aW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFRoZSBkdXJhdGlvbiBmb3IgdGhlIHRyYW5zaXRpb24sIGluIG1pbGxpc2Vjb25kcy5cbiAgICogWW91IG1heSBzcGVjaWZ5IGEgc2luZ2xlIHRpbWVvdXQgZm9yIGFsbCB0cmFuc2l0aW9ucywgb3IgaW5kaXZpZHVhbGx5IHdpdGggYW4gb2JqZWN0LlxuICAgKlxuICAgKiBTZXQgdG8gJ2F1dG8nIHRvIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlIHRyYW5zaXRpb24gdGltZSBiYXNlZCBvbiBoZWlnaHQuXG4gICAqL1xuICB0aW1lb3V0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub25lT2YoWydhdXRvJ10pLCBQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGFwcGVhcjogUHJvcFR5cGVzLm51bWJlcixcbiAgICBlbnRlcjogUHJvcFR5cGVzLm51bWJlcixcbiAgICBleGl0OiBQcm9wVHlwZXMubnVtYmVyXG4gIH0pXSlcbn0gOiB2b2lkIDA7XG5Hcm93Lm11aVN1cHBvcnRBdXRvID0gdHJ1ZTtcbmV4cG9ydCBkZWZhdWx0IEdyb3c7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBjaGFpblByb3BUeXBlcywgZWxlbWVudFR5cGVBY2NlcHRpbmdSZWYsIHJlZlR5cGUsIEhUTUxFbGVtZW50VHlwZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnLi4vdXRpbHMvZGVib3VuY2UnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgb3duZXJEb2N1bWVudCBmcm9tICcuLi91dGlscy9vd25lckRvY3VtZW50JztcbmltcG9ydCBvd25lcldpbmRvdyBmcm9tICcuLi91dGlscy9vd25lcldpbmRvdyc7XG5pbXBvcnQgY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uIGZyb20gJy4uL3V0aWxzL2NyZWF0ZUNoYWluZWRGdW5jdGlvbic7XG5pbXBvcnQgZGVwcmVjYXRlZFByb3BUeXBlIGZyb20gJy4uL3V0aWxzL2RlcHJlY2F0ZWRQcm9wVHlwZSc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5pbXBvcnQgTW9kYWwgZnJvbSAnLi4vTW9kYWwnO1xuaW1wb3J0IEdyb3cgZnJvbSAnLi4vR3Jvdyc7XG5pbXBvcnQgUGFwZXIgZnJvbSAnLi4vUGFwZXInO1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9mZnNldFRvcChyZWN0LCB2ZXJ0aWNhbCkge1xuICB2YXIgb2Zmc2V0ID0gMDtcblxuICBpZiAodHlwZW9mIHZlcnRpY2FsID09PSAnbnVtYmVyJykge1xuICAgIG9mZnNldCA9IHZlcnRpY2FsO1xuICB9IGVsc2UgaWYgKHZlcnRpY2FsID09PSAnY2VudGVyJykge1xuICAgIG9mZnNldCA9IHJlY3QuaGVpZ2h0IC8gMjtcbiAgfSBlbHNlIGlmICh2ZXJ0aWNhbCA9PT0gJ2JvdHRvbScpIHtcbiAgICBvZmZzZXQgPSByZWN0LmhlaWdodDtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0T2Zmc2V0TGVmdChyZWN0LCBob3Jpem9udGFsKSB7XG4gIHZhciBvZmZzZXQgPSAwO1xuXG4gIGlmICh0eXBlb2YgaG9yaXpvbnRhbCA9PT0gJ251bWJlcicpIHtcbiAgICBvZmZzZXQgPSBob3Jpem9udGFsO1xuICB9IGVsc2UgaWYgKGhvcml6b250YWwgPT09ICdjZW50ZXInKSB7XG4gICAgb2Zmc2V0ID0gcmVjdC53aWR0aCAvIDI7XG4gIH0gZWxzZSBpZiAoaG9yaXpvbnRhbCA9PT0gJ3JpZ2h0Jykge1xuICAgIG9mZnNldCA9IHJlY3Qud2lkdGg7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1PcmlnaW5WYWx1ZSh0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgcmV0dXJuIFt0cmFuc2Zvcm1PcmlnaW4uaG9yaXpvbnRhbCwgdHJhbnNmb3JtT3JpZ2luLnZlcnRpY2FsXS5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gdHlwZW9mIG4gPT09ICdudW1iZXInID8gXCJcIi5jb25jYXQobiwgXCJweFwiKSA6IG47XG4gIH0pLmpvaW4oJyAnKTtcbn0gLy8gU3VtIHRoZSBzY3JvbGxUb3AgYmV0d2VlbiB0d28gZWxlbWVudHMuXG5cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIGVsZW1lbnQgPSBjaGlsZDtcbiAgdmFyIHNjcm9sbFRvcCA9IDA7XG5cbiAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudCAhPT0gcGFyZW50KSB7XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICBzY3JvbGxUb3AgKz0gZWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cblxuICByZXR1cm4gc2Nyb2xsVG9wO1xufVxuXG5mdW5jdGlvbiBnZXRBbmNob3JFbChhbmNob3JFbCkge1xuICByZXR1cm4gdHlwZW9mIGFuY2hvckVsID09PSAnZnVuY3Rpb24nID8gYW5jaG9yRWwoKSA6IGFuY2hvckVsO1xufVxuXG5leHBvcnQgdmFyIHN0eWxlcyA9IHtcbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudC4gKi9cbiAgcm9vdDoge30sXG5cbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGBQYXBlcmAgY29tcG9uZW50LiAqL1xuICBwYXBlcjoge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIG92ZXJmbG93WTogJ2F1dG8nLFxuICAgIG92ZXJmbG93WDogJ2hpZGRlbicsXG4gICAgLy8gU28gd2Ugc2VlIHRoZSBwb3BvdmVyIHdoZW4gaXQncyBlbXB0eS5cbiAgICAvLyBJdCdzIG1vc3QgbGlrZWx5IG9uIGlzc3VlIG9uIHVzZXJsYW5kLlxuICAgIG1pbldpZHRoOiAxNixcbiAgICBtaW5IZWlnaHQ6IDE2LFxuICAgIG1heFdpZHRoOiAnY2FsYygxMDAlIC0gMzJweCknLFxuICAgIG1heEhlaWdodDogJ2NhbGMoMTAwJSAtIDMycHgpJyxcbiAgICAvLyBXZSBkaXNhYmxlIHRoZSBmb2N1cyByaW5nIGZvciBtb3VzZSwgdG91Y2ggYW5kIGtleWJvYXJkIHVzZXJzLlxuICAgIG91dGxpbmU6IDBcbiAgfVxufTtcbnZhciBQb3BvdmVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gUG9wb3Zlcihwcm9wcywgcmVmKSB7XG4gIHZhciBhY3Rpb24gPSBwcm9wcy5hY3Rpb24sXG4gICAgICBhbmNob3JFbCA9IHByb3BzLmFuY2hvckVsLFxuICAgICAgX3Byb3BzJGFuY2hvck9yaWdpbiA9IHByb3BzLmFuY2hvck9yaWdpbixcbiAgICAgIGFuY2hvck9yaWdpbiA9IF9wcm9wcyRhbmNob3JPcmlnaW4gPT09IHZvaWQgMCA/IHtcbiAgICB2ZXJ0aWNhbDogJ3RvcCcsXG4gICAgaG9yaXpvbnRhbDogJ2xlZnQnXG4gIH0gOiBfcHJvcHMkYW5jaG9yT3JpZ2luLFxuICAgICAgYW5jaG9yUG9zaXRpb24gPSBwcm9wcy5hbmNob3JQb3NpdGlvbixcbiAgICAgIF9wcm9wcyRhbmNob3JSZWZlcmVuYyA9IHByb3BzLmFuY2hvclJlZmVyZW5jZSxcbiAgICAgIGFuY2hvclJlZmVyZW5jZSA9IF9wcm9wcyRhbmNob3JSZWZlcmVuYyA9PT0gdm9pZCAwID8gJ2FuY2hvckVsJyA6IF9wcm9wcyRhbmNob3JSZWZlcmVuYyxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNvbnRhaW5lclByb3AgPSBwcm9wcy5jb250YWluZXIsXG4gICAgICBfcHJvcHMkZWxldmF0aW9uID0gcHJvcHMuZWxldmF0aW9uLFxuICAgICAgZWxldmF0aW9uID0gX3Byb3BzJGVsZXZhdGlvbiA9PT0gdm9pZCAwID8gOCA6IF9wcm9wcyRlbGV2YXRpb24sXG4gICAgICBnZXRDb250ZW50QW5jaG9yRWwgPSBwcm9wcy5nZXRDb250ZW50QW5jaG9yRWwsXG4gICAgICBfcHJvcHMkbWFyZ2luVGhyZXNob2wgPSBwcm9wcy5tYXJnaW5UaHJlc2hvbGQsXG4gICAgICBtYXJnaW5UaHJlc2hvbGQgPSBfcHJvcHMkbWFyZ2luVGhyZXNob2wgPT09IHZvaWQgMCA/IDE2IDogX3Byb3BzJG1hcmdpblRocmVzaG9sLFxuICAgICAgb25FbnRlciA9IHByb3BzLm9uRW50ZXIsXG4gICAgICBvbkVudGVyZWQgPSBwcm9wcy5vbkVudGVyZWQsXG4gICAgICBvbkVudGVyaW5nID0gcHJvcHMub25FbnRlcmluZyxcbiAgICAgIG9uRXhpdCA9IHByb3BzLm9uRXhpdCxcbiAgICAgIG9uRXhpdGVkID0gcHJvcHMub25FeGl0ZWQsXG4gICAgICBvbkV4aXRpbmcgPSBwcm9wcy5vbkV4aXRpbmcsXG4gICAgICBvcGVuID0gcHJvcHMub3BlbixcbiAgICAgIF9wcm9wcyRQYXBlclByb3BzID0gcHJvcHMuUGFwZXJQcm9wcyxcbiAgICAgIFBhcGVyUHJvcHMgPSBfcHJvcHMkUGFwZXJQcm9wcyA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkUGFwZXJQcm9wcyxcbiAgICAgIF9wcm9wcyR0cmFuc2Zvcm1PcmlnaSA9IHByb3BzLnRyYW5zZm9ybU9yaWdpbixcbiAgICAgIHRyYW5zZm9ybU9yaWdpbiA9IF9wcm9wcyR0cmFuc2Zvcm1PcmlnaSA9PT0gdm9pZCAwID8ge1xuICAgIHZlcnRpY2FsOiAndG9wJyxcbiAgICBob3Jpem9udGFsOiAnbGVmdCdcbiAgfSA6IF9wcm9wcyR0cmFuc2Zvcm1PcmlnaSxcbiAgICAgIF9wcm9wcyRUcmFuc2l0aW9uQ29tcCA9IHByb3BzLlRyYW5zaXRpb25Db21wb25lbnQsXG4gICAgICBUcmFuc2l0aW9uQ29tcG9uZW50ID0gX3Byb3BzJFRyYW5zaXRpb25Db21wID09PSB2b2lkIDAgPyBHcm93IDogX3Byb3BzJFRyYW5zaXRpb25Db21wLFxuICAgICAgX3Byb3BzJHRyYW5zaXRpb25EdXJhID0gcHJvcHMudHJhbnNpdGlvbkR1cmF0aW9uLFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uUHJvcCA9IF9wcm9wcyR0cmFuc2l0aW9uRHVyYSA9PT0gdm9pZCAwID8gJ2F1dG8nIDogX3Byb3BzJHRyYW5zaXRpb25EdXJhLFxuICAgICAgX3Byb3BzJFRyYW5zaXRpb25Qcm9wID0gcHJvcHMuVHJhbnNpdGlvblByb3BzLFxuICAgICAgVHJhbnNpdGlvblByb3BzID0gX3Byb3BzJFRyYW5zaXRpb25Qcm9wID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRUcmFuc2l0aW9uUHJvcCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJhY3Rpb25cIiwgXCJhbmNob3JFbFwiLCBcImFuY2hvck9yaWdpblwiLCBcImFuY2hvclBvc2l0aW9uXCIsIFwiYW5jaG9yUmVmZXJlbmNlXCIsIFwiY2hpbGRyZW5cIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29udGFpbmVyXCIsIFwiZWxldmF0aW9uXCIsIFwiZ2V0Q29udGVudEFuY2hvckVsXCIsIFwibWFyZ2luVGhyZXNob2xkXCIsIFwib25FbnRlclwiLCBcIm9uRW50ZXJlZFwiLCBcIm9uRW50ZXJpbmdcIiwgXCJvbkV4aXRcIiwgXCJvbkV4aXRlZFwiLCBcIm9uRXhpdGluZ1wiLCBcIm9wZW5cIiwgXCJQYXBlclByb3BzXCIsIFwidHJhbnNmb3JtT3JpZ2luXCIsIFwiVHJhbnNpdGlvbkNvbXBvbmVudFwiLCBcInRyYW5zaXRpb25EdXJhdGlvblwiLCBcIlRyYW5zaXRpb25Qcm9wc1wiXSk7XG5cbiAgdmFyIHBhcGVyUmVmID0gUmVhY3QudXNlUmVmKCk7IC8vIFJldHVybnMgdGhlIHRvcC9sZWZ0IG9mZnNldCBvZiB0aGUgcG9zaXRpb25cbiAgLy8gdG8gYXR0YWNoIHRvIG9uIHRoZSBhbmNob3IgZWxlbWVudCAob3IgYm9keSBpZiBub25lIGlzIHByb3ZpZGVkKVxuXG4gIHZhciBnZXRBbmNob3JPZmZzZXQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoY29udGVudEFuY2hvck9mZnNldCkge1xuICAgIGlmIChhbmNob3JSZWZlcmVuY2UgPT09ICdhbmNob3JQb3NpdGlvbicpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICghYW5jaG9yUG9zaXRpb24pIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdNYXRlcmlhbC1VSTogWW91IG5lZWQgdG8gcHJvdmlkZSBhIGBhbmNob3JQb3NpdGlvbmAgcHJvcCB3aGVuIHVzaW5nICcgKyAnPFBvcG92ZXIgYW5jaG9yUmVmZXJlbmNlPVwiYW5jaG9yUG9zaXRpb25cIiAvPi4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYW5jaG9yUG9zaXRpb247XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmVkQW5jaG9yRWwgPSBnZXRBbmNob3JFbChhbmNob3JFbCk7IC8vIElmIGFuIGFuY2hvciBlbGVtZW50IHdhc24ndCBwcm92aWRlZCwganVzdCB1c2UgdGhlIHBhcmVudCBib2R5IGVsZW1lbnQgb2YgdGhpcyBQb3BvdmVyXG5cbiAgICB2YXIgYW5jaG9yRWxlbWVudCA9IHJlc29sdmVkQW5jaG9yRWwgJiYgcmVzb2x2ZWRBbmNob3JFbC5ub2RlVHlwZSA9PT0gMSA/IHJlc29sdmVkQW5jaG9yRWwgOiBvd25lckRvY3VtZW50KHBhcGVyUmVmLmN1cnJlbnQpLmJvZHk7XG4gICAgdmFyIGFuY2hvclJlY3QgPSBhbmNob3JFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBib3ggPSBhbmNob3JFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJiBib3gudG9wID09PSAwICYmIGJveC5sZWZ0ID09PSAwICYmIGJveC5yaWdodCA9PT0gMCAmJiBib3guYm90dG9tID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihbJ01hdGVyaWFsLVVJOiBUaGUgYGFuY2hvckVsYCBwcm9wIHByb3ZpZGVkIHRvIHRoZSBjb21wb25lbnQgaXMgaW52YWxpZC4nLCAnVGhlIGFuY2hvciBlbGVtZW50IHNob3VsZCBiZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBsYXlvdXQuJywgXCJNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgcHJlc2VudCBpbiB0aGUgZG9jdW1lbnQgb3IgdGhhdCBpdCdzIG5vdCBkaXNwbGF5IG5vbmUuXCJdLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYW5jaG9yVmVydGljYWwgPSBjb250ZW50QW5jaG9yT2Zmc2V0ID09PSAwID8gYW5jaG9yT3JpZ2luLnZlcnRpY2FsIDogJ2NlbnRlcic7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogYW5jaG9yUmVjdC50b3AgKyBnZXRPZmZzZXRUb3AoYW5jaG9yUmVjdCwgYW5jaG9yVmVydGljYWwpLFxuICAgICAgbGVmdDogYW5jaG9yUmVjdC5sZWZ0ICsgZ2V0T2Zmc2V0TGVmdChhbmNob3JSZWN0LCBhbmNob3JPcmlnaW4uaG9yaXpvbnRhbClcbiAgICB9O1xuICB9LCBbYW5jaG9yRWwsIGFuY2hvck9yaWdpbi5ob3Jpem9udGFsLCBhbmNob3JPcmlnaW4udmVydGljYWwsIGFuY2hvclBvc2l0aW9uLCBhbmNob3JSZWZlcmVuY2VdKTsgLy8gUmV0dXJucyB0aGUgdmVydGljYWwgb2Zmc2V0IG9mIGlubmVyIGNvbnRlbnQgdG8gYW5jaG9yIHRoZSB0cmFuc2Zvcm0gb24gaWYgcHJvdmlkZWRcblxuICB2YXIgZ2V0Q29udGVudEFuY2hvck9mZnNldCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIGNvbnRlbnRBbmNob3JPZmZzZXQgPSAwO1xuXG4gICAgaWYgKGdldENvbnRlbnRBbmNob3JFbCAmJiBhbmNob3JSZWZlcmVuY2UgPT09ICdhbmNob3JFbCcpIHtcbiAgICAgIHZhciBjb250ZW50QW5jaG9yRWwgPSBnZXRDb250ZW50QW5jaG9yRWwoZWxlbWVudCk7XG5cbiAgICAgIGlmIChjb250ZW50QW5jaG9yRWwgJiYgZWxlbWVudC5jb250YWlucyhjb250ZW50QW5jaG9yRWwpKSB7XG4gICAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCwgY29udGVudEFuY2hvckVsKTtcbiAgICAgICAgY29udGVudEFuY2hvck9mZnNldCA9IGNvbnRlbnRBbmNob3JFbC5vZmZzZXRUb3AgKyBjb250ZW50QW5jaG9yRWwuY2xpZW50SGVpZ2h0IC8gMiAtIHNjcm9sbFRvcCB8fCAwO1xuICAgICAgfSAvLyAhPSB0aGUgZGVmYXVsdCB2YWx1ZVxuXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhbmNob3JPcmlnaW4udmVydGljYWwgIT09ICd0b3AnKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihbJ01hdGVyaWFsLVVJOiBZb3UgY2FuIG5vdCBjaGFuZ2UgdGhlIGRlZmF1bHQgYGFuY2hvck9yaWdpbi52ZXJ0aWNhbGAgdmFsdWUgJywgJ3doZW4gYWxzbyBwcm92aWRpbmcgdGhlIGBnZXRDb250ZW50QW5jaG9yRWxgIHByb3AgdG8gdGhlIHBvcG92ZXIgY29tcG9uZW50LicsICdPbmx5IHVzZSBvbmUgb2YgdGhlIHR3byBwcm9wcy4nLCAnU2V0IGBnZXRDb250ZW50QW5jaG9yRWxgIHRvIGBudWxsIHwgdW5kZWZpbmVkYCcgKyAnIG9yIGxlYXZlIGBhbmNob3JPcmlnaW4udmVydGljYWxgIHVuY2hhbmdlZC4nXS5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGVudEFuY2hvck9mZnNldDtcbiAgfSwgW2FuY2hvck9yaWdpbi52ZXJ0aWNhbCwgYW5jaG9yUmVmZXJlbmNlLCBnZXRDb250ZW50QW5jaG9yRWxdKTsgLy8gUmV0dXJuIHRoZSBiYXNlIHRyYW5zZm9ybSBvcmlnaW4gdXNpbmcgdGhlIGVsZW1lbnRcbiAgLy8gYW5kIHRha2luZyB0aGUgY29udGVudCBhbmNob3Igb2Zmc2V0IGludG8gYWNjb3VudCBpZiBpbiB1c2VcblxuICB2YXIgZ2V0VHJhbnNmb3JtT3JpZ2luID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGVsZW1SZWN0KSB7XG4gICAgdmFyIGNvbnRlbnRBbmNob3JPZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnRpY2FsOiBnZXRPZmZzZXRUb3AoZWxlbVJlY3QsIHRyYW5zZm9ybU9yaWdpbi52ZXJ0aWNhbCkgKyBjb250ZW50QW5jaG9yT2Zmc2V0LFxuICAgICAgaG9yaXpvbnRhbDogZ2V0T2Zmc2V0TGVmdChlbGVtUmVjdCwgdHJhbnNmb3JtT3JpZ2luLmhvcml6b250YWwpXG4gICAgfTtcbiAgfSwgW3RyYW5zZm9ybU9yaWdpbi5ob3Jpem9udGFsLCB0cmFuc2Zvcm1PcmlnaW4udmVydGljYWxdKTtcbiAgdmFyIGdldFBvc2l0aW9uaW5nU3R5bGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIC8vIENoZWNrIGlmIHRoZSBwYXJlbnQgaGFzIHJlcXVlc3RlZCBhbmNob3Jpbmcgb24gYW4gaW5uZXIgY29udGVudCBub2RlXG4gICAgdmFyIGNvbnRlbnRBbmNob3JPZmZzZXQgPSBnZXRDb250ZW50QW5jaG9yT2Zmc2V0KGVsZW1lbnQpO1xuICAgIHZhciBlbGVtUmVjdCA9IHtcbiAgICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodFxuICAgIH07IC8vIEdldCB0aGUgdHJhbnNmb3JtIG9yaWdpbiBwb2ludCBvbiB0aGUgZWxlbWVudCBpdHNlbGZcblxuICAgIHZhciBlbGVtVHJhbnNmb3JtT3JpZ2luID0gZ2V0VHJhbnNmb3JtT3JpZ2luKGVsZW1SZWN0LCBjb250ZW50QW5jaG9yT2Zmc2V0KTtcblxuICAgIGlmIChhbmNob3JSZWZlcmVuY2UgPT09ICdub25lJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBudWxsLFxuICAgICAgICBsZWZ0OiBudWxsLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IGdldFRyYW5zZm9ybU9yaWdpblZhbHVlKGVsZW1UcmFuc2Zvcm1PcmlnaW4pXG4gICAgICB9O1xuICAgIH0gLy8gR2V0IHRoZSBvZmZzZXQgb2Ygb2YgdGhlIGFuY2hvcmluZyBlbGVtZW50XG5cblxuICAgIHZhciBhbmNob3JPZmZzZXQgPSBnZXRBbmNob3JPZmZzZXQoY29udGVudEFuY2hvck9mZnNldCk7IC8vIENhbGN1bGF0ZSBlbGVtZW50IHBvc2l0aW9uaW5nXG5cbiAgICB2YXIgdG9wID0gYW5jaG9yT2Zmc2V0LnRvcCAtIGVsZW1UcmFuc2Zvcm1PcmlnaW4udmVydGljYWw7XG4gICAgdmFyIGxlZnQgPSBhbmNob3JPZmZzZXQubGVmdCAtIGVsZW1UcmFuc2Zvcm1PcmlnaW4uaG9yaXpvbnRhbDtcbiAgICB2YXIgYm90dG9tID0gdG9wICsgZWxlbVJlY3QuaGVpZ2h0O1xuICAgIHZhciByaWdodCA9IGxlZnQgKyBlbGVtUmVjdC53aWR0aDsgLy8gVXNlIHRoZSBwYXJlbnQgd2luZG93IG9mIHRoZSBhbmNob3JFbCBpZiBwcm92aWRlZFxuXG4gICAgdmFyIGNvbnRhaW5lcldpbmRvdyA9IG93bmVyV2luZG93KGdldEFuY2hvckVsKGFuY2hvckVsKSk7IC8vIFdpbmRvdyB0aHJlc2hvbGRzIHRha2luZyByZXF1aXJlZCBtYXJnaW4gaW50byBhY2NvdW50XG5cbiAgICB2YXIgaGVpZ2h0VGhyZXNob2xkID0gY29udGFpbmVyV2luZG93LmlubmVySGVpZ2h0IC0gbWFyZ2luVGhyZXNob2xkO1xuICAgIHZhciB3aWR0aFRocmVzaG9sZCA9IGNvbnRhaW5lcldpbmRvdy5pbm5lcldpZHRoIC0gbWFyZ2luVGhyZXNob2xkOyAvLyBDaGVjayBpZiB0aGUgdmVydGljYWwgYXhpcyBuZWVkcyBzaGlmdGluZ1xuXG4gICAgaWYgKHRvcCA8IG1hcmdpblRocmVzaG9sZCkge1xuICAgICAgdmFyIGRpZmYgPSB0b3AgLSBtYXJnaW5UaHJlc2hvbGQ7XG4gICAgICB0b3AgLT0gZGlmZjtcbiAgICAgIGVsZW1UcmFuc2Zvcm1PcmlnaW4udmVydGljYWwgKz0gZGlmZjtcbiAgICB9IGVsc2UgaWYgKGJvdHRvbSA+IGhlaWdodFRocmVzaG9sZCkge1xuICAgICAgdmFyIF9kaWZmID0gYm90dG9tIC0gaGVpZ2h0VGhyZXNob2xkO1xuXG4gICAgICB0b3AgLT0gX2RpZmY7XG4gICAgICBlbGVtVHJhbnNmb3JtT3JpZ2luLnZlcnRpY2FsICs9IF9kaWZmO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoZWxlbVJlY3QuaGVpZ2h0ID4gaGVpZ2h0VGhyZXNob2xkICYmIGVsZW1SZWN0LmhlaWdodCAmJiBoZWlnaHRUaHJlc2hvbGQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihbJ01hdGVyaWFsLVVJOiBUaGUgcG9wb3ZlciBjb21wb25lbnQgaXMgdG9vIHRhbGwuJywgXCJTb21lIHBhcnQgb2YgaXQgY2FuIG5vdCBiZSBzZWVuIG9uIHRoZSBzY3JlZW4gKFwiLmNvbmNhdChlbGVtUmVjdC5oZWlnaHQgLSBoZWlnaHRUaHJlc2hvbGQsIFwicHgpLlwiKSwgJ1BsZWFzZSBjb25zaWRlciBhZGRpbmcgYSBgbWF4LWhlaWdodGAgdG8gaW1wcm92ZSB0aGUgdXNlci1leHBlcmllbmNlLiddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9IC8vIENoZWNrIGlmIHRoZSBob3Jpem9udGFsIGF4aXMgbmVlZHMgc2hpZnRpbmdcblxuXG4gICAgaWYgKGxlZnQgPCBtYXJnaW5UaHJlc2hvbGQpIHtcbiAgICAgIHZhciBfZGlmZjIgPSBsZWZ0IC0gbWFyZ2luVGhyZXNob2xkO1xuXG4gICAgICBsZWZ0IC09IF9kaWZmMjtcbiAgICAgIGVsZW1UcmFuc2Zvcm1PcmlnaW4uaG9yaXpvbnRhbCArPSBfZGlmZjI7XG4gICAgfSBlbHNlIGlmIChyaWdodCA+IHdpZHRoVGhyZXNob2xkKSB7XG4gICAgICB2YXIgX2RpZmYzID0gcmlnaHQgLSB3aWR0aFRocmVzaG9sZDtcblxuICAgICAgbGVmdCAtPSBfZGlmZjM7XG4gICAgICBlbGVtVHJhbnNmb3JtT3JpZ2luLmhvcml6b250YWwgKz0gX2RpZmYzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0b3A6IFwiXCIuY29uY2F0KE1hdGgucm91bmQodG9wKSwgXCJweFwiKSxcbiAgICAgIGxlZnQ6IFwiXCIuY29uY2F0KE1hdGgucm91bmQobGVmdCksIFwicHhcIiksXG4gICAgICB0cmFuc2Zvcm1PcmlnaW46IGdldFRyYW5zZm9ybU9yaWdpblZhbHVlKGVsZW1UcmFuc2Zvcm1PcmlnaW4pXG4gICAgfTtcbiAgfSwgW2FuY2hvckVsLCBhbmNob3JSZWZlcmVuY2UsIGdldEFuY2hvck9mZnNldCwgZ2V0Q29udGVudEFuY2hvck9mZnNldCwgZ2V0VHJhbnNmb3JtT3JpZ2luLCBtYXJnaW5UaHJlc2hvbGRdKTtcbiAgdmFyIHNldFBvc2l0aW9uaW5nU3R5bGVzID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGVtZW50ID0gcGFwZXJSZWYuY3VycmVudDtcblxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb3NpdGlvbmluZyA9IGdldFBvc2l0aW9uaW5nU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAocG9zaXRpb25pbmcudG9wICE9PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLnRvcCA9IHBvc2l0aW9uaW5nLnRvcDtcbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb25pbmcubGVmdCAhPT0gbnVsbCkge1xuICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gcG9zaXRpb25pbmcubGVmdDtcbiAgICB9XG5cbiAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IHBvc2l0aW9uaW5nLnRyYW5zZm9ybU9yaWdpbjtcbiAgfSwgW2dldFBvc2l0aW9uaW5nU3R5bGVdKTtcblxuICB2YXIgaGFuZGxlRW50ZXJpbmcgPSBmdW5jdGlvbiBoYW5kbGVFbnRlcmluZyhlbGVtZW50LCBpc0FwcGVhcmluZykge1xuICAgIGlmIChvbkVudGVyaW5nKSB7XG4gICAgICBvbkVudGVyaW5nKGVsZW1lbnQsIGlzQXBwZWFyaW5nKTtcbiAgICB9XG5cbiAgICBzZXRQb3NpdGlvbmluZ1N0eWxlcygpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVQYXBlclJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIC8vICNTdHJpY3RNb2RlIHJlYWR5XG4gICAgcGFwZXJSZWYuY3VycmVudCA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKGluc3RhbmNlKTtcbiAgfSwgW10pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBzZXRQb3NpdGlvbmluZ1N0eWxlcygpO1xuICAgIH1cbiAgfSk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUoYWN0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG9wZW4gPyB7XG4gICAgICB1cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICAgIHNldFBvc2l0aW9uaW5nU3R5bGVzKCk7XG4gICAgICB9XG4gICAgfSA6IG51bGw7XG4gIH0sIFtvcGVuLCBzZXRQb3NpdGlvbmluZ1N0eWxlc10pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghb3Blbikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlUmVzaXplID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgc2V0UG9zaXRpb25pbmdTdHlsZXMoKTtcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaGFuZGxlUmVzaXplLmNsZWFyKCk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICB9O1xuICB9LCBbb3Blbiwgc2V0UG9zaXRpb25pbmdTdHlsZXNdKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRyYW5zaXRpb25EdXJhdGlvblByb3A7XG5cbiAgaWYgKHRyYW5zaXRpb25EdXJhdGlvblByb3AgPT09ICdhdXRvJyAmJiAhVHJhbnNpdGlvbkNvbXBvbmVudC5tdWlTdXBwb3J0QXV0bykge1xuICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IHVuZGVmaW5lZDtcbiAgfSAvLyBJZiB0aGUgY29udGFpbmVyIHByb3AgaXMgcHJvdmlkZWQsIHVzZSB0aGF0XG4gIC8vIElmIHRoZSBhbmNob3JFbCBwcm9wIGlzIHByb3ZpZGVkLCB1c2UgaXRzIHBhcmVudCBib2R5IGVsZW1lbnQgYXMgdGhlIGNvbnRhaW5lclxuICAvLyBJZiBuZWl0aGVyIGFyZSBwcm92aWRlZCBsZXQgdGhlIE1vZGFsIHRha2UgY2FyZSBvZiBjaG9vc2luZyB0aGUgY29udGFpbmVyXG5cblxuICB2YXIgY29udGFpbmVyID0gY29udGFpbmVyUHJvcCB8fCAoYW5jaG9yRWwgPyBvd25lckRvY3VtZW50KGdldEFuY2hvckVsKGFuY2hvckVsKSkuYm9keSA6IHVuZGVmaW5lZCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNb2RhbCwgX2V4dGVuZHMoe1xuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIG9wZW46IG9wZW4sXG4gICAgcmVmOiByZWYsXG4gICAgQmFja2Ryb3BQcm9wczoge1xuICAgICAgaW52aXNpYmxlOiB0cnVlXG4gICAgfSxcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUpXG4gIH0sIG90aGVyKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbkNvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIGFwcGVhcjogdHJ1ZSxcbiAgICBpbjogb3BlbixcbiAgICBvbkVudGVyOiBvbkVudGVyLFxuICAgIG9uRW50ZXJlZDogb25FbnRlcmVkLFxuICAgIG9uRXhpdDogb25FeGl0LFxuICAgIG9uRXhpdGVkOiBvbkV4aXRlZCxcbiAgICBvbkV4aXRpbmc6IG9uRXhpdGluZyxcbiAgICB0aW1lb3V0OiB0cmFuc2l0aW9uRHVyYXRpb25cbiAgfSwgVHJhbnNpdGlvblByb3BzLCB7XG4gICAgb25FbnRlcmluZzogY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKGhhbmRsZUVudGVyaW5nLCBUcmFuc2l0aW9uUHJvcHMub25FbnRlcmluZylcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBhcGVyLCBfZXh0ZW5kcyh7XG4gICAgZWxldmF0aW9uOiBlbGV2YXRpb24sXG4gICAgcmVmOiBoYW5kbGVQYXBlclJlZlxuICB9LCBQYXBlclByb3BzLCB7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucGFwZXIsIFBhcGVyUHJvcHMuY2xhc3NOYW1lKVxuICB9KSwgY2hpbGRyZW4pKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFBvcG92ZXIucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQSByZWYgZm9yIGltcGVyYXRpdmUgYWN0aW9ucy5cbiAgICogSXQgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgdXBkYXRlUG9zaXRpb24oKSBhY3Rpb24uXG4gICAqL1xuICBhY3Rpb246IHJlZlR5cGUsXG5cbiAgLyoqXG4gICAqIEEgSFRNTCBlbGVtZW50LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBpdC5cbiAgICogSXQncyB1c2VkIHRvIHNldCB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcG92ZXIuXG4gICAqL1xuICBhbmNob3JFbDogY2hhaW5Qcm9wVHlwZXMoUHJvcFR5cGVzLm9uZU9mVHlwZShbSFRNTEVsZW1lbnRUeXBlLCBQcm9wVHlwZXMuZnVuY10pLCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBpZiAocHJvcHMub3BlbiAmJiAoIXByb3BzLmFuY2hvclJlZmVyZW5jZSB8fCBwcm9wcy5hbmNob3JSZWZlcmVuY2UgPT09ICdhbmNob3JFbCcpKSB7XG4gICAgICB2YXIgcmVzb2x2ZWRBbmNob3JFbCA9IGdldEFuY2hvckVsKHByb3BzLmFuY2hvckVsKTtcblxuICAgICAgaWYgKHJlc29sdmVkQW5jaG9yRWwgJiYgcmVzb2x2ZWRBbmNob3JFbC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICB2YXIgYm94ID0gcmVzb2x2ZWRBbmNob3JFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJiBib3gudG9wID09PSAwICYmIGJveC5sZWZ0ID09PSAwICYmIGJveC5yaWdodCA9PT0gMCAmJiBib3guYm90dG9tID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihbJ01hdGVyaWFsLVVJOiBUaGUgYGFuY2hvckVsYCBwcm9wIHByb3ZpZGVkIHRvIHRoZSBjb21wb25lbnQgaXMgaW52YWxpZC4nLCAnVGhlIGFuY2hvciBlbGVtZW50IHNob3VsZCBiZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBsYXlvdXQuJywgXCJNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgcHJlc2VudCBpbiB0aGUgZG9jdW1lbnQgb3IgdGhhdCBpdCdzIG5vdCBkaXNwbGF5IG5vbmUuXCJdLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihbJ01hdGVyaWFsLVVJOiBUaGUgYGFuY2hvckVsYCBwcm9wIHByb3ZpZGVkIHRvIHRoZSBjb21wb25lbnQgaXMgaW52YWxpZC4nLCBcIkl0IHNob3VsZCBiZSBhbiBFbGVtZW50IGluc3RhbmNlIGJ1dCBpdCdzIGBcIi5jb25jYXQocmVzb2x2ZWRBbmNob3JFbCwgXCJgIGluc3RlYWQuXCIpXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0pLFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBwb2ludCBvbiB0aGUgYW5jaG9yIHdoZXJlIHRoZSBwb3BvdmVyJ3NcbiAgICogYGFuY2hvckVsYCB3aWxsIGF0dGFjaCB0by4gVGhpcyBpcyBub3QgdXNlZCB3aGVuIHRoZVxuICAgKiBhbmNob3JSZWZlcmVuY2UgaXMgJ2FuY2hvclBvc2l0aW9uJy5cbiAgICpcbiAgICogT3B0aW9uczpcbiAgICogdmVydGljYWw6IFt0b3AsIGNlbnRlciwgYm90dG9tXTtcbiAgICogaG9yaXpvbnRhbDogW2xlZnQsIGNlbnRlciwgcmlnaHRdLlxuICAgKi9cbiAgYW5jaG9yT3JpZ2luOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhvcml6b250YWw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbJ2NlbnRlcicsICdsZWZ0JywgJ3JpZ2h0J10pLCBQcm9wVHlwZXMubnVtYmVyXSkuaXNSZXF1aXJlZCxcbiAgICB2ZXJ0aWNhbDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9uZU9mKFsnYm90dG9tJywgJ2NlbnRlcicsICd0b3AnXSksIFByb3BUeXBlcy5udW1iZXJdKS5pc1JlcXVpcmVkXG4gIH0pLFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBwb3NpdGlvbiB0aGF0IG1heSBiZSB1c2VkXG4gICAqIHRvIHNldCB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcG92ZXIuXG4gICAqIFRoZSBjb29yZGluYXRlcyBhcmUgcmVsYXRpdmUgdG9cbiAgICogdGhlIGFwcGxpY2F0aW9uJ3MgY2xpZW50IGFyZWEuXG4gICAqL1xuICBhbmNob3JQb3NpdGlvbjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgfSksXG5cbiAgLyoqXG4gICAqIFRoaXMgZGV0ZXJtaW5lcyB3aGljaCBhbmNob3IgcHJvcCB0byByZWZlciB0byB0byBzZXRcbiAgICogdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyLlxuICAgKi9cbiAgYW5jaG9yUmVmZXJlbmNlOiBQcm9wVHlwZXMub25lT2YoWydhbmNob3JFbCcsICdhbmNob3JQb3NpdGlvbicsICdub25lJ10pLFxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQSBIVE1MIGVsZW1lbnQsIGNvbXBvbmVudCBpbnN0YW5jZSwgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGVpdGhlci5cbiAgICogVGhlIGBjb250YWluZXJgIHdpbGwgcGFzc2VkIHRvIHRoZSBNb2RhbCBjb21wb25lbnQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGl0IHVzZXMgdGhlIGJvZHkgb2YgdGhlIGFuY2hvckVsJ3MgdG9wLWxldmVsIGRvY3VtZW50IG9iamVjdCxcbiAgICogc28gaXQncyBzaW1wbHkgYGRvY3VtZW50LmJvZHlgIG1vc3Qgb2YgdGhlIHRpbWUuXG4gICAqL1xuICBjb250YWluZXI6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5vbmVPZlR5cGUoW0hUTUxFbGVtZW50VHlwZSwgUHJvcFR5cGVzLmluc3RhbmNlT2YoUmVhY3QuQ29tcG9uZW50KSwgUHJvcFR5cGVzLmZ1bmNdKSxcblxuICAvKipcbiAgICogVGhlIGVsZXZhdGlvbiBvZiB0aGUgcG9wb3Zlci5cbiAgICovXG4gIGVsZXZhdGlvbjogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgaW4gb3JkZXIgdG8gcmV0cmlldmUgdGhlIGNvbnRlbnQgYW5jaG9yIGVsZW1lbnQuXG4gICAqIEl0J3MgdGhlIG9wcG9zaXRlIG9mIHRoZSBgYW5jaG9yRWxgIHByb3AuXG4gICAqIFRoZSBjb250ZW50IGFuY2hvciBlbGVtZW50IHNob3VsZCBiZSBhbiBlbGVtZW50IGluc2lkZSB0aGUgcG9wb3Zlci5cbiAgICogSXQncyB1c2VkIHRvIGNvcnJlY3RseSBzY3JvbGwgYW5kIHNldCB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcG92ZXIuXG4gICAqIFRoZSBwb3NpdGlvbmluZyBzdHJhdGVneSB0cmllcyB0byBtYWtlIHRoZSBjb250ZW50IGFuY2hvciBlbGVtZW50IGp1c3QgYWJvdmUgdGhlXG4gICAqIGFuY2hvciBlbGVtZW50LlxuICAgKi9cbiAgZ2V0Q29udGVudEFuY2hvckVsOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogU3BlY2lmaWVzIGhvdyBjbG9zZSB0byB0aGUgZWRnZSBvZiB0aGUgd2luZG93IHRoZSBwb3BvdmVyIGNhbiBhcHBlYXIuXG4gICAqL1xuICBtYXJnaW5UaHJlc2hvbGQ6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGNvbXBvbmVudCByZXF1ZXN0cyB0byBiZSBjbG9zZWQuXG4gICAqL1xuICBvbkNsb3NlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgZW50ZXJpbmcuXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLlxuICAgKi9cbiAgb25FbnRlcjogZGVwcmVjYXRlZFByb3BUeXBlKFByb3BUeXBlcy5mdW5jLCAnVXNlIHRoZSBgVHJhbnNpdGlvblByb3BzYCBwcm9wIGluc3RlYWQuJyksXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgZW50ZXJlZC5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgVHJhbnNpdGlvblByb3BzYCBwcm9wIGluc3RlYWQuXG4gICAqL1xuICBvbkVudGVyZWQ6IGRlcHJlY2F0ZWRQcm9wVHlwZShQcm9wVHlwZXMuZnVuYywgJ1VzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLicpLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZW50ZXJpbmcuXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLlxuICAgKi9cbiAgb25FbnRlcmluZzogZGVwcmVjYXRlZFByb3BUeXBlKFByb3BUeXBlcy5mdW5jLCAnVXNlIHRoZSBgVHJhbnNpdGlvblByb3BzYCBwcm9wIGluc3RlYWQuJyksXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIGV4aXRpbmcuXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLlxuICAgKi9cbiAgb25FeGl0OiBkZXByZWNhdGVkUHJvcFR5cGUoUHJvcFR5cGVzLmZ1bmMsICdVc2UgdGhlIGBUcmFuc2l0aW9uUHJvcHNgIHByb3AgaW5zdGVhZC4nKSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBleGl0ZWQuXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLlxuICAgKi9cbiAgb25FeGl0ZWQ6IGRlcHJlY2F0ZWRQcm9wVHlwZShQcm9wVHlwZXMuZnVuYywgJ1VzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLicpLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZXhpdGluZy5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgVHJhbnNpdGlvblByb3BzYCBwcm9wIGluc3RlYWQuXG4gICAqL1xuICBvbkV4aXRpbmc6IGRlcHJlY2F0ZWRQcm9wVHlwZShQcm9wVHlwZXMuZnVuYywgJ1VzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLicpLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBwb3BvdmVyIGlzIHZpc2libGUuXG4gICAqL1xuICBvcGVuOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBbYFBhcGVyYF0oL2FwaS9wYXBlci8pIGVsZW1lbnQuXG4gICAqL1xuICBQYXBlclByb3BzOiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAuc2hhcGUoe1xuICAgIGNvbXBvbmVudDogZWxlbWVudFR5cGVBY2NlcHRpbmdSZWZcbiAgfSksXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIHBvaW50IG9uIHRoZSBwb3BvdmVyIHdoaWNoXG4gICAqIHdpbGwgYXR0YWNoIHRvIHRoZSBhbmNob3IncyBvcmlnaW4uXG4gICAqXG4gICAqIE9wdGlvbnM6XG4gICAqIHZlcnRpY2FsOiBbdG9wLCBjZW50ZXIsIGJvdHRvbSwgeChweCldO1xuICAgKiBob3Jpem9udGFsOiBbbGVmdCwgY2VudGVyLCByaWdodCwgeChweCldLlxuICAgKi9cbiAgdHJhbnNmb3JtT3JpZ2luOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhvcml6b250YWw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbJ2NlbnRlcicsICdsZWZ0JywgJ3JpZ2h0J10pLCBQcm9wVHlwZXMubnVtYmVyXSkuaXNSZXF1aXJlZCxcbiAgICB2ZXJ0aWNhbDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9uZU9mKFsnYm90dG9tJywgJ2NlbnRlcicsICd0b3AnXSksIFByb3BUeXBlcy5udW1iZXJdKS5pc1JlcXVpcmVkXG4gIH0pLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSB0cmFuc2l0aW9uLlxuICAgKiBbRm9sbG93IHRoaXMgZ3VpZGVdKC9jb21wb25lbnRzL3RyYW5zaXRpb25zLyN0cmFuc2l0aW9uY29tcG9uZW50LXByb3ApIHRvIGxlYXJuIG1vcmUgYWJvdXQgdGhlIHJlcXVpcmVtZW50cyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBUcmFuc2l0aW9uQ29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG5cbiAgLyoqXG4gICAqIFNldCB0byAnYXV0bycgdG8gYXV0b21hdGljYWxseSBjYWxjdWxhdGUgdHJhbnNpdGlvbiB0aW1lIGJhc2VkIG9uIGhlaWdodC5cbiAgICovXG4gIHRyYW5zaXRpb25EdXJhdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9uZU9mKFsnYXV0byddKSwgUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBhcHBlYXI6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgZW50ZXI6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgZXhpdDogUHJvcFR5cGVzLm51bWJlclxuICB9KV0pLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBbYFRyYW5zaXRpb25gXShodHRwOi8vcmVhY3Rjb21tdW5pdHkub3JnL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvdHJhbnNpdGlvbiNUcmFuc2l0aW9uLXByb3BzKSBlbGVtZW50LlxuICAgKi9cbiAgVHJhbnNpdGlvblByb3BzOiBQcm9wVHlwZXMub2JqZWN0XG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aVBvcG92ZXInXG59KShQb3BvdmVyKTsiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG4vKipcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXG4gKi9cblxudmFyIExpc3RDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIExpc3RDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0xpc3RDb250ZXh0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgTGlzdENvbnRleHQ7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IExpc3RDb250ZXh0IGZyb20gJy4vTGlzdENvbnRleHQnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSB7XG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gIHJvb3Q6IHtcbiAgICBsaXN0U3R5bGU6ICdub25lJyxcbiAgICBtYXJnaW46IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICB9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGRpc2FibGVQYWRkaW5nPXtmYWxzZX1gLiAqL1xuICBwYWRkaW5nOiB7XG4gICAgcGFkZGluZ1RvcDogOCxcbiAgICBwYWRkaW5nQm90dG9tOiA4XG4gIH0sXG5cbiAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBkZW5zZS4gKi9cbiAgZGVuc2U6IHt9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYSBgc3ViaGVhZGVyYCBpcyBwcm92aWRlZC4gKi9cbiAgc3ViaGVhZGVyOiB7XG4gICAgcGFkZGluZ1RvcDogMFxuICB9XG59O1xudmFyIExpc3QgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBMaXN0KHByb3BzLCByZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRjb21wb25lbnQgPSBwcm9wcy5jb21wb25lbnQsXG4gICAgICBDb21wb25lbnQgPSBfcHJvcHMkY29tcG9uZW50ID09PSB2b2lkIDAgPyAndWwnIDogX3Byb3BzJGNvbXBvbmVudCxcbiAgICAgIF9wcm9wcyRkZW5zZSA9IHByb3BzLmRlbnNlLFxuICAgICAgZGVuc2UgPSBfcHJvcHMkZGVuc2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGRlbnNlLFxuICAgICAgX3Byb3BzJGRpc2FibGVQYWRkaW5nID0gcHJvcHMuZGlzYWJsZVBhZGRpbmcsXG4gICAgICBkaXNhYmxlUGFkZGluZyA9IF9wcm9wcyRkaXNhYmxlUGFkZGluZyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZVBhZGRpbmcsXG4gICAgICBzdWJoZWFkZXIgPSBwcm9wcy5zdWJoZWFkZXIsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiY29tcG9uZW50XCIsIFwiZGVuc2VcIiwgXCJkaXNhYmxlUGFkZGluZ1wiLCBcInN1YmhlYWRlclwiXSk7XG5cbiAgdmFyIGNvbnRleHQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVuc2U6IGRlbnNlXG4gICAgfTtcbiAgfSwgW2RlbnNlXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaXN0Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSwgZGVuc2UgJiYgY2xhc3Nlcy5kZW5zZSwgIWRpc2FibGVQYWRkaW5nICYmIGNsYXNzZXMucGFkZGluZywgc3ViaGVhZGVyICYmIGNsYXNzZXMuc3ViaGVhZGVyKSxcbiAgICByZWY6IHJlZlxuICB9LCBvdGhlciksIHN1YmhlYWRlciwgY2hpbGRyZW4pKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gTGlzdC5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHVzZWQgZm9yIHRoZSByb290IG5vZGUuXG4gICAqIEVpdGhlciBhIHN0cmluZyB0byB1c2UgYSBIVE1MIGVsZW1lbnQgb3IgYSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnQ6IFByb3BUeXBlc1xuICAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovXG4gIC5lbGVtZW50VHlwZSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBjb21wYWN0IHZlcnRpY2FsIHBhZGRpbmcgZGVzaWduZWQgZm9yIGtleWJvYXJkIGFuZCBtb3VzZSBpbnB1dCB3aWxsIGJlIHVzZWQgZm9yXG4gICAqIHRoZSBsaXN0IGFuZCBsaXN0IGl0ZW1zLlxuICAgKiBUaGUgcHJvcCBpcyBhdmFpbGFibGUgdG8gZGVzY2VuZGFudCBjb21wb25lbnRzIGFzIHRoZSBgZGVuc2VgIGNvbnRleHQuXG4gICAqL1xuICBkZW5zZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdmVydGljYWwgcGFkZGluZyB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgbGlzdC5cbiAgICovXG4gIGRpc2FibGVQYWRkaW5nOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIHN1YmhlYWRlciwgbm9ybWFsbHkgYExpc3RTdWJoZWFkZXJgLlxuICAgKi9cbiAgc3ViaGVhZGVyOiBQcm9wVHlwZXMubm9kZVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlMaXN0J1xufSkoTGlzdCk7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNGcmFnbWVudCB9IGZyb20gJ3JlYWN0LWlzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IG93bmVyRG9jdW1lbnQgZnJvbSAnLi4vdXRpbHMvb3duZXJEb2N1bWVudCc7XG5pbXBvcnQgTGlzdCBmcm9tICcuLi9MaXN0JztcbmltcG9ydCBnZXRTY3JvbGxiYXJTaXplIGZyb20gJy4uL3V0aWxzL2dldFNjcm9sbGJhclNpemUnO1xuaW1wb3J0IHVzZUZvcmtSZWYgZnJvbSAnLi4vdXRpbHMvdXNlRm9ya1JlZic7XG5cbmZ1bmN0aW9uIG5leHRJdGVtKGxpc3QsIGl0ZW0sIGRpc2FibGVMaXN0V3JhcCkge1xuICBpZiAobGlzdCA9PT0gaXRlbSkge1xuICAgIHJldHVybiBsaXN0LmZpcnN0Q2hpbGQ7XG4gIH1cblxuICBpZiAoaXRlbSAmJiBpdGVtLm5leHRFbGVtZW50U2libGluZykge1xuICAgIHJldHVybiBpdGVtLm5leHRFbGVtZW50U2libGluZztcbiAgfVxuXG4gIHJldHVybiBkaXNhYmxlTGlzdFdyYXAgPyBudWxsIDogbGlzdC5maXJzdENoaWxkO1xufVxuXG5mdW5jdGlvbiBwcmV2aW91c0l0ZW0obGlzdCwgaXRlbSwgZGlzYWJsZUxpc3RXcmFwKSB7XG4gIGlmIChsaXN0ID09PSBpdGVtKSB7XG4gICAgcmV0dXJuIGRpc2FibGVMaXN0V3JhcCA/IGxpc3QuZmlyc3RDaGlsZCA6IGxpc3QubGFzdENoaWxkO1xuICB9XG5cbiAgaWYgKGl0ZW0gJiYgaXRlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgcmV0dXJuIGl0ZW0ucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgfVxuXG4gIHJldHVybiBkaXNhYmxlTGlzdFdyYXAgPyBudWxsIDogbGlzdC5sYXN0Q2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHRleHRDcml0ZXJpYU1hdGNoZXMobmV4dEZvY3VzLCB0ZXh0Q3JpdGVyaWEpIHtcbiAgaWYgKHRleHRDcml0ZXJpYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgdGV4dCA9IG5leHRGb2N1cy5pbm5lclRleHQ7XG5cbiAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGpzZG9tIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lclRleHRcbiAgICB0ZXh0ID0gbmV4dEZvY3VzLnRleHRDb250ZW50O1xuICB9XG5cbiAgdGV4dCA9IHRleHQudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRleHRDcml0ZXJpYS5yZXBlYXRpbmcpIHtcbiAgICByZXR1cm4gdGV4dFswXSA9PT0gdGV4dENyaXRlcmlhLmtleXNbMF07XG4gIH1cblxuICByZXR1cm4gdGV4dC5pbmRleE9mKHRleHRDcml0ZXJpYS5rZXlzLmpvaW4oJycpKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gbW92ZUZvY3VzKGxpc3QsIGN1cnJlbnRGb2N1cywgZGlzYWJsZUxpc3RXcmFwLCBkaXNhYmxlZEl0ZW1zRm9jdXNhYmxlLCB0cmF2ZXJzYWxGdW5jdGlvbiwgdGV4dENyaXRlcmlhKSB7XG4gIHZhciB3cmFwcGVkT25jZSA9IGZhbHNlO1xuICB2YXIgbmV4dEZvY3VzID0gdHJhdmVyc2FsRnVuY3Rpb24obGlzdCwgY3VycmVudEZvY3VzLCBjdXJyZW50Rm9jdXMgPyBkaXNhYmxlTGlzdFdyYXAgOiBmYWxzZSk7XG5cbiAgd2hpbGUgKG5leHRGb2N1cykge1xuICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcC5cbiAgICBpZiAobmV4dEZvY3VzID09PSBsaXN0LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGlmICh3cmFwcGVkT25jZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdyYXBwZWRPbmNlID0gdHJ1ZTtcbiAgICB9IC8vIFNhbWUgbG9naWMgYXMgdXNlQXV0b2NvbXBsZXRlLmpzXG5cblxuICAgIHZhciBuZXh0Rm9jdXNEaXNhYmxlZCA9IGRpc2FibGVkSXRlbXNGb2N1c2FibGUgPyBmYWxzZSA6IG5leHRGb2N1cy5kaXNhYmxlZCB8fCBuZXh0Rm9jdXMuZ2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJykgPT09ICd0cnVlJztcblxuICAgIGlmICghbmV4dEZvY3VzLmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSB8fCAhdGV4dENyaXRlcmlhTWF0Y2hlcyhuZXh0Rm9jdXMsIHRleHRDcml0ZXJpYSkgfHwgbmV4dEZvY3VzRGlzYWJsZWQpIHtcbiAgICAgIC8vIE1vdmUgdG8gdGhlIG5leHQgZWxlbWVudC5cbiAgICAgIG5leHRGb2N1cyA9IHRyYXZlcnNhbEZ1bmN0aW9uKGxpc3QsIG5leHRGb2N1cywgZGlzYWJsZUxpc3RXcmFwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dEZvY3VzLmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbnZhciB1c2VFbmhhbmNlZEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gUmVhY3QudXNlRWZmZWN0IDogUmVhY3QudXNlTGF5b3V0RWZmZWN0O1xuLyoqXG4gKiBBIHBlcm1hbmVudGx5IGRpc3BsYXllZCBtZW51IGZvbGxvd2luZyBodHRwczovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEtcHJhY3RpY2VzLyNtZW51YnV0dG9uLlxuICogSXQncyBleHBvc2VkIHRvIGhlbHAgY3VzdG9taXphdGlvbiBvZiB0aGUgW2BNZW51YF0oL2FwaS9tZW51LykgY29tcG9uZW50LiBJZiB5b3VcbiAqIHVzZSBpdCBzZXBhcmF0ZWx5IHlvdSBuZWVkIHRvIG1vdmUgZm9jdXMgaW50byB0aGUgY29tcG9uZW50IG1hbnVhbGx5LiBPbmNlXG4gKiB0aGUgZm9jdXMgaXMgcGxhY2VkIGluc2lkZSB0aGUgY29tcG9uZW50IGl0IGlzIGZ1bGx5IGtleWJvYXJkIGFjY2Vzc2libGUuXG4gKi9cblxudmFyIE1lbnVMaXN0ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gTWVudUxpc3QocHJvcHMsIHJlZikge1xuICB2YXIgYWN0aW9ucyA9IHByb3BzLmFjdGlvbnMsXG4gICAgICBfcHJvcHMkYXV0b0ZvY3VzID0gcHJvcHMuYXV0b0ZvY3VzLFxuICAgICAgYXV0b0ZvY3VzID0gX3Byb3BzJGF1dG9Gb2N1cyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkYXV0b0ZvY3VzLFxuICAgICAgX3Byb3BzJGF1dG9Gb2N1c0l0ZW0gPSBwcm9wcy5hdXRvRm9jdXNJdGVtLFxuICAgICAgYXV0b0ZvY3VzSXRlbSA9IF9wcm9wcyRhdXRvRm9jdXNJdGVtID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRhdXRvRm9jdXNJdGVtLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIF9wcm9wcyRkaXNhYmxlZEl0ZW1zRiA9IHByb3BzLmRpc2FibGVkSXRlbXNGb2N1c2FibGUsXG4gICAgICBkaXNhYmxlZEl0ZW1zRm9jdXNhYmxlID0gX3Byb3BzJGRpc2FibGVkSXRlbXNGID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlZEl0ZW1zRixcbiAgICAgIF9wcm9wcyRkaXNhYmxlTGlzdFdyYSA9IHByb3BzLmRpc2FibGVMaXN0V3JhcCxcbiAgICAgIGRpc2FibGVMaXN0V3JhcCA9IF9wcm9wcyRkaXNhYmxlTGlzdFdyYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZUxpc3RXcmEsXG4gICAgICBvbktleURvd24gPSBwcm9wcy5vbktleURvd24sXG4gICAgICBfcHJvcHMkdmFyaWFudCA9IHByb3BzLnZhcmlhbnQsXG4gICAgICB2YXJpYW50ID0gX3Byb3BzJHZhcmlhbnQgPT09IHZvaWQgMCA/ICdzZWxlY3RlZE1lbnUnIDogX3Byb3BzJHZhcmlhbnQsXG4gICAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wiYWN0aW9uc1wiLCBcImF1dG9Gb2N1c1wiLCBcImF1dG9Gb2N1c0l0ZW1cIiwgXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiLCBcImRpc2FibGVkSXRlbXNGb2N1c2FibGVcIiwgXCJkaXNhYmxlTGlzdFdyYXBcIiwgXCJvbktleURvd25cIiwgXCJ2YXJpYW50XCJdKTtcblxuICB2YXIgbGlzdFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIHRleHRDcml0ZXJpYVJlZiA9IFJlYWN0LnVzZVJlZih7XG4gICAga2V5czogW10sXG4gICAgcmVwZWF0aW5nOiB0cnVlLFxuICAgIHByZXZpb3VzS2V5TWF0Y2hlZDogdHJ1ZSxcbiAgICBsYXN0VGltZTogbnVsbFxuICB9KTtcbiAgdXNlRW5oYW5jZWRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChhdXRvRm9jdXMpIHtcbiAgICAgIGxpc3RSZWYuY3VycmVudC5mb2N1cygpO1xuICAgIH1cbiAgfSwgW2F1dG9Gb2N1c10pO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGFjdGlvbnMsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRqdXN0U3R5bGVGb3JTY3JvbGxiYXI6IGZ1bmN0aW9uIGFkanVzdFN0eWxlRm9yU2Nyb2xsYmFyKGNvbnRhaW5lckVsZW1lbnQsIHRoZW1lKSB7XG4gICAgICAgIC8vIExldCdzIGlnbm9yZSB0aGF0IHBpZWNlIG9mIGxvZ2ljIGlmIHVzZXJzIGFyZSBhbHJlYWR5IG92ZXJyaWRpbmcgdGhlIHdpZHRoXG4gICAgICAgIC8vIG9mIHRoZSBtZW51LlxuICAgICAgICB2YXIgbm9FeHBsaWNpdFdpZHRoID0gIWxpc3RSZWYuY3VycmVudC5zdHlsZS53aWR0aDtcblxuICAgICAgICBpZiAoY29udGFpbmVyRWxlbWVudC5jbGllbnRIZWlnaHQgPCBsaXN0UmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0ICYmIG5vRXhwbGljaXRXaWR0aCkge1xuICAgICAgICAgIHZhciBzY3JvbGxiYXJTaXplID0gXCJcIi5jb25jYXQoZ2V0U2Nyb2xsYmFyU2l6ZSh0cnVlKSwgXCJweFwiKTtcbiAgICAgICAgICBsaXN0UmVmLmN1cnJlbnQuc3R5bGVbdGhlbWUuZGlyZWN0aW9uID09PSAncnRsJyA/ICdwYWRkaW5nTGVmdCcgOiAncGFkZGluZ1JpZ2h0J10gPSBzY3JvbGxiYXJTaXplO1xuICAgICAgICAgIGxpc3RSZWYuY3VycmVudC5zdHlsZS53aWR0aCA9IFwiY2FsYygxMDAlICsgXCIuY29uY2F0KHNjcm9sbGJhclNpemUsIFwiKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaXN0UmVmLmN1cnJlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHZhciBoYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIHZhciBsaXN0ID0gbGlzdFJlZi5jdXJyZW50O1xuICAgIHZhciBrZXkgPSBldmVudC5rZXk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0VsZW1lbnR9IC0gd2lsbCBhbHdheXMgYmUgZGVmaW5lZCBzaW5jZSB3ZSBhcmUgaW4gYSBrZXlkb3duIGhhbmRsZXJcbiAgICAgKiBhdHRhY2hlZCB0byBhbiBlbGVtZW50LiBBIGtleWRvd24gZXZlbnQgaXMgZWl0aGVyIGRpc3BhdGNoZWQgdG8gdGhlIGFjdGl2ZUVsZW1lbnRcbiAgICAgKiBvciBkb2N1bWVudC5ib2R5IG9yIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC4gT25seSB0aGUgZmlyc3QgY2FzZSB3aWxsXG4gICAgICogdHJpZ2dlciB0aGlzIHNwZWNpZmljIGhhbmRsZXIuXG4gICAgICovXG5cbiAgICB2YXIgY3VycmVudEZvY3VzID0gb3duZXJEb2N1bWVudChsaXN0KS5hY3RpdmVFbGVtZW50O1xuXG4gICAgaWYgKGtleSA9PT0gJ0Fycm93RG93bicpIHtcbiAgICAgIC8vIFByZXZlbnQgc2Nyb2xsIG9mIHRoZSBwYWdlXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbW92ZUZvY3VzKGxpc3QsIGN1cnJlbnRGb2N1cywgZGlzYWJsZUxpc3RXcmFwLCBkaXNhYmxlZEl0ZW1zRm9jdXNhYmxlLCBuZXh0SXRlbSk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdBcnJvd1VwJykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG1vdmVGb2N1cyhsaXN0LCBjdXJyZW50Rm9jdXMsIGRpc2FibGVMaXN0V3JhcCwgZGlzYWJsZWRJdGVtc0ZvY3VzYWJsZSwgcHJldmlvdXNJdGVtKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ0hvbWUnKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgbW92ZUZvY3VzKGxpc3QsIG51bGwsIGRpc2FibGVMaXN0V3JhcCwgZGlzYWJsZWRJdGVtc0ZvY3VzYWJsZSwgbmV4dEl0ZW0pO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnRW5kJykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG1vdmVGb2N1cyhsaXN0LCBudWxsLCBkaXNhYmxlTGlzdFdyYXAsIGRpc2FibGVkSXRlbXNGb2N1c2FibGUsIHByZXZpb3VzSXRlbSk7XG4gICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY3JpdGVyaWEgPSB0ZXh0Q3JpdGVyaWFSZWYuY3VycmVudDtcbiAgICAgIHZhciBsb3dlcktleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGN1cnJUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIGlmIChjcml0ZXJpYS5rZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gUmVzZXRcbiAgICAgICAgaWYgKGN1cnJUaW1lIC0gY3JpdGVyaWEubGFzdFRpbWUgPiA1MDApIHtcbiAgICAgICAgICBjcml0ZXJpYS5rZXlzID0gW107XG4gICAgICAgICAgY3JpdGVyaWEucmVwZWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBjcml0ZXJpYS5wcmV2aW91c0tleU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNyaXRlcmlhLnJlcGVhdGluZyAmJiBsb3dlcktleSAhPT0gY3JpdGVyaWEua2V5c1swXSkge1xuICAgICAgICAgIGNyaXRlcmlhLnJlcGVhdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNyaXRlcmlhLmxhc3RUaW1lID0gY3VyclRpbWU7XG4gICAgICBjcml0ZXJpYS5rZXlzLnB1c2gobG93ZXJLZXkpO1xuICAgICAgdmFyIGtlZXBGb2N1c09uQ3VycmVudCA9IGN1cnJlbnRGb2N1cyAmJiAhY3JpdGVyaWEucmVwZWF0aW5nICYmIHRleHRDcml0ZXJpYU1hdGNoZXMoY3VycmVudEZvY3VzLCBjcml0ZXJpYSk7XG5cbiAgICAgIGlmIChjcml0ZXJpYS5wcmV2aW91c0tleU1hdGNoZWQgJiYgKGtlZXBGb2N1c09uQ3VycmVudCB8fCBtb3ZlRm9jdXMobGlzdCwgY3VycmVudEZvY3VzLCBmYWxzZSwgZGlzYWJsZWRJdGVtc0ZvY3VzYWJsZSwgbmV4dEl0ZW0sIGNyaXRlcmlhKSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyaXRlcmlhLnByZXZpb3VzS2V5TWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvbktleURvd24pIHtcbiAgICAgIG9uS2V5RG93bihldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVPd25SZWYgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAvLyAjU3RyaWN0TW9kZSByZWFkeVxuICAgIGxpc3RSZWYuY3VycmVudCA9IFJlYWN0RE9NLmZpbmRET01Ob2RlKGluc3RhbmNlKTtcbiAgfSwgW10pO1xuICB2YXIgaGFuZGxlUmVmID0gdXNlRm9ya1JlZihoYW5kbGVPd25SZWYsIHJlZik7XG4gIC8qKlxuICAgKiB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gc2hvdWxkIHJlY2VpdmUgZm9jdXNcbiAgICogaW4gYSBgdmFyaWFudD1cInNlbGVjdGVkTWVudVwiYCBpdCdzIHRoZSBmaXJzdCBgc2VsZWN0ZWRgIGl0ZW1cbiAgICogb3RoZXJ3aXNlIGl0J3MgdGhlIHZlcnkgZmlyc3QgaXRlbS5cbiAgICovXG5cbiAgdmFyIGFjdGl2ZUl0ZW1JbmRleCA9IC0xOyAvLyBzaW5jZSB3ZSBpbmplY3QgZm9jdXMgcmVsYXRlZCBwcm9wcyBpbnRvIGNoaWxkcmVuIHdlIGhhdmUgdG8gZG8gYSBsb29rYWhlYWRcbiAgLy8gdG8gY2hlY2sgaWYgdGhlcmUgaXMgYSBgc2VsZWN0ZWRgIGl0ZW0uIFdlJ3JlIGxvb2tpbmcgZm9yIHRoZSBsYXN0IGBzZWxlY3RlZGBcbiAgLy8gaXRlbSBhbmQgdXNlIHRoZSBmaXJzdCB2YWxpZCBpdGVtIGFzIGEgZmFsbGJhY2tcblxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKCEgLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaXNGcmFnbWVudChjaGlsZCkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihbXCJNYXRlcmlhbC1VSTogVGhlIE1lbnUgY29tcG9uZW50IGRvZXNuJ3QgYWNjZXB0IGEgRnJhZ21lbnQgYXMgYSBjaGlsZC5cIiwgJ0NvbnNpZGVyIHByb3ZpZGluZyBhbiBhcnJheSBpbnN0ZWFkLiddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICBpZiAodmFyaWFudCA9PT0gJ3NlbGVjdGVkTWVudScgJiYgY2hpbGQucHJvcHMuc2VsZWN0ZWQpIHtcbiAgICAgICAgYWN0aXZlSXRlbUluZGV4ID0gaW5kZXg7XG4gICAgICB9IGVsc2UgaWYgKGFjdGl2ZUl0ZW1JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgYWN0aXZlSXRlbUluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIGl0ZW1zID0gUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSBhY3RpdmVJdGVtSW5kZXgpIHtcbiAgICAgIHZhciBuZXdDaGlsZFByb3BzID0ge307XG5cbiAgICAgIGlmIChhdXRvRm9jdXNJdGVtKSB7XG4gICAgICAgIG5ld0NoaWxkUHJvcHMuYXV0b0ZvY3VzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkLnByb3BzLnRhYkluZGV4ID09PSB1bmRlZmluZWQgJiYgdmFyaWFudCA9PT0gJ3NlbGVjdGVkTWVudScpIHtcbiAgICAgICAgbmV3Q2hpbGRQcm9wcy50YWJJbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBuZXdDaGlsZFByb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGlzdCwgX2V4dGVuZHMoe1xuICAgIHJvbGU6IFwibWVudVwiLFxuICAgIHJlZjogaGFuZGxlUmVmLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICB0YWJJbmRleDogYXV0b0ZvY3VzID8gMCA6IC0xXG4gIH0sIG90aGVyKSwgaXRlbXMpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBNZW51TGlzdC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHdpbGwgZm9jdXMgdGhlIGBbcm9sZT1cIm1lbnVcIl1gIGNvbnRhaW5lciBhbmQgbW92ZSBpbnRvIHRhYiBvcmRlci5cbiAgICovXG4gIGF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgd2lsbCBmb2N1cyB0aGUgZmlyc3QgbWVudWl0ZW0gaWYgYHZhcmlhbnQ9XCJtZW51XCJgIG9yIHNlbGVjdGVkIGl0ZW1cbiAgICogaWYgYHZhcmlhbnQ9XCJzZWxlY3RlZE1lbnVcImAuXG4gICAqL1xuICBhdXRvRm9jdXNJdGVtOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTWVudUxpc3QgY29udGVudHMsIG5vcm1hbGx5IGBNZW51SXRlbWBzLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgd2lsbCBhbGxvdyBmb2N1cyBvbiBkaXNhYmxlZCBpdGVtcy5cbiAgICovXG4gIGRpc2FibGVkSXRlbXNGb2N1c2FibGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBtZW51IGl0ZW1zIHdpbGwgbm90IHdyYXAgZm9jdXMuXG4gICAqL1xuICBkaXNhYmxlTGlzdFdyYXA6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbktleURvd246IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBUaGUgdmFyaWFudCB0byB1c2UuIFVzZSBgbWVudWAgdG8gcHJldmVudCBzZWxlY3RlZCBpdGVtcyBmcm9tIGltcGFjdGluZyB0aGUgaW5pdGlhbCBmb2N1c1xuICAgKiBhbmQgdGhlIHZlcnRpY2FsIGFsaWdubWVudCByZWxhdGl2ZSB0byB0aGUgYW5jaG9yIGVsZW1lbnQuXG4gICAqL1xuICB2YXJpYW50OiBQcm9wVHlwZXMub25lT2YoWydtZW51JywgJ3NlbGVjdGVkTWVudSddKVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IE1lbnVMaXN0OyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzRnJhZ21lbnQgfSBmcm9tICdyZWFjdC1pcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyBIVE1MRWxlbWVudFR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IFBvcG92ZXIgZnJvbSAnLi4vUG9wb3Zlcic7XG5pbXBvcnQgTWVudUxpc3QgZnJvbSAnLi4vTWVudUxpc3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBzZXRSZWYgZnJvbSAnLi4vdXRpbHMvc2V0UmVmJztcbmltcG9ydCB1c2VUaGVtZSBmcm9tICcuLi9zdHlsZXMvdXNlVGhlbWUnO1xuaW1wb3J0IGRlcHJlY2F0ZWRQcm9wVHlwZSBmcm9tICcuLi91dGlscy9kZXByZWNhdGVkUHJvcFR5cGUnO1xudmFyIFJUTF9PUklHSU4gPSB7XG4gIHZlcnRpY2FsOiAndG9wJyxcbiAgaG9yaXpvbnRhbDogJ3JpZ2h0J1xufTtcbnZhciBMVFJfT1JJR0lOID0ge1xuICB2ZXJ0aWNhbDogJ3RvcCcsXG4gIGhvcml6b250YWw6ICdsZWZ0J1xufTtcbmV4cG9ydCB2YXIgc3R5bGVzID0ge1xuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgYFBhcGVyYCBjb21wb25lbnQuICovXG4gIHBhcGVyOiB7XG4gICAgLy8gc3BlY1o6IFRoZSBtYXhpbXVtIGhlaWdodCBvZiBhIHNpbXBsZSBtZW51IHNob3VsZCBiZSBvbmUgb3IgbW9yZSByb3dzIGxlc3MgdGhhbiB0aGUgdmlld1xuICAgIC8vIGhlaWdodC4gVGhpcyBlbnN1cmVzIGEgdGFwYWJsZSBhcmVhIG91dHNpZGUgb2YgdGhlIHNpbXBsZSBtZW51IHdpdGggd2hpY2ggdG8gZGlzbWlzc1xuICAgIC8vIHRoZSBtZW51LlxuICAgIG1heEhlaWdodDogJ2NhbGMoMTAwJSAtIDk2cHgpJyxcbiAgICAvLyBBZGQgaU9TIG1vbWVudHVtIHNjcm9sbGluZy5cbiAgICBXZWJraXRPdmVyZmxvd1Njcm9sbGluZzogJ3RvdWNoJ1xuICB9LFxuXG4gIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBgTGlzdGAgY29tcG9uZW50IHZpYSBgTWVudUxpc3RgLiAqL1xuICBsaXN0OiB7XG4gICAgLy8gV2UgZGlzYWJsZSB0aGUgZm9jdXMgcmluZyBmb3IgbW91c2UsIHRvdWNoIGFuZCBrZXlib2FyZCB1c2Vycy5cbiAgICBvdXRsaW5lOiAwXG4gIH1cbn07XG52YXIgTWVudSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIE1lbnUocHJvcHMsIHJlZikge1xuICB2YXIgX3Byb3BzJGF1dG9Gb2N1cyA9IHByb3BzLmF1dG9Gb2N1cyxcbiAgICAgIGF1dG9Gb2N1cyA9IF9wcm9wcyRhdXRvRm9jdXMgPT09IHZvaWQgMCA/IHRydWUgOiBfcHJvcHMkYXV0b0ZvY3VzLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgX3Byb3BzJGRpc2FibGVBdXRvRm9jID0gcHJvcHMuZGlzYWJsZUF1dG9Gb2N1c0l0ZW0sXG4gICAgICBkaXNhYmxlQXV0b0ZvY3VzSXRlbSA9IF9wcm9wcyRkaXNhYmxlQXV0b0ZvYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzYWJsZUF1dG9Gb2MsXG4gICAgICBfcHJvcHMkTWVudUxpc3RQcm9wcyA9IHByb3BzLk1lbnVMaXN0UHJvcHMsXG4gICAgICBNZW51TGlzdFByb3BzID0gX3Byb3BzJE1lbnVMaXN0UHJvcHMgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJE1lbnVMaXN0UHJvcHMsXG4gICAgICBvbkNsb3NlID0gcHJvcHMub25DbG9zZSxcbiAgICAgIG9uRW50ZXJpbmdQcm9wID0gcHJvcHMub25FbnRlcmluZyxcbiAgICAgIG9wZW4gPSBwcm9wcy5vcGVuLFxuICAgICAgX3Byb3BzJFBhcGVyUHJvcHMgPSBwcm9wcy5QYXBlclByb3BzLFxuICAgICAgUGFwZXJQcm9wcyA9IF9wcm9wcyRQYXBlclByb3BzID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRQYXBlclByb3BzLFxuICAgICAgUG9wb3ZlckNsYXNzZXMgPSBwcm9wcy5Qb3BvdmVyQ2xhc3NlcyxcbiAgICAgIF9wcm9wcyR0cmFuc2l0aW9uRHVyYSA9IHByb3BzLnRyYW5zaXRpb25EdXJhdGlvbixcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9wcm9wcyR0cmFuc2l0aW9uRHVyYSA9PT0gdm9pZCAwID8gJ2F1dG8nIDogX3Byb3BzJHRyYW5zaXRpb25EdXJhLFxuICAgICAgX3Byb3BzJFRyYW5zaXRpb25Qcm9wID0gcHJvcHMuVHJhbnNpdGlvblByb3BzO1xuICBfcHJvcHMkVHJhbnNpdGlvblByb3AgPSBfcHJvcHMkVHJhbnNpdGlvblByb3AgPT09IHZvaWQgMCA/IHt9IDogX3Byb3BzJFRyYW5zaXRpb25Qcm9wO1xuXG4gIHZhciBvbkVudGVyaW5nID0gX3Byb3BzJFRyYW5zaXRpb25Qcm9wLm9uRW50ZXJpbmcsXG4gICAgICBUcmFuc2l0aW9uUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzJFRyYW5zaXRpb25Qcm9wLCBbXCJvbkVudGVyaW5nXCJdKSxcbiAgICAgIF9wcm9wcyR2YXJpYW50ID0gcHJvcHMudmFyaWFudCxcbiAgICAgIHZhcmlhbnQgPSBfcHJvcHMkdmFyaWFudCA9PT0gdm9pZCAwID8gJ3NlbGVjdGVkTWVudScgOiBfcHJvcHMkdmFyaWFudCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJhdXRvRm9jdXNcIiwgXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJkaXNhYmxlQXV0b0ZvY3VzSXRlbVwiLCBcIk1lbnVMaXN0UHJvcHNcIiwgXCJvbkNsb3NlXCIsIFwib25FbnRlcmluZ1wiLCBcIm9wZW5cIiwgXCJQYXBlclByb3BzXCIsIFwiUG9wb3ZlckNsYXNzZXNcIiwgXCJ0cmFuc2l0aW9uRHVyYXRpb25cIiwgXCJUcmFuc2l0aW9uUHJvcHNcIiwgXCJ2YXJpYW50XCJdKTtcblxuICB2YXIgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICB2YXIgYXV0b0ZvY3VzSXRlbSA9IGF1dG9Gb2N1cyAmJiAhZGlzYWJsZUF1dG9Gb2N1c0l0ZW0gJiYgb3BlbjtcbiAgdmFyIG1lbnVMaXN0QWN0aW9uc1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIGNvbnRlbnRBbmNob3JSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG5cbiAgdmFyIGdldENvbnRlbnRBbmNob3JFbCA9IGZ1bmN0aW9uIGdldENvbnRlbnRBbmNob3JFbCgpIHtcbiAgICByZXR1cm4gY29udGVudEFuY2hvclJlZi5jdXJyZW50O1xuICB9O1xuXG4gIHZhciBoYW5kbGVFbnRlcmluZyA9IGZ1bmN0aW9uIGhhbmRsZUVudGVyaW5nKGVsZW1lbnQsIGlzQXBwZWFyaW5nKSB7XG4gICAgaWYgKG1lbnVMaXN0QWN0aW9uc1JlZi5jdXJyZW50KSB7XG4gICAgICBtZW51TGlzdEFjdGlvbnNSZWYuY3VycmVudC5hZGp1c3RTdHlsZUZvclNjcm9sbGJhcihlbGVtZW50LCB0aGVtZSk7XG4gICAgfVxuXG4gICAgaWYgKG9uRW50ZXJpbmdQcm9wKSB7XG4gICAgICBvbkVudGVyaW5nUHJvcChlbGVtZW50LCBpc0FwcGVhcmluZyk7XG4gICAgfVxuXG4gICAgaWYgKG9uRW50ZXJpbmcpIHtcbiAgICAgIG9uRW50ZXJpbmcoZWxlbWVudCwgaXNBcHBlYXJpbmcpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlTGlzdEtleURvd24gPSBmdW5jdGlvbiBoYW5kbGVMaXN0S2V5RG93bihldmVudCkge1xuICAgIGlmIChldmVudC5rZXkgPT09ICdUYWInKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAob25DbG9zZSkge1xuICAgICAgICBvbkNsb3NlKGV2ZW50LCAndGFiS2V5RG93bicpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIHRoZSBpbmRleCBvZiB0aGUgaXRlbSBzaG91bGQgcmVjZWl2ZSBmb2N1c1xuICAgKiBpbiBhIGB2YXJpYW50PVwic2VsZWN0ZWRNZW51XCJgIGl0J3MgdGhlIGZpcnN0IGBzZWxlY3RlZGAgaXRlbVxuICAgKiBvdGhlcndpc2UgaXQncyB0aGUgdmVyeSBmaXJzdCBpdGVtLlxuICAgKi9cblxuXG4gIHZhciBhY3RpdmVJdGVtSW5kZXggPSAtMTsgLy8gc2luY2Ugd2UgaW5qZWN0IGZvY3VzIHJlbGF0ZWQgcHJvcHMgaW50byBjaGlsZHJlbiB3ZSBoYXZlIHRvIGRvIGEgbG9va2FoZWFkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZXJlIGlzIGEgYHNlbGVjdGVkYCBpdGVtLiBXZSdyZSBsb29raW5nIGZvciB0aGUgbGFzdCBgc2VsZWN0ZWRgXG4gIC8vIGl0ZW0gYW5kIHVzZSB0aGUgZmlyc3QgdmFsaWQgaXRlbSBhcyBhIGZhbGxiYWNrXG5cbiAgUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKCEgLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaXNGcmFnbWVudChjaGlsZCkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihbXCJNYXRlcmlhbC1VSTogVGhlIE1lbnUgY29tcG9uZW50IGRvZXNuJ3QgYWNjZXB0IGEgRnJhZ21lbnQgYXMgYSBjaGlsZC5cIiwgJ0NvbnNpZGVyIHByb3ZpZGluZyBhbiBhcnJheSBpbnN0ZWFkLiddLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICBpZiAodmFyaWFudCAhPT0gXCJtZW51XCIgJiYgY2hpbGQucHJvcHMuc2VsZWN0ZWQpIHtcbiAgICAgICAgYWN0aXZlSXRlbUluZGV4ID0gaW5kZXg7XG4gICAgICB9IGVsc2UgaWYgKGFjdGl2ZUl0ZW1JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgYWN0aXZlSXRlbUluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIGl0ZW1zID0gUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSBhY3RpdmVJdGVtSW5kZXgpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKGluc3RhbmNlKSB7XG4gICAgICAgICAgLy8gI1N0cmljdE1vZGUgcmVhZHlcbiAgICAgICAgICBjb250ZW50QW5jaG9yUmVmLmN1cnJlbnQgPSBSZWFjdERPTS5maW5kRE9NTm9kZShpbnN0YW5jZSk7XG4gICAgICAgICAgc2V0UmVmKGNoaWxkLnJlZiwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUG9wb3ZlciwgX2V4dGVuZHMoe1xuICAgIGdldENvbnRlbnRBbmNob3JFbDogZ2V0Q29udGVudEFuY2hvckVsLFxuICAgIGNsYXNzZXM6IFBvcG92ZXJDbGFzc2VzLFxuICAgIG9uQ2xvc2U6IG9uQ2xvc2UsXG4gICAgVHJhbnNpdGlvblByb3BzOiBfZXh0ZW5kcyh7XG4gICAgICBvbkVudGVyaW5nOiBoYW5kbGVFbnRlcmluZ1xuICAgIH0sIFRyYW5zaXRpb25Qcm9wcyksXG4gICAgYW5jaG9yT3JpZ2luOiB0aGVtZS5kaXJlY3Rpb24gPT09ICdydGwnID8gUlRMX09SSUdJTiA6IExUUl9PUklHSU4sXG4gICAgdHJhbnNmb3JtT3JpZ2luOiB0aGVtZS5kaXJlY3Rpb24gPT09ICdydGwnID8gUlRMX09SSUdJTiA6IExUUl9PUklHSU4sXG4gICAgUGFwZXJQcm9wczogX2V4dGVuZHMoe30sIFBhcGVyUHJvcHMsIHtcbiAgICAgIGNsYXNzZXM6IF9leHRlbmRzKHt9LCBQYXBlclByb3BzLmNsYXNzZXMsIHtcbiAgICAgICAgcm9vdDogY2xhc3Nlcy5wYXBlclxuICAgICAgfSlcbiAgICB9KSxcbiAgICBvcGVuOiBvcGVuLFxuICAgIHJlZjogcmVmLFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbjogdHJhbnNpdGlvbkR1cmF0aW9uXG4gIH0sIG90aGVyKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVudUxpc3QsIF9leHRlbmRzKHtcbiAgICBvbktleURvd246IGhhbmRsZUxpc3RLZXlEb3duLFxuICAgIGFjdGlvbnM6IG1lbnVMaXN0QWN0aW9uc1JlZixcbiAgICBhdXRvRm9jdXM6IGF1dG9Gb2N1cyAmJiAoYWN0aXZlSXRlbUluZGV4ID09PSAtMSB8fCBkaXNhYmxlQXV0b0ZvY3VzSXRlbSksXG4gICAgYXV0b0ZvY3VzSXRlbTogYXV0b0ZvY3VzSXRlbSxcbiAgICB2YXJpYW50OiB2YXJpYW50XG4gIH0sIE1lbnVMaXN0UHJvcHMsIHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5saXN0LCBNZW51TGlzdFByb3BzLmNsYXNzTmFtZSlcbiAgfSksIGl0ZW1zKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IE1lbnUucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQSBIVE1MIGVsZW1lbnQsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGl0LlxuICAgKiBJdCdzIHVzZWQgdG8gc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgbWVudS5cbiAgICovXG4gIGFuY2hvckVsOiBQcm9wVHlwZXNcbiAgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqL1xuICAub25lT2ZUeXBlKFtIVE1MRWxlbWVudFR5cGUsIFByb3BUeXBlcy5mdW5jXSksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCAoRGVmYXVsdCkgd2lsbCBmb2N1cyB0aGUgYFtyb2xlPVwibWVudVwiXWAgaWYgbm8gZm9jdXNhYmxlIGNoaWxkIGlzIGZvdW5kLiBEaXNhYmxlZFxuICAgKiBjaGlsZHJlbiBhcmUgbm90IGZvY3VzYWJsZS4gSWYgeW91IHNldCB0aGlzIHByb3AgdG8gYGZhbHNlYCBmb2N1cyB3aWxsIGJlIHBsYWNlZFxuICAgKiBvbiB0aGUgcGFyZW50IG1vZGFsIGNvbnRhaW5lci4gVGhpcyBoYXMgc2V2ZXJlIGFjY2Vzc2liaWxpdHkgaW1wbGljYXRpb25zXG4gICAqIGFuZCBzaG91bGQgb25seSBiZSBjb25zaWRlcmVkIGlmIHlvdSBtYW5hZ2UgZm9jdXMgb3RoZXJ3aXNlLlxuICAgKi9cbiAgYXV0b0ZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTWVudSBjb250ZW50cywgbm9ybWFsbHkgYE1lbnVJdGVtYHMuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogV2hlbiBvcGVuaW5nIHRoZSBtZW51IHdpbGwgbm90IGZvY3VzIHRoZSBhY3RpdmUgaXRlbSBidXQgdGhlIGBbcm9sZT1cIm1lbnVcIl1gXG4gICAqIHVubGVzcyBgYXV0b0ZvY3VzYCBpcyBhbHNvIHNldCB0byBgZmFsc2VgLiBOb3QgdXNpbmcgdGhlIGRlZmF1bHQgbWVhbnMgbm90XG4gICAqIGZvbGxvd2luZyBXQUktQVJJQSBhdXRob3JpbmcgcHJhY3RpY2VzLiBQbGVhc2UgYmUgY29uc2lkZXJhdGUgYWJvdXQgcG9zc2libGVcbiAgICogYWNjZXNzaWJpbGl0eSBpbXBsaWNhdGlvbnMuXG4gICAqL1xuICBkaXNhYmxlQXV0b0ZvY3VzSXRlbTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFByb3BzIGFwcGxpZWQgdG8gdGhlIFtgTWVudUxpc3RgXSgvYXBpL21lbnUtbGlzdC8pIGVsZW1lbnQuXG4gICAqL1xuICBNZW51TGlzdFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBjb21wb25lbnQgcmVxdWVzdHMgdG8gYmUgY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gQ2FuIGJlOiBgXCJlc2NhcGVLZXlEb3duXCJgLCBgXCJiYWNrZHJvcENsaWNrXCJgLCBgXCJ0YWJLZXlEb3duXCJgLlxuICAgKi9cbiAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSB0aGUgTWVudSBlbnRlcnMuXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLlxuICAgKi9cbiAgb25FbnRlcjogZGVwcmVjYXRlZFByb3BUeXBlKFByb3BUeXBlcy5mdW5jLCAnVXNlIHRoZSBgVHJhbnNpdGlvblByb3BzYCBwcm9wIGluc3RlYWQuJyksXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIE1lbnUgaGFzIGVudGVyZWQuXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLlxuICAgKi9cbiAgb25FbnRlcmVkOiBkZXByZWNhdGVkUHJvcFR5cGUoUHJvcFR5cGVzLmZ1bmMsICdVc2UgdGhlIGBUcmFuc2l0aW9uUHJvcHNgIHByb3AgaW5zdGVhZC4nKSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgTWVudSBpcyBlbnRlcmluZy5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgVHJhbnNpdGlvblByb3BzYCBwcm9wIGluc3RlYWQuXG4gICAqL1xuICBvbkVudGVyaW5nOiBkZXByZWNhdGVkUHJvcFR5cGUoUHJvcFR5cGVzLmZ1bmMsICdVc2UgdGhlIGBUcmFuc2l0aW9uUHJvcHNgIHByb3AgaW5zdGVhZC4nKSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYmVmb3JlIHRoZSBNZW51IGV4aXRzLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBUcmFuc2l0aW9uUHJvcHNgIHByb3AgaW5zdGVhZC5cbiAgICovXG4gIG9uRXhpdDogZGVwcmVjYXRlZFByb3BUeXBlKFByb3BUeXBlcy5mdW5jLCAnVXNlIHRoZSBgVHJhbnNpdGlvblByb3BzYCBwcm9wIGluc3RlYWQuJyksXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIE1lbnUgaGFzIGV4aXRlZC5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgVHJhbnNpdGlvblByb3BzYCBwcm9wIGluc3RlYWQuXG4gICAqL1xuICBvbkV4aXRlZDogZGVwcmVjYXRlZFByb3BUeXBlKFByb3BUeXBlcy5mdW5jLCAnVXNlIHRoZSBgVHJhbnNpdGlvblByb3BzYCBwcm9wIGluc3RlYWQuJyksXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIE1lbnUgaXMgZXhpdGluZy5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgVHJhbnNpdGlvblByb3BzYCBwcm9wIGluc3RlYWQuXG4gICAqL1xuICBvbkV4aXRpbmc6IGRlcHJlY2F0ZWRQcm9wVHlwZShQcm9wVHlwZXMuZnVuYywgJ1VzZSB0aGUgYFRyYW5zaXRpb25Qcm9wc2AgcHJvcCBpbnN0ZWFkLicpLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBtZW51IGlzIHZpc2libGUuXG4gICAqL1xuICBvcGVuOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBQYXBlclByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBgY2xhc3Nlc2AgcHJvcCBhcHBsaWVkIHRvIHRoZSBbYFBvcG92ZXJgXSgvYXBpL3BvcG92ZXIvKSBlbGVtZW50LlxuICAgKi9cbiAgUG9wb3ZlckNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFRoZSBsZW5ndGggb2YgdGhlIHRyYW5zaXRpb24gaW4gYG1zYCwgb3IgJ2F1dG8nXG4gICAqL1xuICB0cmFuc2l0aW9uRHVyYXRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbJ2F1dG8nXSksIFByb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgYXBwZWFyOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGVudGVyOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGV4aXQ6IFByb3BUeXBlcy5udW1iZXJcbiAgfSldKSxcblxuICAvKipcbiAgICogUHJvcHMgYXBwbGllZCB0byB0aGUgdHJhbnNpdGlvbiBlbGVtZW50LlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgZWxlbWVudCBpcyBiYXNlZCBvbiB0aGlzIFtgVHJhbnNpdGlvbmBdKGh0dHA6Ly9yZWFjdGNvbW11bml0eS5vcmcvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC90cmFuc2l0aW9uKSBjb21wb25lbnQuXG4gICAqL1xuICBUcmFuc2l0aW9uUHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFRoZSB2YXJpYW50IHRvIHVzZS4gVXNlIGBtZW51YCB0byBwcmV2ZW50IHNlbGVjdGVkIGl0ZW1zIGZyb20gaW1wYWN0aW5nIHRoZSBpbml0aWFsIGZvY3VzXG4gICAqIGFuZCB0aGUgdmVydGljYWwgYWxpZ25tZW50IHJlbGF0aXZlIHRvIHRoZSBhbmNob3IgZWxlbWVudC5cbiAgICovXG4gIHZhcmlhbnQ6IFByb3BUeXBlcy5vbmVPZihbJ21lbnUnLCAnc2VsZWN0ZWRNZW51J10pXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aU1lbnUnXG59KShNZW51KTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCBfdHlwZW9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2ZcIjtcbmltcG9ydCB7IGZvcm1hdE11aUVycm9yTWVzc2FnZSBhcyBfZm9ybWF0TXVpRXJyb3JNZXNzYWdlIH0gZnJvbSBcIkBtYXRlcmlhbC11aS91dGlsc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNGcmFnbWVudCB9IGZyb20gJ3JlYWN0LWlzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCBvd25lckRvY3VtZW50IGZyb20gJy4uL3V0aWxzL293bmVyRG9jdW1lbnQnO1xuaW1wb3J0IGNhcGl0YWxpemUgZnJvbSAnLi4vdXRpbHMvY2FwaXRhbGl6ZSc7XG5pbXBvcnQgeyByZWZUeXBlIH0gZnJvbSAnQG1hdGVyaWFsLXVpL3V0aWxzJztcbmltcG9ydCBNZW51IGZyb20gJy4uL01lbnUvTWVudSc7XG5pbXBvcnQgeyBpc0ZpbGxlZCB9IGZyb20gJy4uL0lucHV0QmFzZS91dGlscyc7XG5pbXBvcnQgdXNlRm9ya1JlZiBmcm9tICcuLi91dGlscy91c2VGb3JrUmVmJztcbmltcG9ydCB1c2VDb250cm9sbGVkIGZyb20gJy4uL3V0aWxzL3VzZUNvbnRyb2xsZWQnO1xuXG5mdW5jdGlvbiBhcmVFcXVhbFZhbHVlcyhhLCBiKSB7XG4gIGlmIChfdHlwZW9mKGIpID09PSAnb2JqZWN0JyAmJiBiICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cblxuICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkoZGlzcGxheSkge1xuICByZXR1cm4gZGlzcGxheSA9PSBudWxsIHx8IHR5cGVvZiBkaXNwbGF5ID09PSAnc3RyaW5nJyAmJiAhZGlzcGxheS50cmltKCk7XG59XG4vKipcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXG4gKi9cblxuXG52YXIgU2VsZWN0SW5wdXQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBTZWxlY3RJbnB1dChwcm9wcywgcmVmKSB7XG4gIHZhciBhcmlhTGFiZWwgPSBwcm9wc1snYXJpYS1sYWJlbCddLFxuICAgICAgYXV0b0ZvY3VzID0gcHJvcHMuYXV0b0ZvY3VzLFxuICAgICAgYXV0b1dpZHRoID0gcHJvcHMuYXV0b1dpZHRoLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGNsYXNzZXMgPSBwcm9wcy5jbGFzc2VzLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGRpc3BsYXlFbXB0eSA9IHByb3BzLmRpc3BsYXlFbXB0eSxcbiAgICAgIEljb25Db21wb25lbnQgPSBwcm9wcy5JY29uQ29tcG9uZW50LFxuICAgICAgaW5wdXRSZWZQcm9wID0gcHJvcHMuaW5wdXRSZWYsXG4gICAgICBsYWJlbElkID0gcHJvcHMubGFiZWxJZCxcbiAgICAgIF9wcm9wcyRNZW51UHJvcHMgPSBwcm9wcy5NZW51UHJvcHMsXG4gICAgICBNZW51UHJvcHMgPSBfcHJvcHMkTWVudVByb3BzID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRNZW51UHJvcHMsXG4gICAgICBtdWx0aXBsZSA9IHByb3BzLm11bHRpcGxlLFxuICAgICAgbmFtZSA9IHByb3BzLm5hbWUsXG4gICAgICBvbkJsdXIgPSBwcm9wcy5vbkJsdXIsXG4gICAgICBvbkNoYW5nZSA9IHByb3BzLm9uQ2hhbmdlLFxuICAgICAgb25DbG9zZSA9IHByb3BzLm9uQ2xvc2UsXG4gICAgICBvbkZvY3VzID0gcHJvcHMub25Gb2N1cyxcbiAgICAgIG9uT3BlbiA9IHByb3BzLm9uT3BlbixcbiAgICAgIG9wZW5Qcm9wID0gcHJvcHMub3BlbixcbiAgICAgIHJlYWRPbmx5ID0gcHJvcHMucmVhZE9ubHksXG4gICAgICByZW5kZXJWYWx1ZSA9IHByb3BzLnJlbmRlclZhbHVlLFxuICAgICAgX3Byb3BzJFNlbGVjdERpc3BsYXlQID0gcHJvcHMuU2VsZWN0RGlzcGxheVByb3BzLFxuICAgICAgU2VsZWN0RGlzcGxheVByb3BzID0gX3Byb3BzJFNlbGVjdERpc3BsYXlQID09PSB2b2lkIDAgPyB7fSA6IF9wcm9wcyRTZWxlY3REaXNwbGF5UCxcbiAgICAgIHRhYkluZGV4UHJvcCA9IHByb3BzLnRhYkluZGV4LFxuICAgICAgdHlwZSA9IHByb3BzLnR5cGUsXG4gICAgICB2YWx1ZVByb3AgPSBwcm9wcy52YWx1ZSxcbiAgICAgIF9wcm9wcyR2YXJpYW50ID0gcHJvcHMudmFyaWFudCxcbiAgICAgIHZhcmlhbnQgPSBfcHJvcHMkdmFyaWFudCA9PT0gdm9pZCAwID8gJ3N0YW5kYXJkJyA6IF9wcm9wcyR2YXJpYW50LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImFyaWEtbGFiZWxcIiwgXCJhdXRvRm9jdXNcIiwgXCJhdXRvV2lkdGhcIiwgXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJkZWZhdWx0VmFsdWVcIiwgXCJkaXNhYmxlZFwiLCBcImRpc3BsYXlFbXB0eVwiLCBcIkljb25Db21wb25lbnRcIiwgXCJpbnB1dFJlZlwiLCBcImxhYmVsSWRcIiwgXCJNZW51UHJvcHNcIiwgXCJtdWx0aXBsZVwiLCBcIm5hbWVcIiwgXCJvbkJsdXJcIiwgXCJvbkNoYW5nZVwiLCBcIm9uQ2xvc2VcIiwgXCJvbkZvY3VzXCIsIFwib25PcGVuXCIsIFwib3BlblwiLCBcInJlYWRPbmx5XCIsIFwicmVuZGVyVmFsdWVcIiwgXCJTZWxlY3REaXNwbGF5UHJvcHNcIiwgXCJ0YWJJbmRleFwiLCBcInR5cGVcIiwgXCJ2YWx1ZVwiLCBcInZhcmlhbnRcIl0pO1xuXG4gIHZhciBfdXNlQ29udHJvbGxlZCA9IHVzZUNvbnRyb2xsZWQoe1xuICAgIGNvbnRyb2xsZWQ6IHZhbHVlUHJvcCxcbiAgICBkZWZhdWx0OiBkZWZhdWx0VmFsdWUsXG4gICAgbmFtZTogJ1NlbGVjdCdcbiAgfSksXG4gICAgICBfdXNlQ29udHJvbGxlZDIgPSBfc2xpY2VkVG9BcnJheShfdXNlQ29udHJvbGxlZCwgMiksXG4gICAgICB2YWx1ZSA9IF91c2VDb250cm9sbGVkMlswXSxcbiAgICAgIHNldFZhbHVlID0gX3VzZUNvbnRyb2xsZWQyWzFdO1xuXG4gIHZhciBpbnB1dFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUobnVsbCksXG4gICAgICBkaXNwbGF5Tm9kZSA9IF9SZWFjdCR1c2VTdGF0ZVswXSxcbiAgICAgIHNldERpc3BsYXlOb2RlID0gX1JlYWN0JHVzZVN0YXRlWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlUmVmID0gUmVhY3QudXNlUmVmKG9wZW5Qcm9wICE9IG51bGwpLFxuICAgICAgaXNPcGVuQ29udHJvbGxlZCA9IF9SZWFjdCR1c2VSZWYuY3VycmVudDtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlMiA9IFJlYWN0LnVzZVN0YXRlKCksXG4gICAgICBtZW51TWluV2lkdGhTdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRNZW51TWluV2lkdGhTdGF0ZSA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTMgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgICBvcGVuU3RhdGUgPSBfUmVhY3QkdXNlU3RhdGUzWzBdLFxuICAgICAgc2V0T3BlblN0YXRlID0gX1JlYWN0JHVzZVN0YXRlM1sxXTtcblxuICB2YXIgaGFuZGxlUmVmID0gdXNlRm9ya1JlZihyZWYsIGlucHV0UmVmUHJvcCk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUoaGFuZGxlUmVmLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgICAgZGlzcGxheU5vZGUuZm9jdXMoKTtcbiAgICAgIH0sXG4gICAgICBub2RlOiBpbnB1dFJlZi5jdXJyZW50LFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbiAgfSwgW2Rpc3BsYXlOb2RlLCB2YWx1ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChhdXRvRm9jdXMgJiYgZGlzcGxheU5vZGUpIHtcbiAgICAgIGRpc3BsYXlOb2RlLmZvY3VzKCk7XG4gICAgfVxuICB9LCBbYXV0b0ZvY3VzLCBkaXNwbGF5Tm9kZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChkaXNwbGF5Tm9kZSkge1xuICAgICAgdmFyIGxhYmVsID0gb3duZXJEb2N1bWVudChkaXNwbGF5Tm9kZSkuZ2V0RWxlbWVudEJ5SWQobGFiZWxJZCk7XG5cbiAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgaWYgKGdldFNlbGVjdGlvbigpLmlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICBkaXNwbGF5Tm9kZS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxhYmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSwgW2xhYmVsSWQsIGRpc3BsYXlOb2RlXSk7XG5cbiAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShvcGVuLCBldmVudCkge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBpZiAob25PcGVuKSB7XG4gICAgICAgIG9uT3BlbihldmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbkNsb3NlKSB7XG4gICAgICBvbkNsb3NlKGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoIWlzT3BlbkNvbnRyb2xsZWQpIHtcbiAgICAgIHNldE1lbnVNaW5XaWR0aFN0YXRlKGF1dG9XaWR0aCA/IG51bGwgOiBkaXNwbGF5Tm9kZS5jbGllbnRXaWR0aCk7XG4gICAgICBzZXRPcGVuU3RhdGUob3Blbik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgZXZlcnl0aGluZyBidXQgbGVmdC1jbGlja1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEhpamFjayB0aGUgZGVmYXVsdCBmb2N1cyBiZWhhdmlvci5cblxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkaXNwbGF5Tm9kZS5mb2N1cygpO1xuICAgIHVwZGF0ZSh0cnVlLCBldmVudCk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUNsb3NlID0gZnVuY3Rpb24gaGFuZGxlQ2xvc2UoZXZlbnQpIHtcbiAgICB1cGRhdGUoZmFsc2UsIGV2ZW50KTtcbiAgfTtcblxuICB2YXIgY2hpbGRyZW5BcnJheSA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pOyAvLyBTdXBwb3J0IGF1dG9maWxsLlxuXG4gIHZhciBoYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgICB2YXIgaW5kZXggPSBjaGlsZHJlbkFycmF5Lm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5wcm9wcy52YWx1ZTtcbiAgICB9KS5pbmRleE9mKGV2ZW50LnRhcmdldC52YWx1ZSk7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5BcnJheVtpbmRleF07XG4gICAgc2V0VmFsdWUoY2hpbGQucHJvcHMudmFsdWUpO1xuXG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICBvbkNoYW5nZShldmVudCwgY2hpbGQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlSXRlbUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlSXRlbUNsaWNrKGNoaWxkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKCFtdWx0aXBsZSkge1xuICAgICAgICB1cGRhdGUoZmFsc2UsIGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld1ZhbHVlO1xuXG4gICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNsaWNlKCkgOiBbXTtcbiAgICAgICAgdmFyIGl0ZW1JbmRleCA9IHZhbHVlLmluZGV4T2YoY2hpbGQucHJvcHMudmFsdWUpO1xuXG4gICAgICAgIGlmIChpdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgbmV3VmFsdWUucHVzaChjaGlsZC5wcm9wcy52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3VmFsdWUuc3BsaWNlKGl0ZW1JbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY2hpbGQucHJvcHMudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZC5wcm9wcy5vbkNsaWNrKSB7XG4gICAgICAgIGNoaWxkLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPT09IG5ld1ZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2V0VmFsdWUobmV3VmFsdWUpO1xuXG4gICAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgICAgZXZlbnQucGVyc2lzdCgpOyAvLyBQcmVhY3Qgc3VwcG9ydCwgdGFyZ2V0IGlzIHJlYWQgb25seSBwcm9wZXJ0eSBvbiBhIG5hdGl2ZSBldmVudC5cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsICd0YXJnZXQnLCB7XG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvbkNoYW5nZShldmVudCwgY2hpbGQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGhhbmRsZUtleURvd24gPSBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKCFyZWFkT25seSkge1xuICAgICAgdmFyIHZhbGlkS2V5cyA9IFsnICcsICdBcnJvd1VwJywgJ0Fycm93RG93bicsIC8vIFRoZSBuYXRpdmUgc2VsZWN0IGRvZXNuJ3QgcmVzcG9uZCB0byBlbnRlciBvbiBNYWNPUywgYnV0IGl0J3MgcmVjb21tZW5kZWQgYnlcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS1wcmFjdGljZXMvZXhhbXBsZXMvbGlzdGJveC9saXN0Ym94LWNvbGxhcHNpYmxlLmh0bWxcbiAgICAgICdFbnRlciddO1xuXG4gICAgICBpZiAodmFsaWRLZXlzLmluZGV4T2YoZXZlbnQua2V5KSAhPT0gLTEpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdXBkYXRlKHRydWUsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIG9wZW4gPSBkaXNwbGF5Tm9kZSAhPT0gbnVsbCAmJiAoaXNPcGVuQ29udHJvbGxlZCA/IG9wZW5Qcm9wIDogb3BlblN0YXRlKTtcblxuICB2YXIgaGFuZGxlQmx1ciA9IGZ1bmN0aW9uIGhhbmRsZUJsdXIoZXZlbnQpIHtcbiAgICAvLyBpZiBvcGVuIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblxuICAgIGlmICghb3BlbiAmJiBvbkJsdXIpIHtcbiAgICAgIGV2ZW50LnBlcnNpc3QoKTsgLy8gUHJlYWN0IHN1cHBvcnQsIHRhcmdldCBpcyByZWFkIG9ubHkgcHJvcGVydHkgb24gYSBuYXRpdmUgZXZlbnQuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgJ3RhcmdldCcsIHtcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvbkJsdXIoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICBkZWxldGUgb3RoZXJbJ2FyaWEtaW52YWxpZCddO1xuICB2YXIgZGlzcGxheTtcbiAgdmFyIGRpc3BsYXlTaW5nbGU7XG4gIHZhciBkaXNwbGF5TXVsdGlwbGUgPSBbXTtcbiAgdmFyIGNvbXB1dGVEaXNwbGF5ID0gZmFsc2U7XG4gIHZhciBmb3VuZE1hdGNoID0gZmFsc2U7IC8vIE5vIG5lZWQgdG8gZGlzcGxheSBhbnkgdmFsdWUgaWYgdGhlIGZpZWxkIGlzIGVtcHR5LlxuXG4gIGlmIChpc0ZpbGxlZCh7XG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pIHx8IGRpc3BsYXlFbXB0eSkge1xuICAgIGlmIChyZW5kZXJWYWx1ZSkge1xuICAgICAgZGlzcGxheSA9IHJlbmRlclZhbHVlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcHV0ZURpc3BsYXkgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpdGVtcyA9IGNoaWxkcmVuQXJyYXkubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmICghIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaXNGcmFnbWVudChjaGlsZCkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihbXCJNYXRlcmlhbC1VSTogVGhlIFNlbGVjdCBjb21wb25lbnQgZG9lc24ndCBhY2NlcHQgYSBGcmFnbWVudCBhcyBhIGNoaWxkLlwiLCAnQ29uc2lkZXIgcHJvdmlkaW5nIGFuIGFycmF5IGluc3RlYWQuJ10uam9pbignXFxuJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzZWxlY3RlZDtcblxuICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJNYXRlcmlhbC1VSTogVGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGJlIGFuIGFycmF5IHdoZW4gdXNpbmcgdGhlIGBTZWxlY3RgIGNvbXBvbmVudCB3aXRoIGBtdWx0aXBsZWAuXCIgOiBfZm9ybWF0TXVpRXJyb3JNZXNzYWdlKDIpKTtcbiAgICAgIH1cblxuICAgICAgc2VsZWN0ZWQgPSB2YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBhcmVFcXVhbFZhbHVlcyh2LCBjaGlsZC5wcm9wcy52YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNlbGVjdGVkICYmIGNvbXB1dGVEaXNwbGF5KSB7XG4gICAgICAgIGRpc3BsYXlNdWx0aXBsZS5wdXNoKGNoaWxkLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0ZWQgPSBhcmVFcXVhbFZhbHVlcyh2YWx1ZSwgY2hpbGQucHJvcHMudmFsdWUpO1xuXG4gICAgICBpZiAoc2VsZWN0ZWQgJiYgY29tcHV0ZURpc3BsYXkpIHtcbiAgICAgICAgZGlzcGxheVNpbmdsZSA9IGNoaWxkLnByb3BzLmNoaWxkcmVuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgZm91bmRNYXRjaCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICdhcmlhLXNlbGVjdGVkJzogc2VsZWN0ZWQgPyAndHJ1ZScgOiB1bmRlZmluZWQsXG4gICAgICBvbkNsaWNrOiBoYW5kbGVJdGVtQ2xpY2soY2hpbGQpLFxuICAgICAgb25LZXlVcDogZnVuY3Rpb24gb25LZXlVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcpIHtcbiAgICAgICAgICAvLyBvdGhlcndpc2Ugb3VyIE1lbnVJdGVtcyBkaXNwYXRjaGVzIGEgY2xpY2sgZXZlbnRcbiAgICAgICAgICAvLyBpdCdzIG5vdCBiZWhhdmlvciBvZiB0aGUgbmF0aXZlIDxvcHRpb24+IGFuZCBjYXVzZXNcbiAgICAgICAgICAvLyB0aGUgc2VsZWN0IHRvIGNsb3NlIGltbWVkaWF0ZWx5IHNpbmNlIHdlIG9wZW4gb24gc3BhY2Uga2V5ZG93blxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGQucHJvcHMub25LZXlVcCkge1xuICAgICAgICAgIGNoaWxkLnByb3BzLm9uS2V5VXAoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcm9sZTogJ29wdGlvbicsXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgLy8gVGhlIHZhbHVlIGlzIG1vc3QgbGlrZWx5IG5vdCBhIHZhbGlkIEhUTUwgYXR0cmlidXRlLlxuICAgICAgJ2RhdGEtdmFsdWUnOiBjaGlsZC5wcm9wcy52YWx1ZSAvLyBJbnN0ZWFkLCB3ZSBwcm92aWRlIGl0IGFzIGEgZGF0YSBhdHRyaWJ1dGUuXG5cbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFmb3VuZE1hdGNoICYmICFtdWx0aXBsZSAmJiB2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGNoaWxkcmVuQXJyYXkubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZC5wcm9wcy52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUud2FybihbXCJNYXRlcmlhbC1VSTogWW91IGhhdmUgcHJvdmlkZWQgYW4gb3V0LW9mLXJhbmdlIHZhbHVlIGBcIi5jb25jYXQodmFsdWUsIFwiYCBmb3IgdGhlIHNlbGVjdCBcIikuY29uY2F0KG5hbWUgPyBcIihuYW1lPVxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiKSBcIikgOiAnJywgXCJjb21wb25lbnQuXCIpLCBcIkNvbnNpZGVyIHByb3ZpZGluZyBhIHZhbHVlIHRoYXQgbWF0Y2hlcyBvbmUgb2YgdGhlIGF2YWlsYWJsZSBvcHRpb25zIG9yICcnLlwiLCBcIlRoZSBhdmFpbGFibGUgdmFsdWVzIGFyZSBcIi5jb25jYXQodmFsdWVzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiB4ICE9IG51bGw7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiBcImBcIi5jb25jYXQoeCwgXCJgXCIpO1xuICAgICAgICB9KS5qb2luKCcsICcpIHx8ICdcIlwiJywgXCIuXCIpXS5qb2luKCdcXG4nKSk7XG4gICAgICB9XG4gICAgfSwgW2ZvdW5kTWF0Y2gsIGNoaWxkcmVuQXJyYXksIG11bHRpcGxlLCBuYW1lLCB2YWx1ZV0pO1xuICB9XG5cbiAgaWYgKGNvbXB1dGVEaXNwbGF5KSB7XG4gICAgZGlzcGxheSA9IG11bHRpcGxlID8gZGlzcGxheU11bHRpcGxlLmpvaW4oJywgJykgOiBkaXNwbGF5U2luZ2xlO1xuICB9IC8vIEF2b2lkIHBlcmZvcm1pbmcgYSBsYXlvdXQgY29tcHV0YXRpb24gaW4gdGhlIHJlbmRlciBtZXRob2QuXG5cblxuICB2YXIgbWVudU1pbldpZHRoID0gbWVudU1pbldpZHRoU3RhdGU7XG5cbiAgaWYgKCFhdXRvV2lkdGggJiYgaXNPcGVuQ29udHJvbGxlZCAmJiBkaXNwbGF5Tm9kZSkge1xuICAgIG1lbnVNaW5XaWR0aCA9IGRpc3BsYXlOb2RlLmNsaWVudFdpZHRoO1xuICB9XG5cbiAgdmFyIHRhYkluZGV4O1xuXG4gIGlmICh0eXBlb2YgdGFiSW5kZXhQcm9wICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRhYkluZGV4ID0gdGFiSW5kZXhQcm9wO1xuICB9IGVsc2Uge1xuICAgIHRhYkluZGV4ID0gZGlzYWJsZWQgPyBudWxsIDogMDtcbiAgfVxuXG4gIHZhciBidXR0b25JZCA9IFNlbGVjdERpc3BsYXlQcm9wcy5pZCB8fCAobmFtZSA/IFwibXVpLWNvbXBvbmVudC1zZWxlY3QtXCIuY29uY2F0KG5hbWUpIDogdW5kZWZpbmVkKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgLy8gVE9ETyB2NTogbWVyZ2Ugcm9vdCBhbmQgc2VsZWN0XG4gICAgY2xhc3Nlcy5zZWxlY3QsIGNsYXNzZXMuc2VsZWN0TWVudSwgY2xhc3Nlc1t2YXJpYW50XSwgY2xhc3NOYW1lLCBkaXNhYmxlZCAmJiBjbGFzc2VzLmRpc2FibGVkKSxcbiAgICByZWY6IHNldERpc3BsYXlOb2RlLFxuICAgIHRhYkluZGV4OiB0YWJJbmRleCxcbiAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgIFwiYXJpYS1kaXNhYmxlZFwiOiBkaXNhYmxlZCA/ICd0cnVlJyA6IHVuZGVmaW5lZCxcbiAgICBcImFyaWEtZXhwYW5kZWRcIjogb3BlbiA/ICd0cnVlJyA6IHVuZGVmaW5lZCxcbiAgICBcImFyaWEtaGFzcG9wdXBcIjogXCJsaXN0Ym94XCIsXG4gICAgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCxcbiAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBbbGFiZWxJZCwgYnV0dG9uSWRdLmZpbHRlcihCb29sZWFuKS5qb2luKCcgJykgfHwgdW5kZWZpbmVkLFxuICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICBvbk1vdXNlRG93bjogZGlzYWJsZWQgfHwgcmVhZE9ubHkgPyBudWxsIDogaGFuZGxlTW91c2VEb3duLFxuICAgIG9uQmx1cjogaGFuZGxlQmx1cixcbiAgICBvbkZvY3VzOiBvbkZvY3VzXG4gIH0sIFNlbGVjdERpc3BsYXlQcm9wcywge1xuICAgIC8vIFRoZSBpZCBpcyByZXF1aXJlZCBmb3IgcHJvcGVyIGExMXlcbiAgICBpZDogYnV0dG9uSWRcbiAgfSksIGlzRW1wdHkoZGlzcGxheSkgP1xuICAvKiNfX1BVUkVfXyovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1kYW5nZXJcbiAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICBfX2h0bWw6ICcmIzgyMDM7J1xuICAgIH1cbiAgfSkgOiBkaXNwbGF5KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBfZXh0ZW5kcyh7XG4gICAgdmFsdWU6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuam9pbignLCcpIDogdmFsdWUsXG4gICAgbmFtZTogbmFtZSxcbiAgICByZWY6IGlucHV0UmVmLFxuICAgIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSxcbiAgICBvbkNoYW5nZTogaGFuZGxlQ2hhbmdlLFxuICAgIHRhYkluZGV4OiAtMSxcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMubmF0aXZlSW5wdXQsXG4gICAgYXV0b0ZvY3VzOiBhdXRvRm9jdXNcbiAgfSwgb3RoZXIpKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkNvbXBvbmVudCwge1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLmljb24sIGNsYXNzZXNbXCJpY29uXCIuY29uY2F0KGNhcGl0YWxpemUodmFyaWFudCkpXSwgb3BlbiAmJiBjbGFzc2VzLmljb25PcGVuLCBkaXNhYmxlZCAmJiBjbGFzc2VzLmRpc2FibGVkKVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVudSwgX2V4dGVuZHMoe1xuICAgIGlkOiBcIm1lbnUtXCIuY29uY2F0KG5hbWUgfHwgJycpLFxuICAgIGFuY2hvckVsOiBkaXNwbGF5Tm9kZSxcbiAgICBvcGVuOiBvcGVuLFxuICAgIG9uQ2xvc2U6IGhhbmRsZUNsb3NlXG4gIH0sIE1lbnVQcm9wcywge1xuICAgIE1lbnVMaXN0UHJvcHM6IF9leHRlbmRzKHtcbiAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBsYWJlbElkLFxuICAgICAgcm9sZTogJ2xpc3Rib3gnLFxuICAgICAgZGlzYWJsZUxpc3RXcmFwOiB0cnVlXG4gICAgfSwgTWVudVByb3BzLk1lbnVMaXN0UHJvcHMpLFxuICAgIFBhcGVyUHJvcHM6IF9leHRlbmRzKHt9LCBNZW51UHJvcHMuUGFwZXJQcm9wcywge1xuICAgICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgICAgbWluV2lkdGg6IG1lbnVNaW5XaWR0aFxuICAgICAgfSwgTWVudVByb3BzLlBhcGVyUHJvcHMgIT0gbnVsbCA/IE1lbnVQcm9wcy5QYXBlclByb3BzLnN0eWxlIDogbnVsbClcbiAgICB9KVxuICB9KSwgaXRlbXMpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gU2VsZWN0SW5wdXQucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgJ2FyaWEtbGFiZWwnOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBhdXRvRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSB3aWR0aCBvZiB0aGUgcG9wb3ZlciB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgc2V0IGFjY29yZGluZyB0byB0aGUgaXRlbXMgaW5zaWRlIHRoZVxuICAgKiBtZW51LCBvdGhlcndpc2UgaXQgd2lsbCBiZSBhdCBsZWFzdCB0aGUgd2lkdGggb2YgdGhlIHNlbGVjdCBpbnB1dC5cbiAgICovXG4gIGF1dG9XaWR0aDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBvcHRpb24gZWxlbWVudHMgdG8gcG9wdWxhdGUgdGhlIHNlbGVjdCB3aXRoLlxuICAgKiBDYW4gYmUgc29tZSBgPE1lbnVJdGVtPmAgZWxlbWVudHMuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBUaGUgQ1NTIGNsYXNzIG5hbWUgb2YgdGhlIHNlbGVjdCBlbGVtZW50LlxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBlbGVtZW50IHZhbHVlLiBVc2Ugd2hlbiB0aGUgY29tcG9uZW50IGlzIG5vdCBjb250cm9sbGVkLlxuICAgKi9cbiAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMuYW55LFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBzZWxlY3Qgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgc2VsZWN0ZWQgaXRlbSBpcyBkaXNwbGF5ZWQgZXZlbiBpZiBpdHMgdmFsdWUgaXMgZW1wdHkuXG4gICAqL1xuICBkaXNwbGF5RW1wdHk6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgaWNvbiB0aGF0IGRpc3BsYXlzIHRoZSBhcnJvdy5cbiAgICovXG4gIEljb25Db21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50VHlwZS5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBJbXBlcmF0aXZlIGhhbmRsZSBpbXBsZW1lbnRpbmcgYHsgdmFsdWU6IFQsIG5vZGU6IEhUTUxFbGVtZW50LCBmb2N1cygpOiB2b2lkIH1gXG4gICAqIEVxdWl2YWxlbnQgdG8gYHJlZmBcbiAgICovXG4gIGlucHV0UmVmOiByZWZUeXBlLFxuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgYW4gZWxlbWVudCB0aGF0IGFjdHMgYXMgYW4gYWRkaXRpb25hbCBsYWJlbC4gVGhlIFNlbGVjdCB3aWxsXG4gICAqIGJlIGxhYmVsbGVkIGJ5IHRoZSBhZGRpdGlvbmFsIGxhYmVsIGFuZCB0aGUgc2VsZWN0ZWQgdmFsdWUuXG4gICAqL1xuICBsYWJlbElkOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBbYE1lbnVgXSgvYXBpL21lbnUvKSBlbGVtZW50LlxuICAgKi9cbiAgTWVudVByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGB2YWx1ZWAgbXVzdCBiZSBhbiBhcnJheSBhbmQgdGhlIG1lbnUgd2lsbCBzdXBwb3J0IG11bHRpcGxlIHNlbGVjdGlvbnMuXG4gICAqL1xuICBtdWx0aXBsZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE5hbWUgYXR0cmlidXRlIG9mIHRoZSBgc2VsZWN0YCBvciBoaWRkZW4gYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gZmlyZWQgd2hlbiBhIG1lbnUgaXRlbSBpcyBzZWxlY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBZb3UgY2FuIHB1bGwgb3V0IHRoZSBuZXcgdmFsdWUgYnkgYWNjZXNzaW5nIGBldmVudC50YXJnZXQudmFsdWVgIChhbnkpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW2NoaWxkXSBUaGUgcmVhY3QgZWxlbWVudCB0aGF0IHdhcyBzZWxlY3RlZC5cbiAgICovXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IHJlcXVlc3RzIHRvIGJlIGNsb3NlZC5cbiAgICogVXNlIGluIGNvbnRyb2xsZWQgbW9kZSAoc2VlIG9wZW4pLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqL1xuICBvbkNsb3NlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIHdoZW4gdGhlIGNvbXBvbmVudCByZXF1ZXN0cyB0byBiZSBvcGVuZWQuXG4gICAqIFVzZSBpbiBjb250cm9sbGVkIG1vZGUgKHNlZSBvcGVuKS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKi9cbiAgb25PcGVuOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ29udHJvbCBgc2VsZWN0YCBvcGVuIHN0YXRlLlxuICAgKi9cbiAgb3BlbjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHJlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBzZWxlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSBgdmFsdWVgIHByb3ZpZGVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIEByZXR1cm5zIHtSZWFjdE5vZGV9XG4gICAqL1xuICByZW5kZXJWYWx1ZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIFByb3BzIGFwcGxpZWQgdG8gdGhlIGNsaWNrYWJsZSBkaXYgZWxlbWVudC5cbiAgICovXG4gIFNlbGVjdERpc3BsYXlQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgdGFiSW5kZXg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgdHlwZTogUHJvcFR5cGVzLmFueSxcblxuICAvKipcbiAgICogVGhlIGlucHV0IHZhbHVlLlxuICAgKi9cbiAgdmFsdWU6IFByb3BUeXBlcy5hbnksXG5cbiAgLyoqXG4gICAqIFRoZSB2YXJpYW50IHRvIHVzZS5cbiAgICovXG4gIHZhcmlhbnQ6IFByb3BUeXBlcy5vbmVPZihbJ3N0YW5kYXJkJywgJ291dGxpbmVkJywgJ2ZpbGxlZCddKVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IFNlbGVjdElucHV0OyIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjcmVhdGVTdmdJY29uIGZyb20gJy4uLy4uL3V0aWxzL2NyZWF0ZVN2Z0ljb24nO1xuLyoqXG4gKiBAaWdub3JlIC0gaW50ZXJuYWwgY29tcG9uZW50LlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVN2Z0ljb24oIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gIGQ6IFwiTTcgMTBsNSA1IDUtNXpcIlxufSksICdBcnJvd0Ryb3BEb3duJyk7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHsgcmVmVHlwZSB9IGZyb20gJ0BtYXRlcmlhbC11aS91dGlscyc7XG5pbXBvcnQgY2FwaXRhbGl6ZSBmcm9tICcuLi91dGlscy9jYXBpdGFsaXplJztcbi8qKlxuICogQGlnbm9yZSAtIGludGVybmFsIGNvbXBvbmVudC5cbiAqL1xuXG52YXIgTmF0aXZlU2VsZWN0SW5wdXQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBOYXRpdmVTZWxlY3RJbnB1dChwcm9wcywgcmVmKSB7XG4gIHZhciBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQsXG4gICAgICBJY29uQ29tcG9uZW50ID0gcHJvcHMuSWNvbkNvbXBvbmVudCxcbiAgICAgIGlucHV0UmVmID0gcHJvcHMuaW5wdXRSZWYsXG4gICAgICBfcHJvcHMkdmFyaWFudCA9IHByb3BzLnZhcmlhbnQsXG4gICAgICB2YXJpYW50ID0gX3Byb3BzJHZhcmlhbnQgPT09IHZvaWQgMCA/ICdzdGFuZGFyZCcgOiBfcHJvcHMkdmFyaWFudCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiZGlzYWJsZWRcIiwgXCJJY29uQ29tcG9uZW50XCIsIFwiaW5wdXRSZWZcIiwgXCJ2YXJpYW50XCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCAvLyBUT0RPIHY1OiBtZXJnZSByb290IGFuZCBzZWxlY3RcbiAgICBjbGFzc2VzLnNlbGVjdCwgY2xhc3Nlc1t2YXJpYW50XSwgY2xhc3NOYW1lLCBkaXNhYmxlZCAmJiBjbGFzc2VzLmRpc2FibGVkKSxcbiAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgcmVmOiBpbnB1dFJlZiB8fCByZWZcbiAgfSwgb3RoZXIpKSwgcHJvcHMubXVsdGlwbGUgPyBudWxsIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkNvbXBvbmVudCwge1xuICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLmljb24sIGNsYXNzZXNbXCJpY29uXCIuY29uY2F0KGNhcGl0YWxpemUodmFyaWFudCkpXSwgZGlzYWJsZWQgJiYgY2xhc3Nlcy5kaXNhYmxlZClcbiAgfSkpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBOYXRpdmVTZWxlY3RJbnB1dC5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBUaGUgb3B0aW9uIGVsZW1lbnRzIHRvIHBvcHVsYXRlIHRoZSBzZWxlY3Qgd2l0aC5cbiAgICogQ2FuIGJlIHNvbWUgYDxvcHRpb24+YCBlbGVtZW50cy5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIFRoZSBDU1MgY2xhc3MgbmFtZSBvZiB0aGUgc2VsZWN0IGVsZW1lbnQuXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHNlbGVjdCB3aWxsIGJlIGRpc2FibGVkLlxuICAgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgaWNvbiB0aGF0IGRpc3BsYXlzIHRoZSBhcnJvdy5cbiAgICovXG4gIEljb25Db21wb25lbnQ6IFByb3BUeXBlcy5lbGVtZW50VHlwZS5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBVc2UgdGhhdCBwcm9wIHRvIHBhc3MgYSByZWYgdG8gdGhlIG5hdGl2ZSBzZWxlY3QgZWxlbWVudC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGlucHV0UmVmOiByZWZUeXBlLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBtdWx0aXBsZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE5hbWUgYXR0cmlidXRlIG9mIHRoZSBgc2VsZWN0YCBvciBoaWRkZW4gYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gZmlyZWQgd2hlbiBhIG1lbnUgaXRlbSBpcyBzZWxlY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBZb3UgY2FuIHB1bGwgb3V0IHRoZSBuZXcgdmFsdWUgYnkgYWNjZXNzaW5nIGBldmVudC50YXJnZXQudmFsdWVgIChzdHJpbmcpLlxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgdmFsdWUuXG4gICAqL1xuICB2YWx1ZTogUHJvcFR5cGVzLmFueSxcblxuICAvKipcbiAgICogVGhlIHZhcmlhbnQgdG8gdXNlLlxuICAgKi9cbiAgdmFyaWFudDogUHJvcFR5cGVzLm9uZU9mKFsnc3RhbmRhcmQnLCAnb3V0bGluZWQnLCAnZmlsbGVkJ10pXG59IDogdm9pZCAwO1xuZXhwb3J0IGRlZmF1bHQgTmF0aXZlU2VsZWN0SW5wdXQ7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBOYXRpdmVTZWxlY3RJbnB1dCBmcm9tICcuL05hdGl2ZVNlbGVjdElucHV0JztcbmltcG9ydCB3aXRoU3R5bGVzIGZyb20gJy4uL3N0eWxlcy93aXRoU3R5bGVzJztcbmltcG9ydCBmb3JtQ29udHJvbFN0YXRlIGZyb20gJy4uL0Zvcm1Db250cm9sL2Zvcm1Db250cm9sU3RhdGUnO1xuaW1wb3J0IHVzZUZvcm1Db250cm9sIGZyb20gJy4uL0Zvcm1Db250cm9sL3VzZUZvcm1Db250cm9sJztcbmltcG9ydCBBcnJvd0Ryb3BEb3duSWNvbiBmcm9tICcuLi9pbnRlcm5hbC9zdmctaWNvbnMvQXJyb3dEcm9wRG93bic7XG5pbXBvcnQgSW5wdXQgZnJvbSAnLi4vSW5wdXQnO1xuZXhwb3J0IHZhciBzdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXModGhlbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgc2VsZWN0IGNvbXBvbmVudCBgcm9vdGAgY2xhc3MuICovXG4gICAgcm9vdDoge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgc2VsZWN0IGNvbXBvbmVudCBgc2VsZWN0YCBjbGFzcy4gKi9cbiAgICBzZWxlY3Q6IHtcbiAgICAgICctbW96LWFwcGVhcmFuY2UnOiAnbm9uZScsXG4gICAgICAvLyBSZXNldFxuICAgICAgJy13ZWJraXQtYXBwZWFyYW5jZSc6ICdub25lJyxcbiAgICAgIC8vIFJlc2V0XG4gICAgICAvLyBXaGVuIGludGVyYWN0aW5nIHF1aWNrbHksIHRoZSB0ZXh0IGNhbiBlbmQgdXAgc2VsZWN0ZWQuXG4gICAgICAvLyBOYXRpdmUgc2VsZWN0IGNhbid0IGJlIHNlbGVjdGVkIGVpdGhlci5cbiAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgIC8vIFJlc2V0XG4gICAgICBtaW5XaWR0aDogMTYsXG4gICAgICAvLyBTbyBpdCBkb2Vzbid0IGNvbGxhcHNlLlxuICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAnJjpmb2N1cyc6IHtcbiAgICAgICAgLy8gU2hvdyB0aGF0IGl0J3Mgbm90IGFuIHRleHQgaW5wdXRcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLnR5cGUgPT09ICdsaWdodCcgPyAncmdiYSgwLCAwLCAwLCAwLjA1KScgOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjA1KScsXG4gICAgICAgIGJvcmRlclJhZGl1czogMCAvLyBSZXNldCBDaHJvbWUgc3R5bGVcblxuICAgICAgfSxcbiAgICAgIC8vIFJlbW92ZSBJRSAxMSBhcnJvd1xuICAgICAgJyY6Oi1tcy1leHBhbmQnOiB7XG4gICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgfSxcbiAgICAgICcmJGRpc2FibGVkJzoge1xuICAgICAgICBjdXJzb3I6ICdkZWZhdWx0J1xuICAgICAgfSxcbiAgICAgICcmW211bHRpcGxlXSc6IHtcbiAgICAgICAgaGVpZ2h0OiAnYXV0bydcbiAgICAgIH0sXG4gICAgICAnJjpub3QoW211bHRpcGxlXSkgb3B0aW9uLCAmOm5vdChbbXVsdGlwbGVdKSBvcHRncm91cCc6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLmJhY2tncm91bmQucGFwZXJcbiAgICAgIH0sXG4gICAgICAnJiYnOiB7XG4gICAgICAgIHBhZGRpbmdSaWdodDogMjRcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHNlbGVjdCBjb21wb25lbnQgaWYgYHZhcmlhbnQ9XCJmaWxsZWRcImAuICovXG4gICAgZmlsbGVkOiB7XG4gICAgICAnJiYnOiB7XG4gICAgICAgIHBhZGRpbmdSaWdodDogMzJcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHNlbGVjdCBjb21wb25lbnQgaWYgYHZhcmlhbnQ9XCJvdXRsaW5lZFwiYC4gKi9cbiAgICBvdXRsaW5lZDoge1xuICAgICAgYm9yZGVyUmFkaXVzOiB0aGVtZS5zaGFwZS5ib3JkZXJSYWRpdXMsXG4gICAgICAnJiYnOiB7XG4gICAgICAgIHBhZGRpbmdSaWdodDogMzJcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIHNlbGVjdCBjb21wb25lbnQgYHNlbGVjdE1lbnVgIGNsYXNzLiAqL1xuICAgIHNlbGVjdE1lbnU6IHtcbiAgICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAgLy8gUmVzZXRzIGZvciBtdWx0cGlsZSBzZWxlY3Qgd2l0aCBjaGlwc1xuICAgICAgbWluSGVpZ2h0OiAnMS4xODc2ZW0nLFxuICAgICAgLy8gUmVxdWlyZWQgZm9yIHNlbGVjdFxcdGV4dC1maWVsZCBoZWlnaHQgY29uc2lzdGVuY3lcbiAgICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgfSxcblxuICAgIC8qIFBzZXVkby1jbGFzcyBhcHBsaWVkIHRvIHRoZSBzZWxlY3QgY29tcG9uZW50IGBkaXNhYmxlZGAgY2xhc3MuICovXG4gICAgZGlzYWJsZWQ6IHt9LFxuXG4gICAgLyogU3R5bGVzIGFwcGxpZWQgdG8gdGhlIGljb24gY29tcG9uZW50LiAqL1xuICAgIGljb246IHtcbiAgICAgIC8vIFdlIHVzZSBhIHBvc2l0aW9uIGFic29sdXRlIG92ZXIgYSBmbGV4Ym94IGluIG9yZGVyIHRvIGZvcndhcmQgdGhlIHBvaW50ZXIgZXZlbnRzXG4gICAgICAvLyB0byB0aGUgaW5wdXQgYW5kIHRvIHN1cHBvcnQgd3JhcHBpbmcgdGFncy4uXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAnY2FsYyg1MCUgLSAxMnB4KScsXG4gICAgICAvLyBDZW50ZXIgdmVydGljYWxseVxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgLy8gRG9uJ3QgYmxvY2sgcG9pbnRlciBldmVudHMgb24gdGhlIHNlbGVjdCB1bmRlciB0aGUgaWNvbi5cbiAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmFjdGlvbi5hY3RpdmUsXG4gICAgICAnJiRkaXNhYmxlZCc6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBpY29uIGNvbXBvbmVudCBpZiB0aGUgcG9wdXAgaXMgb3Blbi4gKi9cbiAgICBpY29uT3Blbjoge1xuICAgICAgdHJhbnNmb3JtOiAncm90YXRlKDE4MGRlZyknXG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSBpY29uIGNvbXBvbmVudCBpZiBgdmFyaWFudD1cImZpbGxlZFwiYC4gKi9cbiAgICBpY29uRmlsbGVkOiB7XG4gICAgICByaWdodDogN1xuICAgIH0sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgaWNvbiBjb21wb25lbnQgaWYgYHZhcmlhbnQ9XCJvdXRsaW5lZFwiYC4gKi9cbiAgICBpY29uT3V0bGluZWQ6IHtcbiAgICAgIHJpZ2h0OiA3XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBpbnB1dCBjb21wb25lbnQuICovXG4gICAgbmF0aXZlSW5wdXQ6IHtcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICB3aWR0aDogJzEwMCUnXG4gICAgfVxuICB9O1xufTtcbnZhciBkZWZhdWx0SW5wdXQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJbnB1dCwgbnVsbCk7XG4vKipcbiAqIEFuIGFsdGVybmF0aXZlIHRvIGA8U2VsZWN0IG5hdGl2ZSAvPmAgd2l0aCBhIG11Y2ggc21hbGxlciBidW5kbGUgc2l6ZSBmb290cHJpbnQuXG4gKi9cblxudmFyIE5hdGl2ZVNlbGVjdCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIE5hdGl2ZVNlbGVjdChwcm9wcywgcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBfcHJvcHMkSWNvbkNvbXBvbmVudCA9IHByb3BzLkljb25Db21wb25lbnQsXG4gICAgICBJY29uQ29tcG9uZW50ID0gX3Byb3BzJEljb25Db21wb25lbnQgPT09IHZvaWQgMCA/IEFycm93RHJvcERvd25JY29uIDogX3Byb3BzJEljb25Db21wb25lbnQsXG4gICAgICBfcHJvcHMkaW5wdXQgPSBwcm9wcy5pbnB1dCxcbiAgICAgIGlucHV0ID0gX3Byb3BzJGlucHV0ID09PSB2b2lkIDAgPyBkZWZhdWx0SW5wdXQgOiBfcHJvcHMkaW5wdXQsXG4gICAgICBpbnB1dFByb3BzID0gcHJvcHMuaW5wdXRQcm9wcyxcbiAgICAgIHZhcmlhbnQgPSBwcm9wcy52YXJpYW50LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3Nlc1wiLCBcIkljb25Db21wb25lbnRcIiwgXCJpbnB1dFwiLCBcImlucHV0UHJvcHNcIiwgXCJ2YXJpYW50XCJdKTtcblxuICB2YXIgbXVpRm9ybUNvbnRyb2wgPSB1c2VGb3JtQ29udHJvbCgpO1xuICB2YXIgZmNzID0gZm9ybUNvbnRyb2xTdGF0ZSh7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIG11aUZvcm1Db250cm9sOiBtdWlGb3JtQ29udHJvbCxcbiAgICBzdGF0ZXM6IFsndmFyaWFudCddXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChpbnB1dCwgX2V4dGVuZHMoe1xuICAgIC8vIE1vc3Qgb2YgdGhlIGxvZ2ljIGlzIGltcGxlbWVudGVkIGluIGBOYXRpdmVTZWxlY3RJbnB1dGAuXG4gICAgLy8gVGhlIGBTZWxlY3RgIGNvbXBvbmVudCBpcyBhIHNpbXBsZSBBUEkgd3JhcHBlciB0byBleHBvc2Ugc29tZXRoaW5nIGJldHRlciB0byBwbGF5IHdpdGguXG4gICAgaW5wdXRDb21wb25lbnQ6IE5hdGl2ZVNlbGVjdElucHV0LFxuICAgIGlucHV0UHJvcHM6IF9leHRlbmRzKHtcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgIGNsYXNzZXM6IGNsYXNzZXMsXG4gICAgICBJY29uQ29tcG9uZW50OiBJY29uQ29tcG9uZW50LFxuICAgICAgdmFyaWFudDogZmNzLnZhcmlhbnQsXG4gICAgICB0eXBlOiB1bmRlZmluZWRcbiAgICB9LCBpbnB1dFByb3BzLCBpbnB1dCA/IGlucHV0LnByb3BzLmlucHV0UHJvcHMgOiB7fSksXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpKTtcbn0pO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gTmF0aXZlU2VsZWN0LnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIFRoZSBvcHRpb24gZWxlbWVudHMgdG8gcG9wdWxhdGUgdGhlIHNlbGVjdCB3aXRoLlxuICAgKiBDYW4gYmUgc29tZSBgPG9wdGlvbj5gIGVsZW1lbnRzLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFRoZSBpY29uIHRoYXQgZGlzcGxheXMgdGhlIGFycm93LlxuICAgKi9cbiAgSWNvbkNvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuXG4gIC8qKlxuICAgKiBBbiBgSW5wdXRgIGVsZW1lbnQ7IGRvZXMgbm90IGhhdmUgdG8gYmUgYSBtYXRlcmlhbC11aSBzcGVjaWZpYyBgSW5wdXRgLlxuICAgKi9cbiAgaW5wdXQ6IFByb3BUeXBlcy5lbGVtZW50LFxuXG4gIC8qKlxuICAgKiBBdHRyaWJ1dGVzIGFwcGxpZWQgdG8gdGhlIGBzZWxlY3RgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBmaXJlZCB3aGVuIGEgbWVudSBpdGVtIGlzIHNlbGVjdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqIFlvdSBjYW4gcHVsbCBvdXQgdGhlIG5ldyB2YWx1ZSBieSBhY2Nlc3NpbmcgYGV2ZW50LnRhcmdldC52YWx1ZWAgKHN0cmluZykuXG4gICAqL1xuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCB2YWx1ZS4gVGhlIERPTSBBUEkgY2FzdHMgdGhpcyB0byBhIHN0cmluZy5cbiAgICovXG4gIHZhbHVlOiBQcm9wVHlwZXMuYW55LFxuXG4gIC8qKlxuICAgKiBUaGUgdmFyaWFudCB0byB1c2UuXG4gICAqL1xuICB2YXJpYW50OiBQcm9wVHlwZXMub25lT2YoWydmaWxsZWQnLCAnb3V0bGluZWQnLCAnc3RhbmRhcmQnXSlcbn0gOiB2b2lkIDA7XG5OYXRpdmVTZWxlY3QubXVpTmFtZSA9ICdTZWxlY3QnO1xuZXhwb3J0IGRlZmF1bHQgd2l0aFN0eWxlcyhzdHlsZXMsIHtcbiAgbmFtZTogJ011aU5hdGl2ZVNlbGVjdCdcbn0pKE5hdGl2ZVNlbGVjdCk7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IG1lcmdlQ2xhc3NlcyB9IGZyb20gJ0BtYXRlcmlhbC11aS9zdHlsZXMnO1xuaW1wb3J0IFNlbGVjdElucHV0IGZyb20gJy4vU2VsZWN0SW5wdXQnO1xuaW1wb3J0IGZvcm1Db250cm9sU3RhdGUgZnJvbSAnLi4vRm9ybUNvbnRyb2wvZm9ybUNvbnRyb2xTdGF0ZSc7XG5pbXBvcnQgdXNlRm9ybUNvbnRyb2wgZnJvbSAnLi4vRm9ybUNvbnRyb2wvdXNlRm9ybUNvbnRyb2wnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IEFycm93RHJvcERvd25JY29uIGZyb20gJy4uL2ludGVybmFsL3N2Zy1pY29ucy9BcnJvd0Ryb3BEb3duJztcbmltcG9ydCBJbnB1dCBmcm9tICcuLi9JbnB1dCc7XG5pbXBvcnQgeyBzdHlsZXMgYXMgbmF0aXZlU2VsZWN0U3R5bGVzIH0gZnJvbSAnLi4vTmF0aXZlU2VsZWN0L05hdGl2ZVNlbGVjdCc7XG5pbXBvcnQgTmF0aXZlU2VsZWN0SW5wdXQgZnJvbSAnLi4vTmF0aXZlU2VsZWN0L05hdGl2ZVNlbGVjdElucHV0JztcbmltcG9ydCBGaWxsZWRJbnB1dCBmcm9tICcuLi9GaWxsZWRJbnB1dCc7XG5pbXBvcnQgT3V0bGluZWRJbnB1dCBmcm9tICcuLi9PdXRsaW5lZElucHV0JztcbmV4cG9ydCB2YXIgc3R5bGVzID0gbmF0aXZlU2VsZWN0U3R5bGVzO1xuXG52YXIgX3JlZiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KElucHV0LCBudWxsKTtcblxudmFyIF9yZWYyID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmlsbGVkSW5wdXQsIG51bGwpO1xuXG52YXIgU2VsZWN0ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gU2VsZWN0KHByb3BzLCByZWYpIHtcbiAgdmFyIF9wcm9wcyRhdXRvV2lkdGggPSBwcm9wcy5hdXRvV2lkdGgsXG4gICAgICBhdXRvV2lkdGggPSBfcHJvcHMkYXV0b1dpZHRoID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRhdXRvV2lkdGgsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBfcHJvcHMkZGlzcGxheUVtcHR5ID0gcHJvcHMuZGlzcGxheUVtcHR5LFxuICAgICAgZGlzcGxheUVtcHR5ID0gX3Byb3BzJGRpc3BsYXlFbXB0eSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZGlzcGxheUVtcHR5LFxuICAgICAgX3Byb3BzJEljb25Db21wb25lbnQgPSBwcm9wcy5JY29uQ29tcG9uZW50LFxuICAgICAgSWNvbkNvbXBvbmVudCA9IF9wcm9wcyRJY29uQ29tcG9uZW50ID09PSB2b2lkIDAgPyBBcnJvd0Ryb3BEb3duSWNvbiA6IF9wcm9wcyRJY29uQ29tcG9uZW50LFxuICAgICAgaWQgPSBwcm9wcy5pZCxcbiAgICAgIGlucHV0ID0gcHJvcHMuaW5wdXQsXG4gICAgICBpbnB1dFByb3BzID0gcHJvcHMuaW5wdXRQcm9wcyxcbiAgICAgIGxhYmVsID0gcHJvcHMubGFiZWwsXG4gICAgICBsYWJlbElkID0gcHJvcHMubGFiZWxJZCxcbiAgICAgIF9wcm9wcyRsYWJlbFdpZHRoID0gcHJvcHMubGFiZWxXaWR0aCxcbiAgICAgIGxhYmVsV2lkdGggPSBfcHJvcHMkbGFiZWxXaWR0aCA9PT0gdm9pZCAwID8gMCA6IF9wcm9wcyRsYWJlbFdpZHRoLFxuICAgICAgTWVudVByb3BzID0gcHJvcHMuTWVudVByb3BzLFxuICAgICAgX3Byb3BzJG11bHRpcGxlID0gcHJvcHMubXVsdGlwbGUsXG4gICAgICBtdWx0aXBsZSA9IF9wcm9wcyRtdWx0aXBsZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkbXVsdGlwbGUsXG4gICAgICBfcHJvcHMkbmF0aXZlID0gcHJvcHMubmF0aXZlLFxuICAgICAgbmF0aXZlID0gX3Byb3BzJG5hdGl2ZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkbmF0aXZlLFxuICAgICAgb25DbG9zZSA9IHByb3BzLm9uQ2xvc2UsXG4gICAgICBvbk9wZW4gPSBwcm9wcy5vbk9wZW4sXG4gICAgICBvcGVuID0gcHJvcHMub3BlbixcbiAgICAgIHJlbmRlclZhbHVlID0gcHJvcHMucmVuZGVyVmFsdWUsXG4gICAgICBTZWxlY3REaXNwbGF5UHJvcHMgPSBwcm9wcy5TZWxlY3REaXNwbGF5UHJvcHMsXG4gICAgICBfcHJvcHMkdmFyaWFudCA9IHByb3BzLnZhcmlhbnQsXG4gICAgICB2YXJpYW50UHJvcHMgPSBfcHJvcHMkdmFyaWFudCA9PT0gdm9pZCAwID8gJ3N0YW5kYXJkJyA6IF9wcm9wcyR2YXJpYW50LFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImF1dG9XaWR0aFwiLCBcImNoaWxkcmVuXCIsIFwiY2xhc3Nlc1wiLCBcImRpc3BsYXlFbXB0eVwiLCBcIkljb25Db21wb25lbnRcIiwgXCJpZFwiLCBcImlucHV0XCIsIFwiaW5wdXRQcm9wc1wiLCBcImxhYmVsXCIsIFwibGFiZWxJZFwiLCBcImxhYmVsV2lkdGhcIiwgXCJNZW51UHJvcHNcIiwgXCJtdWx0aXBsZVwiLCBcIm5hdGl2ZVwiLCBcIm9uQ2xvc2VcIiwgXCJvbk9wZW5cIiwgXCJvcGVuXCIsIFwicmVuZGVyVmFsdWVcIiwgXCJTZWxlY3REaXNwbGF5UHJvcHNcIiwgXCJ2YXJpYW50XCJdKTtcblxuICB2YXIgaW5wdXRDb21wb25lbnQgPSBuYXRpdmUgPyBOYXRpdmVTZWxlY3RJbnB1dCA6IFNlbGVjdElucHV0O1xuICB2YXIgbXVpRm9ybUNvbnRyb2wgPSB1c2VGb3JtQ29udHJvbCgpO1xuICB2YXIgZmNzID0gZm9ybUNvbnRyb2xTdGF0ZSh7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIG11aUZvcm1Db250cm9sOiBtdWlGb3JtQ29udHJvbCxcbiAgICBzdGF0ZXM6IFsndmFyaWFudCddXG4gIH0pO1xuICB2YXIgdmFyaWFudCA9IGZjcy52YXJpYW50IHx8IHZhcmlhbnRQcm9wcztcbiAgdmFyIElucHV0Q29tcG9uZW50ID0gaW5wdXQgfHwge1xuICAgIHN0YW5kYXJkOiBfcmVmLFxuICAgIG91dGxpbmVkOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChPdXRsaW5lZElucHV0LCB7XG4gICAgICBsYWJlbDogbGFiZWwsXG4gICAgICBsYWJlbFdpZHRoOiBsYWJlbFdpZHRoXG4gICAgfSksXG4gICAgZmlsbGVkOiBfcmVmMlxuICB9W3ZhcmlhbnRdO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChJbnB1dENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgIC8vIE1vc3Qgb2YgdGhlIGxvZ2ljIGlzIGltcGxlbWVudGVkIGluIGBTZWxlY3RJbnB1dGAuXG4gICAgLy8gVGhlIGBTZWxlY3RgIGNvbXBvbmVudCBpcyBhIHNpbXBsZSBBUEkgd3JhcHBlciB0byBleHBvc2Ugc29tZXRoaW5nIGJldHRlciB0byBwbGF5IHdpdGguXG4gICAgaW5wdXRDb21wb25lbnQ6IGlucHV0Q29tcG9uZW50LFxuICAgIGlucHV0UHJvcHM6IF9leHRlbmRzKHtcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgIEljb25Db21wb25lbnQ6IEljb25Db21wb25lbnQsXG4gICAgICB2YXJpYW50OiB2YXJpYW50LFxuICAgICAgdHlwZTogdW5kZWZpbmVkLFxuICAgICAgLy8gV2UgcmVuZGVyIGEgc2VsZWN0LiBXZSBjYW4gaWdub3JlIHRoZSB0eXBlIHByb3ZpZGVkIGJ5IHRoZSBgSW5wdXRgLlxuICAgICAgbXVsdGlwbGU6IG11bHRpcGxlXG4gICAgfSwgbmF0aXZlID8ge1xuICAgICAgaWQ6IGlkXG4gICAgfSA6IHtcbiAgICAgIGF1dG9XaWR0aDogYXV0b1dpZHRoLFxuICAgICAgZGlzcGxheUVtcHR5OiBkaXNwbGF5RW1wdHksXG4gICAgICBsYWJlbElkOiBsYWJlbElkLFxuICAgICAgTWVudVByb3BzOiBNZW51UHJvcHMsXG4gICAgICBvbkNsb3NlOiBvbkNsb3NlLFxuICAgICAgb25PcGVuOiBvbk9wZW4sXG4gICAgICBvcGVuOiBvcGVuLFxuICAgICAgcmVuZGVyVmFsdWU6IHJlbmRlclZhbHVlLFxuICAgICAgU2VsZWN0RGlzcGxheVByb3BzOiBfZXh0ZW5kcyh7XG4gICAgICAgIGlkOiBpZFxuICAgICAgfSwgU2VsZWN0RGlzcGxheVByb3BzKVxuICAgIH0sIGlucHV0UHJvcHMsIHtcbiAgICAgIGNsYXNzZXM6IGlucHV0UHJvcHMgPyBtZXJnZUNsYXNzZXMoe1xuICAgICAgICBiYXNlQ2xhc3NlczogY2xhc3NlcyxcbiAgICAgICAgbmV3Q2xhc3NlczogaW5wdXRQcm9wcy5jbGFzc2VzLFxuICAgICAgICBDb21wb25lbnQ6IFNlbGVjdFxuICAgICAgfSkgOiBjbGFzc2VzXG4gICAgfSwgaW5wdXQgPyBpbnB1dC5wcm9wcy5pbnB1dFByb3BzIDoge30pLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFNlbGVjdC5wcm9wVHlwZXMgPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSB3aWR0aCBvZiB0aGUgcG9wb3ZlciB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgc2V0IGFjY29yZGluZyB0byB0aGUgaXRlbXMgaW5zaWRlIHRoZVxuICAgKiBtZW51LCBvdGhlcndpc2UgaXQgd2lsbCBiZSBhdCBsZWFzdCB0aGUgd2lkdGggb2YgdGhlIHNlbGVjdCBpbnB1dC5cbiAgICovXG4gIGF1dG9XaWR0aDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBvcHRpb24gZWxlbWVudHMgdG8gcG9wdWxhdGUgdGhlIHNlbGVjdCB3aXRoLlxuICAgKiBDYW4gYmUgc29tZSBgTWVudUl0ZW1gIHdoZW4gYG5hdGl2ZWAgaXMgZmFsc2UgYW5kIGBvcHRpb25gIHdoZW4gYG5hdGl2ZWAgaXMgdHJ1ZS5cbiAgICpcbiAgICog4pqg77iPVGhlIGBNZW51SXRlbWAgZWxlbWVudHMgKiptdXN0KiogYmUgZGlyZWN0IGRlc2NlbmRhbnRzIHdoZW4gYG5hdGl2ZWAgaXMgZmFsc2UuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgZWxlbWVudCB2YWx1ZS4gVXNlIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBub3QgY29udHJvbGxlZC5cbiAgICovXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLmFueSxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBhIHZhbHVlIGlzIGRpc3BsYXllZCBldmVuIGlmIG5vIGl0ZW1zIGFyZSBzZWxlY3RlZC5cbiAgICpcbiAgICogSW4gb3JkZXIgdG8gZGlzcGxheSBhIG1lYW5pbmdmdWwgdmFsdWUsIGEgZnVuY3Rpb24gc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgYHJlbmRlclZhbHVlYCBwcm9wIHdoaWNoIHJldHVybnMgdGhlIHZhbHVlIHRvIGJlIGRpc3BsYXllZCB3aGVuIG5vIGl0ZW1zIGFyZSBzZWxlY3RlZC5cbiAgICogWW91IGNhbiBvbmx5IHVzZSBpdCB3aGVuIHRoZSBgbmF0aXZlYCBwcm9wIGlzIGBmYWxzZWAgKGRlZmF1bHQpLlxuICAgKi9cbiAgZGlzcGxheUVtcHR5OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGljb24gdGhhdCBkaXNwbGF5cyB0aGUgYXJyb3cuXG4gICAqL1xuICBJY29uQ29tcG9uZW50OiBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG5cbiAgLyoqXG4gICAqIFRoZSBgaWRgIG9mIHRoZSB3cmFwcGVyIGVsZW1lbnQgb3IgdGhlIGBzZWxlY3RgIGVsZW1lbnQgd2hlbiBgbmF0aXZlYC5cbiAgICovXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBBbiBgSW5wdXRgIGVsZW1lbnQ7IGRvZXMgbm90IGhhdmUgdG8gYmUgYSBtYXRlcmlhbC11aSBzcGVjaWZpYyBgSW5wdXRgLlxuICAgKi9cbiAgaW5wdXQ6IFByb3BUeXBlcy5lbGVtZW50LFxuXG4gIC8qKlxuICAgKiBbQXR0cmlidXRlc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0I0F0dHJpYnV0ZXMpIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICogV2hlbiBgbmF0aXZlYCBpcyBgdHJ1ZWAsIHRoZSBhdHRyaWJ1dGVzIGFyZSBhcHBsaWVkIG9uIHRoZSBgc2VsZWN0YCBlbGVtZW50LlxuICAgKi9cbiAgaW5wdXRQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogU2VlIFtPdXRsaW5lZElucHV0I2xhYmVsXSgvYXBpL291dGxpbmVkLWlucHV0LyNwcm9wcylcbiAgICovXG4gIGxhYmVsOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogVGhlIElEIG9mIGFuIGVsZW1lbnQgdGhhdCBhY3RzIGFzIGFuIGFkZGl0aW9uYWwgbGFiZWwuIFRoZSBTZWxlY3Qgd2lsbFxuICAgKiBiZSBsYWJlbGxlZCBieSB0aGUgYWRkaXRpb25hbCBsYWJlbCBhbmQgdGhlIHNlbGVjdGVkIHZhbHVlLlxuICAgKi9cbiAgbGFiZWxJZDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogU2VlIFtPdXRsaW5lZElucHV0I2xhYmVsXSgvYXBpL291dGxpbmVkLWlucHV0LyNwcm9wcylcbiAgICovXG4gIGxhYmVsV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIFByb3BzIGFwcGxpZWQgdG8gdGhlIFtgTWVudWBdKC9hcGkvbWVudS8pIGVsZW1lbnQuXG4gICAqL1xuICBNZW51UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgYHZhbHVlYCBtdXN0IGJlIGFuIGFycmF5IGFuZCB0aGUgbWVudSB3aWxsIHN1cHBvcnQgbXVsdGlwbGUgc2VsZWN0aW9ucy5cbiAgICovXG4gIG11bHRpcGxlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY29tcG9uZW50IHdpbGwgYmUgdXNpbmcgYSBuYXRpdmUgYHNlbGVjdGAgZWxlbWVudC5cbiAgICovXG4gIG5hdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIGZpcmVkIHdoZW4gYSBtZW51IGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgZXZlbnQgc291cmNlIG9mIHRoZSBjYWxsYmFjay5cbiAgICogWW91IGNhbiBwdWxsIG91dCB0aGUgbmV3IHZhbHVlIGJ5IGFjY2Vzc2luZyBgZXZlbnQudGFyZ2V0LnZhbHVlYCAoYW55KS5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtjaGlsZF0gVGhlIHJlYWN0IGVsZW1lbnQgdGhhdCB3YXMgc2VsZWN0ZWQgd2hlbiBgbmF0aXZlYCBpcyBgZmFsc2VgIChkZWZhdWx0KS5cbiAgICovXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IHJlcXVlc3RzIHRvIGJlIGNsb3NlZC5cbiAgICogVXNlIGluIGNvbnRyb2xsZWQgbW9kZSAoc2VlIG9wZW4pLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqL1xuICBvbkNsb3NlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IHJlcXVlc3RzIHRvIGJlIG9wZW5lZC5cbiAgICogVXNlIGluIGNvbnRyb2xsZWQgbW9kZSAoc2VlIG9wZW4pLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqL1xuICBvbk9wZW46IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDb250cm9sIGBzZWxlY3RgIG9wZW4gc3RhdGUuXG4gICAqIFlvdSBjYW4gb25seSB1c2UgaXQgd2hlbiB0aGUgYG5hdGl2ZWAgcHJvcCBpcyBgZmFsc2VgIChkZWZhdWx0KS5cbiAgICovXG4gIG9wZW46IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIHNlbGVjdGVkIHZhbHVlLlxuICAgKiBZb3UgY2FuIG9ubHkgdXNlIGl0IHdoZW4gdGhlIGBuYXRpdmVgIHByb3AgaXMgYGZhbHNlYCAoZGVmYXVsdCkuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgYHZhbHVlYCBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBAcmV0dXJucyB7UmVhY3ROb2RlfVxuICAgKi9cbiAgcmVuZGVyVmFsdWU6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBQcm9wcyBhcHBsaWVkIHRvIHRoZSBjbGlja2FibGUgZGl2IGVsZW1lbnQuXG4gICAqL1xuICBTZWxlY3REaXNwbGF5UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCB2YWx1ZS4gUHJvdmlkaW5nIGFuIGVtcHR5IHN0cmluZyB3aWxsIHNlbGVjdCBubyBvcHRpb25zLlxuICAgKiBUaGlzIHByb3AgaXMgcmVxdWlyZWQgd2hlbiB0aGUgYG5hdGl2ZWAgcHJvcCBpcyBgZmFsc2VgIChkZWZhdWx0KS5cbiAgICogU2V0IHRvIGFuIGVtcHR5IHN0cmluZyBgJydgIGlmIHlvdSBkb24ndCB3YW50IGFueSBvZiB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgdG8gYmUgc2VsZWN0ZWQuXG4gICAqXG4gICAqIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QgaXQgbXVzdCBoYXZlIHJlZmVyZW5jZSBlcXVhbGl0eSB3aXRoIHRoZSBvcHRpb24gaW4gb3JkZXIgdG8gYmUgc2VsZWN0ZWQuXG4gICAqIElmIHRoZSB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0LCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG11c3QgbWF0Y2ggd2l0aCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvcHRpb24gaW4gb3JkZXIgdG8gYmUgc2VsZWN0ZWQuXG4gICAqL1xuICB2YWx1ZTogUHJvcFR5cGVzLmFueSxcblxuICAvKipcbiAgICogVGhlIHZhcmlhbnQgdG8gdXNlLlxuICAgKi9cbiAgdmFyaWFudDogUHJvcFR5cGVzLm9uZU9mKFsnZmlsbGVkJywgJ291dGxpbmVkJywgJ3N0YW5kYXJkJ10pXG59IDogdm9pZCAwO1xuU2VsZWN0Lm11aU5hbWUgPSAnU2VsZWN0JztcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdNdWlTZWxlY3QnXG59KShTZWxlY3QpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IHJlZlR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IElucHV0IGZyb20gJy4uL0lucHV0JztcbmltcG9ydCBGaWxsZWRJbnB1dCBmcm9tICcuLi9GaWxsZWRJbnB1dCc7XG5pbXBvcnQgT3V0bGluZWRJbnB1dCBmcm9tICcuLi9PdXRsaW5lZElucHV0JztcbmltcG9ydCBJbnB1dExhYmVsIGZyb20gJy4uL0lucHV0TGFiZWwnO1xuaW1wb3J0IEZvcm1Db250cm9sIGZyb20gJy4uL0Zvcm1Db250cm9sJztcbmltcG9ydCBGb3JtSGVscGVyVGV4dCBmcm9tICcuLi9Gb3JtSGVscGVyVGV4dCc7XG5pbXBvcnQgU2VsZWN0IGZyb20gJy4uL1NlbGVjdCc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG52YXIgdmFyaWFudENvbXBvbmVudCA9IHtcbiAgc3RhbmRhcmQ6IElucHV0LFxuICBmaWxsZWQ6IEZpbGxlZElucHV0LFxuICBvdXRsaW5lZDogT3V0bGluZWRJbnB1dFxufTtcbmV4cG9ydCB2YXIgc3R5bGVzID0ge1xuICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50LiAqL1xuICByb290OiB7fVxufTtcbi8qKlxuICogVGhlIGBUZXh0RmllbGRgIGlzIGEgY29udmVuaWVuY2Ugd3JhcHBlciBmb3IgdGhlIG1vc3QgY29tbW9uIGNhc2VzICg4MCUpLlxuICogSXQgY2Fubm90IGJlIGFsbCB0aGluZ3MgdG8gYWxsIHBlb3BsZSwgb3RoZXJ3aXNlIHRoZSBBUEkgd291bGQgZ3JvdyBvdXQgb2YgY29udHJvbC5cbiAqXG4gKiAjIyBBZHZhbmNlZCBDb25maWd1cmF0aW9uXG4gKlxuICogSXQncyBpbXBvcnRhbnQgdG8gdW5kZXJzdGFuZCB0aGF0IHRoZSB0ZXh0IGZpZWxkIGlzIGEgc2ltcGxlIGFic3RyYWN0aW9uXG4gKiBvbiB0b3Agb2YgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOlxuICpcbiAqIC0gW0Zvcm1Db250cm9sXSgvYXBpL2Zvcm0tY29udHJvbC8pXG4gKiAtIFtJbnB1dExhYmVsXSgvYXBpL2lucHV0LWxhYmVsLylcbiAqIC0gW0ZpbGxlZElucHV0XSgvYXBpL2ZpbGxlZC1pbnB1dC8pXG4gKiAtIFtPdXRsaW5lZElucHV0XSgvYXBpL291dGxpbmVkLWlucHV0LylcbiAqIC0gW0lucHV0XSgvYXBpL2lucHV0LylcbiAqIC0gW0Zvcm1IZWxwZXJUZXh0XSgvYXBpL2Zvcm0taGVscGVyLXRleHQvKVxuICpcbiAqIElmIHlvdSB3aXNoIHRvIGFsdGVyIHRoZSBwcm9wcyBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQsIHlvdSBjYW4gZG8gc28gYXMgZm9sbG93czpcbiAqXG4gKiBgYGBqc3hcbiAqIGNvbnN0IGlucHV0UHJvcHMgPSB7XG4gKiAgIHN0ZXA6IDMwMCxcbiAqIH07XG4gKlxuICogcmV0dXJuIDxUZXh0RmllbGQgaWQ9XCJ0aW1lXCIgdHlwZT1cInRpbWVcIiBpbnB1dFByb3BzPXtpbnB1dFByb3BzfSAvPjtcbiAqIGBgYFxuICpcbiAqIEZvciBhZHZhbmNlZCBjYXNlcywgcGxlYXNlIGxvb2sgYXQgdGhlIHNvdXJjZSBvZiBUZXh0RmllbGQgYnkgY2xpY2tpbmcgb24gdGhlXG4gKiBcIkVkaXQgdGhpcyBwYWdlXCIgYnV0dG9uIGFib3ZlLiBDb25zaWRlciBlaXRoZXI6XG4gKlxuICogLSB1c2luZyB0aGUgdXBwZXIgY2FzZSBwcm9wcyBmb3IgcGFzc2luZyB2YWx1ZXMgZGlyZWN0bHkgdG8gdGhlIGNvbXBvbmVudHNcbiAqIC0gdXNpbmcgdGhlIHVuZGVybHlpbmcgY29tcG9uZW50cyBkaXJlY3RseSBhcyBzaG93biBpbiB0aGUgZGVtb3NcbiAqL1xuXG52YXIgVGV4dEZpZWxkID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gVGV4dEZpZWxkKHByb3BzLCByZWYpIHtcbiAgdmFyIGF1dG9Db21wbGV0ZSA9IHByb3BzLmF1dG9Db21wbGV0ZSxcbiAgICAgIF9wcm9wcyRhdXRvRm9jdXMgPSBwcm9wcy5hdXRvRm9jdXMsXG4gICAgICBhdXRvRm9jdXMgPSBfcHJvcHMkYXV0b0ZvY3VzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRhdXRvRm9jdXMsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NlcyA9IHByb3BzLmNsYXNzZXMsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBfcHJvcHMkY29sb3IgPSBwcm9wcy5jb2xvcixcbiAgICAgIGNvbG9yID0gX3Byb3BzJGNvbG9yID09PSB2b2lkIDAgPyAncHJpbWFyeScgOiBfcHJvcHMkY29sb3IsXG4gICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICBfcHJvcHMkZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGRpc2FibGVkID0gX3Byb3BzJGRpc2FibGVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRkaXNhYmxlZCxcbiAgICAgIF9wcm9wcyRlcnJvciA9IHByb3BzLmVycm9yLFxuICAgICAgZXJyb3IgPSBfcHJvcHMkZXJyb3IgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGVycm9yLFxuICAgICAgRm9ybUhlbHBlclRleHRQcm9wcyA9IHByb3BzLkZvcm1IZWxwZXJUZXh0UHJvcHMsXG4gICAgICBfcHJvcHMkZnVsbFdpZHRoID0gcHJvcHMuZnVsbFdpZHRoLFxuICAgICAgZnVsbFdpZHRoID0gX3Byb3BzJGZ1bGxXaWR0aCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZnVsbFdpZHRoLFxuICAgICAgaGVscGVyVGV4dCA9IHByb3BzLmhlbHBlclRleHQsXG4gICAgICBoaWRkZW5MYWJlbCA9IHByb3BzLmhpZGRlbkxhYmVsLFxuICAgICAgaWQgPSBwcm9wcy5pZCxcbiAgICAgIElucHV0TGFiZWxQcm9wcyA9IHByb3BzLklucHV0TGFiZWxQcm9wcyxcbiAgICAgIGlucHV0UHJvcHMgPSBwcm9wcy5pbnB1dFByb3BzLFxuICAgICAgSW5wdXRQcm9wcyA9IHByb3BzLklucHV0UHJvcHMsXG4gICAgICBpbnB1dFJlZiA9IHByb3BzLmlucHV0UmVmLFxuICAgICAgbGFiZWwgPSBwcm9wcy5sYWJlbCxcbiAgICAgIF9wcm9wcyRtdWx0aWxpbmUgPSBwcm9wcy5tdWx0aWxpbmUsXG4gICAgICBtdWx0aWxpbmUgPSBfcHJvcHMkbXVsdGlsaW5lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRtdWx0aWxpbmUsXG4gICAgICBuYW1lID0gcHJvcHMubmFtZSxcbiAgICAgIG9uQmx1ciA9IHByb3BzLm9uQmx1cixcbiAgICAgIG9uQ2hhbmdlID0gcHJvcHMub25DaGFuZ2UsXG4gICAgICBvbkZvY3VzID0gcHJvcHMub25Gb2N1cyxcbiAgICAgIHBsYWNlaG9sZGVyID0gcHJvcHMucGxhY2Vob2xkZXIsXG4gICAgICBfcHJvcHMkcmVxdWlyZWQgPSBwcm9wcy5yZXF1aXJlZCxcbiAgICAgIHJlcXVpcmVkID0gX3Byb3BzJHJlcXVpcmVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRyZXF1aXJlZCxcbiAgICAgIHJvd3MgPSBwcm9wcy5yb3dzLFxuICAgICAgcm93c01heCA9IHByb3BzLnJvd3NNYXgsXG4gICAgICBtYXhSb3dzID0gcHJvcHMubWF4Um93cyxcbiAgICAgIG1pblJvd3MgPSBwcm9wcy5taW5Sb3dzLFxuICAgICAgX3Byb3BzJHNlbGVjdCA9IHByb3BzLnNlbGVjdCxcbiAgICAgIHNlbGVjdCA9IF9wcm9wcyRzZWxlY3QgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJHNlbGVjdCxcbiAgICAgIFNlbGVjdFByb3BzID0gcHJvcHMuU2VsZWN0UHJvcHMsXG4gICAgICB0eXBlID0gcHJvcHMudHlwZSxcbiAgICAgIHZhbHVlID0gcHJvcHMudmFsdWUsXG4gICAgICBfcHJvcHMkdmFyaWFudCA9IHByb3BzLnZhcmlhbnQsXG4gICAgICB2YXJpYW50ID0gX3Byb3BzJHZhcmlhbnQgPT09IHZvaWQgMCA/ICdzdGFuZGFyZCcgOiBfcHJvcHMkdmFyaWFudCxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJhdXRvQ29tcGxldGVcIiwgXCJhdXRvRm9jdXNcIiwgXCJjaGlsZHJlblwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJjb2xvclwiLCBcImRlZmF1bHRWYWx1ZVwiLCBcImRpc2FibGVkXCIsIFwiZXJyb3JcIiwgXCJGb3JtSGVscGVyVGV4dFByb3BzXCIsIFwiZnVsbFdpZHRoXCIsIFwiaGVscGVyVGV4dFwiLCBcImhpZGRlbkxhYmVsXCIsIFwiaWRcIiwgXCJJbnB1dExhYmVsUHJvcHNcIiwgXCJpbnB1dFByb3BzXCIsIFwiSW5wdXRQcm9wc1wiLCBcImlucHV0UmVmXCIsIFwibGFiZWxcIiwgXCJtdWx0aWxpbmVcIiwgXCJuYW1lXCIsIFwib25CbHVyXCIsIFwib25DaGFuZ2VcIiwgXCJvbkZvY3VzXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJyZXF1aXJlZFwiLCBcInJvd3NcIiwgXCJyb3dzTWF4XCIsIFwibWF4Um93c1wiLCBcIm1pblJvd3NcIiwgXCJzZWxlY3RcIiwgXCJTZWxlY3RQcm9wc1wiLCBcInR5cGVcIiwgXCJ2YWx1ZVwiLCBcInZhcmlhbnRcIl0pO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHNlbGVjdCAmJiAhY2hpbGRyZW4pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01hdGVyaWFsLVVJOiBgY2hpbGRyZW5gIG11c3QgYmUgcGFzc2VkIHdoZW4gdXNpbmcgdGhlIGBUZXh0RmllbGRgIGNvbXBvbmVudCB3aXRoIGBzZWxlY3RgLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBJbnB1dE1vcmUgPSB7fTtcblxuICBpZiAodmFyaWFudCA9PT0gJ291dGxpbmVkJykge1xuICAgIGlmIChJbnB1dExhYmVsUHJvcHMgJiYgdHlwZW9mIElucHV0TGFiZWxQcm9wcy5zaHJpbmsgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBJbnB1dE1vcmUubm90Y2hlZCA9IElucHV0TGFiZWxQcm9wcy5zaHJpbms7XG4gICAgfVxuXG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICB2YXIgX0lucHV0TGFiZWxQcm9wcyRyZXF1O1xuXG4gICAgICB2YXIgZGlzcGxheVJlcXVpcmVkID0gKF9JbnB1dExhYmVsUHJvcHMkcmVxdSA9IElucHV0TGFiZWxQcm9wcyA9PT0gbnVsbCB8fCBJbnB1dExhYmVsUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IElucHV0TGFiZWxQcm9wcy5yZXF1aXJlZCkgIT09IG51bGwgJiYgX0lucHV0TGFiZWxQcm9wcyRyZXF1ICE9PSB2b2lkIDAgPyBfSW5wdXRMYWJlbFByb3BzJHJlcXUgOiByZXF1aXJlZDtcbiAgICAgIElucHV0TW9yZS5sYWJlbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBsYWJlbCwgZGlzcGxheVJlcXVpcmVkICYmIFwiXFx4QTAqXCIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZWxlY3QpIHtcbiAgICAvLyB1bnNldCBkZWZhdWx0cyBmcm9tIHRleHRib3ggaW5wdXRzXG4gICAgaWYgKCFTZWxlY3RQcm9wcyB8fCAhU2VsZWN0UHJvcHMubmF0aXZlKSB7XG4gICAgICBJbnB1dE1vcmUuaWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgSW5wdXRNb3JlWydhcmlhLWRlc2NyaWJlZGJ5J10gPSB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgaGVscGVyVGV4dElkID0gaGVscGVyVGV4dCAmJiBpZCA/IFwiXCIuY29uY2F0KGlkLCBcIi1oZWxwZXItdGV4dFwiKSA6IHVuZGVmaW5lZDtcbiAgdmFyIGlucHV0TGFiZWxJZCA9IGxhYmVsICYmIGlkID8gXCJcIi5jb25jYXQoaWQsIFwiLWxhYmVsXCIpIDogdW5kZWZpbmVkO1xuICB2YXIgSW5wdXRDb21wb25lbnQgPSB2YXJpYW50Q29tcG9uZW50W3ZhcmlhbnRdO1xuICB2YXIgSW5wdXRFbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXRDb21wb25lbnQsIF9leHRlbmRzKHtcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogaGVscGVyVGV4dElkLFxuICAgIGF1dG9Db21wbGV0ZTogYXV0b0NvbXBsZXRlLFxuICAgIGF1dG9Gb2N1czogYXV0b0ZvY3VzLFxuICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIGZ1bGxXaWR0aDogZnVsbFdpZHRoLFxuICAgIG11bHRpbGluZTogbXVsdGlsaW5lLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcm93czogcm93cyxcbiAgICByb3dzTWF4OiByb3dzTWF4LFxuICAgIG1heFJvd3M6IG1heFJvd3MsXG4gICAgbWluUm93czogbWluUm93cyxcbiAgICB0eXBlOiB0eXBlLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBpZDogaWQsXG4gICAgaW5wdXRSZWY6IGlucHV0UmVmLFxuICAgIG9uQmx1cjogb25CbHVyLFxuICAgIG9uQ2hhbmdlOiBvbkNoYW5nZSxcbiAgICBvbkZvY3VzOiBvbkZvY3VzLFxuICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICBpbnB1dFByb3BzOiBpbnB1dFByb3BzXG4gIH0sIElucHV0TW9yZSwgSW5wdXRQcm9wcykpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybUNvbnRyb2wsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2xhc3Nlcy5yb290LCBjbGFzc05hbWUpLFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICBlcnJvcjogZXJyb3IsXG4gICAgZnVsbFdpZHRoOiBmdWxsV2lkdGgsXG4gICAgaGlkZGVuTGFiZWw6IGhpZGRlbkxhYmVsLFxuICAgIHJlZjogcmVmLFxuICAgIHJlcXVpcmVkOiByZXF1aXJlZCxcbiAgICBjb2xvcjogY29sb3IsXG4gICAgdmFyaWFudDogdmFyaWFudFxuICB9LCBvdGhlciksIGxhYmVsICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KElucHV0TGFiZWwsIF9leHRlbmRzKHtcbiAgICBodG1sRm9yOiBpZCxcbiAgICBpZDogaW5wdXRMYWJlbElkXG4gIH0sIElucHV0TGFiZWxQcm9wcyksIGxhYmVsKSwgc2VsZWN0ID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU2VsZWN0LCBfZXh0ZW5kcyh7XG4gICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGhlbHBlclRleHRJZCxcbiAgICBpZDogaWQsXG4gICAgbGFiZWxJZDogaW5wdXRMYWJlbElkLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBpbnB1dDogSW5wdXRFbGVtZW50XG4gIH0sIFNlbGVjdFByb3BzKSwgY2hpbGRyZW4pIDogSW5wdXRFbGVtZW50LCBoZWxwZXJUZXh0ICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1IZWxwZXJUZXh0LCBfZXh0ZW5kcyh7XG4gICAgaWQ6IGhlbHBlclRleHRJZFxuICB9LCBGb3JtSGVscGVyVGV4dFByb3BzKSwgaGVscGVyVGV4dCkpO1xufSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBUZXh0RmllbGQucHJvcFR5cGVzID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogVGhpcyBwcm9wIGhlbHBzIHVzZXJzIHRvIGZpbGwgZm9ybXMgZmFzdGVyLCBlc3BlY2lhbGx5IG9uIG1vYmlsZSBkZXZpY2VzLlxuICAgKiBUaGUgbmFtZSBjYW4gYmUgY29uZnVzaW5nLCBhcyBpdCdzIG1vcmUgbGlrZSBhbiBhdXRvZmlsbC5cbiAgICogWW91IGNhbiBsZWFybiBtb3JlIGFib3V0IGl0IFtmb2xsb3dpbmcgdGhlIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI2F1dG9maWxsKS5cbiAgICovXG4gIGF1dG9Db21wbGV0ZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgYGlucHV0YCBlbGVtZW50IHdpbGwgYmUgZm9jdXNlZCBkdXJpbmcgdGhlIGZpcnN0IG1vdW50LlxuICAgKi9cbiAgYXV0b0ZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBvciBleHRlbmQgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIFNlZSBbQ1NTIEFQSV0oI2NzcykgYmVsb3cgZm9yIG1vcmUgZGV0YWlscy5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIHRob3NlIHRoZW1lIGNvbG9ycyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLFxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMuYW55LFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBgaW5wdXRgIGVsZW1lbnQgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbGFiZWwgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gYW4gZXJyb3Igc3RhdGUuXG4gICAqL1xuICBlcnJvcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFByb3BzIGFwcGxpZWQgdG8gdGhlIFtgRm9ybUhlbHBlclRleHRgXSgvYXBpL2Zvcm0taGVscGVyLXRleHQvKSBlbGVtZW50LlxuICAgKi9cbiAgRm9ybUhlbHBlclRleHRQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgaW5wdXQgd2lsbCB0YWtlIHVwIHRoZSBmdWxsIHdpZHRoIG9mIGl0cyBjb250YWluZXIuXG4gICAqL1xuICBmdWxsV2lkdGg6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgaGVscGVyIHRleHQgY29udGVudC5cbiAgICovXG4gIGhlbHBlclRleHQ6IFByb3BUeXBlcy5ub2RlLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBoaWRkZW5MYWJlbDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBpZCBvZiB0aGUgYGlucHV0YCBlbGVtZW50LlxuICAgKiBVc2UgdGhpcyBwcm9wIHRvIG1ha2UgYGxhYmVsYCBhbmQgYGhlbHBlclRleHRgIGFjY2Vzc2libGUgZm9yIHNjcmVlbiByZWFkZXJzLlxuICAgKi9cbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFByb3BzIGFwcGxpZWQgdG8gdGhlIFtgSW5wdXRMYWJlbGBdKC9hcGkvaW5wdXQtbGFiZWwvKSBlbGVtZW50LlxuICAgKi9cbiAgSW5wdXRMYWJlbFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBbQXR0cmlidXRlc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0I0F0dHJpYnV0ZXMpIGFwcGxpZWQgdG8gdGhlIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIGlucHV0UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG5cbiAgLyoqXG4gICAqIFByb3BzIGFwcGxpZWQgdG8gdGhlIElucHV0IGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgYmUgYSBbYEZpbGxlZElucHV0YF0oL2FwaS9maWxsZWQtaW5wdXQvKSxcbiAgICogW2BPdXRsaW5lZElucHV0YF0oL2FwaS9vdXRsaW5lZC1pbnB1dC8pIG9yIFtgSW5wdXRgXSgvYXBpL2lucHV0LylcbiAgICogY29tcG9uZW50IGRlcGVuZGluZyBvbiB0aGUgYHZhcmlhbnRgIHByb3AgdmFsdWUuXG4gICAqL1xuICBJbnB1dFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBQYXNzIGEgcmVmIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFJlZjogcmVmVHlwZSxcblxuICAvKipcbiAgICogVGhlIGxhYmVsIGNvbnRlbnQuXG4gICAqL1xuICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIElmIGBkZW5zZWAgb3IgYG5vcm1hbGAsIHdpbGwgYWRqdXN0IHZlcnRpY2FsIHNwYWNpbmcgb2YgdGhpcyBhbmQgY29udGFpbmVkIGNvbXBvbmVudHMuXG4gICAqL1xuICBtYXJnaW46IFByb3BUeXBlcy5vbmVPZihbJ2RlbnNlJywgJ25vbmUnLCAnbm9ybWFsJ10pLFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgd2hlbiBtdWx0aWxpbmUgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgKi9cbiAgbWF4Um93czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBNaW5pbXVtIG51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkuXG4gICAqL1xuICBtaW5Sb3dzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgYSB0ZXh0YXJlYSBlbGVtZW50IHdpbGwgYmUgcmVuZGVyZWQgaW5zdGVhZCBvZiBhbiBpbnB1dC5cbiAgICovXG4gIG11bHRpbGluZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE5hbWUgYXR0cmlidXRlIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqIFlvdSBjYW4gcHVsbCBvdXQgdGhlIG5ldyB2YWx1ZSBieSBhY2Nlc3NpbmcgYGV2ZW50LnRhcmdldC52YWx1ZWAgKHN0cmluZykuXG4gICAqL1xuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBUaGUgc2hvcnQgaGludCBkaXNwbGF5ZWQgaW4gdGhlIGlucHV0IGJlZm9yZSB0aGUgdXNlciBlbnRlcnMgYSB2YWx1ZS5cbiAgICovXG4gIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBsYWJlbCBpcyBkaXNwbGF5ZWQgYXMgcmVxdWlyZWQgYW5kIHRoZSBgaW5wdXRgIGVsZW1lbnRgIHdpbGwgYmUgcmVxdWlyZWQuXG4gICAqL1xuICByZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgd2hlbiBtdWx0aWxpbmUgb3B0aW9uIGlzIHNldCB0byB0cnVlLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYG1pblJvd3NgIGluc3RlYWQuXG4gICAqL1xuICByb3dzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG5cbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBtYXhSb3dzYCBpbnN0ZWFkLlxuICAgKi9cbiAgcm93c01heDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBbYFNlbGVjdGBdKC9hcGkvc2VsZWN0LykgZWxlbWVudCB3aGlsZSBwYXNzaW5nIHRoZSBJbnB1dCBlbGVtZW50IHRvIGBTZWxlY3RgIGFzIGBpbnB1dGAgcGFyYW1ldGVyLlxuICAgKiBJZiB0aGlzIG9wdGlvbiBpcyBzZXQgeW91IG11c3QgcGFzcyB0aGUgb3B0aW9ucyBvZiB0aGUgc2VsZWN0IGFzIGNoaWxkcmVuLlxuICAgKi9cbiAgc2VsZWN0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogUHJvcHMgYXBwbGllZCB0byB0aGUgW2BTZWxlY3RgXSgvYXBpL3NlbGVjdC8pIGVsZW1lbnQuXG4gICAqL1xuICBTZWxlY3RQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIHRleHQgZmllbGQuXG4gICAqL1xuICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydtZWRpdW0nLCAnc21hbGwnXSksXG5cbiAgLyoqXG4gICAqIFR5cGUgb2YgdGhlIGBpbnB1dGAgZWxlbWVudC4gSXQgc2hvdWxkIGJlIFthIHZhbGlkIEhUTUw1IGlucHV0IHR5cGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNGb3JtXyUzQ2lucHV0JTNFX3R5cGVzKS5cbiAgICovXG4gIHR5cGU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgYGlucHV0YCBlbGVtZW50LCByZXF1aXJlZCBmb3IgYSBjb250cm9sbGVkIGNvbXBvbmVudC5cbiAgICovXG4gIHZhbHVlOiBQcm9wVHlwZXMuYW55LFxuXG4gIC8qKlxuICAgKiBUaGUgdmFyaWFudCB0byB1c2UuXG4gICAqL1xuICB2YXJpYW50OiBQcm9wVHlwZXMub25lT2YoWydmaWxsZWQnLCAnb3V0bGluZWQnLCAnc3RhbmRhcmQnXSlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpVGV4dEZpZWxkJ1xufSkoVGV4dEZpZWxkKTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IHJlZlR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IHVzZUNvbnRyb2xsZWQgZnJvbSAnLi4vdXRpbHMvdXNlQ29udHJvbGxlZCc7XG5pbXBvcnQgdXNlRm9ybUNvbnRyb2wgZnJvbSAnLi4vRm9ybUNvbnRyb2wvdXNlRm9ybUNvbnRyb2wnO1xuaW1wb3J0IHdpdGhTdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3dpdGhTdHlsZXMnO1xuaW1wb3J0IEljb25CdXR0b24gZnJvbSAnLi4vSWNvbkJ1dHRvbic7XG5leHBvcnQgdmFyIHN0eWxlcyA9IHtcbiAgcm9vdDoge1xuICAgIHBhZGRpbmc6IDlcbiAgfSxcbiAgY2hlY2tlZDoge30sXG4gIGRpc2FibGVkOiB7fSxcbiAgaW5wdXQ6IHtcbiAgICBjdXJzb3I6ICdpbmhlcml0JyxcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBvcGFjaXR5OiAwLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgbWFyZ2luOiAwLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgekluZGV4OiAxXG4gIH1cbn07XG4vKipcbiAqIEBpZ25vcmUgLSBpbnRlcm5hbCBjb21wb25lbnQuXG4gKi9cblxudmFyIFN3aXRjaEJhc2UgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBTd2l0Y2hCYXNlKHByb3BzLCByZWYpIHtcbiAgdmFyIGF1dG9Gb2N1cyA9IHByb3BzLmF1dG9Gb2N1cyxcbiAgICAgIGNoZWNrZWRQcm9wID0gcHJvcHMuY2hlY2tlZCxcbiAgICAgIGNoZWNrZWRJY29uID0gcHJvcHMuY2hlY2tlZEljb24sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGRlZmF1bHRDaGVja2VkID0gcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgICBkaXNhYmxlZFByb3AgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGljb24gPSBwcm9wcy5pY29uLFxuICAgICAgaWQgPSBwcm9wcy5pZCxcbiAgICAgIGlucHV0UHJvcHMgPSBwcm9wcy5pbnB1dFByb3BzLFxuICAgICAgaW5wdXRSZWYgPSBwcm9wcy5pbnB1dFJlZixcbiAgICAgIG5hbWUgPSBwcm9wcy5uYW1lLFxuICAgICAgb25CbHVyID0gcHJvcHMub25CbHVyLFxuICAgICAgb25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZSxcbiAgICAgIG9uRm9jdXMgPSBwcm9wcy5vbkZvY3VzLFxuICAgICAgcmVhZE9ubHkgPSBwcm9wcy5yZWFkT25seSxcbiAgICAgIHJlcXVpcmVkID0gcHJvcHMucmVxdWlyZWQsXG4gICAgICB0YWJJbmRleCA9IHByb3BzLnRhYkluZGV4LFxuICAgICAgdHlwZSA9IHByb3BzLnR5cGUsXG4gICAgICB2YWx1ZSA9IHByb3BzLnZhbHVlLFxuICAgICAgb3RoZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImF1dG9Gb2N1c1wiLCBcImNoZWNrZWRcIiwgXCJjaGVja2VkSWNvblwiLCBcImNsYXNzZXNcIiwgXCJjbGFzc05hbWVcIiwgXCJkZWZhdWx0Q2hlY2tlZFwiLCBcImRpc2FibGVkXCIsIFwiaWNvblwiLCBcImlkXCIsIFwiaW5wdXRQcm9wc1wiLCBcImlucHV0UmVmXCIsIFwibmFtZVwiLCBcIm9uQmx1clwiLCBcIm9uQ2hhbmdlXCIsIFwib25Gb2N1c1wiLCBcInJlYWRPbmx5XCIsIFwicmVxdWlyZWRcIiwgXCJ0YWJJbmRleFwiLCBcInR5cGVcIiwgXCJ2YWx1ZVwiXSk7XG5cbiAgdmFyIF91c2VDb250cm9sbGVkID0gdXNlQ29udHJvbGxlZCh7XG4gICAgY29udHJvbGxlZDogY2hlY2tlZFByb3AsXG4gICAgZGVmYXVsdDogQm9vbGVhbihkZWZhdWx0Q2hlY2tlZCksXG4gICAgbmFtZTogJ1N3aXRjaEJhc2UnLFxuICAgIHN0YXRlOiAnY2hlY2tlZCdcbiAgfSksXG4gICAgICBfdXNlQ29udHJvbGxlZDIgPSBfc2xpY2VkVG9BcnJheShfdXNlQ29udHJvbGxlZCwgMiksXG4gICAgICBjaGVja2VkID0gX3VzZUNvbnRyb2xsZWQyWzBdLFxuICAgICAgc2V0Q2hlY2tlZFN0YXRlID0gX3VzZUNvbnRyb2xsZWQyWzFdO1xuXG4gIHZhciBtdWlGb3JtQ29udHJvbCA9IHVzZUZvcm1Db250cm9sKCk7XG5cbiAgdmFyIGhhbmRsZUZvY3VzID0gZnVuY3Rpb24gaGFuZGxlRm9jdXMoZXZlbnQpIHtcbiAgICBpZiAob25Gb2N1cykge1xuICAgICAgb25Gb2N1cyhldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKG11aUZvcm1Db250cm9sICYmIG11aUZvcm1Db250cm9sLm9uRm9jdXMpIHtcbiAgICAgIG11aUZvcm1Db250cm9sLm9uRm9jdXMoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlQmx1ciA9IGZ1bmN0aW9uIGhhbmRsZUJsdXIoZXZlbnQpIHtcbiAgICBpZiAob25CbHVyKSB7XG4gICAgICBvbkJsdXIoZXZlbnQpO1xuICAgIH1cblxuICAgIGlmIChtdWlGb3JtQ29udHJvbCAmJiBtdWlGb3JtQ29udHJvbC5vbkJsdXIpIHtcbiAgICAgIG11aUZvcm1Db250cm9sLm9uQmx1cihldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVJbnB1dENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUlucHV0Q2hhbmdlKGV2ZW50KSB7XG4gICAgdmFyIG5ld0NoZWNrZWQgPSBldmVudC50YXJnZXQuY2hlY2tlZDtcbiAgICBzZXRDaGVja2VkU3RhdGUobmV3Q2hlY2tlZCk7XG5cbiAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgIC8vIFRPRE8gdjU6IHJlbW92ZSB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgICAgb25DaGFuZ2UoZXZlbnQsIG5ld0NoZWNrZWQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZGlzYWJsZWQgPSBkaXNhYmxlZFByb3A7XG5cbiAgaWYgKG11aUZvcm1Db250cm9sKSB7XG4gICAgaWYgKHR5cGVvZiBkaXNhYmxlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRpc2FibGVkID0gbXVpRm9ybUNvbnRyb2wuZGlzYWJsZWQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhhc0xhYmVsRm9yID0gdHlwZSA9PT0gJ2NoZWNrYm94JyB8fCB0eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbiwgX2V4dGVuZHMoe1xuICAgIGNvbXBvbmVudDogXCJzcGFuXCIsXG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMucm9vdCwgY2xhc3NOYW1lLCBjaGVja2VkICYmIGNsYXNzZXMuY2hlY2tlZCwgZGlzYWJsZWQgJiYgY2xhc3Nlcy5kaXNhYmxlZCksXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgIHRhYkluZGV4OiBudWxsLFxuICAgIHJvbGU6IHVuZGVmaW5lZCxcbiAgICBvbkZvY3VzOiBoYW5kbGVGb2N1cyxcbiAgICBvbkJsdXI6IGhhbmRsZUJsdXIsXG4gICAgcmVmOiByZWZcbiAgfSwgb3RoZXIpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIF9leHRlbmRzKHtcbiAgICBhdXRvRm9jdXM6IGF1dG9Gb2N1cyxcbiAgICBjaGVja2VkOiBjaGVja2VkUHJvcCxcbiAgICBkZWZhdWx0Q2hlY2tlZDogZGVmYXVsdENoZWNrZWQsXG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzLmlucHV0LFxuICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICBpZDogaGFzTGFiZWxGb3IgJiYgaWQsXG4gICAgbmFtZTogbmFtZSxcbiAgICBvbkNoYW5nZTogaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgcmVhZE9ubHk6IHJlYWRPbmx5LFxuICAgIHJlZjogaW5wdXRSZWYsXG4gICAgcmVxdWlyZWQ6IHJlcXVpcmVkLFxuICAgIHRhYkluZGV4OiB0YWJJbmRleCxcbiAgICB0eXBlOiB0eXBlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9LCBpbnB1dFByb3BzKSksIGNoZWNrZWQgPyBjaGVja2VkSWNvbiA6IGljb24pO1xufSk7IC8vIE5COiBJZiBjaGFuZ2VkLCBwbGVhc2UgdXBkYXRlIENoZWNrYm94LCBTd2l0Y2ggYW5kIFJhZGlvXG4vLyBzbyB0aGF0IHRoZSBBUEkgZG9jdW1lbnRhdGlvbiBpcyB1cGRhdGVkLlxuXG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBTd2l0Y2hCYXNlLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIGZvY3VzZWQgZHVyaW5nIHRoZSBmaXJzdCBtb3VudC5cbiAgICovXG4gIGF1dG9Gb2N1czogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNvbXBvbmVudCBpcyBjaGVja2VkLlxuICAgKi9cbiAgY2hlY2tlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBpY29uIHRvIGRpc3BsYXkgd2hlbiB0aGUgY29tcG9uZW50IGlzIGNoZWNrZWQuXG4gICAqL1xuICBjaGVja2VkSWNvbjogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBTZWUgW0NTUyBBUEldKCNjc3MpIGJlbG93IGZvciBtb3JlIGRldGFpbHMuXG4gICAqL1xuICBjbGFzc2VzOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZGVmYXVsdENoZWNrZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBzd2l0Y2ggd2lsbCBiZSBkaXNhYmxlZC5cbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGljb24gdG8gZGlzcGxheSB3aGVuIHRoZSBjb21wb25lbnQgaXMgdW5jaGVja2VkLlxuICAgKi9cbiAgaWNvbjogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogVGhlIGlkIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogW0F0dHJpYnV0ZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNBdHRyaWJ1dGVzKSBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBQYXNzIGEgcmVmIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFJlZjogcmVmVHlwZSxcblxuICAvKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBzdGF0ZSBpcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqIFlvdSBjYW4gcHVsbCBvdXQgdGhlIG5ldyBjaGVja2VkIHN0YXRlIGJ5IGFjY2Vzc2luZyBgZXZlbnQudGFyZ2V0LmNoZWNrZWRgIChib29sZWFuKS5cbiAgICovXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEl0IHByZXZlbnRzIHRoZSB1c2VyIGZyb20gY2hhbmdpbmcgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZFxuICAgKiAobm90IGZyb20gaW50ZXJhY3Rpbmcgd2l0aCB0aGUgZmllbGQpLlxuICAgKi9cbiAgcmVhZE9ubHk6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoZSBgaW5wdXRgIGVsZW1lbnQgd2lsbCBiZSByZXF1aXJlZC5cbiAgICovXG4gIHJlcXVpcmVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgdGFiSW5kZXg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICAvKipcbiAgICogVGhlIGlucHV0IGNvbXBvbmVudCBwcm9wIGB0eXBlYC5cbiAgICovXG4gIHR5cGU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICB2YWx1ZTogUHJvcFR5cGVzLmFueVxufSA6IHZvaWQgMDtcbmV4cG9ydCBkZWZhdWx0IHdpdGhTdHlsZXMoc3R5bGVzLCB7XG4gIG5hbWU6ICdQcml2YXRlU3dpdGNoQmFzZSdcbn0pKFN3aXRjaEJhc2UpOyIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjcmVhdGVTdmdJY29uIGZyb20gJy4uLy4uL3V0aWxzL2NyZWF0ZVN2Z0ljb24nO1xuLyoqXG4gKiBAaWdub3JlIC0gaW50ZXJuYWwgY29tcG9uZW50LlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVN2Z0ljb24oIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gIGQ6IFwiTTE5IDV2MTRINVY1aDE0bTAtMkg1Yy0xLjEgMC0yIC45LTIgMnYxNGMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6XCJcbn0pLCAnQ2hlY2tCb3hPdXRsaW5lQmxhbmsnKTsiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3JlYXRlU3ZnSWNvbiBmcm9tICcuLi8uLi91dGlscy9jcmVhdGVTdmdJY29uJztcbi8qKlxuICogQGlnbm9yZSAtIGludGVybmFsIGNvbXBvbmVudC5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTdmdJY29uKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICBkOiBcIk0xOSAzSDVjLTEuMTEgMC0yIC45LTIgMnYxNGMwIDEuMS44OSAyIDIgMmgxNGMxLjExIDAgMi0uOSAyLTJWNWMwLTEuMS0uODktMi0yLTJ6bS05IDE0bC01LTUgMS40MS0xLjQxTDEwIDE0LjE3bDcuNTktNy41OUwxOSA4bC05IDl6XCJcbn0pLCAnQ2hlY2tCb3gnKTsiLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3JlYXRlU3ZnSWNvbiBmcm9tICcuLi8uLi91dGlscy9jcmVhdGVTdmdJY29uJztcbi8qKlxuICogQGlnbm9yZSAtIGludGVybmFsIGNvbXBvbmVudC5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTdmdJY29uKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICBkOiBcIk0xOSAzSDVjLTEuMSAwLTIgLjktMiAydjE0YzAgMS4xLjkgMiAyIDJoMTRjMS4xIDAgMi0uOSAyLTJWNWMwLTEuMS0uOS0yLTItMnptLTIgMTBIN3YtMmgxMHYyelwiXG59KSwgJ0luZGV0ZXJtaW5hdGVDaGVja0JveCcpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IHJlZlR5cGUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvdXRpbHMnO1xuaW1wb3J0IFN3aXRjaEJhc2UgZnJvbSAnLi4vaW50ZXJuYWwvU3dpdGNoQmFzZSc7XG5pbXBvcnQgQ2hlY2tCb3hPdXRsaW5lQmxhbmtJY29uIGZyb20gJy4uL2ludGVybmFsL3N2Zy1pY29ucy9DaGVja0JveE91dGxpbmVCbGFuayc7XG5pbXBvcnQgQ2hlY2tCb3hJY29uIGZyb20gJy4uL2ludGVybmFsL3N2Zy1pY29ucy9DaGVja0JveCc7XG5pbXBvcnQgeyBhbHBoYSB9IGZyb20gJy4uL3N0eWxlcy9jb2xvck1hbmlwdWxhdG9yJztcbmltcG9ydCBJbmRldGVybWluYXRlQ2hlY2tCb3hJY29uIGZyb20gJy4uL2ludGVybmFsL3N2Zy1pY29ucy9JbmRldGVybWluYXRlQ2hlY2tCb3gnO1xuaW1wb3J0IGNhcGl0YWxpemUgZnJvbSAnLi4vdXRpbHMvY2FwaXRhbGl6ZSc7XG5pbXBvcnQgd2l0aFN0eWxlcyBmcm9tICcuLi9zdHlsZXMvd2l0aFN0eWxlcyc7XG5leHBvcnQgdmFyIHN0eWxlcyA9IGZ1bmN0aW9uIHN0eWxlcyh0aGVtZSkge1xuICByZXR1cm4ge1xuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQuICovXG4gICAgcm9vdDoge1xuICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudGV4dC5zZWNvbmRhcnlcbiAgICB9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgY2hlY2tlZD17dHJ1ZX1gLiAqL1xuICAgIGNoZWNrZWQ6IHt9LFxuXG4gICAgLyogUHNldWRvLWNsYXNzIGFwcGxpZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBgZGlzYWJsZWQ9e3RydWV9YC4gKi9cbiAgICBkaXNhYmxlZDoge30sXG5cbiAgICAvKiBQc2V1ZG8tY2xhc3MgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBpbmRldGVybWluYXRlPXt0cnVlfWAuICovXG4gICAgaW5kZXRlcm1pbmF0ZToge30sXG5cbiAgICAvKiBTdHlsZXMgYXBwbGllZCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGBjb2xvcj1cInByaW1hcnlcImAuICovXG4gICAgY29sb3JQcmltYXJ5OiB7XG4gICAgICAnJiRjaGVja2VkJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW4sXG4gICAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYWxwaGEodGhlbWUucGFsZXR0ZS5wcmltYXJ5Lm1haW4sIHRoZW1lLnBhbGV0dGUuYWN0aW9uLmhvdmVyT3BhY2l0eSksXG4gICAgICAgICAgLy8gUmVzZXQgb24gdG91Y2ggZGV2aWNlcywgaXQgZG9lc24ndCBhZGQgc3BlY2lmaWNpdHlcbiAgICAgICAgICAnQG1lZGlhIChob3Zlcjogbm9uZSknOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnJiRkaXNhYmxlZCc6IHtcbiAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuYWN0aW9uLmRpc2FibGVkXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIFN0eWxlcyBhcHBsaWVkIHRvIHRoZSByb290IGVsZW1lbnQgaWYgYGNvbG9yPVwic2Vjb25kYXJ5XCJgLiAqL1xuICAgIGNvbG9yU2Vjb25kYXJ5OiB7XG4gICAgICAnJiRjaGVja2VkJzoge1xuICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5zZWNvbmRhcnkubWFpbixcbiAgICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBhbHBoYSh0aGVtZS5wYWxldHRlLnNlY29uZGFyeS5tYWluLCB0aGVtZS5wYWxldHRlLmFjdGlvbi5ob3Zlck9wYWNpdHkpLFxuICAgICAgICAgIC8vIFJlc2V0IG9uIHRvdWNoIGRldmljZXMsIGl0IGRvZXNuJ3QgYWRkIHNwZWNpZmljaXR5XG4gICAgICAgICAgJ0BtZWRpYSAoaG92ZXI6IG5vbmUpJzoge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJyYkZGlzYWJsZWQnOiB7XG4gICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmFjdGlvbi5kaXNhYmxlZFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG52YXIgZGVmYXVsdENoZWNrZWRJY29uID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hlY2tCb3hJY29uLCBudWxsKTtcbnZhciBkZWZhdWx0SWNvbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENoZWNrQm94T3V0bGluZUJsYW5rSWNvbiwgbnVsbCk7XG52YXIgZGVmYXVsdEluZGV0ZXJtaW5hdGVJY29uID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSW5kZXRlcm1pbmF0ZUNoZWNrQm94SWNvbiwgbnVsbCk7XG52YXIgQ2hlY2tib3ggPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDaGVja2JveChwcm9wcywgcmVmKSB7XG4gIHZhciBfcHJvcHMkY2hlY2tlZEljb24gPSBwcm9wcy5jaGVja2VkSWNvbixcbiAgICAgIGNoZWNrZWRJY29uID0gX3Byb3BzJGNoZWNrZWRJY29uID09PSB2b2lkIDAgPyBkZWZhdWx0Q2hlY2tlZEljb24gOiBfcHJvcHMkY2hlY2tlZEljb24sXG4gICAgICBjbGFzc2VzID0gcHJvcHMuY2xhc3NlcyxcbiAgICAgIF9wcm9wcyRjb2xvciA9IHByb3BzLmNvbG9yLFxuICAgICAgY29sb3IgPSBfcHJvcHMkY29sb3IgPT09IHZvaWQgMCA/ICdzZWNvbmRhcnknIDogX3Byb3BzJGNvbG9yLFxuICAgICAgX3Byb3BzJGljb24gPSBwcm9wcy5pY29uLFxuICAgICAgaWNvblByb3AgPSBfcHJvcHMkaWNvbiA9PT0gdm9pZCAwID8gZGVmYXVsdEljb24gOiBfcHJvcHMkaWNvbixcbiAgICAgIF9wcm9wcyRpbmRldGVybWluYXRlID0gcHJvcHMuaW5kZXRlcm1pbmF0ZSxcbiAgICAgIGluZGV0ZXJtaW5hdGUgPSBfcHJvcHMkaW5kZXRlcm1pbmF0ZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkaW5kZXRlcm1pbmF0ZSxcbiAgICAgIF9wcm9wcyRpbmRldGVybWluYXRlSSA9IHByb3BzLmluZGV0ZXJtaW5hdGVJY29uLFxuICAgICAgaW5kZXRlcm1pbmF0ZUljb25Qcm9wID0gX3Byb3BzJGluZGV0ZXJtaW5hdGVJID09PSB2b2lkIDAgPyBkZWZhdWx0SW5kZXRlcm1pbmF0ZUljb24gOiBfcHJvcHMkaW5kZXRlcm1pbmF0ZUksXG4gICAgICBpbnB1dFByb3BzID0gcHJvcHMuaW5wdXRQcm9wcyxcbiAgICAgIF9wcm9wcyRzaXplID0gcHJvcHMuc2l6ZSxcbiAgICAgIHNpemUgPSBfcHJvcHMkc2l6ZSA9PT0gdm9pZCAwID8gJ21lZGl1bScgOiBfcHJvcHMkc2l6ZSxcbiAgICAgIG90aGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJjaGVja2VkSWNvblwiLCBcImNsYXNzZXNcIiwgXCJjb2xvclwiLCBcImljb25cIiwgXCJpbmRldGVybWluYXRlXCIsIFwiaW5kZXRlcm1pbmF0ZUljb25cIiwgXCJpbnB1dFByb3BzXCIsIFwic2l6ZVwiXSk7XG5cbiAgdmFyIGljb24gPSBpbmRldGVybWluYXRlID8gaW5kZXRlcm1pbmF0ZUljb25Qcm9wIDogaWNvblByb3A7XG4gIHZhciBpbmRldGVybWluYXRlSWNvbiA9IGluZGV0ZXJtaW5hdGUgPyBpbmRldGVybWluYXRlSWNvblByb3AgOiBjaGVja2VkSWNvbjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFN3aXRjaEJhc2UsIF9leHRlbmRzKHtcbiAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgY2xhc3Nlczoge1xuICAgICAgcm9vdDogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzZXNbXCJjb2xvclwiLmNvbmNhdChjYXBpdGFsaXplKGNvbG9yKSldLCBpbmRldGVybWluYXRlICYmIGNsYXNzZXMuaW5kZXRlcm1pbmF0ZSksXG4gICAgICBjaGVja2VkOiBjbGFzc2VzLmNoZWNrZWQsXG4gICAgICBkaXNhYmxlZDogY2xhc3Nlcy5kaXNhYmxlZFxuICAgIH0sXG4gICAgY29sb3I6IGNvbG9yLFxuICAgIGlucHV0UHJvcHM6IF9leHRlbmRzKHtcbiAgICAgICdkYXRhLWluZGV0ZXJtaW5hdGUnOiBpbmRldGVybWluYXRlXG4gICAgfSwgaW5wdXRQcm9wcyksXG4gICAgaWNvbjogLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChpY29uLCB7XG4gICAgICBmb250U2l6ZTogaWNvbi5wcm9wcy5mb250U2l6ZSA9PT0gdW5kZWZpbmVkICYmIHNpemUgPT09IFwic21hbGxcIiA/IHNpemUgOiBpY29uLnByb3BzLmZvbnRTaXplXG4gICAgfSksXG4gICAgY2hlY2tlZEljb246IC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoaW5kZXRlcm1pbmF0ZUljb24sIHtcbiAgICAgIGZvbnRTaXplOiBpbmRldGVybWluYXRlSWNvbi5wcm9wcy5mb250U2l6ZSA9PT0gdW5kZWZpbmVkICYmIHNpemUgPT09IFwic21hbGxcIiA/IHNpemUgOiBpbmRldGVybWluYXRlSWNvbi5wcm9wcy5mb250U2l6ZVxuICAgIH0pLFxuICAgIHJlZjogcmVmXG4gIH0sIG90aGVyKSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IENoZWNrYm94LnByb3BUeXBlcyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNvbXBvbmVudCBpcyBjaGVja2VkLlxuICAgKi9cbiAgY2hlY2tlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBpY29uIHRvIGRpc3BsYXkgd2hlbiB0aGUgY29tcG9uZW50IGlzIGNoZWNrZWQuXG4gICAqL1xuICBjaGVja2VkSWNvbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogU2VlIFtDU1MgQVBJXSgjY3NzKSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBjb21wb25lbnQuIEl0IHN1cHBvcnRzIHRob3NlIHRoZW1lIGNvbG9ycyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ2RlZmF1bHQnLCAncHJpbWFyeScsICdzZWNvbmRhcnknXSksXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNoZWNrYm94IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIHJpcHBsZSBlZmZlY3Qgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICovXG4gIGRpc2FibGVSaXBwbGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgaWNvbiB0byBkaXNwbGF5IHdoZW4gdGhlIGNvbXBvbmVudCBpcyB1bmNoZWNrZWQuXG4gICAqL1xuICBpY29uOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogVGhlIGlkIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY29tcG9uZW50IGFwcGVhcnMgaW5kZXRlcm1pbmF0ZS5cbiAgICogVGhpcyBkb2VzIG5vdCBzZXQgdGhlIG5hdGl2ZSBpbnB1dCBlbGVtZW50IHRvIGluZGV0ZXJtaW5hdGUgZHVlXG4gICAqIHRvIGluY29uc2lzdGVudCBiZWhhdmlvciBhY3Jvc3MgYnJvd3NlcnMuXG4gICAqIEhvd2V2ZXIsIHdlIHNldCBhIGBkYXRhLWluZGV0ZXJtaW5hdGVgIGF0dHJpYnV0ZSBvbiB0aGUgaW5wdXQuXG4gICAqL1xuICBpbmRldGVybWluYXRlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGljb24gdG8gZGlzcGxheSB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5kZXRlcm1pbmF0ZS5cbiAgICovXG4gIGluZGV0ZXJtaW5hdGVJY29uOiBQcm9wVHlwZXMubm9kZSxcblxuICAvKipcbiAgICogW0F0dHJpYnV0ZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNBdHRyaWJ1dGVzKSBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBQYXNzIGEgcmVmIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG4gICAqL1xuICBpbnB1dFJlZjogcmVmVHlwZSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgc3RhdGUgaXMgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKiBZb3UgY2FuIHB1bGwgb3V0IHRoZSBuZXcgY2hlY2tlZCBzdGF0ZSBieSBhY2Nlc3NpbmcgYGV2ZW50LnRhcmdldC5jaGVja2VkYCAoYm9vbGVhbikuXG4gICAqL1xuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGBpbnB1dGAgZWxlbWVudCB3aWxsIGJlIHJlcXVpcmVkLlxuICAgKi9cbiAgcmVxdWlyZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgY2hlY2tib3guXG4gICAqIGBzbWFsbGAgaXMgZXF1aXZhbGVudCB0byB0aGUgZGVuc2UgY2hlY2tib3ggc3R5bGluZy5cbiAgICovXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ21lZGl1bScsICdzbWFsbCddKSxcblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBjb21wb25lbnQuIFRoZSBET00gQVBJIGNhc3RzIHRoaXMgdG8gYSBzdHJpbmcuXG4gICAqIFRoZSBicm93c2VyIHVzZXMgXCJvblwiIGFzIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgKi9cbiAgdmFsdWU6IFByb3BUeXBlcy5hbnlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCB3aXRoU3R5bGVzKHN0eWxlcywge1xuICBuYW1lOiAnTXVpQ2hlY2tib3gnXG59KShDaGVja2JveCk7IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gXCJyZWFjdFwiXHJcblxyXG5pbXBvcnQgQXV0b2NvbXBsZXRlIGZyb20gJ0BtYXRlcmlhbC11aS9sYWIvQXV0b2NvbXBsZXRlJztcclxuaW1wb3J0IFRleHRGaWVsZCBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS9UZXh0RmllbGQnO1xyXG5pbXBvcnQgQ2hlY2tib3ggZnJvbSAnQG1hdGVyaWFsLXVpL2NvcmUvQ2hlY2tib3gnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEF1dG9jb21wbGV0ZVVJIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICByZW5kZXIoKSB7XHJcbiAgICByZXR1cm4gPEF1dG9jb21wbGV0ZSBcclxuICAgICAgICBrZXkgPSB7dGhpcy5wcm9wcy5rZXl9XHJcbiAgICAgICAgbXVsdGlwbGUgPSB7dGhpcy5wcm9wcy5tdWx0aXBsZX1cclxuICAgICAgICBzaXplPVwic21hbGxcIlxyXG4gICAgICAgIGRpc2FibGVkID0ge3RoaXMucHJvcHMuZGlzYWJsZWR9XHJcbiAgICAgICAgZmlsdGVyU2VsZWN0ZWRPcHRpb25zID0ge3RoaXMucHJvcHMuZmlsdGVyU2VsZWN0ZWRPcHRpb25zfVxyXG4gICAgICAgIGRpc2FibGVDbG9zZU9uU2VsZWN0ID0ge3RoaXMucHJvcHMuZGlzYWJsZUNsb3NlT25TZWxlY3R9XHJcbiAgICAgICAgb3B0aW9ucyA9IHt0aGlzLnByb3BzLm9wdGlvbnN9XHJcbiAgICAgICAgdmFsdWUgPSB7dGhpcy5wcm9wcy52YWx1ZX1cclxuICAgICAgICBnZXRPcHRpb25MYWJlbCA9IHtvcHRpb24gPT4gb3B0aW9uLnRpdGxlfVxyXG4gICAgICAgIG9uQ2hhbmdlID0ge3RoaXMucHJvcHMub25DaGFuZ2V9XHJcbiAgICAgICAgbm9PcHRpb25zVGV4dCA9IHt0aGlzLnByb3BzLm5vT3B0aW9uc1RleHR9XHJcbiAgICAgICAgbGltaXRUYWdzPXt0aGlzLnByb3BzLmxpbWl0VGFnc31cclxuICAgICAgICBvbk9wZW4gPSB7dGhpcy5wcm9wcy5vbk9wZW59XHJcbiAgICAgICAgbG9hZGluZyA9IHt0aGlzLnByb3BzLmxvYWRpbmd9XHJcbiAgICAgICAgbG9hZGluZ1RleHQgPSB7dGhpcy5wcm9wcy5sb2FkaW5nVGV4dH1cclxuICAgICAgICBvbklucHV0Q2hhbmdlPXsgdGhpcy5wcm9wcy5vbklucHV0Q2hhbmdlfVxyXG4gICAgICAgIGdldE9wdGlvblNlbGVjdGVkPXsob3B0aW9uLCB2YWx1ZSkgPT4gb3B0aW9uLnRpdGxlID09PSB2YWx1ZS50aXRsZSAmJiBvcHRpb24ua2V5ID09PSB2YWx1ZS5rZXl9XHJcbiAgICAgICAgcmVuZGVyT3B0aW9uPXsob3B0aW9uLCB7IHNlbGVjdGVkIH0pID0+IChcclxuICAgICAgICAgICAgPEZyYWdtZW50PlxyXG4gICAgICAgICAgICB7dGhpcy5wcm9wcy5zaG93Q2hlY2tib3hlcyA/IDxDaGVja2JveFxyXG4gICAgICAgICAgICAgICAgY2hlY2tlZD17c2VsZWN0ZWR9XHJcbiAgICAgICAgICAgIC8+IDogbnVsbCB9XHJcbiAgICAgICAgICAgIHtvcHRpb24udGl0bGV9XHJcbiAgICAgICAgICAgIDwvRnJhZ21lbnQ+XHJcbiAgICAgICAgKX1cclxuICAgICAgICByZW5kZXJJbnB1dD17cGFyYW1zID0+IChcclxuICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgIHsuLi5wYXJhbXN9XHJcbiAgICAgICAgICAgIHZhcmlhbnQ9e3RoaXMucHJvcHMudmFyaWFudH1cclxuICAgICAgICAgICAgbGFiZWw9e3RoaXMucHJvcHMubGFiZWx9XHJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPXt0aGlzLnByb3BzLnBsYWNlaG9sZGVyfVxyXG4gICAgICAgIC8+XHJcbiAgICAgICAgKX1cclxuICAgIC8+O1xyXG4gIH1cclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCBcIi4vdWkvQXV0b2NvbXBsZXRlTXVsdGlzZWxlY3QuY3NzXCI7XG5cbmltcG9ydCB7IEF1dG9jb21wbGV0ZVVJIH0gZnJvbSBcIi4vY29tcG9uZW50cy9BdXRvY29tcGxldGVVSVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvY29tcGxldGVNdWx0aXNlbGVjdCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdXBkYXRlRGF0ZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmF1dG9Db21wbGV0ZUtleSA9IDA7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSB0aGlzLmNoYW5nZVZhbHVlcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uT3BlbkRyb3Bkb3duID0gdGhpcy5vcGVuRHJvcGRvd24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbklucHV0Q2hhbmdlID0gdGhpcy5pbnB1dENoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5vcHRpb25zU2VsZWN0ZWQgPSBbXTsgLy8gQXJyYXkgZm9yIG11bHRpc2VsZWN0LCBvdGhlcndpc2Ugb2JqZWN0XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIHRvIHRydWUgdG8gbWFrZSBzdXJlIGRhdGEgaXMgcmV0cmlldmVkIHdoZW4gaW5pdGlhbGl6aW5nIHdpZGdldFxuICAgICAgICB0aGlzLnJlZnJlc2hEYXRhID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuc2hvd1RvRmV3Q2hhcnNUZXh0ID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5sYXRlc3RJbnB1dENoYW5nZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGxldCByZWZyZXNoU3RhdGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBSZWZyZXNoIHRoZSBkYXRhIGlmIHRoZSByZWZyZXNoQXR0cmlidXRlIGhhcyBiZWVuIHNldCB0byB0cnVlXG4gICAgICAgIGlmIChwcmV2UHJvcHMucmVmcmVzaEF0dHJpYnV0ZSAmJiB0aGlzLnByb3BzLnJlZnJlc2hBdHRyaWJ1dGUudmFsdWUgJiYgIXByZXZQcm9wcy5yZWZyZXNoQXR0cmlidXRlLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLnJlZnJlc2hBdHRyaWJ1dGUuc2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5hdXRvQ29tcGxldGVLZXkrKztcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBkYXRhIGFuZCBzdGF0ZSB3aWxsIGJlIHJlZnJlc2hlZFxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoRGF0YSA9IHRydWU7XG4gICAgICAgICAgICByZWZyZXNoU3RhdGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgZGF0YSBzb3Vyc2Ugb3IgYXR0cmlidXRlIGlzIHVzZWRcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuSlNPTkF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuSlNPTkF0dHJpYnV0ZS5zdGF0dXMgPT09IFwiYXZhaWxhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgaXRlbXMgaGFzIGJlZW4gY2hhbmdlZCBvciBkYXRhIG5lZWRzIHRvIGJlIHJlZnJlc2hlZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZnJlc2hEYXRhIHx8IHRoaXMucHJvcHMuSlNPTkF0dHJpYnV0ZSAhPT0gcHJldlByb3BzLkpTT05BdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFQYXJzZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgdGhlIGpzb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuSlNPTkF0dHJpYnV0ZS52YWx1ZSAmJiB0aGlzLnByb3BzLkpTT05BdHRyaWJ1dGUudmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQYXJzZWQgPSBKU09OLnBhcnNlKHRoaXMucHJvcHMuSlNPTkF0dHJpYnV0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZGF0YSBuZWVkcyB0byBiZSByZWZyZXNoZWQsIHJlc2V0IGRlZmF1bHRzXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZnJlc2hEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBkYXRhUGFyc2VkLmZpbHRlcihvcHRpb24gPT4gb3B0aW9uLmRlZmF1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNTZWxlY3RlZCA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zU2VsZWN0ZWQgPSBkZWZhdWx0VmFsdWVbMF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWZhdWx0VmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBjdXN0b20gc2VhcmNoIGlzIHVzZWQsIGl0IGNhbiBiZSB0aGF0IHNvbWUgb3B0aW9ucyBhcmUgbm90IGluIHRoZSBKU09OXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlc2Ugb3B0aW9ucyB0byBtYWtlIHN1cmUgdGhlIGRlZmF1bHRzIGFyZSBpbiwgdGhleSB3aWxsIGJlIGZpbHRlcmVkIG91dCBpZiBub3QgYXBwbGljYWJsZSB0byBpbnB1dCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25JbnB1dENoYW5nZUFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnNTZWxlY3RlZE5vdEluTGlzdCA9IHRoaXMub3B0aW9uc1NlbGVjdGVkLmZpbHRlcihzZWxlY3RlZE9wdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhUGFyc2VkLmZpbmQob3B0aW9uID0+IG9wdGlvbi50aXRsZSA9PT0gc2VsZWN0ZWRPcHRpb24udGl0bGUgJiYgb3B0aW9uLmtleSA9PT0gc2VsZWN0ZWRPcHRpb24ua2V5KSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQYXJzZWQgPSBkYXRhUGFyc2VkLmNvbmNhdChvcHRpb25zU2VsZWN0ZWROb3RJbkxpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbHNlIGNoZWNrIGlmIG9wdGlvblNlbGVjdGVkIGFyZSBzdGlsbCBhdmFpbGFibGUuIFRoaXMgaXMgZG9uZSBzaW5jZSBpdCBjYW4gYmUgdGhlIGNhc2UgdGhhdCB0aGUgb3B0aW9ucyBoYXZlIGJlZW4gY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zU2VsZWN0ZWQgPSB0aGlzLm9wdGlvbnNTZWxlY3RlZC5maWx0ZXIoc2VsZWN0ZWRPcHRpb24gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFQYXJzZWQuZmluZChvcHRpb24gPT4gb3B0aW9uLnRpdGxlID09PSBzZWxlY3RlZE9wdGlvbi50aXRsZSAmJiBvcHRpb24ua2V5ID09PSBzZWxlY3RlZE9wdGlvbi5rZXkpICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zU2VsZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zU2VsZWN0ZWQgPSBkYXRhUGFyc2VkLmZpbmQob3B0aW9uID0+IG9wdGlvbi50aXRsZSA9PT0gdGhpcy5vcHRpb25zU2VsZWN0ZWQudGl0bGUgJiYgb3B0aW9uLmtleSA9PT0gdGhpcy5vcHRpb25zU2VsZWN0ZWQua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGlmICh0aGlzLm9wdGlvbnNTZWxlY3RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1NlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gZGF0YVBhcnNlZDtcblxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoU3RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoRGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSByZXNwb25zZSBpbiByZXNwb25zZUF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnJlc3BvbnNlQXR0cmlidXRlLnNldFZhbHVlKEpTT04uc3RyaW5naWZ5KHRoaXMub3B0aW9uc1NlbGVjdGVkKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLmRhdGFTb3VyY2VPcHRpb25zICE9PSBwcmV2UHJvcHMuZGF0YVNvdXJjZU9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBkYXRhc291cmNlIGhhcyBiZWVuIGxvYWRlZFxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuZGF0YVNvdXJjZU9wdGlvbnMuc3RhdHVzID09PSAnYXZhaWxhYmxlJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpdGVtcyBoYXZlIGJlZW4gY2hhbmdlZCBvciBpZiBkYXRlIG5lZWRzIHRvIGJlIHJlZnJlc2hlZCwgY2hhbmdlIHRoZSBvcHRpb25zXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVmcmVzaERhdGEgfHwgdGhpcy5wcm9wcy5kYXRhU291cmNlT3B0aW9ucy5pdGVtcyAhPT0gcHJldlByb3BzLmRhdGFTb3VyY2VPcHRpb25zLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3YXJuaW5nR2l2ZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXVsdGlTZWxlY3QgPSB0aGlzLnByb3BzLm11bHRpcGxlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3B0aW9uc1NlbGVjdGVkID0gbXVsdGlTZWxlY3QgPyBbXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWZhdWx0U2VsZWN0ZWRTdHJpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFwIHRoZSBvcHRpb25zIGFuZCBnZXQgdGhlIHNlbGVjdGVkIG9uZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5wcm9wcy5kYXRhU291cmNlT3B0aW9ucy5pdGVtcy5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25UaXRsZSA9IHRoaXMucHJvcHMudGl0bGVBdHRyLmdldChpdGVtKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IHt0aXRsZTogb3B0aW9uVGl0bGV9O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiBrZXkgaXMgdXNlZCwgYWRkIGtleSB0byB0aGUgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5rZXlBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLmtleSA9IHRoaXMucHJvcHMua2V5QXR0ci5nZXQoaXRlbSkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBkYXRhIG5lZWRzIHRvIGJlIHJlZnJlc2hlZCwgZ2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVmcmVzaERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzdHJpbmcgaXMgbm90IHlldCBmaWxsZWQsIGZpbGwgd2l0aCBlaXRoZXIgdGhlIGpzb24gb3Igd2l0aCBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRTZWxlY3RlZFN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmRlZmF1bHRTZWxlY3RlZFN0cmluZ0F0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U2VsZWN0ZWRTdHJpbmcgPSBKU09OLnBhcnNlKHRoaXMucHJvcHMuZGVmYXVsdFNlbGVjdGVkU3RyaW5nQXR0ci52YWx1ZSk7O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTZWxlY3RlZFN0cmluZyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHRvIG51bGwgdG8gbm90IGNoZWNrIHRoaXMgZm9yIGV2ZXJ5IGl0ZW0gYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTZWxlY3RlZFN0cmluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzSXRlbURlZmF1bHRTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0ZW1zIGNhbiBiZSBzZXQgdG8gZGVmYXVsdCBzZWxlY3RlZCBpbiB0d28gd2F5czogZGVmYXVsdFNlbGVjdGVkU3RyaW5nQXR0ciBwcm9wIG9yIGRlZmF1bHRTZWxlY3RlZEF0dHIgcHJvcCBvbiBhbiBpdGVtLiBJZiB0aGUgZmlyc3Qgb3B0aW9uIGlzIGNob3NlbiwgdGhlIHByb3Agb24gdGhlIGl0ZW0gaXMgaWdub3JlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdFNlbGVjdGVkU3RyaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSXRlbURlZmF1bHRTZWxlY3RlZCA9IGRlZmF1bHRTZWxlY3RlZFN0cmluZy5pbmRleE9mKG9wdGlvblRpdGxlKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJdGVtRGVmYXVsdFNlbGVjdGVkID0gdGhpcy5wcm9wcy5kZWZhdWx0U2VsZWN0ZWRBdHRyICYmIHRoaXMucHJvcHMuZGVmYXVsdFNlbGVjdGVkQXR0ci5nZXQoaXRlbSkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0l0ZW1EZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zU2VsZWN0ZWQucHVzaChvcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNTZWxlY3RlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNTZWxlY3RlZCA9IG9wdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3YXJuaW5nR2l2ZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQXV0b2NvbXBsZXRlIE11bHRpc2VsZWN0OiBNdWx0aXBsZSBvcHRpb25zIGFyZSBzZXQgYXMgZGVmYXVsdCBmb3IgYSBzaW5nbGUgc2VsZWN0LiBGaXJzdCBvcHRpb24gaXMgc2V0IGFzIHRoZSBzZWxlY3RlZCBvbmUuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nR2l2ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSBjaGVjayBpZiBvcHRpb24gaXMgc2VsZWN0ZWQgKGJhc2VkIG9uIHRoZSB0aXRsZSkuIFRoaXMgaXMgZG9uZSBzaW5jZSBpdCBjYW4gYmUgdGhlIGNhc2UgdGhhdCB0aGUgb3B0aW9ucyBoYXZlIGJlZW4gY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1NlbGVjdGVkLmZpbmQob3B0aW9uID0+IG9wdGlvbi50aXRsZSA9PT0gb3B0aW9uVGl0bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zU2VsZWN0ZWQucHVzaChvcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnNTZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zU2VsZWN0ZWQudGl0bGUgPT09IG9wdGlvblRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zU2VsZWN0ZWQgPSBvcHRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoU3RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoRGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNTZWxlY3RlZCA9IG9wdGlvbnNTZWxlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgcmVzcG9uc2UgaW4gcmVzcG9uc2VBdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5yZXNwb25zZUF0dHJpYnV0ZS5zZXRWYWx1ZShKU09OLnN0cmluZ2lmeShvcHRpb25zU2VsZWN0ZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZnJlc2hTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dXBkYXRlRGF0ZTogbmV3IERhdGUoKX0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gY2FsbGVkIHdoZW4gYSBuZXcgdmFsdWUgaXMgc2VsZWN0ZWQgb3IgdmFsdWUocykgYXJlIGRlc2VsZWN0ZWQuIFxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Kn0gZXZlbnQgLSB0aGUgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBhY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IG5ld1ZhbHVlIC0gdGhlIG5ldyB2YWx1ZSBvZiB0aGUgZHJvcGRvd25cbiAgICAgKiBAcGFyYW0geyp9IHJlYXNvbiAtIHRoZSByZWFzb24gdGhhdCB0aGlzIGFjdGlvbiBpcyB0cmlnZ2VyZWQsIGVpdGhlciBzZWxlY3Qtb3B0aW9uLCByZW1vdmUtb3B0aW9uLCBjcmVhdGUtb3B0aW9uLCBibHVyIG9yIGNsZWFyXG4gICAgICogQHBhcmFtIHsqfSBkZXRhaWxzIC0gbW9yZSBkZXRhaWxzIGFib3V0IHRoZSBvcHRpb24gZm9yIHdoaWNoIHRoaXMgZXZlbnQgaXMgdHJpZ2dlcmVkXG4gICAgICovXG4gICAgY2hhbmdlVmFsdWVzKGV2ZW50LCBuZXdWYWx1ZSwgcmVhc29uLCBkZXRhaWxzKSB7XG4gICAgICAgIC8vIFN0b3JlIHJlc3BvbnNlIGluIHJlc3BvbnNlQXR0cmlidXRlIGFuZCBjYWxsIG9uIGNoYW5nZSBhY3Rpb25cbiAgICAgICAgdGhpcy5wcm9wcy5yZXNwb25zZUF0dHJpYnV0ZS5zZXRWYWx1ZShKU09OLnN0cmluZ2lmeShuZXdWYWx1ZSkpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25DaGFuZ2VBY3Rpb24gJiYgdGhpcy5wcm9wcy5vbkNoYW5nZUFjdGlvbi5jYW5FeGVjdXRlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlQWN0aW9uLmV4ZWN1dGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIHdpZGdldCB3aXRoIHRoZSBuZXcgdmFsdWVzIHNlbGVjdGVkXG4gICAgICAgIHRoaXMub3B0aW9uc1NlbGVjdGVkID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe3VwZGF0ZURhdGU6IG5ldyBEYXRlKCl9KTsgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gY2FsbGVzIHdoZW4gZHJvcGRvd24gaXMgb3BlbmVkXG4gICAgICovXG4gICAgb3BlbkRyb3Bkb3duKCkge1xuICAgICAgICBsZXQgc2V0TG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgLy8gY2hlY2sgaWYgZW5vdWdoIGNoYXJzIGFyZSBmaWxsZWRcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25JbnB1dENoYW5nZUFjdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuc2VhcmNoQWZ0ZXJYQ2hhcnMudmFsdWUgJiYgdGhpcy5wcm9wcy5zZWFyY2hBZnRlclhDaGFycy52YWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dUb0Zld0NoYXJzVGV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2V0TG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25PcGVuQWN0aW9uICYmIHRoaXMucHJvcHMub25PcGVuQWN0aW9uLmNhbkV4ZWN1dGUpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25PcGVuQWN0aW9uLmV4ZWN1dGUoKTtcbiAgICAgICAgICAgIHNldExvYWRpbmcgPSB0cnVlO1xuICAgICAgICB9IFxuICAgICAgICBpZiAoc2V0TG9hZGluZykge1xuICAgICAgICAgICAgLy8gUmVyZW5kZXIgd2lkZ2V0XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dXBkYXRlRGF0ZTogbmV3IERhdGUoKX0pOyBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIGEgdGhlIGlucHV0IHZhbHVlIGNoYW5nZXNcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0geyp9IGV2ZW50IC0gdGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgYWN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIHRoZSBuZXcgdmFsdWUgb2YgdGhlIGlucHV0XG4gICAgICogQHBhcmFtIHsqfSByZWFzb24gLSB0aGUgcmVhc29uIHRoYXQgdGhpcyBhY3Rpb24gaXMgdHJpZ2dlcmVkLCBlaXRoZXIgaW5wdXQsIGNsZWFyIG9yIHJlc2V0XG4gICAgICovXG4gICAgaW5wdXRDaGFuZ2UgPSAoZXZlbnQsIHZhbHVlLCByZWFzb24pICA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnNlYXJjaEFmdGVyWENoYXJzLnZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUubGVuZ3RoID49IHRoaXMucHJvcHMuc2VhcmNoQWZ0ZXJYQ2hhcnMudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd1RvRmV3Q2hhcnNUZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCB0aW1lU3RhbXAgPSBldmVudC50aW1lU3RhbXBcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0SW5wdXRDaGFuZ2UgPSB0aW1lU3RhbXA7XG4gICAgICAgICAgICAvL0NoZWNrIGlmIG5vIG90aGVyIGlucHV0Y2hhbmdlIHdpbGwgYmUgZG9uZVxuICAgICAgICAgICAgc2V0VGltZW91dCgodGltZVN0YW1wLCB2YWx1ZSwgcmVhc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGF0ZXN0SW5wdXRDaGFuZ2UgPT09IHRpbWVTdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5zZWFyY2hWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5zZWFyY2hWYWx1ZS5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25JbnB1dENoYW5nZUFjdGlvbiAmJiB0aGlzLnByb3BzLm9uSW5wdXRDaGFuZ2VBY3Rpb24uY2FuRXhlY3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbklucHV0Q2hhbmdlQWN0aW9uLmV4ZWN1dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMucHJvcHMub25JbnB1dENoYW5nZURlbGF5LnZhbHVlLCB0aW1lU3RhbXAsIHZhbHVlLCByZWFzb24pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3dUb0Zld0NoYXJzVGV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHJlcmVuZGVyIHRoZSB3aWRnZXRcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dXBkYXRlRGF0ZTogbmV3IERhdGUoKX0pO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLy8gRG8gbm90IHJlbmRlciB0aGUgd2lkZ2V0IGlmIGl0IGlzIG5vdCBpbml0aWFsaXplZCB5ZXRcbiAgICAgICAgaWYoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGRpc2FibGVkIHByb3BlcnR5IGlzIG5vdCBmaWxsZWQsIHRoZSB3aWRnZXQgd2lsbCBiZSBlZGl0YWJsZVxuICAgICAgICBsZXQgZGlzYWJsZWQgPSB0aGlzLnByb3BzLmVkaXRhYmxlID8gIXRoaXMucHJvcHMuZWRpdGFibGUudmFsdWUgOiBmYWxzZTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdXNlciBoYXMgcmlnaHRzIG9uIHJlc3BvbnNlIGF0dHJpYnV0ZVxuICAgICAgICBpZighZGlzYWJsZWQgJiYgdGhpcy5wcm9wcy5yZXNwb25zZUF0dHJpYnV0ZS5yZWFkT25seSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdBdXRvY29tcGxldGUgTXVsdGlzZWxlY3Q6IFVzZXIgaGFzIG5vIHJpZ2h0cyB0byBjaGFuZ2UgdGhlIHJlc3BvbnNlIGF0dHJpYnV0ZS4nKVxuICAgICAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBub09wdGlvbnNUZXh0ID0gdGhpcy5wcm9wcy5ub09wdGlvbnNUZXh0ID8gdGhpcy5wcm9wcy5ub09wdGlvbnNUZXh0LnZhbHVlIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wcm9wcy5wbGFjZWhvbGRlciA/IHRoaXMucHJvcHMucGxhY2Vob2xkZXIudmFsdWUgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY29uc3QgbGltaXRUYWdzID0gdGhpcy5wcm9wcy5saW1pdFRhZ3MgPiAwID8gdGhpcy5wcm9wcy5saW1pdFRhZ3MgOiB1bmRlZmluZWQ7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMucHJvcHMubGFiZWwgPyB0aGlzLnByb3BzLmxhYmVsLnZhbHVlIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIEZvbGxvd2luZyBvcHRpb25zIG9ubHkgdXNlZCB3aGVuIGpzb24gYXR0cmlidXRlIGlzIHVzZWRcbiAgICAgICAgbGV0IG9uT3BlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG9uSW5wdXRDaGFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBsb2FkaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgbG9hZGluZ1RleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5KU09OQXR0cmlidXRlKSB7XG4gICAgICAgICAgICBvbk9wZW4gPSB0aGlzLm9uT3BlbkRyb3Bkb3duO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25JbnB1dENoYW5nZUFjdGlvbikge1xuICAgICAgICAgICAgICAgIG9uSW5wdXRDaGFuZ2UgPSB0aGlzLm9uSW5wdXRDaGFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2FkaW5nID0gdGhpcy5sb2FkaW5nO1xuXG4gICAgICAgICAgICAvLyBzZXQgbG9hZGluZyB0ZXh0LCBpZiB0byBmZXcgY2hhcnMgYXJlIGZpbGxlZCB1c2UgdGhpcyB0ZXh0LlxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd1RvRmV3Q2hhcnNUZXh0KSB7XG4gICAgICAgICAgICAgICAgbG9hZGluZ1RleHQgPSB0aGlzLnByb3BzLnNlYXJjaEFmdGVyWENoYXJzVGV4dCA/IHRoaXMucHJvcHMuc2VhcmNoQWZ0ZXJYQ2hhcnNUZXh0LnZhbHVlIDogXCJFbnRlciBhdCBsZWFzdCBcIiArIHRoaXMucHJvcHMuc2VhcmNoQWZ0ZXJYQ2hhcnMudmFsdWUgKyBcIiBjaGFyYWN0ZXJzXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvYWRpbmdUZXh0ID0gdGhpcy5wcm9wcy5sb2FkaW5nVGV4dCA/IHRoaXMucHJvcHMubG9hZGluZ1RleHQudmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjb21wb25lbnQgaXMgbG9hZGluZywgaGlkZSBvcHRpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gPEF1dG9jb21wbGV0ZVVJIFxuICAgICAgICAgICAgICAgICAgICBrZXkgPSB7dGhpcy5hdXRvQ29tcGxldGVLZXl9XG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxlID0ge3RoaXMucHJvcHMubXVsdGlwbGV9XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkID0ge2Rpc2FibGVkfVxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlQ2xvc2VPblNlbGVjdCA9IHt0aGlzLnByb3BzLmRpc2FibGVDbG9zZU9uU2VsZWN0fVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge29wdGlvbnN9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0ge3RoaXMub3B0aW9uc1NlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSA9IHt0aGlzLm9uQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICBub09wdGlvbnNUZXh0ID0ge25vT3B0aW9uc1RleHR9XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0VGFncz17bGltaXRUYWdzfVxuICAgICAgICAgICAgICAgICAgICBzaG93Q2hlY2tib3hlcyA9IHt0aGlzLnByb3BzLnNob3dDaGVja2JveGVzfVxuICAgICAgICAgICAgICAgICAgICB2YXJpYW50PXt0aGlzLnByb3BzLnZhcmlhbnR9XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPXtsYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e3BsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJTZWxlY3RlZE9wdGlvbnM9e3RoaXMucHJvcHMuZmlsdGVyU2VsZWN0ZWRPcHRpb25zfVxuICAgICAgICAgICAgICAgICAgICBvbk9wZW4gPSB7b25PcGVufVxuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nID0ge2xvYWRpbmd9XG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmdUZXh0ID0ge2xvYWRpbmdUZXh0fVxuICAgICAgICAgICAgICAgICAgICBvbklucHV0Q2hhbmdlPXtvbklucHV0Q2hhbmdlfVxuICAgICAgICAgICAgLz47XG4gICAgfVxufVxuXG5cblxuIl0sIm5hbWVzIjpbInN0eWxlSW5qZWN0IiwiY3NzIiwicmVmIiwiaW5zZXJ0QXQiLCJkb2N1bWVudCIsImhlYWQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInN0eWxlIiwiY3JlYXRlRWxlbWVudCIsInR5cGUiLCJmaXJzdENoaWxkIiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJzdHlsZVNoZWV0IiwiY3NzVGV4dCIsImNyZWF0ZVRleHROb2RlIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJzb3VyY2UiLCJleGNsdWRlZCIsInRhcmdldCIsInNvdXJjZUtleXMiLCJPYmplY3QiLCJrZXlzIiwia2V5IiwiaSIsImxlbmd0aCIsImluZGV4T2YiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsInByb3RvdHlwZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiY2FsbCIsIl9kZWZpbmVQcm9wZXJ0eSIsIm9iaiIsInZhbHVlIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImFyZ3VtZW50cyIsImhhc093blByb3BlcnR5IiwiYXBwbHkiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9BU1lOQ19NT0RFX1RZUEUiLCJSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfQkxPQ0tfVFlQRSIsIlJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUiLCJSRUFDVF9SRVNQT05ERVJfVFlQRSIsIlJFQUNUX1NDT1BFX1RZUEUiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCIkJHR5cGVvZiIsInR5cGVPZiIsIm9iamVjdCIsIiQkdHlwZW9mVHlwZSIsInVuZGVmaW5lZCIsIkFzeW5jTW9kZSIsIkNvbmN1cnJlbnRNb2RlIiwiQ29udGV4dENvbnN1bWVyIiwiQ29udGV4dFByb3ZpZGVyIiwiRWxlbWVudCIsIkZvcndhcmRSZWYiLCJGcmFnbWVudCIsIkxhenkiLCJNZW1vIiwiUG9ydGFsIiwiUHJvZmlsZXIiLCJTdHJpY3RNb2RlIiwiU3VzcGVuc2UiLCJoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSIsImlzQXN5bmNNb2RlIiwiY29uc29sZSIsImlzQ29uY3VycmVudE1vZGUiLCJpc0NvbnRleHRDb25zdW1lciIsImlzQ29udGV4dFByb3ZpZGVyIiwiaXNFbGVtZW50IiwiaXNGb3J3YXJkUmVmIiwiaXNGcmFnbWVudCIsImlzTGF6eSIsImlzTWVtbyIsImlzUG9ydGFsIiwiaXNQcm9maWxlciIsImlzU3RyaWN0TW9kZSIsImlzU3VzcGVuc2UiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsInByb3BJc0VudW1lcmFibGUiLCJ0b09iamVjdCIsInZhbCIsIlR5cGVFcnJvciIsInNob3VsZFVzZU5hdGl2ZSIsInRlc3QxIiwiU3RyaW5nIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRlc3QyIiwiZnJvbUNoYXJDb2RlIiwib3JkZXIyIiwibWFwIiwibiIsImpvaW4iLCJ0ZXN0MyIsInNwbGl0IiwiZm9yRWFjaCIsImxldHRlciIsImVyciIsImZyb20iLCJ0byIsInN5bWJvbHMiLCJzIiwiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJwcmludFdhcm5pbmciLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJoYXMiLCJGdW5jdGlvbiIsImJpbmQiLCJ0ZXh0IiwibWVzc2FnZSIsImVycm9yIiwiRXJyb3IiLCJ4IiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImNvbXBvbmVudE5hbWUiLCJnZXRTdGFjayIsInR5cGVTcGVjTmFtZSIsIm5hbWUiLCJleCIsInN0YWNrIiwicmVzZXRXYXJuaW5nQ2FjaGUiLCJSZWFjdElzIiwiZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCIsImlzVmFsaWRFbGVtZW50IiwidGhyb3dPbkRpcmVjdEFjY2VzcyIsIklURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIml0ZXJhdG9yRm4iLCJBTk9OWU1PVVMiLCJSZWFjdFByb3BUeXBlcyIsImFycmF5IiwiY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIiLCJib29sIiwiZnVuYyIsIm51bWJlciIsInN0cmluZyIsInN5bWJvbCIsImFueSIsImNyZWF0ZUFueVR5cGVDaGVja2VyIiwiYXJyYXlPZiIsImNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlciIsImVsZW1lbnQiLCJjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIiLCJlbGVtZW50VHlwZSIsImNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIiLCJpbnN0YW5jZU9mIiwiY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlciIsIm5vZGUiLCJjcmVhdGVOb2RlQ2hlY2tlciIsIm9iamVjdE9mIiwiY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlciIsIm9uZU9mIiwiY3JlYXRlRW51bVR5cGVDaGVja2VyIiwib25lT2ZUeXBlIiwiY3JlYXRlVW5pb25UeXBlQ2hlY2tlciIsInNoYXBlIiwiY3JlYXRlU2hhcGVUeXBlQ2hlY2tlciIsImV4YWN0IiwiY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlciIsImlzIiwieSIsIlByb3BUeXBlRXJyb3IiLCJjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlciIsInZhbGlkYXRlIiwibWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUiLCJtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCIsImNoZWNrVHlwZSIsImlzUmVxdWlyZWQiLCJwcm9wcyIsInByb3BOYW1lIiwicHJvcEZ1bGxOYW1lIiwic2VjcmV0IiwiY2FjaGVLZXkiLCJjaGFpbmVkQ2hlY2tUeXBlIiwiZXhwZWN0ZWRUeXBlIiwicHJvcFZhbHVlIiwicHJvcFR5cGUiLCJnZXRQcm9wVHlwZSIsInByZWNpc2VUeXBlIiwiZ2V0UHJlY2lzZVR5cGUiLCJ0eXBlQ2hlY2tlciIsIkFycmF5IiwiaXNBcnJheSIsImV4cGVjdGVkQ2xhc3MiLCJleHBlY3RlZENsYXNzTmFtZSIsImFjdHVhbENsYXNzTmFtZSIsImdldENsYXNzTmFtZSIsImV4cGVjdGVkVmFsdWVzIiwidmFsdWVzU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlcGxhY2VyIiwiYXJyYXlPZlR5cGVDaGVja2VycyIsInByb2Nlc3MiLCJjaGVja2VyIiwiZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nIiwiaXNOb2RlIiwic2hhcGVUeXBlcyIsImFsbEtleXMiLCJldmVyeSIsInN0ZXAiLCJlbnRyaWVzIiwibmV4dCIsImRvbmUiLCJlbnRyeSIsImlzU3ltYm9sIiwiUmVnRXhwIiwiRGF0ZSIsImNvbnN0cnVjdG9yIiwiUHJvcFR5cGVzIiwidG9WYWwiLCJtaXgiLCJrIiwic3RyIiwidG1wIiwiY2hhaW5Qcm9wVHlwZXMiLCJwcm9wVHlwZTEiLCJwcm9wVHlwZTIiLCJfdHlwZW9mIiwiaXNQbGFpbk9iamVjdCIsIml0ZW0iLCJkZWVwbWVyZ2UiLCJvcHRpb25zIiwiY2xvbmUiLCJvdXRwdXQiLCJpc0NsYXNzQ29tcG9uZW50IiwiX2VsZW1lbnRUeXBlJHByb3RvdHlwIiwiQm9vbGVhbiIsImlzUmVhY3RDb21wb25lbnQiLCJhY2NlcHRpbmdSZWYiLCJzYWZlUHJvcE5hbWUiLCJ3YXJuaW5nSGludCIsImNvbmNhdCIsImVsZW1lbnRBY2NlcHRpbmdSZWYiLCJlbGVtZW50VHlwZUFjY2VwdGluZ1JlZiIsInNwZWNpYWxQcm9wZXJ0eSIsImV4YWN0UHJvcCIsInByb3BUeXBlcyIsInVuc3VwcG9ydGVkUHJvcHMiLCJmaWx0ZXIiLCJwcm9wIiwiZm5OYW1lTWF0Y2hSZWdleCIsImdldEZ1bmN0aW9uTmFtZSIsImZuIiwibWF0Y2giLCJnZXRGdW5jdGlvbkNvbXBvbmVudE5hbWUiLCJDb21wb25lbnQiLCJmYWxsYmFjayIsImRpc3BsYXlOYW1lIiwiZ2V0V3JhcHBlZE5hbWUiLCJvdXRlclR5cGUiLCJpbm5lclR5cGUiLCJ3cmFwcGVyTmFtZSIsImZ1bmN0aW9uTmFtZSIsImdldERpc3BsYXlOYW1lIiwicmVuZGVyIiwiSFRNTEVsZW1lbnRUeXBlIiwibm9kZVR5cGUiLCJyZWZUeXBlIiwiY2xhbXAiLCJtaW4iLCJtYXgiLCJNYXRoIiwiaGV4VG9SZ2IiLCJjb2xvciIsInN1YnN0ciIsInJlIiwiY29sb3JzIiwiaW5kZXgiLCJwYXJzZUludCIsInJvdW5kIiwiaHNsVG9SZ2IiLCJkZWNvbXBvc2VDb2xvciIsIl9jb2xvciIsImgiLCJsIiwiYSIsImYiLCJyZ2IiLCJwdXNoIiwicmVjb21wb3NlQ29sb3IiLCJjaGFyQXQiLCJtYXJrZXIiLCJzdWJzdHJpbmciLCJwYXJzZUZsb2F0IiwiZ2V0Q29udHJhc3RSYXRpbyIsImZvcmVncm91bmQiLCJiYWNrZ3JvdW5kIiwibHVtQSIsImdldEx1bWluYW5jZSIsImx1bUIiLCJwb3ciLCJOdW1iZXIiLCJ0b0ZpeGVkIiwiZW1waGFzaXplIiwiY29lZmZpY2llbnQiLCJkYXJrZW4iLCJsaWdodGVuIiwiYWxwaGEiLCJjcmVhdGVCcmVha3BvaW50cyIsImJyZWFrcG9pbnRzIiwiX2JyZWFrcG9pbnRzJHZhbHVlcyIsInhzIiwic20iLCJtZCIsImxnIiwieGwiLCJfYnJlYWtwb2ludHMkdW5pdCIsInVuaXQiLCJfYnJlYWtwb2ludHMkc3RlcCIsIm90aGVyIiwidXAiLCJkb3duIiwiZW5kSW5kZXgiLCJ1cHBlcmJvdW5kIiwiYmV0d2VlbiIsInN0YXJ0IiwiZW5kIiwib25seSIsIndhcm5lZE9uY2UiLCJ3aWR0aCIsIndhcm4iLCJjcmVhdGVNaXhpbnMiLCJzcGFjaW5nIiwibWl4aW5zIiwiX3Rvb2xiYXIiLCJndXR0ZXJzIiwic3R5bGVzIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJ0b29sYmFyIiwibWluSGVpZ2h0IiwiY29tbW9uIiwiYmxhY2siLCJ3aGl0ZSIsImdyZXkiLCJBMTAwIiwiQTIwMCIsIkE0MDAiLCJBNzAwIiwiaW5kaWdvIiwicGluayIsInJlZCIsIm9yYW5nZSIsImJsdWUiLCJncmVlbiIsImxpZ2h0IiwicHJpbWFyeSIsInNlY29uZGFyeSIsImRpc2FibGVkIiwiaGludCIsImRpdmlkZXIiLCJwYXBlciIsImRlZmF1bHQiLCJhY3Rpb24iLCJhY3RpdmUiLCJob3ZlciIsImhvdmVyT3BhY2l0eSIsInNlbGVjdGVkIiwic2VsZWN0ZWRPcGFjaXR5IiwiZGlzYWJsZWRCYWNrZ3JvdW5kIiwiZGlzYWJsZWRPcGFjaXR5IiwiZm9jdXMiLCJmb2N1c09wYWNpdHkiLCJhY3RpdmF0ZWRPcGFjaXR5IiwiZGFyayIsImljb24iLCJhZGRMaWdodE9yRGFyayIsImludGVudCIsImRpcmVjdGlvbiIsInNoYWRlIiwidG9uYWxPZmZzZXQiLCJ0b25hbE9mZnNldExpZ2h0IiwidG9uYWxPZmZzZXREYXJrIiwibWFpbiIsImNyZWF0ZVBhbGV0dGUiLCJwYWxldHRlIiwiX3BhbGV0dGUkcHJpbWFyeSIsIl9wYWxldHRlJHNlY29uZGFyeSIsIl9wYWxldHRlJGVycm9yIiwiX3BhbGV0dGUkd2FybmluZyIsIndhcm5pbmciLCJfcGFsZXR0ZSRpbmZvIiwiaW5mbyIsIl9wYWxldHRlJHN1Y2Nlc3MiLCJzdWNjZXNzIiwiX3BhbGV0dGUkdHlwZSIsIl9wYWxldHRlJGNvbnRyYXN0VGhyZSIsImNvbnRyYXN0VGhyZXNob2xkIiwiX3BhbGV0dGUkdG9uYWxPZmZzZXQiLCJnZXRDb250cmFzdFRleHQiLCJjb250cmFzdFRleHQiLCJjb250cmFzdCIsImF1Z21lbnRDb2xvciIsIm1haW5TaGFkZSIsImxpZ2h0U2hhZGUiLCJkYXJrU2hhZGUiLCJ0eXBlcyIsInBhbGV0dGVPdXRwdXQiLCJyb3VuZFdpdGhEZXByZWNhdGlvbldhcm5pbmciLCJjYXNlQWxsQ2FwcyIsInRleHRUcmFuc2Zvcm0iLCJkZWZhdWx0Rm9udEZhbWlseSIsImNyZWF0ZVR5cG9ncmFwaHkiLCJ0eXBvZ3JhcGh5IiwiX3JlZiIsIl9yZWYkZm9udEZhbWlseSIsImZvbnRGYW1pbHkiLCJfcmVmJGZvbnRTaXplIiwiZm9udFNpemUiLCJfcmVmJGZvbnRXZWlnaHRMaWdodCIsImZvbnRXZWlnaHRMaWdodCIsIl9yZWYkZm9udFdlaWdodFJlZ3VsYSIsImZvbnRXZWlnaHRSZWd1bGFyIiwiX3JlZiRmb250V2VpZ2h0TWVkaXVtIiwiZm9udFdlaWdodE1lZGl1bSIsIl9yZWYkZm9udFdlaWdodEJvbGQiLCJmb250V2VpZ2h0Qm9sZCIsIl9yZWYkaHRtbEZvbnRTaXplIiwiaHRtbEZvbnRTaXplIiwiYWxsVmFyaWFudHMiLCJweFRvUmVtMiIsInB4VG9SZW0iLCJjb2VmIiwic2l6ZSIsImJ1aWxkVmFyaWFudCIsImZvbnRXZWlnaHQiLCJsaW5lSGVpZ2h0IiwibGV0dGVyU3BhY2luZyIsImNhc2luZyIsInZhcmlhbnRzIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2Iiwic3VidGl0bGUxIiwic3VidGl0bGUyIiwiYm9keTEiLCJib2R5MiIsImJ1dHRvbiIsImNhcHRpb24iLCJvdmVybGluZSIsInNoYWRvd0tleVVtYnJhT3BhY2l0eSIsInNoYWRvd0tleVBlbnVtYnJhT3BhY2l0eSIsInNoYWRvd0FtYmllbnRTaGFkb3dPcGFjaXR5IiwiY3JlYXRlU2hhZG93Iiwic2hhZG93cyIsImJvcmRlclJhZGl1cyIsInJlc3BvbnNpdmVQcm9wVHlwZSIsIl9hcnJheUxpa2VUb0FycmF5IiwiYXJyIiwibGVuIiwiYXJyMiIsIl9hcnJheVdpdGhvdXRIb2xlcyIsImFycmF5TGlrZVRvQXJyYXkiLCJfaXRlcmFibGVUb0FycmF5IiwiaXRlciIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm8iLCJtaW5MZW4iLCJ0b1N0cmluZyIsInNsaWNlIiwidGVzdCIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIl90b0NvbnN1bWFibGVBcnJheSIsImFycmF5V2l0aG91dEhvbGVzIiwiaXRlcmFibGVUb0FycmF5IiwidW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJub25JdGVyYWJsZVNwcmVhZCIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl9pIiwiX2FyciIsIl9uIiwiX2QiLCJfcyIsIl9lIiwiX25vbkl0ZXJhYmxlUmVzdCIsIl9zbGljZWRUb0FycmF5IiwiYXJyYXlXaXRoSG9sZXMiLCJpdGVyYWJsZVRvQXJyYXlMaW1pdCIsIm5vbkl0ZXJhYmxlUmVzdCIsInNwYWNpbmdLZXlzIiwiY3JlYXRlVW5hcnlTcGFjaW5nIiwidGhlbWUiLCJ0aGVtZVNwYWNpbmciLCJhYnMiLCJyZWR1Y2UiLCJ3YXJuT25jZSIsImNyZWF0ZVNwYWNpbmciLCJzcGFjaW5nSW5wdXQiLCJtdWkiLCJ0cmFuc2Zvcm0iLCJfbGVuIiwiYXJncyIsIl9rZXkiLCJhcmd1bWVudCIsImdldCIsImVhc2luZyIsImVhc2VJbk91dCIsImVhc2VPdXQiLCJlYXNlSW4iLCJzaGFycCIsImR1cmF0aW9uIiwic2hvcnRlc3QiLCJzaG9ydGVyIiwic2hvcnQiLCJzdGFuZGFyZCIsImNvbXBsZXgiLCJlbnRlcmluZ1NjcmVlbiIsImxlYXZpbmdTY3JlZW4iLCJmb3JtYXRNcyIsIm1pbGxpc2Vjb25kcyIsImNyZWF0ZSIsIl9vcHRpb25zJGR1cmF0aW9uIiwiZHVyYXRpb25PcHRpb24iLCJfb3B0aW9ucyRlYXNpbmciLCJlYXNpbmdPcHRpb24iLCJfb3B0aW9ucyRkZWxheSIsImRlbGF5IiwiaXNTdHJpbmciLCJpc051bWJlciIsImlzTmFOIiwiYW5pbWF0ZWRQcm9wIiwiZ2V0QXV0b0hlaWdodER1cmF0aW9uIiwiaGVpZ2h0IiwiY29uc3RhbnQiLCJ6SW5kZXgiLCJtb2JpbGVTdGVwcGVyIiwic3BlZWREaWFsIiwiYXBwQmFyIiwiZHJhd2VyIiwibW9kYWwiLCJzbmFja2JhciIsInRvb2x0aXAiLCJjcmVhdGVUaGVtZSIsIl9vcHRpb25zJGJyZWFrcG9pbnRzIiwiYnJlYWtwb2ludHNJbnB1dCIsIl9vcHRpb25zJG1peGlucyIsIm1peGluc0lucHV0IiwiX29wdGlvbnMkcGFsZXR0ZSIsInBhbGV0dGVJbnB1dCIsIl9vcHRpb25zJHR5cG9ncmFwaHkiLCJ0eXBvZ3JhcGh5SW5wdXQiLCJtdWlUaGVtZSIsIm92ZXJyaWRlcyIsInRyYW5zaXRpb25zIiwiYWNjIiwicHNldWRvQ2xhc3NlcyIsInRyYXZlcnNlIiwicGFyZW50S2V5IiwiZGVwdGgiLCJjaGlsZCIsInJvb3QiLCJjcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZSIsIl9vcHRpb25zJGRpc2FibGVHbG9iYSIsImRpc2FibGVHbG9iYWwiLCJwcm9kdWN0aW9uUHJlZml4IiwiX29wdGlvbnMkc2VlZCIsInNlZWQiLCJzZWVkUHJlZml4IiwicnVsZUNvdW50ZXIiLCJnZXROZXh0Q291bnRlcklkIiwicnVsZSIsImxpbmsiLCJwcmVmaXgiLCJuZXN0ZWQiLCJzdWZmaXgiLCJjbGFzc05hbWVQcmVmaXgiLCJnZXRUaGVtZVByb3BzIiwicGFyYW1zIiwiZGVmYXVsdFByb3BzIiwiaXNQcm9kdWN0aW9uIiwiY29uZGl0aW9uIiwiaXNCcm93c2VyIiwid2luZG93IiwiX2RlZmluZVByb3BlcnRpZXMiLCJkZXNjcmlwdG9yIiwiX2NyZWF0ZUNsYXNzIiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfc2V0UHJvdG90eXBlT2YiLCJwIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfaW5oZXJpdHNMb29zZSIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJwbGFpbk9iamVjdENvbnN0cnVyY3RvciIsImNsb25lU3R5bGUiLCJuZXdTdHlsZSIsImNyZWF0ZVJ1bGUiLCJkZWNsIiwianNzIiwiZGVjbENvcHkiLCJwbHVnaW5zIiwib25DcmVhdGVSdWxlIiwiYnkiLCJyZXN1bHQiLCJ0b0Nzc1ZhbHVlIiwiaWdub3JlSW1wb3J0YW50IiwiY3NzVmFsdWUiLCJnZXRXaGl0ZXNwYWNlU3ltYm9scyIsImZvcm1hdCIsImxpbmVicmVhayIsInNwYWNlIiwiaW5kZW50U3RyIiwiaW5kZW50IiwidG9Dc3MiLCJzZWxlY3RvciIsIl9vcHRpb25zIiwiX29wdGlvbnMkaW5kZW50IiwiZmFsbGJhY2tzIiwiSW5maW5pdHkiLCJfZ2V0V2hpdGVzcGFjZVN5bWJvbHMiLCJfcHJvcCIsIl92YWx1ZSIsIl9wcm9wMiIsIl92YWx1ZTIiLCJhbGxvd0VtcHR5IiwiZXNjYXBlUmVnZXgiLCJuYXRpdmVFc2NhcGUiLCJDU1MiLCJlc2NhcGUiLCJyZXBsYWNlIiwiQmFzZVN0eWxlUnVsZSIsImlzUHJvY2Vzc2VkIiwic2hlZXQiLCJSZW5kZXJlciIsInJlbmRlcmVyIiwiX3Byb3RvIiwiZm9yY2UiLCJuZXdWYWx1ZSIsIm9uQ2hhbmdlVmFsdWUiLCJpc0VtcHR5IiwiaXNEZWZpbmVkIiwicmVtb3ZlIiwicmVuZGVyYWJsZSIsInJlbW92ZVByb3BlcnR5Iiwic2V0UHJvcGVydHkiLCJhdHRhY2hlZCIsIlN0eWxlUnVsZSIsIl9CYXNlU3R5bGVSdWxlIiwiX3RoaXMiLCJzY29wZWQiLCJnZW5lcmF0ZUlkIiwic2VsZWN0b3JUZXh0IiwiaWQiLCJfcHJvdG8yIiwiYXBwbHlUbyIsImpzb24iLCJ0b0pTT04iLCJvcHRzIiwic2V0IiwiaGFzQ2hhbmdlZCIsInNldFNlbGVjdG9yIiwicmVwbGFjZVJ1bGUiLCJwbHVnaW5TdHlsZVJ1bGUiLCJwYXJlbnQiLCJkZWZhdWx0VG9TdHJpbmdPcHRpb25zIiwiY2hpbGRyZW4iLCJhdFJlZ0V4cCIsIkNvbmRpdGlvbmFsUnVsZSIsImF0TWF0Y2giLCJhdCIsInF1ZXJ5IiwicnVsZXMiLCJSdWxlTGlzdCIsImFkZCIsImdldFJ1bGUiLCJhZGRSdWxlIiwib25Qcm9jZXNzUnVsZSIsImtleVJlZ0V4cCIsInBsdWdpbkNvbmRpdGlvbmFsUnVsZSIsImRlZmF1bHRUb1N0cmluZ09wdGlvbnMkMSIsIm5hbWVSZWdFeHAiLCJLZXlmcmFtZXNSdWxlIiwiZnJhbWVzIiwibmFtZU1hdGNoIiwia2V5UmVnRXhwJDEiLCJyZWZSZWdFeHAiLCJmaW5kUmVmZXJlbmNlZEtleWZyYW1lIiwia2V5ZnJhbWVzIiwicmVwbGFjZVJlZiIsInJlZktleWZyYW1lIiwicGx1Z2luS2V5ZnJhbWVzUnVsZSIsIm9uUHJvY2Vzc1N0eWxlIiwiS2V5ZnJhbWVSdWxlIiwicGx1Z2luS2V5ZnJhbWVSdWxlIiwiRm9udEZhY2VSdWxlIiwia2V5UmVnRXhwJDIiLCJwbHVnaW5Gb250RmFjZVJ1bGUiLCJWaWV3cG9ydFJ1bGUiLCJwbHVnaW5WaWV3cG9ydFJ1bGUiLCJTaW1wbGVSdWxlIiwia2V5c01hcCIsInBsdWdpblNpbXBsZVJ1bGUiLCJkZWZhdWx0VXBkYXRlT3B0aW9ucyIsImZvcmNlVXBkYXRlT3B0aW9ucyIsInJhdyIsImNvdW50ZXIiLCJjbGFzc2VzIiwicnVsZU9wdGlvbnMiLCJfdGhpcyRvcHRpb25zIiwicmVnaXN0ZXIiLCJzcGxpY2UiLCJ1bnJlZ2lzdGVyIiwidXBkYXRlIiwiZGF0YSIsInVwZGF0ZU9uZSIsIl90aGlzJG9wdGlvbnMyIiwib25VcGRhdGUiLCJuZXh0VmFsdWUiLCJwcmV2VmFsdWUiLCJfbmV4dFZhbHVlIiwiX3ByZXZWYWx1ZSIsIlN0eWxlU2hlZXQiLCJkZXBsb3llZCIsImF0dGFjaCIsImRlcGxveSIsImRldGFjaCIsInF1ZXVlIiwiaW5zZXJ0UnVsZSIsImFkZFJ1bGVzIiwiYWRkZWQiLCJkZWxldGVSdWxlIiwiX3RoaXMkcnVsZXMiLCJQbHVnaW5zUmVnaXN0cnkiLCJpbnRlcm5hbCIsImV4dGVybmFsIiwicmVnaXN0cnkiLCJvblByb2Nlc3NTaGVldCIsInByb2Nlc3NlZFZhbHVlIiwidXNlIiwibmV3UGx1Z2luIiwicGx1Z2luIiwiU2hlZXRzUmVnaXN0cnkiLCJyZXNldCIsIl90ZW1wIiwic2hlZXRzIiwiZ2xvYmFsVGhpcyQxIiwiZ2xvYmFsVGhpcyIsIm5zIiwibW9kdWxlSWQiLCJtYXhSdWxlcyIsImNyZWF0ZUdlbmVyYXRlSWQiLCJqc3NJZCIsIm1pbmlmeSIsIm1lbW9pemUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiY3NzUnVsZSIsImF0dHJpYnV0ZVN0eWxlTWFwIiwiZGVsZXRlIiwiZ2V0SGVhZCIsInF1ZXJ5U2VsZWN0b3IiLCJmaW5kSGlnaGVyU2hlZXQiLCJpbnNlcnRpb25Qb2ludCIsImZpbmRIaWdoZXN0U2hlZXQiLCJmaW5kQ29tbWVudE5vZGUiLCJjaGlsZE5vZGVzIiwibm9kZVZhbHVlIiwidHJpbSIsImZpbmRQcmV2Tm9kZSIsInBhcmVudE5vZGUiLCJuZXh0U2libGluZyIsImNvbW1lbnQiLCJpbnNlcnRTdHlsZSIsIm5leHROb2RlIiwiaW5zZXJ0aW9uUG9pbnRFbGVtZW50IiwiZ2V0Tm9uY2UiLCJnZXRBdHRyaWJ1dGUiLCJfaW5zZXJ0UnVsZSIsImNvbnRhaW5lciIsImFwcGVuZFJ1bGUiLCJjc3NSdWxlcyIsImdldFZhbGlkUnVsZUluc2VydGlvbkluZGV4IiwibWF4SW5kZXgiLCJjcmVhdGVTdHlsZSIsImVsIiwidGV4dENvbnRlbnQiLCJEb21SZW5kZXJlciIsImhhc0luc2VydGVkUnVsZXMiLCJtZWRpYSIsIm1ldGEiLCJzZXRBdHRyaWJ1dGUiLCJub25jZSIsInJlbW92ZUNoaWxkIiwiaW5zZXJ0UnVsZXMiLCJuYXRpdmVQYXJlbnQiLCJsYXRlc3ROYXRpdmVQYXJlbnQiLCJfaW5zZXJ0aW9uSW5kZXgiLCJyZWZDc3NSdWxlIiwicnVsZVN0ciIsImluc2VydGlvbkluZGV4IiwibmF0aXZlUnVsZSIsImdldFJ1bGVzIiwiaW5zdGFuY2VDb3VudGVyIiwiSnNzIiwidmVyc2lvbiIsImlzSW5Ccm93c2VyIiwic2V0dXAiLCJjcmVhdGVTdHlsZVNoZWV0IiwicmVtb3ZlU3R5bGVTaGVldCIsImNyZWF0ZVJ1bGUkMSIsImNyZWF0ZUpzcyIsImhhc0NTU1RPTVN1cHBvcnQiLCJnZXREeW5hbWljU3R5bGVzIiwiZXh0cmFjdGVkIiwibm93IiwiZm5WYWx1ZXNOcyIsImZuUnVsZU5zIiwiZnVuY3Rpb25QbHVnaW4iLCJmblZhbHVlcyIsInN0eWxlUnVsZSIsImZuUnVsZSIsImF0UHJlZml4IiwiR2xvYmFsQ29udGFpbmVyUnVsZSIsIkdsb2JhbFByZWZpeGVkUnVsZSIsInNlcGFyYXRvclJlZ0V4cCIsImFkZFNjb3BlIiwic2NvcGUiLCJwYXJ0cyIsImhhbmRsZU5lc3RlZEdsb2JhbENvbnRhaW5lclJ1bGUiLCJoYW5kbGVQcmVmaXhlZEdsb2JhbFJ1bGUiLCJqc3NHbG9iYWwiLCJwYXJlbnRSZWdFeHAiLCJqc3NOZXN0ZWQiLCJnZXRSZXBsYWNlUmVmIiwicmVwbGFjZVBhcmVudFJlZnMiLCJuZXN0ZWRQcm9wIiwicGFyZW50UHJvcCIsInBhcmVudFNlbGVjdG9ycyIsIm5lc3RlZFNlbGVjdG9ycyIsImoiLCJnZXRPcHRpb25zIiwicHJldk9wdGlvbnMiLCJuZXN0aW5nTGV2ZWwiLCJpc05lc3RlZCIsImlzTmVzdGVkQ29uZGl0aW9uYWwiLCJ1cHBlcmNhc2VQYXR0ZXJuIiwibXNQYXR0ZXJuIiwiY2FjaGUiLCJ0b0h5cGhlbkxvd2VyIiwidG9Mb3dlckNhc2UiLCJoeXBoZW5hdGVTdHlsZU5hbWUiLCJoTmFtZSIsImNvbnZlcnRDYXNlIiwiY29udmVydGVkIiwiaHlwaGVuYXRlIiwiY2FtZWxDYXNlIiwiaHlwaGVuYXRlZFByb3AiLCJweCIsIm1zIiwicGVyY2VudCIsImRlZmF1bHRVbml0cyIsImJvcmRlciIsIm1hcmdpbiIsInBhZGRpbmciLCJib3R0b20iLCJsZWZ0IiwidG9wIiwicmlnaHQiLCJpbnNldCIsIm1vdGlvbiIsIm91dGxpbmUiLCJwZXJzcGVjdGl2ZSIsImdhcCIsImdyaWQiLCJhZGRDYW1lbENhc2VkVmVyc2lvbiIsInJlZ0V4cCIsInRvVXBwZXJDYXNlIiwibmV3T2JqIiwidW5pdHMiLCJpdGVyYXRlIiwiaW5uZXJQcm9wIiwiX2lubmVyUHJvcCIsImRlZmF1bHRVbml0IiwiY2FtZWxDYXNlZE9wdGlvbnMiLCJqcyIsInZlbmRvciIsImJyb3dzZXIiLCJpc1RvdWNoIiwiZG9jdW1lbnRFbGVtZW50IiwianNDc3NNYXAiLCJNb3oiLCJPIiwiV2Via2l0IiwiX2RvY3VtZW50JGNyZWF0ZUVsZW1lIiwidGVzdFByb3AiLCJzdXBwb3J0ZWRLZXlmcmFtZXMiLCJhcHBlYXJlbmNlIiwibm9QcmVmaWxsIiwic3VwcG9ydGVkUHJvcGVydHkiLCJjb2xvckFkanVzdCIsInRvVXBwZXIiLCJjIiwiY2FtZWxpemUiLCJwYXNjYWxpemUiLCJtYXNrIiwibG9uZ2hhbmQiLCJ0ZXh0T3JpZW50YXRpb24iLCJ0cmFuc2l0aW9uIiwid3JpdGluZ01vZGUiLCJ1c2VyU2VsZWN0IiwiYnJlYWtQcm9wc09sZCIsImpzUHJvcCIsIl9qc1Byb3AiLCJpbmxpbmVMb2dpY2FsT2xkIiwibmV3UHJvcCIsInVucHJlZml4ZWQiLCJwcmVmaXhlZCIsInBhc2NhbGl6ZWQiLCJzY3JvbGxTbmFwIiwib3ZlcnNjcm9sbEJlaGF2aW9yIiwicHJvcE1hcCIsIm9yZGVyIiwiZmxleDIwMTIiLCJwcm9wTWFwJDEiLCJmbGV4IiwicHJvcEtleXMiLCJwcmVmaXhDc3MiLCJmbGV4MjAwOSIsIm11bHRpcGxlIiwicHJvcGVydHlEZXRlY3RvcnMiLCJjb21wdXRlZCIsImdldENvbXB1dGVkU3R5bGUiLCJrZXkkMSIsImNhY2hlJDEiLCJ0cmFuc2l0aW9uUHJvcGVydGllcyIsInRyYW5zUHJvcHNSZWdFeHAiLCJlbCQxIiwicHJlZml4VHJhbnNpdGlvbkNhbGxiYWNrIiwicDEiLCJwMiIsInByZWZpeGVkVmFsdWUiLCJzdXBwb3J0ZWRWYWx1ZSIsInByb3BlcnR5IiwianNzVmVuZG9yUHJlZml4ZXIiLCJhdFJ1bGUiLCJwcmVmaXhTdHlsZSIsImNoYW5nZVByb3AiLCJzdXBwb3J0ZWRQcm9wIiwiY2hhbmdlVmFsdWUiLCJzdXBwb3J0ZWRWYWx1ZSQxIiwianNzUHJvcHNTb3J0Iiwic29ydCIsInByb3AwIiwicHJvcDEiLCJqc3NQcmVzZXQiLCJmdW5jdGlvbnMiLCJnbG9iYWwiLCJ2ZW5kb3JQcmVmaXhlciIsInByb3BzU29ydCIsIm1lcmdlQ2xhc3NlcyIsImJhc2VDbGFzc2VzIiwibmV3Q2xhc3NlcyIsIm5leHRDbGFzc2VzIiwibXVsdGlLZXlTdG9yZSIsImtleTEiLCJrZXkyIiwic3ViQ2FjaGUiLCJNYXAiLCJfZGVsZXRlIiwiVGhlbWVDb250ZXh0IiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlVGhlbWUiLCJ1c2VDb250ZXh0IiwidXNlRGVidWdWYWx1ZSIsImdlbmVyYXRlQ2xhc3NOYW1lIiwic2hlZXRzTWFuYWdlciIsImRlZmF1bHRPcHRpb25zIiwiZGlzYWJsZUdlbmVyYXRpb24iLCJzaGVldHNDYWNoZSIsInNoZWV0c1JlZ2lzdHJ5IiwiU3R5bGVzQ29udGV4dCIsImluamVjdEZpcnN0Tm9kZSIsIlN0eWxlc1Byb3ZpZGVyIiwiX3Byb3BzJGluamVjdEZpcnN0IiwiaW5qZWN0Rmlyc3QiLCJfcHJvcHMkZGlzYWJsZUdlbmVyYXQiLCJsb2NhbE9wdGlvbnMiLCJvdXRlck9wdGlvbnMiLCJjb250ZXh0IiwiY3JlYXRlQ29tbWVudCIsIlByb3ZpZGVyIiwic2VydmVyR2VuZXJhdGVDbGFzc05hbWUiLCJpbmRleENvdW50ZXIiLCJpbmNyZW1lbnQiLCJub29wVGhlbWUiLCJnZXRTdHlsZXNDcmVhdG9yIiwic3R5bGVzT3JDcmVhdG9yIiwidGhlbWluZ0VuYWJsZWQiLCJzdHlsZXNXaXRoT3ZlcnJpZGVzIiwiZ2V0Q2xhc3NlcyIsInN0YXRlIiwic3R5bGVzT3B0aW9ucyIsImNhY2hlQ2xhc3NlcyIsImxhc3RQcm9wIiwibGFzdEpTUyIsImdlbmVyYXRlIiwiX3JlZjIiLCJzdHlsZXNDcmVhdG9yIiwic2hlZXRNYW5hZ2VyIiwicmVmcyIsInN0YXRpY1NoZWV0IiwiZHluYW1pY1N0eWxlcyIsImZsaXAiLCJkeW5hbWljU2hlZXQiLCJfcmVmMyIsIl9yZWY0IiwidXNlU3luY2hyb25vdXNFZmZlY3QiLCJ1c2VSZWYiLCJjdXJyZW50S2V5IiwidXNlTWVtbyIsImN1cnJlbnQiLCJ1c2VFZmZlY3QiLCJtYWtlU3R5bGVzIiwiY2xhc3NOYW1lUHJlZml4T3B0aW9uIiwiX29wdGlvbnMkZGVmYXVsdFRoZW1lIiwiZGVmYXVsdFRoZW1lIiwic3R5bGVzT3B0aW9uczIiLCJ1c2VTdHlsZXMiLCJpbnN0YW5jZSIsInNob3VsZFVwZGF0ZSIsIl9jbGFzc0NhbGxDaGVjayIsInJlYWN0SXMiLCJSRUFDVF9TVEFUSUNTIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJjb250ZXh0VHlwZSIsImNvbnRleHRUeXBlcyIsImdldERlZmF1bHRQcm9wcyIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIktOT1dOX1NUQVRJQ1MiLCJjYWxsZXIiLCJjYWxsZWUiLCJhcml0eSIsIkZPUldBUkRfUkVGX1NUQVRJQ1MiLCJNRU1PX1NUQVRJQ1MiLCJjb21wYXJlIiwiVFlQRV9TVEFUSUNTIiwiZ2V0U3RhdGljcyIsImNvbXBvbmVudCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldFByb3RvdHlwZU9mIiwib2JqZWN0UHJvdG90eXBlIiwiaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJ0YXJnZXRDb21wb25lbnQiLCJzb3VyY2VDb21wb25lbnQiLCJibGFja2xpc3QiLCJpbmhlcml0ZWRDb21wb25lbnQiLCJ0YXJnZXRTdGF0aWNzIiwic291cmNlU3RhdGljcyIsImUiLCJ3aXRoU3R5bGVzIiwiX29wdGlvbnMkd2l0aFRoZW1lIiwid2l0aFRoZW1lIiwiV2l0aFN0eWxlcyIsImZvcndhcmRSZWYiLCJpbm5lclJlZiIsIm1vcmUiLCJOYWtlZCIsInVzZVRoZW1lV2l0aG91dERlZmF1bHQiLCJ3aXRoU3R5bGVzV2l0aG91dERlZmF1bHQiLCJkZXByZWNhdGVkUHJvcFR5cGUiLCJ2YWxpZGF0b3IiLCJyZWFzb24iLCJjb21wb25lbnROYW1lU2FmZSIsInByb3BGdWxsTmFtZVNhZmUiLCJzZXRSZWYiLCJ1c2VGb3JrUmVmIiwicmVmQSIsInJlZkIiLCJyZWZWYWx1ZSIsImdldENvbnRhaW5lciIsIlJlYWN0RE9NIiwiZmluZERPTU5vZGUiLCJ1c2VFbmhhbmNlZEVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsIl9wcm9wcyRkaXNhYmxlUG9ydGFsIiwiZGlzYWJsZVBvcnRhbCIsIm9uUmVuZGVyZWQiLCJfUmVhY3QkdXNlU3RhdGUiLCJ1c2VTdGF0ZSIsIm1vdW50Tm9kZSIsInNldE1vdW50Tm9kZSIsImhhbmRsZVJlZiIsImJvZHkiLCJjbG9uZUVsZW1lbnQiLCJjcmVhdGVQb3J0YWwiLCJjcmVhdGVDaGFpbmVkRnVuY3Rpb24iLCJmdW5jcyIsImNoYWluZWRGdW5jdGlvbiIsIl9sZW4yIiwiX2tleTIiLCJmbGlwUGxhY2VtZW50IiwicGxhY2VtZW50IiwiZ2V0QW5jaG9yRWwiLCJhbmNob3JFbCIsImRlZmF1bHRQb3BwZXJPcHRpb25zIiwiUG9wcGVyIiwiX3Byb3BzJGtlZXBNb3VudGVkIiwia2VlcE1vdW50ZWQiLCJtb2RpZmllcnMiLCJvcGVuIiwiX3Byb3BzJHBsYWNlbWVudCIsImluaXRpYWxQbGFjZW1lbnQiLCJfcHJvcHMkcG9wcGVyT3B0aW9ucyIsInBvcHBlck9wdGlvbnMiLCJwb3BwZXJSZWZQcm9wIiwicG9wcGVyUmVmIiwiX3Byb3BzJHRyYW5zaXRpb24iLCJ0b29sdGlwUmVmIiwib3duUmVmIiwiaGFuZGxlUG9wcGVyUmVmIiwiaGFuZGxlUG9wcGVyUmVmUmVmIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImV4aXRlZCIsInNldEV4aXRlZCIsInJ0bFBsYWNlbWVudCIsIl9SZWFjdCR1c2VTdGF0ZTIiLCJzZXRQbGFjZW1lbnQiLCJoYW5kbGVPcGVuIiwidXNlQ2FsbGJhY2siLCJkZXN0cm95IiwiaGFuZGxlUG9wcGVyVXBkYXRlIiwicmVzb2x2ZWRBbmNob3JFbCIsImJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBvcHBlciIsIlBvcHBlckpzIiwicHJldmVudE92ZXJmbG93IiwiYm91bmRhcmllc0VsZW1lbnQiLCJvbkNyZWF0ZSIsImhhbmRsZUVudGVyIiwiaGFuZGxlQ2xvc2UiLCJoYW5kbGVFeGl0ZWQiLCJjaGlsZFByb3BzIiwiVHJhbnNpdGlvblByb3BzIiwiaW4iLCJvbkVudGVyIiwib25FeGl0ZWQiLCJyb2xlIiwicG9zaXRpb24iLCJkaXNwbGF5IiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJjYXBpdGFsaXplIiwiYm94U2l6aW5nIiwibGlzdFN0eWxlIiwiY29sb3JQcmltYXJ5IiwiY29sb3JJbmhlcml0Iiwic3RpY2t5IiwiYmFja2dyb3VuZENvbG9yIiwiTGlzdFN1YmhlYWRlciIsImNsYXNzTmFtZSIsIl9wcm9wcyRjb2xvciIsIl9wcm9wcyRjb21wb25lbnQiLCJfcHJvcHMkZGlzYWJsZUd1dHRlcnMiLCJkaXNhYmxlR3V0dGVycyIsIl9wcm9wcyRkaXNhYmxlU3RpY2t5IiwiZGlzYWJsZVN0aWNreSIsIl9wcm9wcyRpbnNldCIsImNsc3giLCJlbGV2YXRpb25zIiwic2hhZG93IiwiYm94U2hhZG93Iiwicm91bmRlZCIsIm91dGxpbmVkIiwiUGFwZXIiLCJfcHJvcHMkc3F1YXJlIiwic3F1YXJlIiwiX3Byb3BzJGVsZXZhdGlvbiIsImVsZXZhdGlvbiIsIl9wcm9wcyR2YXJpYW50IiwidmFyaWFudCIsInVzZUV2ZW50Q2FsbGJhY2siLCJoYWRLZXlib2FyZEV2ZW50IiwiaGFkRm9jdXNWaXNpYmxlUmVjZW50bHkiLCJoYWRGb2N1c1Zpc2libGVSZWNlbnRseVRpbWVvdXQiLCJpbnB1dFR5cGVzV2hpdGVsaXN0Iiwic2VhcmNoIiwidXJsIiwidGVsIiwiZW1haWwiLCJwYXNzd29yZCIsImRhdGUiLCJtb250aCIsIndlZWsiLCJ0aW1lIiwiZGF0ZXRpbWUiLCJmb2N1c1RyaWdnZXJzS2V5Ym9hcmRNb2RhbGl0eSIsInRhZ05hbWUiLCJyZWFkT25seSIsImlzQ29udGVudEVkaXRhYmxlIiwiaGFuZGxlS2V5RG93biIsImV2ZW50IiwibWV0YUtleSIsImFsdEtleSIsImN0cmxLZXkiLCJoYW5kbGVQb2ludGVyRG93biIsImhhbmRsZVZpc2liaWxpdHlDaGFuZ2UiLCJ2aXNpYmlsaXR5U3RhdGUiLCJwcmVwYXJlIiwiZG9jIiwiYWRkRXZlbnRMaXN0ZW5lciIsImlzRm9jdXNWaXNpYmxlIiwibWF0Y2hlcyIsImhhbmRsZUJsdXJWaXNpYmxlIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInVzZUlzRm9jdXNWaXNpYmxlIiwib3duZXJEb2N1bWVudCIsIm9uQmx1clZpc2libGUiLCJ0aW1lb3V0c1NoYXBlIiwiZW50ZXIiLCJleGl0IiwiYXBwZWFyIiwiZW50ZXJEb25lIiwiZW50ZXJBY3RpdmUiLCJleGl0RG9uZSIsImV4aXRBY3RpdmUiLCJVTk1PVU5URUQiLCJFWElURUQiLCJFTlRFUklORyIsIkVOVEVSRUQiLCJFWElUSU5HIiwiVHJhbnNpdGlvbiIsIl9SZWFjdCRDb21wb25lbnQiLCJwYXJlbnRHcm91cCIsImlzTW91bnRpbmciLCJpbml0aWFsU3RhdHVzIiwiYXBwZWFyU3RhdHVzIiwidW5tb3VudE9uRXhpdCIsIm1vdW50T25FbnRlciIsInN0YXR1cyIsIm5leHRDYWxsYmFjayIsInByZXZTdGF0ZSIsIm5leHRJbiIsImNvbXBvbmVudERpZE1vdW50IiwidXBkYXRlU3RhdHVzIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwibmV4dFN0YXR1cyIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiY2FuY2VsTmV4dENhbGxiYWNrIiwiZ2V0VGltZW91dHMiLCJ0aW1lb3V0IiwibW91bnRpbmciLCJwZXJmb3JtRW50ZXIiLCJwZXJmb3JtRXhpdCIsInNldFN0YXRlIiwiX3RoaXMyIiwiYXBwZWFyaW5nIiwibm9kZVJlZiIsIm1heWJlTm9kZSIsIm1heWJlQXBwZWFyaW5nIiwidGltZW91dHMiLCJlbnRlclRpbWVvdXQiLCJjb25maWciLCJzYWZlU2V0U3RhdGUiLCJvbkVudGVyZWQiLCJvbkVudGVyaW5nIiwib25UcmFuc2l0aW9uRW5kIiwiX3RoaXMzIiwib25FeGl0Iiwib25FeGl0aW5nIiwiY2FuY2VsIiwibmV4dFN0YXRlIiwiY2FsbGJhY2siLCJzZXROZXh0Q2FsbGJhY2siLCJfdGhpczQiLCJoYW5kbGVyIiwiZG9lc05vdEhhdmVUaW1lb3V0T3JMaXN0ZW5lciIsImFkZEVuZExpc3RlbmVyIiwibWF5YmVOZXh0Q2FsbGJhY2siLCJfdGhpcyRwcm9wcyIsIlRyYW5zaXRpb25Hcm91cENvbnRleHQiLCJDaGlsZHJlbiIsImRlZmF1bHRWaWV3IiwicHQiLCJub29wIiwiZ2V0Q2hpbGRNYXBwaW5nIiwibWFwRm4iLCJtYXBwZXIiLCJtZXJnZUNoaWxkTWFwcGluZ3MiLCJwcmV2IiwiZ2V0VmFsdWVGb3JLZXkiLCJuZXh0S2V5c1BlbmRpbmciLCJwZW5kaW5nS2V5cyIsInByZXZLZXkiLCJjaGlsZE1hcHBpbmciLCJuZXh0S2V5IiwicGVuZGluZ05leHRLZXkiLCJnZXRQcm9wIiwiZ2V0SW5pdGlhbENoaWxkTWFwcGluZyIsImdldE5leHRDaGlsZE1hcHBpbmciLCJuZXh0UHJvcHMiLCJwcmV2Q2hpbGRNYXBwaW5nIiwibmV4dENoaWxkTWFwcGluZyIsImhhc1ByZXYiLCJoYXNOZXh0IiwicHJldkNoaWxkIiwiaXNMZWF2aW5nIiwiY2hpbGRGYWN0b3J5IiwiVHJhbnNpdGlvbkdyb3VwIiwiY29udGV4dFZhbHVlIiwiZmlyc3RSZW5kZXIiLCJtb3VudGVkIiwiY3VycmVudENoaWxkTWFwcGluZyIsIlJpcHBsZSIsIl9wcm9wcyRwdWxzYXRlIiwicHVsc2F0ZSIsInJpcHBsZVgiLCJyaXBwbGVZIiwicmlwcGxlU2l6ZSIsImluUHJvcCIsIl9wcm9wcyRvbkV4aXRlZCIsImxlYXZpbmciLCJzZXRMZWF2aW5nIiwicmlwcGxlQ2xhc3NOYW1lIiwicmlwcGxlIiwicmlwcGxlVmlzaWJsZSIsInJpcHBsZVB1bHNhdGUiLCJyaXBwbGVTdHlsZXMiLCJjaGlsZENsYXNzTmFtZSIsImNoaWxkTGVhdmluZyIsImNoaWxkUHVsc2F0ZSIsInRpbWVvdXRJZCIsIkRVUkFUSU9OIiwiREVMQVlfUklQUExFIiwib3ZlcmZsb3ciLCJwb2ludGVyRXZlbnRzIiwib3BhY2l0eSIsImFuaW1hdGlvbiIsImFuaW1hdGlvbkR1cmF0aW9uIiwiVG91Y2hSaXBwbGUiLCJfcHJvcHMkY2VudGVyIiwiY2VudGVyIiwiY2VudGVyUHJvcCIsInJpcHBsZXMiLCJzZXRSaXBwbGVzIiwicmlwcGxlQ2FsbGJhY2siLCJpZ25vcmluZ01vdXNlRG93biIsInN0YXJ0VGltZXIiLCJzdGFydFRpbWVyQ29tbWl0Iiwic3RhcnRDb21taXQiLCJjYiIsIm9sZFJpcHBsZXMiLCJfb3B0aW9ucyRwdWxzYXRlIiwiX29wdGlvbnMkY2VudGVyIiwiX29wdGlvbnMkZmFrZUVsZW1lbnQiLCJmYWtlRWxlbWVudCIsInJlY3QiLCJjbGllbnRYIiwiY2xpZW50WSIsInRvdWNoZXMiLCJzcXJ0Iiwic2l6ZVgiLCJzaXplWSIsInN0b3AiLCJwZXJzaXN0IiwibWVtbyIsImFsaWduSXRlbXMiLCJqdXN0aWZ5Q29udGVudCIsIldlYmtpdFRhcEhpZ2hsaWdodENvbG9yIiwiY3Vyc29yIiwidmVydGljYWxBbGlnbiIsInRleHREZWNvcmF0aW9uIiwiYm9yZGVyU3R5bGUiLCJmb2N1c1Zpc2libGUiLCJCdXR0b25CYXNlIiwiYnV0dG9uUmVmUHJvcCIsImJ1dHRvblJlZiIsIl9wcm9wcyRjZW50ZXJSaXBwbGUiLCJjZW50ZXJSaXBwbGUiLCJfcHJvcHMkZGlzYWJsZWQiLCJfcHJvcHMkZGlzYWJsZVJpcHBsZSIsImRpc2FibGVSaXBwbGUiLCJfcHJvcHMkZGlzYWJsZVRvdWNoUmkiLCJkaXNhYmxlVG91Y2hSaXBwbGUiLCJfcHJvcHMkZm9jdXNSaXBwbGUiLCJmb2N1c1JpcHBsZSIsImZvY3VzVmlzaWJsZUNsYXNzTmFtZSIsIm9uQmx1ciIsIm9uQ2xpY2siLCJvbkZvY3VzIiwib25Gb2N1c1Zpc2libGUiLCJvbktleURvd24iLCJvbktleVVwIiwib25Nb3VzZURvd24iLCJvbk1vdXNlTGVhdmUiLCJvbk1vdXNlVXAiLCJvblRvdWNoRW5kIiwib25Ub3VjaE1vdmUiLCJvblRvdWNoU3RhcnQiLCJvbkRyYWdMZWF2ZSIsIl9wcm9wcyR0YWJJbmRleCIsInRhYkluZGV4IiwiVG91Y2hSaXBwbGVQcm9wcyIsIl9wcm9wcyR0eXBlIiwiZ2V0QnV0dG9uTm9kZSIsInJpcHBsZVJlZiIsInNldEZvY3VzVmlzaWJsZSIsIl91c2VJc0ZvY3VzVmlzaWJsZSIsImZvY3VzVmlzaWJsZVJlZiIsInVzZVJpcHBsZUhhbmRsZXIiLCJyaXBwbGVBY3Rpb24iLCJldmVudENhbGxiYWNrIiwic2tpcFJpcHBsZUFjdGlvbiIsImlnbm9yZSIsImhhbmRsZU1vdXNlRG93biIsImhhbmRsZURyYWdMZWF2ZSIsImhhbmRsZU1vdXNlVXAiLCJoYW5kbGVNb3VzZUxlYXZlIiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVUb3VjaFN0YXJ0IiwiaGFuZGxlVG91Y2hFbmQiLCJoYW5kbGVUb3VjaE1vdmUiLCJoYW5kbGVCbHVyIiwiaGFuZGxlRm9jdXMiLCJjdXJyZW50VGFyZ2V0IiwiaXNOb25OYXRpdmVCdXR0b24iLCJocmVmIiwia2V5ZG93blJlZiIsImhhbmRsZUtleVVwIiwiZGVmYXVsdFByZXZlbnRlZCIsIkNvbXBvbmVudFByb3AiLCJidXR0b25Qcm9wcyIsImhhbmRsZVVzZXJSZWYiLCJoYW5kbGVPd25SZWYiLCJtb3VudGVkU3RhdGUiLCJzZXRNb3VudGVkU3RhdGUiLCJlbmFibGVUb3VjaFJpcHBsZSIsInRleHRBbGlnbiIsImVkZ2VTdGFydCIsIm1hcmdpbkxlZnQiLCJlZGdlRW5kIiwibWFyZ2luUmlnaHQiLCJjb2xvclNlY29uZGFyeSIsInNpemVTbWFsbCIsImxhYmVsIiwiSWNvbkJ1dHRvbiIsIl9wcm9wcyRlZGdlIiwiZWRnZSIsIl9wcm9wcyRkaXNhYmxlRm9jdXNSaSIsImRpc2FibGVGb2N1c1JpcHBsZSIsIl9wcm9wcyRzaXplIiwiZm91bmQiLCJ0b0FycmF5Iiwic29tZSIsImZpbGwiLCJmbGV4U2hyaW5rIiwiY29sb3JBY3Rpb24iLCJjb2xvckVycm9yIiwiY29sb3JEaXNhYmxlZCIsImZvbnRTaXplSW5oZXJpdCIsImZvbnRTaXplU21hbGwiLCJmb250U2l6ZUxhcmdlIiwiU3ZnSWNvbiIsIl9wcm9wcyRmb250U2l6ZSIsImh0bWxDb2xvciIsInRpdGxlQWNjZXNzIiwiX3Byb3BzJHZpZXdCb3giLCJ2aWV3Qm94IiwiZm9jdXNhYmxlIiwic2hhcGVSZW5kZXJpbmciLCJtdWlOYW1lIiwiY3JlYXRlU3ZnSWNvbiIsInBhdGgiLCJkIiwidW5zdXBwb3J0ZWRQcm9wIiwiZGVsZXRlSWNvbkNvbG9yIiwid2hpdGVTcGFjZSIsImNsaWNrYWJsZSIsImNsaWNrYWJsZUNvbG9yUHJpbWFyeSIsImNsaWNrYWJsZUNvbG9yU2Vjb25kYXJ5IiwiZGVsZXRhYmxlIiwiZGVsZXRhYmxlQ29sb3JQcmltYXJ5IiwiZGVsZXRhYmxlQ29sb3JTZWNvbmRhcnkiLCJvdXRsaW5lZFByaW1hcnkiLCJvdXRsaW5lZFNlY29uZGFyeSIsImF2YXRhciIsImF2YXRhclNtYWxsIiwiYXZhdGFyQ29sb3JQcmltYXJ5IiwiYXZhdGFyQ29sb3JTZWNvbmRhcnkiLCJpY29uU21hbGwiLCJpY29uQ29sb3JQcmltYXJ5IiwiaWNvbkNvbG9yU2Vjb25kYXJ5IiwidGV4dE92ZXJmbG93IiwibGFiZWxTbWFsbCIsImRlbGV0ZUljb24iLCJkZWxldGVJY29uU21hbGwiLCJkZWxldGVJY29uQ29sb3JQcmltYXJ5IiwiZGVsZXRlSWNvbkNvbG9yU2Vjb25kYXJ5IiwiZGVsZXRlSWNvbk91dGxpbmVkQ29sb3JQcmltYXJ5IiwiZGVsZXRlSWNvbk91dGxpbmVkQ29sb3JTZWNvbmRhcnkiLCJpc0RlbGV0ZUtleWJvYXJkRXZlbnQiLCJrZXlib2FyZEV2ZW50IiwiQ2hpcCIsImF2YXRhclByb3AiLCJjbGlja2FibGVQcm9wIiwiZGVsZXRlSWNvblByb3AiLCJpY29uUHJvcCIsIm9uRGVsZXRlIiwiY2hpcFJlZiIsImhhbmRsZURlbGV0ZUljb25DbGljayIsInN0b3BQcm9wYWdhdGlvbiIsImJsdXIiLCJzbWFsbCIsIm1vcmVQcm9wcyIsImN1c3RvbUNsYXNzZXMiLCJDYW5jZWxJY29uIiwiZGVib3VuY2UiLCJ3YWl0IiwiZGVib3VuY2VkIiwidGhhdCIsImxhdGVyIiwiY2xlYXIiLCJpc011aUVsZW1lbnQiLCJtdWlOYW1lcyIsIm93bmVyV2luZG93IiwidXNlQ29udHJvbGxlZCIsImNvbnRyb2xsZWQiLCJkZWZhdWx0UHJvcCIsIl9yZWYkc3RhdGUiLCJfUmVhY3QkdXNlUmVmIiwiaXNDb250cm9sbGVkIiwidmFsdWVTdGF0ZSIsInNldFZhbHVlIiwiX1JlYWN0JHVzZVJlZjIiLCJkZWZhdWx0VmFsdWUiLCJzZXRWYWx1ZUlmVW5jb250cm9sbGVkIiwidXNlSWQiLCJpZE92ZXJyaWRlIiwiZGVmYXVsdElkIiwic2V0RGVmYXVsdElkIiwicmFuZG9tIiwic3RyaXBEaWFjcml0aWNzIiwibm9ybWFsaXplIiwiY3JlYXRlRmlsdGVyT3B0aW9ucyIsIl9jb25maWckaWdub3JlQWNjZW50cyIsImlnbm9yZUFjY2VudHMiLCJfY29uZmlnJGlnbm9yZUNhc2UiLCJpZ25vcmVDYXNlIiwibGltaXQiLCJfY29uZmlnJG1hdGNoRnJvbSIsIm1hdGNoRnJvbSIsIl9jb25maWckdHJpbSIsImlucHV0VmFsdWUiLCJnZXRPcHRpb25MYWJlbCIsImlucHV0IiwiZmlsdGVyZWRPcHRpb25zIiwib3B0aW9uIiwiY2FuZGlkYXRlIiwiZmluZEluZGV4IiwiY29tcCIsImRlZmF1bHRGaWx0ZXJPcHRpb25zIiwicGFnZVNpemUiLCJ1c2VBdXRvY29tcGxldGUiLCJfcHJvcHMkYXV0b0NvbXBsZXRlIiwiYXV0b0NvbXBsZXRlIiwiX3Byb3BzJGF1dG9IaWdobGlnaHQiLCJhdXRvSGlnaGxpZ2h0IiwiX3Byb3BzJGF1dG9TZWxlY3QiLCJhdXRvU2VsZWN0IiwiX3Byb3BzJGJsdXJPblNlbGVjdCIsImJsdXJPblNlbGVjdCIsIl9wcm9wcyRjbGVhck9uQmx1ciIsImNsZWFyT25CbHVyIiwiZnJlZVNvbG8iLCJfcHJvcHMkY2xlYXJPbkVzY2FwZSIsImNsZWFyT25Fc2NhcGUiLCJfcHJvcHMkY29tcG9uZW50TmFtZSIsIl9wcm9wcyRkZWJ1ZyIsImRlYnVnIiwiX3Byb3BzJGRlZmF1bHRWYWx1ZSIsIl9wcm9wcyRkaXNhYmxlQ2xlYXJhYiIsImRpc2FibGVDbGVhcmFibGUiLCJfcHJvcHMkZGlzYWJsZUNsb3NlT24iLCJkaXNhYmxlQ2xvc2VPblNlbGVjdCIsIl9wcm9wcyRkaXNhYmxlZEl0ZW1zRiIsImRpc2FibGVkSXRlbXNGb2N1c2FibGUiLCJfcHJvcHMkZGlzYWJsZUxpc3RXcmEiLCJkaXNhYmxlTGlzdFdyYXAiLCJfcHJvcHMkZmlsdGVyT3B0aW9ucyIsImZpbHRlck9wdGlvbnMiLCJfcHJvcHMkZmlsdGVyU2VsZWN0ZWQiLCJmaWx0ZXJTZWxlY3RlZE9wdGlvbnMiLCJfcHJvcHMkZnJlZVNvbG8iLCJnZXRPcHRpb25EaXNhYmxlZCIsIl9wcm9wcyRnZXRPcHRpb25MYWJlbCIsImdldE9wdGlvbkxhYmVsUHJvcCIsIl9wcm9wcyRnZXRPcHRpb25TZWxlYyIsImdldE9wdGlvblNlbGVjdGVkIiwiZ3JvdXBCeSIsIl9wcm9wcyRoYW5kbGVIb21lRW5kSyIsImhhbmRsZUhvbWVFbmRLZXlzIiwiaWRQcm9wIiwiX3Byb3BzJGluY2x1ZGVJbnB1dEluIiwiaW5jbHVkZUlucHV0SW5MaXN0IiwiaW5wdXRWYWx1ZVByb3AiLCJfcHJvcHMkbXVsdGlwbGUiLCJvbkNoYW5nZSIsIm9uQ2xvc2UiLCJvbkhpZ2hsaWdodENoYW5nZSIsIm9uSW5wdXRDaGFuZ2UiLCJvbk9wZW4iLCJvcGVuUHJvcCIsIl9wcm9wcyRvcGVuT25Gb2N1cyIsIm9wZW5PbkZvY3VzIiwiX3Byb3BzJHNlbGVjdE9uRm9jdXMiLCJzZWxlY3RPbkZvY3VzIiwidmFsdWVQcm9wIiwib3B0aW9uTGFiZWwiLCJlcnJvbmVvdXNSZXR1cm4iLCJpZ25vcmVGb2N1cyIsImZpcnN0Rm9jdXMiLCJpbnB1dFJlZiIsImxpc3Rib3hSZWYiLCJzZXRBbmNob3JFbCIsImZvY3VzZWRUYWciLCJzZXRGb2N1c2VkVGFnIiwiZGVmYXVsdEhpZ2hsaWdodGVkIiwiaGlnaGxpZ2h0ZWRJbmRleFJlZiIsIl91c2VDb250cm9sbGVkIiwiX3VzZUNvbnRyb2xsZWQyIiwiX3VzZUNvbnRyb2xsZWQzIiwiX3VzZUNvbnRyb2xsZWQ0Iiwic2V0SW5wdXRWYWx1ZSIsIl9SZWFjdCR1c2VTdGF0ZTMiLCJmb2N1c2VkIiwic2V0Rm9jdXNlZCIsInJlc2V0SW5wdXRWYWx1ZSIsIm5ld0lucHV0VmFsdWUiLCJfdXNlQ29udHJvbGxlZDUiLCJfdXNlQ29udHJvbGxlZDYiLCJzZXRPcGVuU3RhdGUiLCJpbnB1dFZhbHVlSXNTZWxlY3RlZFZhbHVlIiwicG9wdXBPcGVuIiwidmFsdWUyIiwibWlzc2luZ1ZhbHVlIiwiZm9jdXNUYWciLCJ0YWdUb0ZvY3VzIiwidmFsaWRPcHRpb25JbmRleCIsIm5leHRGb2N1cyIsIm5leHRGb2N1c0Rpc2FibGVkIiwiaGFzQXR0cmlidXRlIiwic2V0SGlnaGxpZ2h0ZWRJbmRleCIsIl9yZWYyJHJlYXNvbiIsInJlbW92ZUF0dHJpYnV0ZSIsImxpc3Rib3hOb2RlIiwicGFyZW50RWxlbWVudCIsInNjcm9sbFRvcCIsInNjcm9sbEhlaWdodCIsInNjcm9sbEJvdHRvbSIsImVsZW1lbnRCb3R0b20iLCJvZmZzZXRUb3AiLCJvZmZzZXRIZWlnaHQiLCJjaGFuZ2VIaWdobGlnaHRlZEluZGV4IiwiZGlmZiIsIl9yZWYzJGRpcmVjdGlvbiIsIl9yZWYzJHJlYXNvbiIsImdldE5leHRJbmRleCIsIm5ld0luZGV4IiwibmV4dEluZGV4Iiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJzeW5jSGlnaGxpZ2h0ZWRJbmRleCIsInZhbHVlSXRlbSIsImN1cnJlbnRPcHRpb24iLCJpdGVtSW5kZXgiLCJvcHRpb25JdGVtIiwiaGFuZGxlTGlzdGJveFJlZiIsImhhbmRsZVZhbHVlIiwiZGV0YWlscyIsInNlbGVjdE5ld1ZhbHVlIiwicmVhc29uUHJvcCIsIm9yaWdpbiIsInZhbGlkVGFnSW5kZXgiLCJoYW5kbGVGb2N1c1RhZyIsIm5leHRUYWciLCJoYW5kbGVDbGVhciIsIndoaWNoIiwiYWN0aXZlRWxlbWVudCIsImhhbmRsZUlucHV0Q2hhbmdlIiwiaGFuZGxlT3B0aW9uTW91c2VPdmVyIiwiaGFuZGxlT3B0aW9uVG91Y2hTdGFydCIsImhhbmRsZU9wdGlvbkNsaWNrIiwiaGFuZGxlVGFnRGVsZXRlIiwiaGFuZGxlUG9wdXBJbmRpY2F0b3IiLCJoYW5kbGVDbGljayIsInNlbGVjdGlvbkVuZCIsInNlbGVjdGlvblN0YXJ0Iiwic2VsZWN0IiwiaGFuZGxlSW5wdXRNb3VzZURvd24iLCJkaXJ0eSIsImdyb3VwZWRPcHRpb25zIiwiaW5kZXhCeSIsImdyb3VwIiwiZ2V0Um9vdFByb3BzIiwiZ2V0SW5wdXRMYWJlbFByb3BzIiwiaHRtbEZvciIsImdldElucHV0UHJvcHMiLCJhdXRvQ2FwaXRhbGl6ZSIsInNwZWxsQ2hlY2siLCJnZXRDbGVhclByb3BzIiwiZ2V0UG9wdXBJbmRpY2F0b3JQcm9wcyIsImdldFRhZ1Byb3BzIiwiZ2V0TGlzdGJveFByb3BzIiwiZ2V0T3B0aW9uUHJvcHMiLCJfcmVmNSIsIm9uTW91c2VPdmVyIiwiX29wdGlvbiIsInZpc2liaWxpdHkiLCJmdWxsV2lkdGgiLCJ0YWciLCJtYXhXaWR0aCIsInRhZ1NpemVTbWFsbCIsImhhc1BvcHVwSWNvbiIsImhhc0NsZWFySWNvbiIsImlucHV0Um9vdCIsImZsZXhXcmFwIiwibWluV2lkdGgiLCJwYWRkaW5nQm90dG9tIiwicGFkZGluZ1RvcCIsImZsZXhHcm93IiwiaW5wdXRGb2N1c2VkIiwiZW5kQWRvcm5tZW50IiwiY2xlYXJJbmRpY2F0b3IiLCJjbGVhckluZGljYXRvckRpcnR5IiwicG9wdXBJbmRpY2F0b3IiLCJwb3B1cEluZGljYXRvck9wZW4iLCJwb3BwZXJEaXNhYmxlUG9ydGFsIiwibGlzdGJveCIsIm1heEhlaWdodCIsImxvYWRpbmciLCJub09wdGlvbnMiLCJncm91cExhYmVsIiwiZ3JvdXBVbCIsIkRpc2FibGVQb3J0YWwiLCJDbG9zZUljb24iLCJBcnJvd0Ryb3BEb3duSWNvbiIsIkF1dG9jb21wbGV0ZSIsIkNoaXBQcm9wcyIsIl9wcm9wcyRjbGVhclRleHQiLCJjbGVhclRleHQiLCJfcHJvcHMkY2xvc2VJY29uIiwiY2xvc2VJY29uIiwiX3Byb3BzJGNsb3NlVGV4dCIsImNsb3NlVGV4dCIsIl9wcm9wcyRmb3JjZVBvcHVwSWNvbiIsImZvcmNlUG9wdXBJY29uIiwiX3Byb3BzJGZ1bGxXaWR0aCIsIl9wcm9wcyRnZXRMaW1pdFRhZ3NUZSIsImdldExpbWl0VGFnc1RleHQiLCJfcHJvcHMkbGltaXRUYWdzIiwibGltaXRUYWdzIiwiX3Byb3BzJExpc3Rib3hDb21wb25lIiwiTGlzdGJveENvbXBvbmVudCIsIkxpc3Rib3hQcm9wcyIsIl9wcm9wcyRsb2FkaW5nIiwiX3Byb3BzJGxvYWRpbmdUZXh0IiwibG9hZGluZ1RleHQiLCJfcHJvcHMkbm9PcHRpb25zVGV4dCIsIm5vT3B0aW9uc1RleHQiLCJfcHJvcHMkb3BlblRleHQiLCJvcGVuVGV4dCIsIl9wcm9wcyRQYXBlckNvbXBvbmVudCIsIlBhcGVyQ29tcG9uZW50IiwiX3Byb3BzJFBvcHBlckNvbXBvbmVuIiwiUG9wcGVyQ29tcG9uZW50IiwiUG9wcGVyQ29tcG9uZW50UHJvcCIsIl9wcm9wcyRwb3B1cEljb24iLCJwb3B1cEljb24iLCJyZW5kZXJHcm91cFByb3AiLCJyZW5kZXJHcm91cCIsInJlbmRlcklucHV0IiwicmVuZGVyT3B0aW9uUHJvcCIsInJlbmRlck9wdGlvbiIsInJlbmRlclRhZ3MiLCJfdXNlQXV0b2NvbXBsZXRlIiwic3RhcnRBZG9ybm1lbnQiLCJnZXRDdXN0b21pemVkVGFnUHJvcHMiLCJkZWZhdWx0UmVuZGVyR3JvdXAiLCJyZW5kZXJMaXN0T3B0aW9uIiwib3B0aW9uUHJvcHMiLCJJbnB1dExhYmVsUHJvcHMiLCJJbnB1dFByb3BzIiwidGl0bGUiLCJpbnB1dFByb3BzIiwib3B0aW9uMiIsImluZGV4MiIsImZvcm1Db250cm9sU3RhdGUiLCJzdGF0ZXMiLCJtdWlGb3JtQ29udHJvbCIsIkZvcm1Db250cm9sQ29udGV4dCIsInVzZUZvcm1Db250cm9sIiwiZ2V0U3R5bGVWYWx1ZSIsImNvbXB1dGVkU3R5bGUiLCJUZXh0YXJlYUF1dG9zaXplIiwicm93cyIsInJvd3NNYXgiLCJyb3dzTWluUHJvcCIsInJvd3NNaW4iLCJtYXhSb3dzUHJvcCIsIm1heFJvd3MiLCJfcHJvcHMkbWluUm93cyIsIm1pblJvd3MiLCJtaW5Sb3dzUHJvcCIsInNoYWRvd1JlZiIsInJlbmRlcnMiLCJzeW5jSGVpZ2h0IiwiaW5wdXRTaGFsbG93IiwicGxhY2Vob2xkZXIiLCJpbm5lckhlaWdodCIsInNpbmdsZVJvd0hlaWdodCIsIm91dGVySGVpZ2h0Iiwib3V0ZXJIZWlnaHRTdHlsZSIsImhhbmRsZVJlc2l6ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVDaGFuZ2UiLCJoYXNWYWx1ZSIsImlzRmlsbGVkIiwiU1NSIiwiaXNBZG9ybmVkU3RhcnQiLCJwbGFjZWhvbGRlckhpZGRlbiIsInBsYWNlaG9sZGVyVmlzaWJsZSIsImZvcm1Db250cm9sIiwiYWRvcm5lZFN0YXJ0IiwiYWRvcm5lZEVuZCIsIm1hcmdpbkRlbnNlIiwibXVsdGlsaW5lIiwiZm9udCIsImFuaW1hdGlvbk5hbWUiLCJpbnB1dE1hcmdpbkRlbnNlIiwiaW5wdXRNdWx0aWxpbmUiLCJyZXNpemUiLCJpbnB1dFR5cGVTZWFyY2giLCJpbnB1dEFkb3JuZWRTdGFydCIsImlucHV0QWRvcm5lZEVuZCIsImlucHV0SGlkZGVuTGFiZWwiLCJJbnB1dEJhc2UiLCJhcmlhRGVzY3JpYmVkYnkiLCJhdXRvRm9jdXMiLCJfcHJvcHMkaW5wdXRDb21wb25lbnQiLCJpbnB1dENvbXBvbmVudCIsIl9wcm9wcyRpbnB1dFByb3BzIiwiaW5wdXRQcm9wc1Byb3AiLCJpbnB1dFJlZlByb3AiLCJfcHJvcHMkbXVsdGlsaW5lIiwicmVuZGVyU3VmZml4IiwiaGFuZGxlSW5wdXRSZWZXYXJuaW5nIiwibm9kZU5hbWUiLCJoYW5kbGVJbnB1dFByb3BzUmVmUHJvcCIsImhhbmRsZUlucHV0UmVmUHJvcCIsImhhbmRsZUlucHV0UmVmIiwicmVnaXN0ZXJFZmZlY3QiLCJmY3MiLCJvbkZpbGxlZCIsIm9uRW1wdHkiLCJjaGVja0RpcnR5IiwiSW5wdXRDb21wb25lbnQiLCJoYW5kbGVBdXRvRmlsbCIsInNldEFkb3JuZWRTdGFydCIsIm9uQW5pbWF0aW9uU3RhcnQiLCJyZXF1aXJlZCIsImhpZGRlbkxhYmVsIiwiYm90dG9tTGluZUNvbG9yIiwibWFyZ2luVG9wIiwiYm9yZGVyQm90dG9tQ29sb3IiLCJ1bmRlcmxpbmUiLCJib3JkZXJCb3R0b20iLCJjb250ZW50IiwiYm9yZGVyQm90dG9tU3R5bGUiLCJJbnB1dCIsImRpc2FibGVVbmRlcmxpbmUiLCJib3JkZXJUb3BMZWZ0UmFkaXVzIiwiYm9yZGVyVG9wUmlnaHRSYWRpdXMiLCJXZWJraXRCb3hTaGFkb3ciLCJXZWJraXRUZXh0RmlsbENvbG9yIiwiY2FyZXRDb2xvciIsIkZpbGxlZElucHV0IiwiYm9yZGVyV2lkdGgiLCJsZWdlbmQiLCJsZWdlbmRMYWJlbGxlZCIsImxlZ2VuZE5vdGNoZWQiLCJOb3RjaGVkT3V0bGluZSIsImxhYmVsV2lkdGhQcm9wIiwibGFiZWxXaWR0aCIsIm5vdGNoZWQiLCJhbGlnbiIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwiYm9yZGVyQ29sb3IiLCJub3RjaGVkT3V0bGluZSIsIk91dGxpbmVkSW5wdXQiLCJfcHJvcHMkbGFiZWxXaWR0aCIsImZpbGxlZCIsImFzdGVyaXNrIiwiRm9ybUxhYmVsIiwidHJhbnNmb3JtT3JpZ2luIiwic2hyaW5rIiwiYW5pbWF0ZWQiLCJJbnB1dExhYmVsIiwiX3Byb3BzJGRpc2FibGVBbmltYXRpIiwiZGlzYWJsZUFuaW1hdGlvbiIsInNocmlua1Byb3AiLCJmbGV4RGlyZWN0aW9uIiwibWFyZ2luTm9ybWFsIiwibWFyZ2luQm90dG9tIiwiRm9ybUNvbnRyb2wiLCJfcHJvcHMkZXJyb3IiLCJ2aXN1YWxseUZvY3VzZWQiLCJfcHJvcHMkaGlkZGVuTGFiZWwiLCJfcHJvcHMkbWFyZ2luIiwiX3Byb3BzJHJlcXVpcmVkIiwiaW5pdGlhbEFkb3JuZWRTdGFydCIsImluaXRpYWxGaWxsZWQiLCJzZXRGaWxsZWQiLCJfZm9jdXNlZCIsInJlZ2lzdGVyZWRJbnB1dCIsImNoaWxkQ29udGV4dCIsImNvbnRhaW5lZCIsIkZvcm1IZWxwZXJUZXh0IiwiZ2V0U2Nyb2xsYmFyU2l6ZSIsInNjcm9sbERpdiIsInNjcm9sbGJhclNpemUiLCJvZmZzZXRXaWR0aCIsImlzT3ZlcmZsb3dpbmciLCJpbm5lcldpZHRoIiwiYXJpYUhpZGRlbiIsInNob3ciLCJnZXRQYWRkaW5nUmlnaHQiLCJhcmlhSGlkZGVuU2libGluZ3MiLCJjdXJyZW50Tm9kZSIsIm5vZGVzVG9FeGNsdWRlIiwiYmxhY2tsaXN0VGFnTmFtZXMiLCJmaW5kSW5kZXhPZiIsImNvbnRhaW5lckluZm8iLCJpZHgiLCJoYW5kbGVDb250YWluZXIiLCJyZXN0b3JlU3R5bGUiLCJyZXN0b3JlUGFkZGluZ3MiLCJmaXhlZE5vZGVzIiwiZGlzYWJsZVNjcm9sbExvY2siLCJxdWVyeVNlbGVjdG9yQWxsIiwic2Nyb2xsQ29udGFpbmVyIiwicmVzdG9yZSIsImdldEhpZGRlblNpYmxpbmdzIiwiaGlkZGVuU2libGluZ3MiLCJNb2RhbE1hbmFnZXIiLCJtb2RhbHMiLCJjb250YWluZXJzIiwibW9kYWxJbmRleCIsIm1vZGFsUmVmIiwiaGlkZGVuU2libGluZ05vZGVzIiwiY29udGFpbmVySW5kZXgiLCJtb3VudCIsIm5leHRUb3AiLCJpc1RvcE1vZGFsIiwiVW5zdGFibGVfVHJhcEZvY3VzIiwiX3Byb3BzJGRpc2FibGVBdXRvRm9jIiwiZGlzYWJsZUF1dG9Gb2N1cyIsIl9wcm9wcyRkaXNhYmxlRW5mb3JjZSIsImRpc2FibGVFbmZvcmNlRm9jdXMiLCJfcHJvcHMkZGlzYWJsZVJlc3RvcmUiLCJkaXNhYmxlUmVzdG9yZUZvY3VzIiwiZ2V0RG9jIiwiaXNFbmFibGVkIiwiaWdub3JlTmV4dEVuZm9yY2VGb2N1cyIsInNlbnRpbmVsU3RhcnQiLCJzZW50aW5lbEVuZCIsIm5vZGVUb1Jlc3RvcmUiLCJyb290UmVmIiwicHJldk9wZW5SZWYiLCJjb250YWlucyIsImNvbnRhaW4iLCJyb290RWxlbWVudCIsImhhc0ZvY3VzIiwibG9vcEZvY3VzIiwia2V5Q29kZSIsInNoaWZ0S2V5IiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJpbnZpc2libGUiLCJTaW1wbGVCYWNrZHJvcCIsIl9wcm9wcyRpbnZpc2libGUiLCJnZXRIYXNUcmFuc2l0aW9uIiwiZGVmYXVsdE1hbmFnZXIiLCJoaWRkZW4iLCJNb2RhbCIsImluUHJvcHMiLCJfcHJvcHMkQmFja2Ryb3BDb21wb24iLCJCYWNrZHJvcENvbXBvbmVudCIsIkJhY2tkcm9wUHJvcHMiLCJfcHJvcHMkY2xvc2VBZnRlclRyYW4iLCJjbG9zZUFmdGVyVHJhbnNpdGlvbiIsIl9wcm9wcyRkaXNhYmxlQmFja2RybyIsImRpc2FibGVCYWNrZHJvcENsaWNrIiwiX3Byb3BzJGRpc2FibGVFc2NhcGVLIiwiZGlzYWJsZUVzY2FwZUtleURvd24iLCJfcHJvcHMkZGlzYWJsZVNjcm9sbEwiLCJfcHJvcHMkaGlkZUJhY2tkcm9wIiwiaGlkZUJhY2tkcm9wIiwiX3Byb3BzJG1hbmFnZXIiLCJtYW5hZ2VyIiwib25CYWNrZHJvcENsaWNrIiwib25Fc2NhcGVLZXlEb3duIiwibW91bnROb2RlUmVmIiwiaGFzVHJhbnNpdGlvbiIsImdldE1vZGFsIiwiaGFuZGxlTW91bnRlZCIsInJlc29sdmVkQ29udGFpbmVyIiwiaGFuZGxlUG9ydGFsUmVmIiwiaGFuZGxlQmFja2Ryb3BDbGljayIsImlubGluZVN0eWxlIiwiVHJhcEZvY3VzIiwicmVmbG93IiwiZ2V0VHJhbnNpdGlvblByb3BzIiwiX3Byb3BzJHN0eWxlIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwibW9kZSIsInRyYW5zaXRpb25EZWxheSIsImdldFNjYWxlIiwiZW50ZXJpbmciLCJlbnRlcmVkIiwiR3JvdyIsIl9wcm9wcyRkaXNhYmxlU3RyaWN0TSIsImRpc2FibGVTdHJpY3RNb2RlQ29tcGF0IiwiX3Byb3BzJHRpbWVvdXQiLCJfcHJvcHMkVHJhbnNpdGlvbkNvbXAiLCJUcmFuc2l0aW9uQ29tcG9uZW50IiwidGltZXIiLCJhdXRvVGltZW91dCIsImVuYWJsZVN0cmljdE1vZGVDb21wYXQiLCJ1bnN0YWJsZV9zdHJpY3RNb2RlIiwiZm9yZWlnblJlZiIsIm5vcm1hbGl6ZWRUcmFuc2l0aW9uQ2FsbGJhY2siLCJub2RlT3JBcHBlYXJpbmciLCJpc0FwcGVhcmluZyIsImhhbmRsZUVudGVyaW5nIiwiX2dldFRyYW5zaXRpb25Qcm9wcyIsImhhbmRsZUVudGVyZWQiLCJoYW5kbGVFeGl0aW5nIiwiaGFuZGxlRXhpdCIsIl9nZXRUcmFuc2l0aW9uUHJvcHMyIiwibm9kZU9yTmV4dCIsIm1heWJlTmV4dCIsIm11aVN1cHBvcnRBdXRvIiwiZ2V0T2Zmc2V0VG9wIiwidmVydGljYWwiLCJvZmZzZXQiLCJnZXRPZmZzZXRMZWZ0IiwiaG9yaXpvbnRhbCIsImdldFRyYW5zZm9ybU9yaWdpblZhbHVlIiwiZ2V0U2Nyb2xsUGFyZW50Iiwib3ZlcmZsb3dZIiwib3ZlcmZsb3dYIiwiUG9wb3ZlciIsIl9wcm9wcyRhbmNob3JPcmlnaW4iLCJhbmNob3JPcmlnaW4iLCJhbmNob3JQb3NpdGlvbiIsIl9wcm9wcyRhbmNob3JSZWZlcmVuYyIsImFuY2hvclJlZmVyZW5jZSIsImNvbnRhaW5lclByb3AiLCJnZXRDb250ZW50QW5jaG9yRWwiLCJfcHJvcHMkbWFyZ2luVGhyZXNob2wiLCJtYXJnaW5UaHJlc2hvbGQiLCJfcHJvcHMkUGFwZXJQcm9wcyIsIlBhcGVyUHJvcHMiLCJfcHJvcHMkdHJhbnNmb3JtT3JpZ2kiLCJfcHJvcHMkdHJhbnNpdGlvbkR1cmEiLCJ0cmFuc2l0aW9uRHVyYXRpb25Qcm9wIiwiX3Byb3BzJFRyYW5zaXRpb25Qcm9wIiwicGFwZXJSZWYiLCJnZXRBbmNob3JPZmZzZXQiLCJjb250ZW50QW5jaG9yT2Zmc2V0IiwiYW5jaG9yRWxlbWVudCIsImFuY2hvclJlY3QiLCJhbmNob3JWZXJ0aWNhbCIsImdldENvbnRlbnRBbmNob3JPZmZzZXQiLCJjb250ZW50QW5jaG9yRWwiLCJnZXRUcmFuc2Zvcm1PcmlnaW4iLCJlbGVtUmVjdCIsImdldFBvc2l0aW9uaW5nU3R5bGUiLCJlbGVtVHJhbnNmb3JtT3JpZ2luIiwiYW5jaG9yT2Zmc2V0IiwiY29udGFpbmVyV2luZG93IiwiaGVpZ2h0VGhyZXNob2xkIiwid2lkdGhUaHJlc2hvbGQiLCJfZGlmZiIsIl9kaWZmMiIsIl9kaWZmMyIsInNldFBvc2l0aW9uaW5nU3R5bGVzIiwicG9zaXRpb25pbmciLCJoYW5kbGVQYXBlclJlZiIsInVwZGF0ZVBvc2l0aW9uIiwiTGlzdENvbnRleHQiLCJkZW5zZSIsInN1YmhlYWRlciIsIkxpc3QiLCJfcHJvcHMkZGVuc2UiLCJfcHJvcHMkZGlzYWJsZVBhZGRpbmciLCJkaXNhYmxlUGFkZGluZyIsIm5leHRJdGVtIiwibGlzdCIsIm5leHRFbGVtZW50U2libGluZyIsInByZXZpb3VzSXRlbSIsImxhc3RDaGlsZCIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJ0ZXh0Q3JpdGVyaWFNYXRjaGVzIiwidGV4dENyaXRlcmlhIiwiaW5uZXJUZXh0IiwicmVwZWF0aW5nIiwibW92ZUZvY3VzIiwiY3VycmVudEZvY3VzIiwidHJhdmVyc2FsRnVuY3Rpb24iLCJ3cmFwcGVkT25jZSIsIk1lbnVMaXN0IiwiYWN0aW9ucyIsIl9wcm9wcyRhdXRvRm9jdXMiLCJfcHJvcHMkYXV0b0ZvY3VzSXRlbSIsImF1dG9Gb2N1c0l0ZW0iLCJsaXN0UmVmIiwidGV4dENyaXRlcmlhUmVmIiwicHJldmlvdXNLZXlNYXRjaGVkIiwibGFzdFRpbWUiLCJhZGp1c3RTdHlsZUZvclNjcm9sbGJhciIsImNvbnRhaW5lckVsZW1lbnQiLCJub0V4cGxpY2l0V2lkdGgiLCJjcml0ZXJpYSIsImxvd2VyS2V5IiwiY3VyclRpbWUiLCJwZXJmb3JtYW5jZSIsImtlZXBGb2N1c09uQ3VycmVudCIsImFjdGl2ZUl0ZW1JbmRleCIsIml0ZW1zIiwibmV3Q2hpbGRQcm9wcyIsIlJUTF9PUklHSU4iLCJMVFJfT1JJR0lOIiwiV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmciLCJNZW51IiwiZGlzYWJsZUF1dG9Gb2N1c0l0ZW0iLCJfcHJvcHMkTWVudUxpc3RQcm9wcyIsIk1lbnVMaXN0UHJvcHMiLCJvbkVudGVyaW5nUHJvcCIsIlBvcG92ZXJDbGFzc2VzIiwibWVudUxpc3RBY3Rpb25zUmVmIiwiY29udGVudEFuY2hvclJlZiIsImhhbmRsZUxpc3RLZXlEb3duIiwiYXJlRXF1YWxWYWx1ZXMiLCJiIiwiU2VsZWN0SW5wdXQiLCJhcmlhTGFiZWwiLCJhdXRvV2lkdGgiLCJkaXNwbGF5RW1wdHkiLCJJY29uQ29tcG9uZW50IiwibGFiZWxJZCIsIl9wcm9wcyRNZW51UHJvcHMiLCJNZW51UHJvcHMiLCJyZW5kZXJWYWx1ZSIsIl9wcm9wcyRTZWxlY3REaXNwbGF5UCIsIlNlbGVjdERpc3BsYXlQcm9wcyIsInRhYkluZGV4UHJvcCIsImRpc3BsYXlOb2RlIiwic2V0RGlzcGxheU5vZGUiLCJpc09wZW5Db250cm9sbGVkIiwibWVudU1pbldpZHRoU3RhdGUiLCJzZXRNZW51TWluV2lkdGhTdGF0ZSIsIm9wZW5TdGF0ZSIsImdldEVsZW1lbnRCeUlkIiwiZ2V0U2VsZWN0aW9uIiwiaXNDb2xsYXBzZWQiLCJjaGlsZHJlbkFycmF5IiwiaGFuZGxlSXRlbUNsaWNrIiwidmFsaWRLZXlzIiwiZGlzcGxheVNpbmdsZSIsImRpc3BsYXlNdWx0aXBsZSIsImNvbXB1dGVEaXNwbGF5IiwiZm91bmRNYXRjaCIsInYiLCJtZW51TWluV2lkdGgiLCJidXR0b25JZCIsInNlbGVjdE1lbnUiLCJuYXRpdmVJbnB1dCIsImljb25PcGVuIiwiTmF0aXZlU2VsZWN0SW5wdXQiLCJpY29uRmlsbGVkIiwiaWNvbk91dGxpbmVkIiwiZGVmYXVsdElucHV0IiwiTmF0aXZlU2VsZWN0IiwiX3Byb3BzJEljb25Db21wb25lbnQiLCJfcHJvcHMkaW5wdXQiLCJuYXRpdmVTZWxlY3RTdHlsZXMiLCJTZWxlY3QiLCJfcHJvcHMkYXV0b1dpZHRoIiwiX3Byb3BzJGRpc3BsYXlFbXB0eSIsIl9wcm9wcyRuYXRpdmUiLCJuYXRpdmUiLCJ2YXJpYW50UHJvcHMiLCJ2YXJpYW50Q29tcG9uZW50IiwiVGV4dEZpZWxkIiwiRm9ybUhlbHBlclRleHRQcm9wcyIsImhlbHBlclRleHQiLCJfcHJvcHMkc2VsZWN0IiwiU2VsZWN0UHJvcHMiLCJJbnB1dE1vcmUiLCJfSW5wdXRMYWJlbFByb3BzJHJlcXUiLCJkaXNwbGF5UmVxdWlyZWQiLCJoZWxwZXJUZXh0SWQiLCJpbnB1dExhYmVsSWQiLCJJbnB1dEVsZW1lbnQiLCJjaGVja2VkIiwiU3dpdGNoQmFzZSIsImNoZWNrZWRQcm9wIiwiY2hlY2tlZEljb24iLCJkZWZhdWx0Q2hlY2tlZCIsImRpc2FibGVkUHJvcCIsInNldENoZWNrZWRTdGF0ZSIsIm5ld0NoZWNrZWQiLCJoYXNMYWJlbEZvciIsImluZGV0ZXJtaW5hdGUiLCJkZWZhdWx0Q2hlY2tlZEljb24iLCJDaGVja0JveEljb24iLCJkZWZhdWx0SWNvbiIsIkNoZWNrQm94T3V0bGluZUJsYW5rSWNvbiIsImRlZmF1bHRJbmRldGVybWluYXRlSWNvbiIsIkluZGV0ZXJtaW5hdGVDaGVja0JveEljb24iLCJDaGVja2JveCIsIl9wcm9wcyRjaGVja2VkSWNvbiIsIl9wcm9wcyRpY29uIiwiX3Byb3BzJGluZGV0ZXJtaW5hdGUiLCJfcHJvcHMkaW5kZXRlcm1pbmF0ZUkiLCJpbmRldGVybWluYXRlSWNvbiIsImluZGV0ZXJtaW5hdGVJY29uUHJvcCIsIkF1dG9jb21wbGV0ZVVJIiwic2hvd0NoZWNrYm94ZXMiLCJBdXRvY29tcGxldGVNdWx0aXNlbGVjdCIsInNlYXJjaEFmdGVyWENoYXJzIiwic2hvd1RvRmV3Q2hhcnNUZXh0IiwidGltZVN0YW1wIiwibGF0ZXN0SW5wdXRDaGFuZ2UiLCJzZWFyY2hWYWx1ZSIsIm9uSW5wdXRDaGFuZ2VBY3Rpb24iLCJjYW5FeGVjdXRlIiwiZXhlY3V0ZSIsIm9uSW5wdXRDaGFuZ2VEZWxheSIsInVwZGF0ZURhdGUiLCJhdXRvQ29tcGxldGVLZXkiLCJjaGFuZ2VWYWx1ZXMiLCJvbk9wZW5Ecm9wZG93biIsIm9wZW5Ecm9wZG93biIsImlucHV0Q2hhbmdlIiwib3B0aW9uc1NlbGVjdGVkIiwiaW5pdGlhbGl6ZWQiLCJyZWZyZXNoRGF0YSIsInJlZnJlc2hTdGF0ZSIsInJlZnJlc2hBdHRyaWJ1dGUiLCJKU09OQXR0cmlidXRlIiwiZGF0YVBhcnNlZCIsInBhcnNlIiwib3B0aW9uc1NlbGVjdGVkTm90SW5MaXN0Iiwic2VsZWN0ZWRPcHRpb24iLCJmaW5kIiwicmVzcG9uc2VBdHRyaWJ1dGUiLCJkYXRhU291cmNlT3B0aW9ucyIsIndhcm5pbmdHaXZlbiIsIm11bHRpU2VsZWN0IiwiZGVmYXVsdFNlbGVjdGVkU3RyaW5nIiwib3B0aW9uVGl0bGUiLCJ0aXRsZUF0dHIiLCJrZXlBdHRyIiwiZGVmYXVsdFNlbGVjdGVkU3RyaW5nQXR0ciIsImlzSXRlbURlZmF1bHRTZWxlY3RlZCIsImRlZmF1bHRTZWxlY3RlZEF0dHIiLCJvbkNoYW5nZUFjdGlvbiIsInNldExvYWRpbmciLCJvbk9wZW5BY3Rpb24iLCJlZGl0YWJsZSIsInNlYXJjaEFmdGVyWENoYXJzVGV4dCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBQUEsU0FBU0EsV0FBVCxDQUFxQkMsR0FBckIsRUFBMEJDLEdBQTFCLEVBQStCO0VBQzdCLE1BQUtBLEdBQUcsS0FBSyxLQUFLLENBQWxCLEVBQXNCQSxHQUFHLEdBQUcsRUFBTjtFQUN0QixNQUFJQyxRQUFRLEdBQUdELEdBQUcsQ0FBQ0MsUUFBbkI7O0VBRUEsTUFBSSxDQUFDRixHQUFELElBQVEsT0FBT0csUUFBUCxLQUFvQixXQUFoQyxFQUE2QztFQUFFO0VBQVM7O0VBRXhELE1BQUlDLElBQUksR0FBR0QsUUFBUSxDQUFDQyxJQUFULElBQWlCRCxRQUFRLENBQUNFLG9CQUFULENBQThCLE1BQTlCLEVB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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
